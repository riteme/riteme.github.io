<!DOCTYPE html>
<html>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?72d0c4a099cd676176e657b871326707";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<head>
  <title>树链剖分 - riteme.site</title>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="../../favicon.png" type="image/png">
  <link rel="stylesheet" type="text/css" href="../../css/site.min.css">
  <script type="text/javascript" async src="../../mathjax/MathJax.js?config=TeX-AMS_HTML"></script>
  <script   src="https://code.jquery.com/jquery-2.2.4.min.js"   integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="   crossorigin="anonymous"></script>
  <link href="../../tipuesearch/tipuesearch.css" rel="stylesheet">
  <script src="../../tipuesearch/tipuesearch_set.js"></script>
  <script src="../../tipuesearch/tipuesearch.min.js"></script>
</head>
<body>
<div id="topbar">
  <div style="display: block; float: right">
  <form action="../../search.html">
  <input type="text" placeholder="Search Here" name="q" id="tipue_search_input" autocomplete="off" required>
  </form>
  </div>
</div>
<ul class="breadcrumb"><li><a href="../../index.html">HOME</a></li><li><a href="../../posts.html">POSTS</a></li><li><a href="../../posts.html#2016-4-20">2016-4-20</a></li><li class="active">树链剖分</li></ul>

<div id="view">
<div class="toc">
<ul>
<li><a href="#_1">树链剖分</a><ul>
<li><a href="#_2">用途</a></li>
<li><a href="#_3">无根树与有根树</a></li>
<li><a href="#_4">剖分</a></li>
<li><a href="#_5">基础操作</a><ul>
<li><a href="#_6">查询</a></li>
<li><a href="#_7">修改</a></li>
</ul>
</li>
<li><a href="#_8">时间复杂度</a></li>
<li><a href="#lca">树链剖分计算LCA</a></li>
<li><a href="#dfs">树链剖分与DFS序</a></li>
</ul>
</li>
</ul>
</div>
<div id="container">

<h1 id="_1">树链剖分</h1>
<h2 id="_2">用途</h2>
<p><strong>问题:</strong> 给你一棵<strong>无根树</strong>，每条边有边权，请你实现以下操作：</p>
<ul>
<li>查询<mathjax>$u$</mathjax>到<mathjax>$v$</mathjax>的路径上边权<strong>之和</strong>。</li>
<li>查询<mathjax>$u$</mathjax>到<mathjax>$v$</mathjax>的路径上边权<strong>最大值</strong>。</li>
<li><strong>修改</strong><mathjax>$u$</mathjax>到<mathjax>$v$</mathjax>的路径上每条边的边权。</li>
<li>&hellip;</li>
</ul>
<p>这些操作利用树链剖分，都可以在<mathjax>$O(\log n)$</mathjax>的时间内解决。</p>
<h2 id="_3">无根树与有根树</h2>
<p>一般来说，无根树是很不好处理的，因此将其转为有根树就会好处理些。<br />
我们只要选定一个节点为根，然后进行DFS即可转化为有根树。</p>
<p>转换的时候，我们需要额外记录以下信息：</p>
<ul>
<li><mathjax>$x.\text{father}$</mathjax>: <mathjax>$x$</mathjax>的父亲节点。</li>
<li><mathjax>$x.\text{children}$</mathjax>: <mathjax>$x$</mathjax>的所有孩子。</li>
<li><mathjax>$x.\text{size}$</mathjax>: 以<mathjax>$x$</mathjax>为根的这一棵子树的大小。</li>
<li><mathjax>$x.\text{depth}$</mathjax>: <mathjax>$x$</mathjax>在树中的深度，即<mathjax>$x$</mathjax>到树根的距离<mathjax>$+1$</mathjax>。</li>
</ul>
<p><img alt="tree-normal" src="http://git.oschina.net/riteme/blogimg/raw/master/tree-split/tree-normal.svg" /><br />
这是一棵以<mathjax>$1$</mathjax>为根的树。为了解释更加清楚，这里举几个例子：</p>
<ul>
<li><mathjax>$10.\text{father} = 5,\; 1.\text{father} = nil$</mathjax></li>
<li><mathjax>$1.\text{children} = \{2, 5, 6\},\;7.\text{children} = \varnothing$</mathjax></li>
<li><mathjax>$1.\text{size} = 17,\;6.\text{size} = 8,\;3.\text{size} = 1$</mathjax></li>
<li><mathjax>$1.\text{depth} = 1,\;10.\text{depth} = 3,\;14.\text{depth} = 4$</mathjax></li>
</ul>
<p>为了进行树链剖分，我们在立树的过程中需要计算一个<strong>重儿子</strong>，记作<mathjax>$x.\text{next}$</mathjax>：<br />
<mathjax>$$ x.\text{next} = u: u \in x.\text{children},\;u.\text{size}\text{最大} $$</mathjax></p>
<p>即所有儿子中大小最大的一个，就记为重儿子，其它的儿子就是<strong>轻儿子</strong>。同时称与重儿子相连的边为<strong>重边</strong>，与轻儿子相连的边为<strong>轻边</strong>。</p>
<p>下面的伪代码是建立有根树的过程(假设我们输入的是无根树<mathjax>$G$</mathjax>，这是一张无向图，其中与<mathjax>$u$</mathjax>相连的顶点集合为<mathjax>$G[u].\text{neighbors}$</mathjax>)：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>function MAKE-ROOT(G, u):  // 以u为树根
    u.visited = true  // u已经访问过了
    u.father = nil // u没有父亲
    u.depth = 1

    REAL-MAKE-ROOT(G, u)

function REAL-MAKE-ROOT(G, u):  // DFS过程
    u.size = 1
    u.next = nil

    foreach v in G[u].neighbors:
        if not v.visited:  // 如果还未访问
            v.visited = true
            u.children += v  // 添加儿子节点
            v.father = u
            v.depth = u.depth + 1

            REAL-MAKE-ROOT(G, v)  // 递归向下

            u.size += v.size  // 更新子树大小

            if u.next = nil || v.size &gt; u.next.size:  // 更新重儿子
                u.next = v
</pre></div>
</td></tr></table>

<h2 id="_4">剖分</h2>
<p>在介绍树链剖分的算法之前，我们先来看看剖分后的树是个什么样子：<br />
<img alt="tree-splited" src="http://git.oschina.net/riteme/blogimg/raw/master/tree-split/tree-splited.png" /><br />
剖分后的树信息量一下子大了很多。我将会逐条解释上面都画了些什么。</p>
<ul>
<li><strong>树链(重链)</strong>: 所有红色的边所连成的一条链都是剖分后的结果。某些树链没有边，就只有一个节点，这个节点是红色的。在上面，<code>1-6-8-11-13-17</code>是剖分出来的最长的树链，而<code>3</code>独自一个节点形成了树链。</li>
<li><strong>树链起点</strong>: 红色的节点是每一条树链的起点。</li>
<li><strong>重儿子</strong>: 蓝色的节点是重儿子。</li>
<li><strong>编号</strong>: 每一条边上的数字为剖分后的编号。</li>
</ul>
<p>可以看出，树中的<strong>每一个节点都会在一条树链中</strong>。因此我们需要对树链也进行编号。我们以树链顶端的节点作为树链的编号，并记为<mathjax>$x.\text{top}$</mathjax>。例如，<mathjax>$8.\text{top} = 1,\;16.\text{top} = 16$</mathjax>。<br />
如果两个节点<mathjax>$u$</mathjax>和<mathjax>$v$</mathjax><strong>在同一树链中</strong>，当且仅当<mathjax>$u.\text{top} = v.\text{top}$</mathjax>。</p>
<p>对于边<mathjax>$u \rightarrow v$</mathjax>的编号，我们记边为二元组<mathjax>$(u, v)$</mathjax>，那么记编号为<mathjax>$(u,v).\text{id}$</mathjax>。<br />
但是这样不方便在程序中储存，因此我们将边的编号放到节点里面。在上面的写法中，如果<mathjax>$u$</mathjax>是<mathjax>$v$</mathjax>的父亲，那么我们将边<mathjax>$(u,v)$</mathjax>的编号放到<mathjax>$v$</mathjax>中，即<mathjax>$v.\text{id}$</mathjax>。这样表示<mathjax>$v$</mathjax><strong>与其父亲相连的边</strong><mathjax>$(u,v)$</mathjax>的编号为<mathjax>$v.\text{id}$</mathjax>。</p>
<p>边的编号是树剖的关键，给边赋予编号后，就可以实现很多操作了。<br />
我们首先来看这些编号有什么特点：</p>
<ul>
<li>每个边的编号都不一样。</li>
<li>同一条的树链的边的编号<strong>从高处向低处</strong>编号<strong>递增</strong>。这样做的好处就是同一条链上面的数据可以用一些数据结构(如线段树、Splay等)来维护。</li>
<li>对于节点<mathjax>$u$</mathjax>，其<strong>重边</strong>的编号是<mathjax>$u$</mathjax>与所有儿子的连边中<strong>最小</strong>的。</li>
</ul>
<p>估计你已经猜到计算<mathjax>$\text{top}$</mathjax>和<mathjax>$\text{id}$</mathjax>的用处了。但不要着急，下面就将计算这些值。</p>
<p>计算的过程也是一遍DFS。这次的DFS是在第一次建立好的有根树上进行的。<br />
当我们处理到节点<mathjax>$u$</mathjax>时，我们将<mathjax>$u$</mathjax>和<mathjax>$u.\text{next}$</mathjax>相连来形成树链。之所以选取重儿子，是因为重儿子的大小最大，因此所生成的树链将尽可能长<sup id="fnref:chain-is-longer"><a class="footnote-ref" href="#fn:chain-is-longer" rel="footnote">1</a></sup>。那么其它的儿子将自己成为新的树链。<br />
此时来考虑编号。因为同一条树链上的边的编号是递增的，因此要优先对重儿子进行DFS。由于轻儿子是新创建的树链，因此DFS的顺序并不重要。</p>
<p>至此，树链剖分的算法就结束了。当算法完成时，每个节点就会有正确的<mathjax>$\text{top}$</mathjax>和<mathjax>$\text{id}$</mathjax>。</p>
<p>下面是树链剖分的伪代码：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>count = 0  // 已编号的数量

function TREE-SPLIT(x):  // 剖分子树u
    x.id = 0  // 根节点没有父亲
    x.top = x  // 根节点是第一条链

    REAL-TREE-SPLIT(x)

function REAL-TREE-SPLIT(x):  // DFS过程
    if x.next != nil:  // 如果有重儿子
        count += 1
        x.next.id = count
        x.next.top = x.top

        REAL-TREE-SPLIT(x.next)  // 优先重儿子

    foreach v in x.children:  // 对于轻儿子则新创一条链
        if v != x.next:  // 检查是不是重儿子
            count += 1
            v.id = count
            v.top = v

            REAL-TREE-SPLIT(v)
</pre></div>
</td></tr></table>

<h2 id="_5">基础操作</h2>
<p>树链剖分完有什么用呢？<br />
就像一开场所说的：</p>
<blockquote>
<ul>
<li>查询<mathjax>$u$</mathjax>到<mathjax>$v$</mathjax>的路径上边权<strong>之和</strong>。</li>
<li>查询<mathjax>$u$</mathjax>到<mathjax>$v$</mathjax>的路径上边权<strong>最大值</strong>。</li>
<li><strong>修改</strong><mathjax>$u$</mathjax>到<mathjax>$v$</mathjax>的路径上每条边的边权。</li>
<li>&hellip;</li>
</ul>
</blockquote>
<p>下面将介绍如何进行<strong>路径边权之和的查询</strong>和<strong>修改路径边权</strong>这两个操作。其它的操作可以在此思想上扩展。</p>
<h3 id="_6">查询</h3>
<p>假如我们要查询<mathjax>$u$</mathjax>到<mathjax>$v$</mathjax>的路径上的权值之和，那么就会有两种情况：</p>
<ul>
<li><mathjax>$u$</mathjax>和<mathjax>$v$</mathjax><strong>在</strong>同一条树链上。</li>
<li><mathjax>$u$</mathjax>和<mathjax>$v$</mathjax><strong>不在</strong>同一条树链上。</li>
</ul>
<p>对于第一种情况，非常好解决。我们可以用线段树来维护每一条边的权值，直接按照编号来排列。由于同一条链上的编号是递增的，如果<mathjax>$u.\text{depth} &lt; v.\text{depth}$</mathjax>，则可以直接查询<mathjax>$[u.\text{next}.\text{id}, v.\text{id}]$</mathjax>的和。如果<mathjax>$u.\text{depth} = v.\text{depth}$</mathjax>，由于<mathjax>$u$</mathjax>和<mathjax>$v$</mathjax>是在同一条树链上的，也就是意味着<mathjax>$u = v$</mathjax>，那么就不需要统计。</p>
<p>对于第二种情况，我们考虑使它们不断逼近到同一条链上来，从而就转为了第一种情况。但是，在其中一个节点变化到另一条树链上时，要将经过的树链的值进行统计。<br />
我们按照一下步骤来处理：</p>
<ul>
<li>如果<mathjax>$u.\text{top}.\text{depth} &lt; v.\text{top}.\text{depth}$</mathjax>，那么交换<mathjax>$u$</mathjax>和<mathjax>$v$</mathjax>，使<mathjax>$u$</mathjax>所在的树链为所处位置较深的一个。</li>
<li>计算<mathjax>$[u.\text{top}.\text{id},u.\text{id}]$</mathjax>的值并<strong>累加</strong>。</li>
<li>令<mathjax>$u = u.\text{top}.\text{father}$</mathjax>。</li>
<li>如果<mathjax>$u.\text{top} = v.\text{top}$</mathjax>，则转化为第一种情况。否则跳转第一步。</li>
</ul>
<p>上面步骤的思想就是将上升期间的每一条树链的和统计出来，这样实则就是统计了这条路径上的和。<br />
第一步的操作是为了方便后续的处理。第二步是计算这一条链上的和，包括这条链上面的一条轻边，因为在第三步中要<strong>走这条轻边到达上面一条树链</strong>。最后一步是检查是否成为了第一种情况。</p>
<p>下面是上面步骤的参考伪代码：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>function QUERY-SUM(u, v):
    sum = 0

    // 如果不在同一条树链
    while u.top != v.top:
        if u.top.depth &lt; v.top.depth:
            SWAP(u, v)  // 交换u和v

        sum += QUERY(u.top.id, u.id)  // 利用线段树等数据结构来求和
        u = u.top.father  // 走轻边进入上面的树链

    if u == v:  // 如果处在相同位置
        return sum

    if u.depth &gt; v.depth:  // 使u成为深度较小的节点
        SWAP(u, v)

    return QUERY(u.next.id, v.id) + sum
</pre></div>
</td></tr></table>

<p>如果不能理解，这里给出一个示例：<br />
<img alt="tree-splited" src="http://git.oschina.net/riteme/blogimg/raw/master/tree-split/tree-splited.png" /><br />
假设我们查询<mathjax>$16$</mathjax>到<mathjax>$17$</mathjax>：<br />
首先会发现它们不在同一条链上，由于<mathjax>$16$</mathjax>所处的链的深度较大，为<mathjax>$5$</mathjax>，因此将<mathjax>$16$</mathjax>进行上移，上移至<mathjax>$14$</mathjax>，并统计<mathjax>$[13, 13]$</mathjax>的和。<br />
然后<mathjax>$14$</mathjax>和<mathjax>$17$</mathjax>依然不在同一条链中，由于<mathjax>$14$</mathjax>所处的链的深度为<mathjax>$2$</mathjax>，因此将<mathjax>$14$</mathjax>上移。上移至<mathjax>$1$</mathjax>，并统计<mathjax>$[9, 11]$</mathjax>的和。<br />
最后发现<mathjax>$1$</mathjax>和<mathjax>$17$</mathjax>已经在同一条链中了，直接统计<mathjax>$[1, 5]$</mathjax>的和即可。</p>
<h3 id="_7">修改</h3>
<p>事实上，修改操作和查询几乎是一模一样的，只是将求和的地方变成了相应的数据结构的修改操作。这里就不再多说了。</p>
<h2 id="_8">时间复杂度</h2>
<p>每当学习了一个新算法，我们最关切的就是它的时间复杂度了。<br />
如果树链剖分的时间复杂度高到爆，我们写的时候估计得虚死。<br />
但是可以证明，树链剖分后的树，从根节点到任意一个叶节点的路径只会与<mathjax>$O(\log n)$</mathjax>条树链相交。这意味着将两个节点逼近到同一条链上时，只需经过<mathjax>$O(\log n)$</mathjax>次跳转。<br />
即基于树剖的其它操作的时间复杂度为<mathjax>$\Omega(\log n)$</mathjax>(注意是下界，具体的上界取决于操作本身的附加的复杂度)。</p>
<p><del>为什么会只有<mathjax>$O(\log n)$</mathjax>条呢？</del><br />
<del>我们来考虑树链剖分时最坏的情况：</del><br />
<img alt="tree-worst" src="http://git.oschina.net/riteme/blogimg/raw/master/tree-split/tree-worst.png" /><br />
<del>想象这是树剖是最坏的情况(因为实际上并不会这样)。因为树剖总是尝试将最长的剖分出来，因此树链都是向右的。如果最左链再加一个节点，树链就会向左剖分了。</del><br />
<del>为了达到这样的效果，这棵有根树是接近<strong>平衡</strong>的，即树高为<mathjax>$\Theta(\log n)$</mathjax>。</del><br />
<del>因此最坏的情况下，当查询最左边的节点时，只需要使用<mathjax>$O(\log n)$</mathjax>次跳转就可完成。</del></p>
<p><del>当然上面并不是严格的证明，只是一个形象的说明罢了。我们只需要知道树链剖分能保证很好的时间复杂度即可。</del></p>
<p>正确的证明思路因该是这样的：<br />
可以考虑一棵树中轻边的数量。由于从某一个节点开始，每走一条轻边，子树的大小都会<strong>减小</strong>一倍。因此任意一条树链上只有<mathjax>$O(\log n)$</mathjax>条轻边，即意味着只有<mathjax>$O(\log n)$</mathjax>。</p>
<h2 id="lca">树链剖分计算LCA</h2>
<p>LCA即最近公共祖先。计算LCA的算法可以说是各种各样，有暴力的爬山法，炸空间的Tarjan算法，开挂的倍增法，莫名高大上的ST跳表的搞法，还有不知所云的转成RMQ问题......在与树相关的操作中，经常需要一些求LCA的操作。其中最常用的就是倍增法，它能在<mathjax>$O(\log n)$</mathjax>的时间内求出LCA，并且其空间复杂度为<mathjax>$\Theta(n \log n)$</mathjax>。</p>
<p>当我们树剖后的操作需要借助到LCA时，是不是就要写个LCA的算法呢？<br />
其实并不需要，我们可以直接利用树剖的结果来计算LCA。</p>
<p>然而，求LCA的过程和之前查询也是差不多的：在同一条链上的时候，<strong>深度值较小的就是LCA</strong>。如果不在同一条链上，就不断往上跳即可。这样可以在<mathjax>$O(\log n)$</mathjax>时间内求出LCA。并且仅使用了<mathjax>$\Theta(n)$</mathjax>的空间复杂度，优势十分显著。</p>
<p>当然，单纯拿树链剖分来求LCA也煞是浪费。既然树剖有能求LCA的能力，因此在面对需要LCA的时候就不必求助于其它的算法了。</p>
<h2 id="dfs">树链剖分与DFS序</h2>
<p><a href="http://uoj.ac/problem/128">【NOI2015】软件包管理器</a></p>
<p>当我们既需要维护链上信息，又需要维护子树信息时，就有点棘手了。<br />
维护子树信息的通常做法是DFS序。为了能够将树链剖分与DFS序结合起来，目标就是将树链剖分的编号与DFS序统一起来。<br />
考虑到DFS序实际上不是唯一的，因此在树链剖分的过程中可以先对重儿子进行DFS，这样就可以保证一条重链上的DFS序也是递增的了。于是，我们可以继续按照DFS序维护子树的方法，同时树链剖分的信息也会被同时更新。</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:chain-is-longer">
<p>实际上，按照子树大小来剖分不一定能剖分出最长的树链，但这并不影响最终的操作的效率。如果要剖分出的链真正最长，应当选择秩最大的儿子作为重儿子。&#160;<a class="footnote-backref" href="#fnref:chain-is-longer" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
<hr/>
<a href="tree-split-printable.html">查看打印版本</a><br/>
标签: <span class="label label-default">数据结构</span> <span class="label label-default">树链剖分</span> <span class="label label-default">LCA</span><br/>
创建时间: 2016.04.20<br/>
上次修改: 2016.04.20
<div class="ds-thread" data-thread-key="ceaea6f4d2bcae3d57a210b9093aa310" data-title="树链剖分" data-url="http://riteme.github.io/blog/2016-4-20/tree-split.html"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"riteme"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (
        document.location.protocol == 'https:' ? 'https:' : 'http:'
    ) + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
</div>
</div>

<footer class="page-footer">
  <div id="container">
    <div class="footer-left">
        <h4 class="white-text">关于riteme.site</h5>
        <ul class="mdul">
          <li class="mdli white-text">一个从不乱说话的博客...</li>
        </ul>
    </div>
    <div class="footer-right">
        <h4 class="white-text">友情链接</h5>
        <ul class="mdul">
          <li class="mdli"><a class="white-text" href="http://link-arthur.github.io/"><del>LinkSBK</del></a></li>
          <li class="mdli"><a class="white-text" href="http://ruanxingzhi.github.io/">ruanxingzhi</a></li>
          <li class="mdli"><a class="white-text" href="http://haogram.hol.es/">核糖核酸</a></li>
          <li class="mdli"><a class="white-text" href="http://hjwjbsr.is-programmer.com/">HJWJBSR</a></li>
        </ul>
    </div>
  </div>
  <div class="footer-copyright">
    <div id="container">
        Copyright © 2015-2016 riteme. All rights reserved.
    </div>
  </div>
</footer>
</body>
</html>
