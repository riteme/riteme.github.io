<!DOCTYPE html> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1.0"> <title>莫比乌斯反演 - riteme.site</title> <link rel="shortcut icon" href="/favicon.png" type="image/png"> <link rel=stylesheet  href="/styles/material-icons.css"> <link rel=stylesheet  href="/styles/material.min.css" > <link rel=stylesheet  href="/styles/gitment.css"> <link rel=stylesheet  href="/math-renderer/katex/katex.min.css"> <link rel=stylesheet  href="/styles/site.css"> <script src="/scripts/jquery.min.js"></script> <script src="/scripts/js-cookie.js"></script> <script src="/scripts/quicklink.umd.js"></script> <script defer src="/scripts/material.min.js"></script> <script src="/scripts/site.js"></script> <script src="/scripts/gitment.js"></script> <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header"> <header class=mdl-layout__header > <div class=mdl-layout__header-row > <span class=mdl-layout-title >莫比乌斯反演</span> <div class=mdl-layout-spacer ></div> <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right"> <label class="mdl-button mdl-js-button mdl-button--icon" for=fixed-header-drawer-exp ><i class=material-icons >search</i></label> <div class=mdl-textfield__expandable-holder > <form action="/search.html"><input type=text  class=mdl-textfield__input  placeholder="Search Here" name=q  id=fixed-header-drawer-exp  autocomplete=off  required></form> </div> </div> </div> </header> <div class=mdl-layout__drawer > <span class="mdl-layout-title drawer-title"> <a href="/index.html" style="color: inherit; font-weight: inherit;text-decoration: none;"><img src="/favicon.png" width=32 height=32> riteme.site</a> </span> <nav class=mdl-navigation > <a class=mdl-navigation__link  href="/index.html"><i class="material-icons drawer-icon">home</i> 首页</a> <a class=mdl-navigation__link  href="/posts.html"><i class="material-icons drawer-icon">library_books</i> 所有文章</a> <a class=mdl-navigation__link  href="/about.html"><i class="material-icons drawer-icon">info</i> 关于</a> <a class=mdl-navigation__link  href="/links.html"><i class="material-icons drawer-icon">link</i> 友链</a> <a class=mdl-navigation__link  href="/search.html"><i class="material-icons drawer-icon">search</i> 搜索</a> <a class=mdl-navigation__link  href="https://github.com/riteme/riteme.github.io"><i class="material-icons drawer-icon">class</i> GitHub 项目</a> </nav> </div> <main class=mdl-layout__content > <div class=mdl-grid > <div class="mdl-cell main-cell"> <div class="article main-article" lang=en-US > <h1 id=_1 >莫比乌斯反演</h1> <blockquote> <p>我把《组合数学》抄了一遍，免得我记不住......</p> </blockquote> <h2 id=_2 >偏序集</h2> <p>这里的莫比乌斯反演是从关联代数的角度来介绍的。首先介绍一个基础的概念：偏序集。<br /> 它通常写作<tex>$(X_n,\;\leqslant)$</tex>，其中<tex>$X_n$</tex>是一个有限或者无限的集合，<tex>$\leqslant$</tex>是代指偏序关系，而<strong>不是特指小于等于符号</strong>。<br /> 所谓偏序关系，就是指<tex>$a,\;b,\;c \in X_n$</tex>并且<tex>$a \leqslant b,\;b \leqslant c$</tex>，有<tex>$a \leqslant c$</tex>的性质的关系。<br /> 这种偏序关系一般是比较符<tex>$\leqslant$</tex>、集合的<tex>$\subseteq$</tex>符号和整除<tex>$\;\mid\;$</tex>。</p> <h2 id=_3 >卷积</h2> <p>对于定义在偏序集<tex>$(X_n,\;\leqslant)$</tex>上的二元函数<tex>$f(x,\;y)$</tex>，我们假定当<tex>$x \not\leqslant y$</tex>时，<tex>$f(x,\;y)$</tex>均为<tex>$0$</tex>，这样是为了方便我们之后的讨论。<br /> 考虑偏序集<tex>$(X_n, \leqslant)$</tex>上的二元函数<tex>$f(x,\;y)$</tex>和<tex>$g(x,\;y)$</tex>，定义它们的卷积为：<br /> <tex>$$ (f \times g)(x,\;y) = \sum_{x \leqslant z \leqslant y} f(x,\;z)g(z,\;y) \tag{2.1} $$</tex></p> <p>这个卷积满足结合律：<br /> <tex>$$ (f \times g) \times h = f \times (g \times h) \tag{2.2} $$</tex></p> <p>注意，这个卷积<strong>不一定<sup id="fnref:possible"><a class=footnote-ref  href="#fn:possible" rel=footnote >1</a></sup>满足交换律</strong>。</p> <p>以及三种强行定义的莫名其妙的函数：<br /> <tex>$\delta$</tex> (delta) 函数：<br /> <tex>$$ \delta(x,\;y) = [x = y] \tag{2.3} $$</tex></p> <p>任意函数卷<tex>$\delta$</tex>函数均会得到原函数。</p> <p><tex>$\zeta$</tex> (zeta) 函数：<br /> <tex>$$ \zeta(x,\;y) = [x \leqslant y] \tag{2.4} $$</tex></p> <p>以及莫比乌斯<tex>$\mu$</tex>函数是定义为<tex>$\zeta$</tex>函数的<strong>逆函数</strong>，即：<br /> <tex>$$ \mu \times \zeta = \zeta \times \mu = \delta \tag{2.5} $$</tex></p> <p>展开卷积可得：<br /> <tex>$$ \begin{aligned} \delta = \mu \times \zeta \Longrightarrow \delta(x,\;y) &amp; = \sum_{x \leqslant z \leqslant y} \mu(x,\;z)\zeta(z,\;y) \\ &amp; = \sum_{x \leqslant z \leqslant y} \mu(x,\;z) \end{aligned} $$</tex></p> <p>因此，当<tex>$x \neq y$</tex>时：<br /> <tex>$$ \mu(x,\;y) = - \sum_{x \leqslant z \lt y} \mu(x,\;z) \tag{2.6} $$</tex></p> <h2 id=_4 >莫比乌斯反演公式</h2> <blockquote> <p><strong>(莫比乌斯反演公式)</strong><br /> 对于有限偏序集<tex>$(X_n,\;\leqslant)$</tex>上的两个函数<tex>$F(x,\;y)$</tex>和<tex>$G(x,\;y)$</tex>，如果：<br /> <tex>$$ G(x,\;y) = \sum_{x \leqslant z \leqslant y} F(x,\;z) \tag{3.1}$$</tex></p> <p>那么：<br /> <tex>$$F(x,\;y) = \sum_{x \leqslant z \leqslant y} G(x,\;z)\mu(z,\;y) = (G \times \mu)(x,\;y) \tag{3.2}$$</tex></p> </blockquote> <p><strong>证明</strong> 首先将式子展开：<br /> <tex>$$ \begin{aligned} F(x,\;y) &amp; = \sum_{x \leqslant z \leqslant y} G(x,\;z)\mu(z,\;y) \\ &amp; = \sum_{x \leqslant z \leqslant y} \mu(z,\;y) \sum_{x \leqslant m \leqslant z} F(x,\;m) \end{aligned} $$</tex></p> <p>我们使用<tex>$\zeta$</tex>函数来表示上下界，于是式子改写为以下形式：<br /> <tex>$$ \sum_{x \leqslant z \leqslant y} \mu(z,\;y) \sum_{m \in X_n} F(x,\;m)\zeta(x,\;m)\zeta(m,\;z) $$</tex></p> <p>改变求和的枚举顺序，先枚举<tex>$m$</tex>，其值依然不变：<br /> <tex>$$ \sum_{m \in X_n} \sum_{x \leqslant z \leqslant y} \zeta(m,\;z)\mu(z,\;y)\zeta(x,\;m)F(x,\;m) $$</tex></p> <p>由于当<tex>$m \lt x$</tex>的时候<tex>$\zeta(x,\;m)$</tex>为<tex>$0$</tex>，因此只用考虑<tex>$m \geqslant x$</tex>。<br /> 同理，我们可以得出<tex>$z \geqslant m$</tex>是必须的。<br /> 因此可以改写下界：<br /> <tex>$$ \sum_{m \in X_n} \sum_{m \leqslant z \leqslant y} \zeta(m,\;z)\mu(z,\;y)F(x,\;m) $$</tex></p> <p>然后变成了卷积的形式：<br /> <tex>$$ \begin{aligned} \sum_{m \in X_n} F(x,\;m) \sum_{m \leqslant z \leqslant y} \zeta(m,\;z)\mu(z,\;y) &amp; = \sum_{m \in X_n} F(x,\;m) \delta(m,\;y) \\ &amp; = F(x,\;y) \end{aligned} $$</tex></p> <p>当<tex>$m = y$</tex>时，<tex>$\delta(m,\;y)$</tex>才为<tex>$1$</tex>，所以综上所述：<br /> <tex>$$ F(x,\;y) = \sum_{x \leqslant z \leqslant y} G(x,\;z)\mu(z,\;y) \tag{3.2} $$</tex></p> <h2 id=_5 >偏序集直积</h2> <p>对于两个偏序集<tex>$(A,\;\leqslant_1)$</tex>和<tex>$(B,\;\leqslant_2)$</tex>，它们的直积<tex>$C = A \times B = (A \times B,\;\leqslant)$</tex>也是偏序集，其中的元素为<tex>$(x,\;y)\;\;(x \in A,\;y \in B)$</tex>。其关系<tex>$\leqslant$</tex>的定义如下：<br /> <tex>$$ (x_1,\;y_1) \leqslant (x_2,\;y_2) \Longleftrightarrow x_1 \leqslant_1 x_2 \land y_1 \leqslant_2 y_2 $$</tex></p> <p>对于偏序集的直积，我们有以下定理：</p> <blockquote> <p>设<tex>$A$</tex>和<tex>$B$</tex>的莫比乌斯函数分别为<tex>$\mu_1$</tex>和<tex>$\mu_2$</tex>，那么<tex>$C$</tex>的莫比乌斯函数满足：<br /> <tex>$$\mu((x_1,\;y_1),\;(x_2,\;y_2)) = \mu_1(x_1,\;x_2)\mu(y_1,\;y_2) \tag{4.1}$$</tex></p> </blockquote> <p><strong>证明</strong> 对于<tex>$(x_1,\;y_1) \not\leqslant (x_2,\;y_2)$</tex>和<tex>$(x_1,\;y_1) = (x_2,\;y_2)$</tex>的情况，上式显然成立。<br /> 假设对于满足<tex>$(x_1,\;y_1) \leqslant (u,\;v) \lt (x_2,\;y_2)$</tex>的二元组均满足，那么有：<br /> <tex>$$ \begin{aligned} \mu((x_1,\;y_1),\;(x_2,\;y_2)) &amp; = - \sum_{(x_1,\;y_1) \leqslant (u,\;v) \lt (x_2,\;y_2)} \mu((x_1,\;y_1),\;(u,\;v)) \\ &amp; = - \sum_{(x_1,\;y_1) \leqslant (u,\;v) \lt (x_2,\;y_2)} \mu_1(x_1,\;u)\mu_2(y_1,\;v) &amp; (\text{根据归纳假设}) \\ &amp; = - \sum_{x_1 \leqslant_1 u \lt_1 x_2} \sum_{y_1 \leqslant_2 v \lt_2 y_2} \mu_1(x_1,\;u)\mu_2(y_1,\;v) &amp; (\text{分别枚举}) \\ &amp; = - \sum_{x_1 \leqslant_1 u \leqslant_1 x_2} \sum_{y_1 \leqslant_2 v \leqslant_2 y_2} \mu_1(x_1,\;u)\mu_2(y_1,\;v) \\ &amp;\;\;\;\, + \mu_1(x_1,\;x_2)\sum_{y_1 \leqslant_2 v \leqslant_2 y_2} \mu_2(y_1,\;v) \\ &amp;\;\;\;\, + \mu_2(y_1,\;y_2)\sum_{x_1 \leqslant_1 u \leqslant_1 x_2} \mu_1(x_1,\;u) \\ &amp;\;\;\;\, \color{red}{+} \mu_1(x_1,\;x_2)\mu_2(y_1,\;y_2) &amp; (\text{扩展上界}) \end{aligned} $$</tex></p> <p>(2016.12.22: 上述证明最后一步展开存在问题 (红色正号)，但是《组合数学》上没有这一步的详细推导，正确的证明方式还请大神们指出)</p> <p>由于：<br /> <tex>$$ \begin{aligned} 0 &amp; = \sum_{y_1 \leqslant_2 v \leqslant_2 y_2} \mu_2(y_1,\;v) \\ &amp; = \sum_{x_1 \leqslant_1 u \leqslant_1 x_2} \mu_1(x_1,\;u) \\ &amp; = \sum_{x_1 \leqslant_1 u \leqslant_1 x_2} \sum_{y_1 \leqslant_2 v \leqslant_2 y_2} \mu_1(x_1,\;u)\mu_2(y_1,\;v) \end{aligned} $$</tex></p> <p>所以定理成立。</p> <h2 id=x_nleqslant >在<tex>$(X_n,\;\leqslant)$</tex>上的莫比乌斯函数</h2> <p>注意这里的是真正的小于等于号了......<br /> 这个比较智障，分析一下就好了：<br /> 对于<tex>$y = x$</tex>，我们有：<br /> <tex>$$ \mu(x,\;y) = \mu(x,\;x) = 1 $$</tex></p> <p>对于<tex>$y = x + 1$</tex>，我们有：<br /> <tex>$$ \mu(x,\;y) = \mu(x,\;x + 1) = -\mu(x,\;x) = -1 $$</tex></p> <p>对于<tex>$y = x + 2$</tex>，我们有：<br /> <tex>$$ \mu(x,\;y) = \mu(x,\;x + 2) = -\left[\mu(x,\;x) + \mu(x,\;x + 1)\right] = 0 $$</tex></p> <p>不难发现，对于<tex>$y \gt x + 1$</tex>的函数值就全都变为<tex>$0$</tex>了。<br /> 总结一下就是：<br /> <tex>$$ \mu(x,\;y) = \begin{cases} 1 &amp; (y = x) \\ -1 &amp; (y = x + 1) \\ 0 &amp; (\text{otherwise}) \end{cases} \tag{5.1} $$</tex></p> <h2 id=x_nsubseteq >在<tex>$(X_n,\;\subseteq)$</tex>上的莫比乌斯函数</h2> <blockquote> <p>试证明：<br /> 偏序集<tex>$(X_n,\;\subseteq)$</tex>的莫比乌斯函数是：<br /> <tex>$$\mu(A,\;B) = (-1)^{|B| - |A|} \tag{6.1}$$</tex></p> </blockquote> <p>运用归纳法证明：<br /> 首先对于<tex>$A = B$</tex>，显然成立：<br /> <tex>$$ \mu(A, B) = \mu(A, A) = 1 = (-1)^0 $$</tex></p> <p>假设对于<tex>$|B| - |A| \leqslant k$</tex>均成立，尝试证明对于<tex>$|B| - |A| = k + 1$</tex>也成立：<br /> <tex>$$ \begin{aligned} \mu(A,\;B) &amp; = -\sum_{A \subseteq C \subset B} \mu(A,\;C) \\ &amp; = -\sum_{A \subseteq C \subset B} (-1)^{|C| - |A|} \\ &amp; = -\sum_{i = 0}^{k} {k + 1 \choose i}(-1)^i \\ &amp; = -\left[(1 - 1)^{k + 1} - (-1)^{k + 1} \right] \\ &amp; = (-1)^{k + 1} \\ &amp; = (-1)^{|B| - |A|} \end{aligned} $$</tex></p> <h2 id=x_nmid >在<tex>$(X_n,\;\mid)$</tex>上的莫比乌斯函数</h2> <p>对于<tex>$(X_n, \;\mid)$</tex>这个偏序集，有如下定理：<br /> <tex>$$ a \mid b \Longrightarrow \mu(a,\;b) = \mu(1,\;\frac{b}a) \tag{7.1} $$</tex></p> <p><strong>证明</strong> 我们尝试使用归纳法证明。首先对于<tex>$a = b$</tex>的情况显然成立：<br /> <tex>$$ \mu(a,\;b) = \mu(a,\;a) = \mu(1,\;1) = 1 $$</tex></p> <p>假设对于<tex>$a \leqslant c \lt b$</tex>的莫比乌斯函数<tex>$\mu(a,\;c)$</tex>均满足上述定理，下面证明对于<tex>$\mu(a,\;b)$</tex>也满足。<br /> 根据莫比乌斯函数的性质可得：<br /> <tex>$$ \mu(a,\;b) = -\sum_{a \mid c \mid b, \;c \neq b} \mu(a,\;c) $$</tex></p> <p>由于<tex>$a \mid b$</tex>，所以：<br /> <tex>$$ -\sum_{c \mid (b / a), \;c \neq (b / a)} \mu(a,\;ac) $$</tex></p> <p>根据归纳假设，可以将上式变为：<br /> <tex>$$ -\sum_{c \mid (b / a), \;c \neq (b / a)} \mu(1,\;c) = \mu(1,\;\frac{b}a) $$</tex></p> <p>因此定理成立。</p> <p>由于有上面的定理，所以我们只用关心<tex>$\mu(1,\;n)$</tex>。<br /> 首先可以递归计算：<br /> <tex>$$ \mu(1,\;n) = -\sum_{a \mid n,\;a\neq n} \mu(1,\;a) $$</tex></p> <p>考虑对<tex>$n$</tex>进行质因数分解：<br /> <tex>$$ n = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_m^{\alpha_m} $$</tex></p> <p>对于<tex>$n$</tex>的任意一个因子<tex>$d$</tex>都有：<br /> <tex>$$ d = p_1^{\beta_1}p_2^{\beta_2}\cdots p_m^{\beta_m} \;\;\;\; (0 \leqslant \beta_i \leqslant \alpha_i) $$</tex></p> <p>相当于可以看作<tex>$m$</tex>个大小为<tex>$\alpha_1 + 1,\;\alpha_2 + 1,\;\dots,\;\alpha_m + 1$</tex>的偏序集的直积的结果。<br /> 于是可以得到：<br /> <tex>$$ \mu(1,\;n) = \prod_{i=1}^m\mu(1,\;p_i^{\alpha_i}) \tag{7.2} $$</tex></p> <p>注意到，对于<tex>$\varphi(p) = p - 1$</tex>：<br /> <tex>$$ \mu(1,\;1) = 1 \\ \mu(1,\;p) = -\mu(1,\;1) = -1 \;\; \\ \mu(1,\;p^2) = -\left[ \mu(1,\;1) + \mu(1,\;p) \right] = 0 \\ \dots $$</tex></p> <p>总结一下就是：<br /> <tex>$$ \mu(1,\;p^k) = \begin{cases} 1 &amp; (k = 0) \\ -1 &amp; (k = 1) \\ 0 &amp; (\text{otherwise}) \end{cases} \tag{7.3} $$</tex></p> <p>运用直积，可以知道：<br /> <tex>$$ \mu(1,\;n) = \begin{cases} 1 &amp; (n = 1) \\ (-1)^k &amp; (n = p_1p_2\cdots p_k, \;\;\varphi(p_i) = p_i - 1) \\ 0 &amp; (\text{otherwise}) \end{cases} \tag{7.4} $$</tex></p> <p>为了方便，通常把<tex>$\mu(1,\;n)$</tex>记作<tex>$\mu(n)$</tex>，就变成常见的莫比乌斯函数了。</p> <p>据此，我们可以证明莫比乌斯函数是积性函数，即：<br /> <tex>$$ a \bot b \Longrightarrow \mu(ab) = \mu(a)\mu(b) \tag{7.5} $$</tex></p> <p><strong>证明</strong>：<br /> 1. 如果<tex>$a$</tex>、<tex>$b$</tex>中有一者为<tex>$1$</tex>，结论显然成立。<br /> 2. 如果<tex>$a$</tex>、<tex>$b$</tex>中有一者不为素数连乘的形式，它们的积也一定不会是素数连乘的形式，故等于<tex>$0$</tex>。<br /> 3. 此时假设<tex>$a$</tex>、<tex>$b$</tex>都是素数连乘的形式，又因为<tex>$a$</tex>与<tex>$b$</tex>互质，所以它们的素因子中没有相同的。设<tex>$a = p_1p_2\cdots p_m$</tex>和<tex>$b = q_1q_2\cdots q_n$</tex>所以可以知道<tex>$\mu(ab) = (-1)^{n + m} = \mu(a)\mu(b)$</tex>。</p> <h2 id=_6 >反演示例：容斥原理</h2> <p>设<tex>$S$</tex>为有限集，<tex>$A_1,\;A_2,\;\dots,\;A_n$</tex>是<tex>$S$</tex>的子集，<tex>$K \subseteq \{1,\;2,\;\dots,\;n\}$</tex>。<br /> 定义函数<tex>$F(K)$</tex>计数<tex>$s$</tex><strong>同时</strong>满足下列条件：<br /> <tex>$$ s \not\in \bigcup_{i \in K} A_i \\ s \in \bigcap_{i \not\in K} A_i $$</tex></p> <p>即：<br /> <tex>$$ F(K) = \left| \bigcap_{i \not\in K} A_i - \bigcup_{i \in K} A_i \right| \tag{8.1} $$</tex></p> <p>如何脑补这个函数？可以想象成是用<tex>$K$</tex>把<tex>$S$</tex>中的很多东西挖走了，然后剩下的集合再求交集。<br /> 对于此，再定义函数<tex>$G(K)$</tex>：<br /> <tex>$$ G(K) = \sum_{L \subseteq K} F(L) \tag{8.2} $$</tex></p> <p>这货居然计数的是：<br /> <tex>$$ G(K) = \left| \bigcap_{i \not\in K} A_i \right| \tag{8.3} $$</tex></p> <p>如何脑补其正确性？可以想象是一个智障用<tex>$K$</tex>把本来属于它们交集的东西挖去了，然后又一个一个吐出来，于是就还原了原本的交集......<br /> 根据莫比乌斯反演公式可以知道：<br /> <tex>$$ G(K) = \sum_{L \subseteq K} F(K) \Longrightarrow F(K) = \sum_{L \subseteq K} (-1)^{|K| - |L|} G(L) $$</tex></p> <p>所以取<tex>$K = \{1,\;2,\;\dots,\;n\}$</tex>可以得到：<br /> <tex>$$ F(K) = \sum_{L \subseteq K} (-1)^{n - |L|} G(L) \tag{8.4} $$</tex></p> <p>这个时候的<tex>$F(K)$</tex>计数的东西有了新的含义：<br /> <tex>$$ F(K) = \left|\bigcup_{i \in K} A_i\right| = \left|\bigcap_{i \in K} \overline{A}_i \right| \tag{8.5} $$</tex></p> <p>用<tex>$F(K)$</tex>和<tex>$G(K)$</tex>本身的含义来替换，就可以得到<strong>容斥原理</strong> (感觉好神奇)：<br /> <tex>$$ \left|\bigcap_{i = 1}^n \overline{A}_i \right| = \sum_{K \subseteq \{1,\;,2,\;,\dots,\;n\}} (-1)^{|K|} \left| \bigcap_{i \in K} A_i \right| \tag{8.6} $$</tex></p> <h2 id=varphin >反演示例：<tex>$\varphi(n)$</tex>通项公式</h2> <p>欧拉<tex>$\varphi(n)$</tex>函数计数的是不大于<tex>$n$</tex>的与<tex>$n$</tex>互质的正整数个数。<br /> 对于欧拉<tex>$\varphi$</tex>函数，我们有如下的定理：<br /> <tex>$$ n = \sum_{d \mid n} \varphi(d) \tag{9.1} $$</tex></p> <p>有两种证明方法：<br /> 第一种考虑不与<tex>$n$</tex>互质的数，如果存在一个数<tex>$d$</tex>与<tex>$n$</tex>不互质，那么必有<tex>$\gcd(d, n) = a \gt 1$</tex>，换言之<tex>$\gcd(d / a, n / a) = 1$</tex>，所以一个数不与<tex>$n$</tex>互质，那么必定与<tex>$n$</tex>的一个因子互质。所以上式成立。</p> <p>另一种是使用归纳法证明：<br /> 首先考虑<tex>$1$</tex>，是显然成立的。<br /> 然后考虑质数<tex>$p$</tex>，<tex>$\varphi(1) + \varphi(p) = p$</tex>，所以也是成立的。<br /> 考虑质数<tex>$p$</tex>的幂<tex>$p^k$</tex>，它的因子有<tex>$1,\;p,\;p^2,\;\dots,\;p^k$</tex>，由于：<br /> <tex>$$ \varphi(p^k) = (p - 1)p^{k-1} \;\;\;\; (\varphi(p) = p - 1) $$</tex></p> <p>所以我们对其进行等比数列求和：<br /> <tex>$$ \begin{aligned} \sum_{d \mid n} \varphi(d) &amp; = 1 + (p - 1)\sum_{i=0}^{k-1} p^i \\ &amp; = 1 + (p - 1) \cdot {1 - p^k \over 1 - p} \\ &amp; = 1 + p^k - 1 \\ &amp; = p^k \end{aligned} $$</tex></p> <p>故对质数的幂也成立。<br /> 假设对于一个数<tex>$c$</tex>，所有小于<tex>$c$</tex>的数均成立，那么选取<tex>$n$</tex>的两个互质的因子<tex>$a$</tex>、<tex>$b$</tex>使得<tex>$ab = c$</tex>，那么有：<br /> <tex>$$ \sum_{n \mid a} \varphi(n) \sum_{m \mid b} \varphi(m) = a \cdot b = c $$</tex></p> <p>下面证明<tex>$\sum_{n \mid a} \varphi(n) \sum_{m \mid b} \varphi(m) = \sum_{d \mid c} \varphi(d)$</tex>，即可证明原式：<br /> <tex>$$ \begin{aligned} \sum_{n \mid a} \varphi(n) \sum_{m \mid b} \varphi(m) &amp; = \sum_{n \mid a}\sum_{m \mid b}\varphi(n)\varphi(m) &amp; (\text{改变枚举顺序}) \\ &amp; = \sum_{n \mid a}\sum_{m \mid b} \varphi(nm) &amp; (\text{由于}n \bot m) \\ &amp; = \sum_{nm \mid ab} \varphi(nm) &amp; (\text{由于}a \bot b) \\ &amp; = \sum_{d \mid c} \varphi(d) &amp; (\text{等价代换}) \\ &amp; = c \end{aligned} $$</tex></p> <p>注意到<tex>$(9.1)$</tex>式是一个明显的莫比乌斯反演的形式。根据莫比乌斯反演公式，我们可以得到：<br /> <tex>$$ \begin{aligned} \varphi(n) &amp; = \sum_{d \mid n} d \cdot \mu(d,\;n) \\ &amp; = \sum_{d \mid n} d \cdot \mu(1,\;n / d) \\ &amp; = \sum_{d \mid n} d \cdot \mu(n / d) \\ &amp; = \sum_{d \mid n} \mu(d) \cdot n/d \end{aligned} $$</tex></p> <p>考虑一下<tex>$\mu$</tex>函数的取值，对于因子<tex>$1$</tex>，和式中的结果为<tex>$n$</tex>。对于由素数相乘的因子，这些素因子必定来自<tex>$n$</tex>。而其它情况就都为<tex>$0$</tex>。<br /> 设<tex>$n = p_1^{k_1}p_2^{k_2}\cdots p_m^{k_m}$</tex>。<br /> 因此可以得到下面的式子：<br /> <tex>$$ \varphi(n) = n\left[1 - \sum \frac1{p_i} + \sum \frac1{p_ip_j} - \cdots + (-1)^{m}\sum \frac1{\prod_{i=1}^m p_i} \right] \tag{9.2} $$</tex></p> <p>这恰好是下面的式子展开的形式：<br /> <tex>$$ \varphi(n) = n\prod_{i=1}^m \left( 1 - \frac1{p_i} \right) \tag{9.3} $$</tex></p> <p>因此：<br /> <tex>$$ \varphi(n) = n\prod_{p \mid n,\;\varphi(p) = p - 1} \left( 1 - \frac1p\right) \tag{9.4} $$</tex></p> <h2 id=_7 >反演示例：多重集合的循环排列</h2> <blockquote> <p>我们有一个多重集合<tex>$\{\infty \cdot 1,\;\infty \cdot 2,\;\dots,\;\infty \cdot k\}$</tex>。易知长度为<tex>$n$</tex>的全排列数为<tex>$k^n$</tex>。<br /> 现在对于两个排列<tex>$A$</tex>和<tex>$B$</tex>，如果<tex>$A$</tex>通过&rdquo;旋转&rdquo; (即将最后一个变成第一个，并且把之前的全部后移) 能变成<tex>$B$</tex>，那么<tex>$A$</tex>和<tex>$B$</tex>是等价的。<br /> 换言之，最小表示法相同的排列是等价。<br /> 求不同的长度为<tex>$n$</tex>的<strong>循环排列</strong>数量。</p> </blockquote> <p>对于这个计数问题，我们记<tex>$h(n)$</tex>为长度为<tex>$n$</tex>时的答案，<tex>$f(n)$</tex>为长度为<tex>$n$</tex>并且<strong>旋转</strong><tex>$n$</tex>次才会变为原排列 (即循环节长度为<tex>$n$</tex>) 的排列的数量。显然，一个排列的循环节长度<tex>$m$</tex>必须满足<tex>$m \mid n$</tex>。<br /> 那么可以知道：<br /> <tex>$$ h(n) = \sum_{d \mid n} \frac{f(d)}d \tag{10.1} $$</tex></p> <p>由于循环节长度小于<tex>$n$</tex>的排列都可以由循环节不断重复而得来。因此我们设：<br /> <tex>$$ g(n) = \sum_{d \mid n} f(d) $$</tex></p> <p><tex>$g(n)$</tex>就计数了所有长度为<tex>$n$</tex>的排列数量。<br /> 所以：<br /> <tex>$$ g(n) = k^n \tag{10.2} $$</tex></p> <p>根据莫比乌斯反演公式可得：<br /> <tex>$$ \begin{aligned} f(n) &amp; = \sum_{d \mid n} g(d)\mu(n/d) \\ &amp; = \sum_{d \mid n} k^d\mu(n/d) \end{aligned} \tag{10.3} $$</tex></p> <p>带入<tex>$h(n)$</tex>的计算公式可得：<br /> <tex>$$ h(n) = \sum_{d \mid n} \frac1d \sum_{e \mid d} k^e\mu(d/e) \tag{10.4} $$</tex></p> <p>由于<tex>$e \mid d$</tex>并且<tex>$d \mid n$</tex>，所以我们设<tex>$n = rd,\;d = me$</tex>，所以<tex>$n = rem$</tex>，这样将方便我们变换公式：<br /> <tex>$$ \begin{aligned} \sum_{d \mid n} \frac1d \sum_{e \mid d} k^e\mu(d/e) &amp; = \sum_{e \mid n} k^e \sum_{m \mid (n/e)} \frac1{me}\mu(m) \\ &amp; =\sum_{e\mid n} \frac{k^e}n \sum_{r \mid (n/e)} r\cdot\mu(\frac{n}e/r) \end{aligned} $$</tex></p> <p>由于：<br /> <tex>$$ \varphi(n) = \sum_{d \mid n} d \cdot \mu(n/d) $$</tex></p> <p>所以：<br /> <tex>$$ h(n) = \frac1n \sum_{d \mid n} k^d \varphi(n/d) \tag{10.5} $$</tex></p> <h2 id=_8 >莫比乌斯函数示例：最大公约数</h2> <p>除了莫比乌斯反演公式，莫比乌斯函数本身的性质也是很好的。<br /> 考虑下面一个问题：</p> <blockquote> <p>给定<tex>$n$</tex>和<tex>$m$</tex>，求<tex>$\gcd(x,\;y)\;\;(1 \leqslant x \leqslant n,\;1 \leqslant y \leqslant m)$</tex>为<strong>素数</strong>的二元组<tex>$(x,\;y)$</tex>个数。</p> </blockquote> <p>换言之，我们要求的是这个：<br /> <tex>$$ \sum_{x=1}^n\sum_{y=1}^m \left[\varphi(\gcd(x,\;y)) = \gcd(x,\;y) - 1\right] \tag{11.1} $$</tex></p> <p>首先，我们可以换个思路，就是枚举最大公约数的答案：<br /> <tex>$$ \sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^n\sum_{y=1}^m \left[ \gcd(x,\;y) = p \right] \tag{11.2} $$</tex></p> <p>由于<tex>$\gcd(x,\;y) = p \Longrightarrow \gcd(x/p,\;y/p) = 1$</tex>，所以就变成了枚举互质的数的对数：<br /> <tex>$$ \sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^{\left\lfloor \frac{n}p\right\rfloor}\sum_{y=1}^{\left\lfloor \frac{m}p \right\rfloor} \left[ \gcd(x,\;y) = 1 \right] \tag{11.3} $$</tex></p> <p>由于莫比乌斯函数有这样的性质：<br /> <tex>$$ \sum_{d \mid n} \mu(d) = [n = 1] \tag{11.4} $$</tex></p> <p>所以可以使用莫比乌斯函数来测试一个数是否为<tex>$1$</tex>：<br /> <tex>$$ \sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^{\left\lfloor \frac{n}p\right\rfloor}\sum_{y=1}^{\left\lfloor \frac{m}p \right\rfloor} \sum_{d \mid \gcd(x,\;y)} \mu(d) \tag{11.5} $$</tex></p> <p>因为<tex>$d \mid \gcd(x,\;y)$</tex>当且仅当<tex>$d \mid x$</tex>并且<tex>$d \mid y$</tex>，所以可以变成这样：<br /> <tex>$$ \sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^{\left\lfloor \frac{n}p\right\rfloor}\sum_{y=1}^{\left\lfloor \frac{m}p \right\rfloor} \sum_{d \mid x \,\land\, d \mid y} \mu(d) \tag{11.6} $$</tex></p> <p>现在东西越来越多了，是时候考虑简化一下了。<br /> 首先对于一堆和式的一个技巧就是<strong>调整枚举顺序</strong>。<br /> 尝试先枚举<tex>$d$</tex>，这样合法的<tex>$d$</tex>就可以直接计算了：<br /> <tex>$$ \sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}} \sum_{d=1}^{\min\{n,\;m\}} \left\lfloor \frac{n}{dp} \right\rfloor \left\lfloor \frac{m}{dp} \right\rfloor \mu(d) \tag{11.7} $$</tex></p> <p>其实这个式子已经可以用来计算答案了。注意到对于一个数<tex>$n$</tex>，<tex>$\lfloor n / i \rfloor$</tex>的取值最多有<tex>$O(\sqrt{n})$</tex>种，因为：</p> <ol> <li>如果<tex>$i \leqslant \sqrt{n}$</tex>，这样的<tex>$i$</tex>只有<tex>$O(\sqrt{n})$</tex>种。 <li>如果<tex>$i &gt; \sqrt{n}$</tex>，那么<tex>$\lfloor n / i \rfloor \leqslant \sqrt{n}$</tex>，这样的取值只有<tex>$O(\sqrt{n})$</tex>种。 </ol> <p>所以两个向下取整的乘积最多有<tex>$O(\sqrt{n} + \sqrt{m})$</tex>个不同的取值，左边枚举的素数约为<tex>$O({n \over \ln n})$</tex>个，故根据此公式计算的时间复杂度为<tex>$O({n (\sqrt{n} + \sqrt{m}) \over \ln n})$</tex>。<br /> 然而我们可以做得更快一些。<br /> 设<tex>$T = dp$</tex>，现在改成先枚举<tex>$T$</tex>：<br /> <tex>$$ \sum_{T = 1}^{\min\{n,\;m\}} \left\lfloor \frac{n}T \right\rfloor \left\lfloor \frac{m}T \right\rfloor \sum_{p \mid T,\;\varphi(p) = p - 1} \mu(T / p) \tag{11.8} $$</tex></p> <p>这样左边就可以在<tex>$O(\sqrt{n} + \sqrt{m})$</tex>的时间内进行枚举。<br /> 枚举大概是这样的一个过程：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre>1
2
3
4
5
6</pre></div><td class=code ><div class=codehilite ><pre><span></span>lastpos = 0
i = 1
while i &lt;= min(n, m):
    lastpos = min(n / (n / i), m / (m / i))
    # Do something...
    i = lastpos + 1
</pre></div> </table> <p>我们企图能使右边快速计算。因此我们来研究一下右边这个玩意。<br /> 设：<br /> <tex>$$ g(x) = \sum_{p \mid x,\;\varphi(p) = p - 1} \mu(x/p) \tag{11.9} $$</tex></p> <p>考虑使用线性筛来计算<tex>$g(x)$</tex>。</p> <ol> <li>当<tex>$x = 1$</tex>时，<tex>$g(x) = 0$</tex>。 <li>当<tex>$x$</tex>为素数时，<tex>$g(x) = 1$</tex>。 <li>在线性筛的处理过程中，设当前数为<tex>$i$</tex>，枚举到的素数为<tex>$p$</tex>，我们将要计算<tex>$g(ip)$</tex>：<ol> <li>当<tex>$\mu(i) = 0$</tex>时，说明<tex>$i$</tex>的质因数分解中至少存在一个一个素因子的次数大于<tex>$1$</tex>。<br /> 在这种情况下，除非<strong>只有一个</strong>素因子的次数为<tex>$2$</tex>，其它均为<tex>$1$</tex>，否则无论如何<tex>$g$</tex>的函数值都为<tex>$0$</tex>。<br /> 假设只存在一个素因子的次数为<tex>$2$</tex>，记这个素因子为<tex>$f(i)$</tex>。<ol> <li>若<tex>$p \mid i$</tex>，那么将会导致无论是哪个素因子，<tex>$\mu$</tex>函数的值都为<tex>$0$</tex>。因此<tex>$g$</tex>函数的值为<tex>$0$</tex>。 <li>若<tex>$p \nmid i$</tex>，那么就只有除以<tex>$f(i)$</tex>时会有值，此时的值为<tex>$\mu(i / f(i) \cdot p)$</tex>。 </ol> <li>当<tex>$\mu(i) \neq 0$</tex>时，意味着<tex>$i$</tex>将是多个素数之积。同样我们来考虑两种情况：<ol> <li>若<tex>$p \mid i$</tex>，那么就只有<tex>$p$</tex>的次数为<tex>$2$</tex>，此时<tex>$g(ip) = \mu(i)$</tex>。 <li>若<tex>$p \nmid i$</tex>，那么<tex>$\mu(ip)$</tex>依然不为<tex>$0$</tex>。假设<tex>$i$</tex>有<tex>$r$</tex>个素因子，那么<tex>$g(i) = r(-1)^{r-1}$</tex>，并且<tex>$g(ip) = (r + 1)(-1)^r = -r(-1)^{r-1} + (-1)^{r+1}$</tex>，这意味着它们符号相反且绝对值差<tex>$1$</tex>。这样就可以直接计算。 </ol> </ol> </ol> <p>经过一番分类讨论，我们总算成功地找到了预处理<tex>$g(x)$</tex>的方法。<br /> 在这中间有一个问题还亟待解决，就是我们需要计算<tex>$f(x)$</tex>，事实上它也可以用线性筛计算。<br /> 假设存在这样的素因子<tex>$p$</tex>，就记<tex>$f(x) = p$</tex>。如果<tex>$x$</tex>还是多个素数相乘，就记<tex>$f(x) = 1$</tex>。否则记作<tex>$0$</tex>，又称为&rdquo;没救了&rdquo;。这样就只有<tex>$f(x) \gt 1$</tex>时才有我们需要的结果。</p> <ol> <li>当<tex>$x = 1$</tex>或<tex>$x$</tex>为质数时，<tex>$f(x) = 1$</tex>。 <li>每次往一个数<tex>$i$</tex>加入一个素数<tex>$p$</tex>时，需要考虑下面的情况：<ol> <li>若<tex>$f(i) = 0$</tex>，那么没救了。 <li>若<tex>$p \mid i$</tex>，并且<tex>$f(i) = 1$</tex>，那么<tex>$ip$</tex>将不再是素数连乘的形式，此时可以记下<tex>$f(ip) = p$</tex>。如果<tex>$f(i) &gt; 1$</tex>，那么它没救了。 <li>若<tex>$p \nmid i$</tex>，那么<tex>$f$</tex>函数值不会改变。 </ol> </ol> <p>这样就可以欢快地计算<tex>$f$</tex>函数啦~<br /> 回到之前的问题，我们能够计算<tex>$g(x)$</tex>函数后，预处理出它的前缀和，就可以在前面伪代码中展示的迭代过程计算答案了。时间复杂度是<tex>$O(\sqrt{n} + \sqrt{m})$</tex>。</p> <h2 id=divcnt2 >莫比乌斯函数示例：DIVCNT2</h2> <p><a href="http://www.spoj.com/problems/DIVCNT2">SPOJ DIVCNT2</a></p> <blockquote> <p>要求求出：<br /> <tex>$$ \sum_{a = 1}^n \sigma(a^2) $$</tex></p> <p>的值。其中<tex>$\sigma(n)$</tex>表示<tex>$n$</tex>的因子个数。</p> </blockquote> <p>考虑这么几个等式关系：<br /> <tex>$$ \sigma(n^2) = \sum_{d \mid n} 2^{\omega(d)} \tag{12.1} $$</tex></p> <p>其中<tex>$\omega(n)$</tex>表示<tex>$n$</tex>的质因子个数。为什么这是正确的呢？考虑每个<tex>$n$</tex>的因子<tex>$d$</tex>，<tex>$d^2$</tex>都是<tex>$n^2$</tex>的因子。另外，对于任意<tex>$n$</tex>的任意两个不同的因子，它们的质因数分解中至少有一个素数的次数的差不小于<tex>$1$</tex>，那么经过平方后，这个差值将不小于<tex>$2$</tex>。于是它们的平方任意删去一个素数后，是不会冲突的。这样，我们只要对每个<tex>$d^2$</tex>，都枚举一下删去素数的方案，就可以得到<tex>$n^2$</tex>的所有因子。答案也就是上式。</p> <p><tex>$$ 2^{\omega(n)} = \sum_{d \mid n} \mu^2(d) \tag{12.2} $$</tex></p> <p>考虑到<tex>$\mu$</tex>函数的取值：<br /> <tex>$$ \mu(n) = \begin{cases} 1 &amp; (n = 1) \\ (-1)^k &amp; (n = p_1p_2\cdots p_k, \;\;\varphi(p_i) = p_i - 1) \\ 0 &amp; (\text{otherwise}) \end{cases} $$</tex></p> <p>因此：<br /> <tex>$$ \mu^2(n) = \begin{cases} 1 &amp; (n = 1) \\ 1 &amp; (n = p_1p_2\cdots p_k, \;\;\varphi(p_i) = p_i - 1) \\ 0 &amp; (\text{otherwise}) \end{cases} $$</tex></p> <p>即只要是<tex>$d$</tex>是素数连乘的形式，就会对答案贡献。否则没有贡献。这也正是<tex>$2^{\omega(n)}$</tex>想要统计的。</p> <p>对于省去了第一维的数论函数<tex>$f$</tex>和<tex>$g$</tex>，定义它们的<strong>狄利克雷卷积</strong>是下面的形式：<br /> <tex>$$ (f \times g)(n) = \sum_{d \mid n} f(d)g\left(\frac{n}{d}\right) \tag{12.3} $$</tex></p> <p>也就是在偏序集<tex>$(X_n, \;\mid)$</tex>上的卷积。令<tex>$f(n) = \sigma(n^2)$</tex>，<tex>$g(n) = 2^{\omega(n)}$</tex>，<tex>$h(n) = \mu^2(n)$</tex>以及<tex>$\epsilon(n) = 1$</tex>，这样我们可以把之前的结果简写为：<br /> <tex>$$ f = g \times \epsilon \\ g = h \times \epsilon $$</tex></p> <p>利用卷积的结合律，可以得到：<br /> <tex>$$ \begin{aligned} f &amp; = (h \times \epsilon) \times \epsilon \\ &amp; = h \times (\epsilon \times \epsilon) \end{aligned} $$</tex></p> <p>注意到：<br /> <tex>$$ \begin{aligned} \epsilon \times \epsilon &amp; = \sum_{d \mid n} 1 \\ &amp; = \sigma(n) \end{aligned} $$</tex></p> <p>所以，我们要求的东西也就是：<br /> <tex>$$ \begin{aligned} \sum_{i = 1}^n f(i) &amp; = \sum_{i = 1}^n \sum_{d \mid i} \mu^2(d) \sigma\left({i \over d}\right) \\ &amp; = \sum_{i = 1}^n \mu^2(i) \sum_{j = 1}^{\left\lfloor {n \over i} \right\rfloor} \sigma(j) \end{aligned} $$</tex></p> <p>首先考虑<tex>$\sigma(n)$</tex>的前缀和如何计算：<br /> <tex>$$ \sum_{i = 1}^n \sigma(i) = \sum_{i = 1}^n \left\lfloor {n \over i} \right\rfloor \tag{12.4} $$</tex></p> <p>由于下取整可以分段，所以可以在<tex>$O(\sqrt{n})$</tex>的复杂度内计算。</p> <p>然后考虑<tex>$\mu^2(n)$</tex>的前缀和如何计算：<br /> <tex>$$ \sum_{i = 1}^n \mu^2(i) = \sum_{i = 1}^{\sqrt{n}} \mu(i)\left\lfloor {n \over i^2} \right\rfloor \tag{12.5} $$</tex></p> <p>这是为什么？结合<tex>$\mu^2(n)$</tex>的意义，这个前缀和就是统计前<tex>$n$</tex>个数里面，有多少个数是素数连乘的形式。当<tex>$i = 1$</tex>时，所有数字均被统计了一遍。然后枚举<tex>$1$</tex>到<tex>$\sqrt{n}$</tex>的每个数字，如果不是素数连乘的形式，<tex>$\mu(i)$</tex>会返回<tex>$0$</tex>。如果是素数连乘的形式，那么它的任意大于<tex>$1$</tex>的次数的幂都不是答案，此时应当删去。于是<tex>$\mu$</tex>函数在此充当了容斥系数。</p> <p>回到之前的式子：<br /> <tex>$$ \sum_{i = 1}^n \mu^2(i) \sum_{j = 1}^{\left\lfloor {n \over i} \right\rfloor} \sigma(j) $$</tex></p> <p>对于<tex>$\sigma(n)$</tex>的前缀和的上标也是可以分段的，这样就需要用到<tex>$\mu^2(n)$</tex>的前缀和。</p> <p>所以最后的复杂度可以这样估计：<br /> <tex>$$ \sum_{k = 1}^{\sqrt{n}} \sqrt{k} + \sum_{k = 1}^{\sqrt{n}} \sqrt{{n \over k}} \tag{12.6} $$</tex></p> <p>显然右边的代价更高。用积分可以估计一下：<br /> <tex>$$ \sum_{k = 1}^{\lfloor \sqrt{n} \rfloor} \sqrt{n \over k} \leqslant \int_0^{\lfloor \sqrt{n} \rfloor} \sqrt{n \over x} \;\mathrm{d}x = O(n^{3/4}) $$</tex></p> <p>如果预处理前<tex>$S$</tex>个前缀和的答案，当询问<tex>$\mu^2(n)$</tex>和<tex>$\sigma(n)$</tex>的前缀和时，如果<tex>$n \leqslant S$</tex>，就直接返回预处理的值。那么复杂度大约为：<br /> <tex>$$ \sum_{k = 1}^{\min\{\lfloor \sqrt{n} \rfloor, \lfloor n / S \rfloor\}} \sqrt{n \over x} \tag{12.7} $$</tex></p> <p>当<tex>$S \lt \sqrt{n}$</tex>时，时间复杂度的分析不变。否则时间复杂度上界变为：<br /> <tex>$$ O\left(S + {n \over \sqrt{S}}\right) $$</tex></p> <p>当<tex>$S = n / \sqrt{S}$</tex>时取得最小值，此时<tex>$S = n^{2/3}$</tex>，时间复杂度为<tex>$O(n^{2/3})$</tex>。注意，这里空间上也要付出同样的代价。</p> <div class=footnote > <hr /> <ol> <li id="fn:possible"> <p>在偏序集<tex>$(X_n,\;\mid\;)$</tex>上简化后的卷积 (即狄利克雷卷积)，会满足交换律。&#160;<a class=footnote-backref  href="#fnref:possible" rev=footnote  title="Jump back to footnote 1 in the text">&#8617;</a></p> </ol> </div> <hr/> <div id=comments ></div> <script> window.addEventListener('load', () => { quicklink(); }); const gitment = new Gitment({id: '4040224722c8bc957a9a714393a4c385', owner: 'riteme', repo: 'riteme.github.io', oauth: { client_id: 'd4fcffa25858a7a58e1a', client_secret: 'e0c8e08beb95497871f8355416c69390634cec76' }, perPage: 10, }); gitment.render('comments'); </script> </div> </div> <div class="mdl-cell sidebar"> <div class=article > <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">页面信息</div> <div class=mdl-card__supporting-text > 标签: <a href="/search.html?q=数学"><span class=label >数学</span></a> <a href="/search.html?q=组合数学"><span class=label >组合数学</span></a> <a href="/search.html?q=莫比乌斯反演"><span class=label >莫比乌斯反演</span></a><br/> 创建时间: 2016.08.18<br/> 上次修改: 2019.02.27<br/> 字数统计: 19310 字 / 约 1 小时 17 分钟 </div> </div> <br/> <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">目录</div> <div class=mdl-card__supporting-text > <div class=toc > <ul> <li><a href="#_1">莫比乌斯反演</a><ul> <li><a href="#_2">偏序集</a> <li><a href="#_3">卷积</a> <li><a href="#_4">莫比乌斯反演公式</a> <li><a href="#_5">偏序集直积</a> <li><a href="#x_nleqslant">在$(X_n,\;\leqslant)$上的莫比乌斯函数</a> <li><a href="#x_nsubseteq">在$(X_n,\;\subseteq)$上的莫比乌斯函数</a> <li><a href="#x_nmid">在$(X_n,\;\mid)$上的莫比乌斯函数</a> <li><a href="#_6">反演示例：容斥原理</a> <li><a href="#varphin">反演示例：$\varphi(n)$通项公式</a> <li><a href="#_7">反演示例：多重集合的循环排列</a> <li><a href="#_8">莫比乌斯函数示例：最大公约数</a> <li><a href="#divcnt2">莫比乌斯函数示例：DIVCNT2</a> </ul> </ul> <ul><li><a href="#comments">评论区</a></ul></div> </div> </div> <br/> <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">数学公式渲染</div> <div class=mdl-card__supporting-text > <form name=mathopt > <label class="mdl-radio mdl-js-radio" for=option-1 > <input type=radio  id=option-1  class=mdl-radio__button  name=sel  value=mathjax > <span class=mdl-radio__label >MathJax</span> </label><br/> <label class="mdl-radio mdl-js-radio" for=option-2 > <input type=radio  id=option-2  class=mdl-radio__button  name=sel  value=katex > <span class=mdl-radio__label >KaTeX</span> </label> <div id=tip-1 > <label class="mdl-radio mdl-js-radio" for=option-3 > <input type=radio  id=option-3  class=mdl-radio__button  name=sel  value="katex&mathjax"> <span class=mdl-radio__label >Mixed</span> </label> </div> </form> <div id=tip-2 > <label class="mdl-checkbox mdl-js-checkbox" for=mathopt-align > <input type=checkbox  id=mathopt-align  class=mdl-checkbox__input > <span class=mdl-checkbox__label >居中显示</span> </label> </div> </div> </div> <div class=mdl-tooltip  data-mdl-for=tip-1 >先使用 KaTeX 渲染，再使用 MathJax 渲染</div> <div class=mdl-tooltip  data-mdl-for=tip-2 >该选项目前仅支持 KaTeX 渲染的公式<br/>点击公式可以切换单个公式的对齐方式</div> <br/> <div class="nano mdl-card mdl-shadow--2dp sidebar-card"> <div class=mdl-card__actions > <div class=nano-shell ><span class=shell-start >$</span> nano <a href="https://github.com/riteme/riteme.github.io/blob/master/blog/2016-8-18/mobius.md" id=nano-link >mobius.md</a></div> </div> </div> <div class=mdl-tooltip  data-mdl-for=nano-link >查看原始 Markdown 文档</div> </div> </div> </div> <footer class=mdl-mega-footer > <div class=mdl-mega-footer__middle-section > <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >RITEME.SITE</h2><del>一个从不乱说话的博客</del> </div> <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >POWERED BY</h2> <ul class=mdl-mega-footer__link-list > <li><a href="http://pythonhosted.org/Markdown/">Python Markdown</a> <li><a href="http://getmdl.io/">Material Design Lite</a> <li><a href="http://www.tipue.com/search/">Tipuesearch</a> <li><a href="http://www.mathjax.org/">MathJax</a> & <a href="http://khan.github.io/KaTeX/">KaTeX</a> <li><a href="https://github.com/imsun/gitment">Gitment</a> </ul> </div> <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >友情链接</h2> <ul class=mdl-mega-footer__link-list > <li><a href="http://ruanx.pw/">ruanxingzhi</a> <li><a href="https://blog.xehoth.cc/">xehoth</a> <li><a href="http://hjwjbsr.is-programmer.com/">HJWJBSR</a> <li><a href="http://www.micdz.cn/">MicDZ</a> <li><a href="https://cmxrynp.github.io/">CMXRYNP</a> <li><a href="http://memset0.cn/">memset0</a> </ul> </div> </div> <div class=mdl-mega-footer__bottom-section >Theme based on <a href="https://getmdl.io/">MDL</a> | <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" class=cc  src="/assets/cc-by-nc-sa-4.png" /></a> CC BY-NC-SA 4.0 </div> </footer> </main> </div>