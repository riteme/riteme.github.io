<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>莫比乌斯反演 - riteme.site</title>
  <link rel="shortcut icon" href="/favicon.png" type="image/png">
  <link rel="stylesheet" href="/material/material-icons.css">
  <link rel="stylesheet" href="/material/material.min.css" >
  <link href="/tipuesearch/tipuesearch.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/gitment/gitment.css">
  <link rel="stylesheet" href="/math-renderer/katex/katex.min.css">
  <link href="/css/site.css" rel="stylesheet">
  <script src="/jquery/jquery-2.2.4.min.js"></script>
  <script src="/jquery/js-cookie.js"></script>
  <script defer src="/material/material.min.js"></script>
  <script src="/tipuesearch/tipuesearch_set.js"></script>
  <script src="/tipuesearch/tipuesearch.min.js"></script>
  <script src="/gitment/gitment.js"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config( { tex2jax: { inlineMath: [['$','$']] }, "HTML-CSS": { scale: 95 } } );
  </script>
  <script src="/math-renderer/selector.js"></script>
  <script src="/math-renderer/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script src="/math-renderer/katex/katex.min.js"></script>
  <script src="/math-renderer/katex/auto-render.min.js"></script>
</head>

<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header">
    <header class="mdl-layout__header">
      <div class="mdl-layout__header-row">
        <span class="mdl-layout-title">莫比乌斯反演</span>
        <div class="mdl-layout-spacer"></div>
        <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable
        mdl-textfield--floating-label mdl-textfield--align-right">
        <label class="mdl-button mdl-js-button mdl-button--icon"
        for="fixed-header-drawer-exp"><i class="material-icons">search</i></label>
        <div class="mdl-textfield__expandable-holder">
          <form action="/search.html"><input type="text" class="mdl-textfield__input" placeholder="Search Here" name="q" id="fixed-header-drawer-exp" autocomplete="off" required></form>
        </div>
      </div>
    </div>
  </header>
  <div class="mdl-layout__drawer">
    <span class="mdl-layout-title drawer-title">
      <a href="/index.html" style="color: inherit; font-weight: inherit;text-decoration: none;">
        <img src="/favicon.png" width=32 height=32> riteme.site
      </a>
    </span>
    <nav class="mdl-navigation">
      <a class="mdl-navigation__link" href="/index.html"><i class="material-icons drawer-icon">home</i> 首页</a>
      <a class="mdl-navigation__link" href="/posts.html"><i class="material-icons drawer-icon">library_books</i> 所有文章</a>
      <a class="mdl-navigation__link" href="/about.html"><i class="material-icons drawer-icon">info</i> 关于</a>
      <a class="mdl-navigation__link" href="/links.html"><i class="material-icons drawer-icon">link</i> 友链</a>
      <a class="mdl-navigation__link" href="/search.html"><i class="material-icons drawer-icon">search</i> 搜索</a>
      <a class="mdl-navigation__link" href="https://github.com/riteme/riteme.github.io"><i class="material-icons drawer-icon">class</i> GitHub 项目</a>
    </nav>
  </div>
  <main class="mdl-layout__content">
    <div class="mdl-grid">
      <div class="mdl-cell mdl-cell--9-col mdl-cell--12-col-tablet mdl-cell--12-col-phone">
        <div class="article">
          
<h1 id="_1">莫比乌斯反演</h1>
<blockquote>
<p>我把《组合数学》抄了一遍，免得我记不住......</p>
</blockquote>
<h2 id="_2">偏序集</h2>
<p>这里的莫比乌斯反演是从关联代数的角度来介绍的。首先介绍一个基础的概念：偏序集。<br />
它通常写作<mathjax>$(X_n,\;\leqslant)$</mathjax>，其中<mathjax>$X_n$</mathjax>是一个有限或者无限的集合，<mathjax>$\leqslant$</mathjax>是代指偏序关系，而<strong>不是特指小于等于符号</strong>。<br />
所谓偏序关系，就是指<mathjax>$a,\;b,\;c \in X_n$</mathjax>并且<mathjax>$a \leqslant b,\;b \leqslant c$</mathjax>，有<mathjax>$a \leqslant c$</mathjax>的性质的关系。<br />
这种偏序关系一般是比较符<mathjax>$\leqslant$</mathjax>、集合的<mathjax>$\subseteq$</mathjax>符号和整除<mathjax>$\;\mid\;$</mathjax>。</p>
<h2 id="_3">卷积</h2>
<p>对于定义在偏序集<mathjax>$(X_n,\;\leqslant)$</mathjax>上的二元函数<mathjax>$f(x,\;y)$</mathjax>，我们假定当<mathjax>$x \not\leqslant y$</mathjax>时，<mathjax>$f(x,\;y)$</mathjax>均为<mathjax>$0$</mathjax>，这样是为了方便我们之后的讨论。<br />
考虑偏序集<mathjax>$(X_n, \leqslant)$</mathjax>上的二元函数<mathjax>$f(x,\;y)$</mathjax>和<mathjax>$g(x,\;y)$</mathjax>，定义它们的卷积为：<br />
<mathjax>$$
(f \times g)(x,\;y) = \sum_{x \leqslant z \leqslant y} f(x,\;z)g(z,\;y) \tag{2.1}
$$</mathjax></p>
<p>这个卷积满足结合律：<br />
<mathjax>$$
(f \times g) \times h = f \times (g \times h) \tag{2.2}
$$</mathjax></p>
<p>注意，这个卷积<strong>不一定<sup id="fnref:possible"><a class="footnote-ref" href="#fn:possible" rel="footnote">1</a></sup>满足交换律</strong>。</p>
<p>以及三种强行定义的莫名其妙的函数：<br />
<mathjax>$\delta$</mathjax> (delta) 函数：<br />
<mathjax>$$
\delta(x,\;y) = [x = y] \tag{2.3}
$$</mathjax></p>
<p>任意函数卷<mathjax>$\delta$</mathjax>函数均会得到原函数。</p>
<p><mathjax>$\zeta$</mathjax> (zeta) 函数：<br />
<mathjax>$$
\zeta(x,\;y) = [x \leqslant y] \tag{2.4}
$$</mathjax></p>
<p>以及莫比乌斯<mathjax>$\mu$</mathjax>函数是定义为<mathjax>$\zeta$</mathjax>函数的<strong>逆函数</strong>，即：<br />
<mathjax>$$
\mu \times \zeta = \zeta \times \mu = \delta \tag{2.5}
$$</mathjax></p>
<p>展开卷积可得：<br />
<mathjax>$$
\begin{aligned}
\delta = \mu \times \zeta \Longrightarrow \delta(x,\;y) &amp; = \sum_{x \leqslant z \leqslant y} \mu(x,\;z)\zeta(z,\;y) \\
&amp; = \sum_{x \leqslant z \leqslant y} \mu(x,\;z)
\end{aligned}
$$</mathjax></p>
<p>因此，当<mathjax>$x \neq y$</mathjax>时：<br />
<mathjax>$$
\mu(x,\;y) = - \sum_{x \leqslant z \lt y} \mu(x,\;z) \tag{2.6}
$$</mathjax></p>
<h2 id="_4">莫比乌斯反演公式</h2>
<blockquote>
<p><strong>(莫比乌斯反演公式)</strong><br />
对于有限偏序集<mathjax>$(X_n,\;\leqslant)$</mathjax>上的两个函数<mathjax>$F(x,\;y)$</mathjax>和<mathjax>$G(x,\;y)$</mathjax>，如果：<br />
<mathjax>$$ G(x,\;y) = \sum_{x \leqslant z \leqslant y} F(x,\;z) \tag{3.1}$$</mathjax></p>
<p>那么：<br />
<mathjax>$$F(x,\;y) = \sum_{x \leqslant z \leqslant y} G(x,\;z)\mu(z,\;y)  = (G \times \mu)(x,\;y) \tag{3.2}$$</mathjax></p>
</blockquote>
<p><strong>证明</strong> 首先将式子展开：<br />
<mathjax>$$
\begin{aligned}
F(x,\;y) &amp; = \sum_{x \leqslant z \leqslant y} G(x,\;z)\mu(z,\;y) \\
&amp; = \sum_{x \leqslant z \leqslant y} \mu(z,\;y) \sum_{x \leqslant m \leqslant z} F(x,\;m)
\end{aligned}
$$</mathjax></p>
<p>我们使用<mathjax>$\zeta$</mathjax>函数来表示上下界，于是式子改写为以下形式：<br />
<mathjax>$$
\sum_{x \leqslant z \leqslant y} \mu(z,\;y) \sum_{m \in X_n} F(x,\;m)\zeta(x,\;m)\zeta(m,\;z)
$$</mathjax></p>
<p>改变求和的枚举顺序，先枚举<mathjax>$m$</mathjax>，其值依然不变：<br />
<mathjax>$$
\sum_{m \in X_n} \sum_{x \leqslant z \leqslant y} \zeta(m,\;z)\mu(z,\;y)\zeta(x,\;m)F(x,\;m)
$$</mathjax></p>
<p>由于当<mathjax>$m \lt x$</mathjax>的时候<mathjax>$\zeta(x,\;m)$</mathjax>为<mathjax>$0$</mathjax>，因此只用考虑<mathjax>$m \geqslant x$</mathjax>。<br />
同理，我们可以得出<mathjax>$z \geqslant m$</mathjax>是必须的。<br />
因此可以改写下界：<br />
<mathjax>$$
\sum_{m \in X_n} \sum_{m \leqslant z \leqslant y} \zeta(m,\;z)\mu(z,\;y)F(x,\;m)
$$</mathjax></p>
<p>然后变成了卷积的形式：<br />
<mathjax>$$
\begin{aligned}
\sum_{m \in X_n} F(x,\;m) \sum_{m \leqslant z \leqslant y} \zeta(m,\;z)\mu(z,\;y) &amp; = \sum_{m \in X_n} F(x,\;m) \delta(m,\;y) \\
&amp; = F(x,\;y)
\end{aligned}
$$</mathjax></p>
<p>当<mathjax>$m = y$</mathjax>时，<mathjax>$\delta(m,\;y)$</mathjax>才为<mathjax>$1$</mathjax>，所以综上所述：<br />
<mathjax>$$
F(x,\;y) = \sum_{x \leqslant z \leqslant y} G(x,\;z)\mu(z,\;y) \tag{3.2}
$$</mathjax></p>
<h2 id="_5">偏序集直积</h2>
<p>对于两个偏序集<mathjax>$(A,\;\leqslant_1)$</mathjax>和<mathjax>$(B,\;\leqslant_2)$</mathjax>，它们的直积<mathjax>$C = A \times B = (A \times B,\;\leqslant)$</mathjax>也是偏序集，其中的元素为<mathjax>$(x,\;y)\;\;(x \in A,\;y \in B)$</mathjax>。其关系<mathjax>$\leqslant$</mathjax>的定义如下：<br />
<mathjax>$$
(x_1,\;y_1) \leqslant (x_2,\;y_2) \Longleftrightarrow x_1 \leqslant_1 x_2 \land y_1 \leqslant_2 y_2
$$</mathjax></p>
<p>对于偏序集的直积，我们有以下定理：</p>
<blockquote>
<p>设<mathjax>$A$</mathjax>和<mathjax>$B$</mathjax>的莫比乌斯函数分别为<mathjax>$\mu_1$</mathjax>和<mathjax>$\mu_2$</mathjax>，那么<mathjax>$C$</mathjax>的莫比乌斯函数满足：<br />
<mathjax>$$\mu((x_1,\;y_1),\;(x_2,\;y_2)) = \mu_1(x_1,\;x_2)\mu(y_1,\;y_2) \tag{4.1}$$</mathjax></p>
</blockquote>
<p><strong>证明</strong> 对于<mathjax>$(x_1,\;y_1) \not\leqslant (x_2,\;y_2)$</mathjax>和<mathjax>$(x_1,\;y_1) = (x_2,\;y_2)$</mathjax>的情况，上式显然成立。<br />
假设对于满足<mathjax>$(x_1,\;y_1) \leqslant (u,\;v) \lt (x_2,\;y_2)$</mathjax>的二元组均满足，那么有：<br />
<mathjax>$$
\begin{aligned}
\mu((x_1,\;y_1),\;(x_2,\;y_2)) &amp; = - \sum_{(x_1,\;y_1) \leqslant (u,\;v) \lt (x_2,\;y_2)} \mu((x_1,\;y_1),\;(u,\;v)) \\
&amp; = - \sum_{(x_1,\;y_1) \leqslant (u,\;v) \lt (x_2,\;y_2)} \mu_1(x_1,\;u)\mu_2(y_1,\;v) &amp; (\text{根据归纳假设}) \\
&amp; = - \sum_{x_1 \leqslant_1 u \lt_1 x_2} \sum_{y_1 \leqslant_2 v \lt_2 y_2} \mu_1(x_1,\;u)\mu_2(y_1,\;v) &amp; (\text{分别枚举}) \\
&amp; =  - \sum_{x_1 \leqslant_1 u \leqslant_1 x_2} \sum_{y_1 \leqslant_2 v \leqslant_2 y_2} \mu_1(x_1,\;u)\mu_2(y_1,\;v) \\
&amp;\;\;\;\, + \mu_1(x_1,\;x_2)\sum_{y_1 \leqslant_2 v \leqslant_2 y_2} \mu_2(y_1,\;v) \\
&amp;\;\;\;\, + \mu_2(y_1,\;y_2)\sum_{x_1 \leqslant_1 u \leqslant_1 x_2} \mu_1(x_1,\;u) \\
&amp;\;\;\;\, \color{red}{+} \mu_1(x_1,\;x_2)\mu_2(y_1,\;y_2) &amp; (\text{扩展上界})
\end{aligned}
$$</mathjax></p>
<p>(2016.12.22: 上述证明最后一步展开存在问题 (红色正号)，但是《组合数学》上没有这一步的详细推导，正确的证明方式还请大神们指出)</p>
<p>由于：<br />
<mathjax>$$
\begin{aligned}
0
&amp; = \sum_{y_1 \leqslant_2 v \leqslant_2 y_2} \mu_2(y_1,\;v) \\
&amp; = \sum_{x_1 \leqslant_1 u \leqslant_1 x_2} \mu_1(x_1,\;u)  \\
&amp; = \sum_{x_1 \leqslant_1 u \leqslant_1 x_2} \sum_{y_1 \leqslant_2 v \leqslant_2 y_2} \mu_1(x_1,\;u)\mu_2(y_1,\;v)
\end{aligned}
$$</mathjax></p>
<p>所以定理成立。</p>
<h2 id="x_nleqslant">在<mathjax>$(X_n,\;\leqslant)$</mathjax>上的莫比乌斯函数</h2>
<p>注意这里的是真正的小于等于号了......<br />
这个比较智障，分析一下就好了：<br />
对于<mathjax>$y = x$</mathjax>，我们有：<br />
<mathjax>$$
\mu(x,\;y) = \mu(x,\;x) = 1
$$</mathjax></p>
<p>对于<mathjax>$y = x + 1$</mathjax>，我们有：<br />
<mathjax>$$
\mu(x,\;y) = \mu(x,\;x + 1) = -\mu(x,\;x) = -1
$$</mathjax></p>
<p>对于<mathjax>$y = x + 2$</mathjax>，我们有：<br />
<mathjax>$$
\mu(x,\;y) = \mu(x,\;x + 2) = -\left[\mu(x,\;x) + \mu(x,\;x + 1)\right] = 0
$$</mathjax></p>
<p>不难发现，对于<mathjax>$y \gt x + 1$</mathjax>的函数值就全都变为<mathjax>$0$</mathjax>了。<br />
总结一下就是：<br />
<mathjax>$$
\mu(x,\;y) =
\begin{cases}
1 &amp; (y = x) \\
-1 &amp; (y = x + 1) \\
0 &amp; (\text{otherwise})
\end{cases}
\tag{5.1}
$$</mathjax></p>
<h2 id="x_nsubseteq">在<mathjax>$(X_n,\;\subseteq)$</mathjax>上的莫比乌斯函数</h2>
<blockquote>
<p>试证明：<br />
偏序集<mathjax>$(X_n,\;\subseteq)$</mathjax>的莫比乌斯函数是：<br />
<mathjax>$$\mu(A,\;B) = (-1)^{|B| - |A|} \tag{6.1}$$</mathjax></p>
</blockquote>
<p>运用归纳法证明：<br />
首先对于<mathjax>$A = B$</mathjax>，显然成立：<br />
<mathjax>$$
\mu(A, B) = \mu(A, A) = 1 = (-1)^0
$$</mathjax></p>
<p>假设对于<mathjax>$|B| - |A| \leqslant k$</mathjax>均成立，尝试证明对于<mathjax>$|B| - |A| = k + 1$</mathjax>也成立：<br />
<mathjax>$$
\begin{aligned}
\mu(A,\;B) &amp; = -\sum_{A \subseteq C \subset B} \mu(A,\;C) \\
&amp; = -\sum_{A \subseteq C \subset B} (-1)^{|C| - |A|} \\
&amp; = -\sum_{i = 0}^{k} {k + 1 \choose i}(-1)^i \\
&amp; = -\left[(1 - 1)^{k + 1} - (-1)^{k + 1} \right] \\
&amp; = (-1)^{k + 1} \\
&amp; = (-1)^{|B| - |A|}
\end{aligned}
$$</mathjax></p>
<h2 id="x_nmid">在<mathjax>$(X_n,\;\mid)$</mathjax>上的莫比乌斯函数</h2>
<p>对于<mathjax>$(X_n, \;\mid)$</mathjax>这个偏序集，有如下定理：<br />
<mathjax>$$
a \mid b \Longrightarrow \mu(a,\;b) = \mu(1,\;\frac{b}a) \tag{7.1}
$$</mathjax></p>
<p><strong>证明</strong> 我们尝试使用归纳法证明。首先对于<mathjax>$a = b$</mathjax>的情况显然成立：<br />
<mathjax>$$
\mu(a,\;b) = \mu(a,\;a) = \mu(1,\;1) = 1
$$</mathjax></p>
<p>假设对于<mathjax>$a \leqslant c \lt b$</mathjax>的莫比乌斯函数<mathjax>$\mu(a,\;c)$</mathjax>均满足上述定理，下面证明对于<mathjax>$\mu(a,\;b)$</mathjax>也满足。<br />
根据莫比乌斯函数的性质可得：<br />
<mathjax>$$
\mu(a,\;b) = -\sum_{a \mid c \mid b, \;c \neq b} \mu(a,\;c)
$$</mathjax></p>
<p>由于<mathjax>$a \mid b$</mathjax>，所以：<br />
<mathjax>$$
-\sum_{c \mid (b / a), \;c \neq (b / a)} \mu(a,\;ac)
$$</mathjax></p>
<p>根据归纳假设，可以将上式变为：<br />
<mathjax>$$
-\sum_{c \mid (b / a), \;c \neq (b / a)} \mu(1,\;c) = \mu(1,\;\frac{b}a)
$$</mathjax></p>
<p>因此定理成立。</p>
<p>由于有上面的定理，所以我们只用关心<mathjax>$\mu(1,\;n)$</mathjax>。<br />
首先可以递归计算：<br />
<mathjax>$$
\mu(1,\;n) = -\sum_{a \mid n,\;a\neq n} \mu(1,\;a)
$$</mathjax></p>
<p>考虑对<mathjax>$n$</mathjax>进行质因数分解：<br />
<mathjax>$$
n = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_m^{\alpha_m}
$$</mathjax></p>
<p>对于<mathjax>$n$</mathjax>的任意一个因子<mathjax>$d$</mathjax>都有：<br />
<mathjax>$$
d = p_1^{\beta_1}p_2^{\beta_2}\cdots p_m^{\beta_m} \;\;\;\; (0 \leqslant \beta_i \leqslant \alpha_i)
$$</mathjax></p>
<p>相当于可以看作<mathjax>$m$</mathjax>个大小为<mathjax>$\alpha_1 + 1,\;\alpha_2 + 1,\;\dots,\;\alpha_m + 1$</mathjax>的偏序集的直积的结果。<br />
于是可以得到：<br />
<mathjax>$$
\mu(1,\;n) = \prod_{i=1}^m\mu(1,\;p_i^{\alpha_i}) \tag{7.2}
$$</mathjax></p>
<p>注意到，对于<mathjax>$\varphi(p) = p - 1$</mathjax>：<br />
<mathjax>$$
\mu(1,\;1) = 1 \\
\mu(1,\;p) = -\mu(1,\;1) = -1 \;\; \\
\mu(1,\;p^2) = -\left[ \mu(1,\;1) + \mu(1,\;p) \right] = 0 \\
\dots
$$</mathjax></p>
<p>总结一下就是：<br />
<mathjax>$$
\mu(1,\;p^k) =
\begin{cases}
1 &amp; (k = 0) \\
-1 &amp; (k = 1) \\
0 &amp; (\text{otherwise})
\end{cases}
\tag{7.3}
$$</mathjax></p>
<p>运用直积，可以知道：<br />
<mathjax>$$
\mu(1,\;n) =
\begin{cases}
1 &amp; (n = 1) \\
(-1)^k &amp; (n = p_1p_2\cdots p_k, \;\;\varphi(p_i) = p_i - 1) \\
0 &amp; (\text{otherwise})
\end{cases}
\tag{7.4}
$$</mathjax></p>
<p>为了方便，通常把<mathjax>$\mu(1,\;n)$</mathjax>记作<mathjax>$\mu(n)$</mathjax>，就变成常见的莫比乌斯函数了。</p>
<p>据此，我们可以证明莫比乌斯函数是积性函数，即：<br />
<mathjax>$$
a \bot b \Longrightarrow \mu(ab) = \mu(a)\mu(b) \tag{7.5}
$$</mathjax></p>
<p><strong>证明</strong>：<br />
1. 如果<mathjax>$a$</mathjax>、<mathjax>$b$</mathjax>中有一者为<mathjax>$1$</mathjax>，结论显然成立。<br />
2. 如果<mathjax>$a$</mathjax>、<mathjax>$b$</mathjax>中有一者不为素数连乘的形式，它们的积也一定不会是素数连乘的形式，故等于<mathjax>$0$</mathjax>。<br />
3. 此时假设<mathjax>$a$</mathjax>、<mathjax>$b$</mathjax>都是素数连乘的形式，又因为<mathjax>$a$</mathjax>与<mathjax>$b$</mathjax>互质，所以它们的素因子中没有相同的。设<mathjax>$a = p_1p_2\cdots p_m$</mathjax>和<mathjax>$b = q_1q_2\cdots q_n$</mathjax>所以可以知道<mathjax>$\mu(ab) = (-1)^{n + m} = \mu(a)\mu(b)$</mathjax>。</p>
<h2 id="_6">反演示例：容斥原理</h2>
<p>设<mathjax>$S$</mathjax>为有限集，<mathjax>$A_1,\;A_2,\;\dots,\;A_n$</mathjax>是<mathjax>$S$</mathjax>的子集，<mathjax>$K \subseteq \{1,\;2,\;\dots,\;n\}$</mathjax>。<br />
定义函数<mathjax>$F(K)$</mathjax>计数<mathjax>$s$</mathjax><strong>同时</strong>满足下列条件：<br />
<mathjax>$$
s \not\in \bigcup_{i \in K} A_i \\
s \in \bigcap_{i \not\in K} A_i
$$</mathjax></p>
<p>即：<br />
<mathjax>$$
F(K) = \left| \bigcap_{i \not\in K} A_i - \bigcup_{i \in K} A_i \right| \tag{8.1}
$$</mathjax></p>
<p>如何脑补这个函数？可以想象成是用<mathjax>$K$</mathjax>把<mathjax>$S$</mathjax>中的很多东西挖走了，然后剩下的集合再求交集。<br />
对于此，再定义函数<mathjax>$G(K)$</mathjax>：<br />
<mathjax>$$
G(K) = \sum_{L \subseteq K} F(L) \tag{8.2}
$$</mathjax></p>
<p>这货居然计数的是：<br />
<mathjax>$$
G(K) = \left| \bigcap_{i \not\in K} A_i \right| \tag{8.3}
$$</mathjax></p>
<p>如何脑补其正确性？可以想象是一个智障用<mathjax>$K$</mathjax>把本来属于它们交集的东西挖去了，然后又一个一个吐出来，于是就还原了原本的交集......<br />
根据莫比乌斯反演公式可以知道：<br />
<mathjax>$$
G(K) = \sum_{L \subseteq K} F(K) \Longrightarrow F(K) = \sum_{L \subseteq K} (-1)^{|K| - |L|} G(L)
$$</mathjax></p>
<p>所以取<mathjax>$K = \{1,\;2,\;\dots,\;n\}$</mathjax>可以得到：<br />
<mathjax>$$
F(K) = \sum_{L \subseteq K} (-1)^{n - |L|} G(L) \tag{8.4}
$$</mathjax></p>
<p>这个时候的<mathjax>$F(K)$</mathjax>计数的东西有了新的含义：<br />
<mathjax>$$
F(K) = \left|\bigcup_{i \in K} A_i\right| = \left|\bigcap_{i \in K} \overline{A}_i \right| \tag{8.5}
$$</mathjax></p>
<p>用<mathjax>$F(K)$</mathjax>和<mathjax>$G(K)$</mathjax>本身的含义来替换，就可以得到<strong>容斥原理</strong> (感觉好神奇)：<br />
<mathjax>$$
\left|\bigcap_{i = 1}^n \overline{A}_i \right| = \sum_{K \subseteq \{1,\;,2,\;,\dots,\;n\}} (-1)^{|K|} \left| \bigcap_{i \in K} A_i \right| \tag{8.6}
$$</mathjax></p>
<h2 id="varphin">反演示例：<mathjax>$\varphi(n)$</mathjax>通项公式</h2>
<p>欧拉<mathjax>$\varphi(n)$</mathjax>函数计数的是不大于<mathjax>$n$</mathjax>的与<mathjax>$n$</mathjax>互质的正整数个数。<br />
对于欧拉<mathjax>$\varphi$</mathjax>函数，我们有如下的定理：<br />
<mathjax>$$
n = \sum_{d \mid n} \varphi(d) \tag{9.1}
$$</mathjax></p>
<p>有两种证明方法：<br />
第一种考虑不与<mathjax>$n$</mathjax>互质的数，如果存在一个数<mathjax>$d$</mathjax>与<mathjax>$n$</mathjax>不互质，那么必有<mathjax>$\gcd(d, n) = a \gt 1$</mathjax>，换言之<mathjax>$\gcd(d / a, n / a) = 1$</mathjax>，所以一个数不与<mathjax>$n$</mathjax>互质，那么必定与<mathjax>$n$</mathjax>的一个因子互质。所以上式成立。</p>
<p>另一种是使用归纳法证明：<br />
首先考虑<mathjax>$1$</mathjax>，是显然成立的。<br />
然后考虑质数<mathjax>$p$</mathjax>，<mathjax>$\varphi(1) + \varphi(p) = p$</mathjax>，所以也是成立的。<br />
考虑质数<mathjax>$p$</mathjax>的幂<mathjax>$p^k$</mathjax>，它的因子有<mathjax>$1,\;p,\;p^2,\;\dots,\;p^k$</mathjax>，由于：<br />
<mathjax>$$
\varphi(p^k) = (p - 1)p^{k-1} \;\;\;\; (\varphi(p) = p - 1)
$$</mathjax></p>
<p>所以我们对其进行等比数列求和：<br />
<mathjax>$$
\begin{aligned}
\sum_{d \mid n} \varphi(d) &amp; = 1 + (p - 1)\sum_{i=0}^{k-1} p^i \\
&amp; = 1 + (p - 1) \cdot {1 - p^k \over 1 - p} \\
&amp; = 1 + p^k - 1 \\
&amp; = p^k
\end{aligned}
$$</mathjax></p>
<p>故对质数的幂也成立。<br />
假设对于一个数<mathjax>$c$</mathjax>，所有小于<mathjax>$c$</mathjax>的数均成立，那么选取<mathjax>$n$</mathjax>的两个互质的因子<mathjax>$a$</mathjax>、<mathjax>$b$</mathjax>使得<mathjax>$ab = c$</mathjax>，那么有：<br />
<mathjax>$$
\sum_{n \mid a} \varphi(n) \sum_{m \mid b} \varphi(m) = a \cdot b = c
$$</mathjax></p>
<p>下面证明<mathjax>$\sum_{n \mid a} \varphi(n) \sum_{m \mid b} \varphi(m) = \sum_{d \mid c} \varphi(d)$</mathjax>，即可证明原式：<br />
<mathjax>$$
\begin{aligned}
\sum_{n \mid a} \varphi(n) \sum_{m \mid b} \varphi(m) &amp; = \sum_{n \mid a}\sum_{m \mid b}\varphi(n)\varphi(m) &amp; (\text{改变枚举顺序}) \\
&amp; = \sum_{n \mid a}\sum_{m \mid b} \varphi(nm) &amp; (\text{由于}n \bot m) \\
&amp; = \sum_{nm \mid ab} \varphi(nm) &amp; (\text{由于}a \bot b) \\
&amp; = \sum_{d \mid c} \varphi(d) &amp; (\text{等价代换}) \\
&amp; = c
\end{aligned}
$$</mathjax></p>
<p>注意到<mathjax>$(9.1)$</mathjax>式是一个明显的莫比乌斯反演的形式。根据莫比乌斯反演公式，我们可以得到：<br />
<mathjax>$$
\begin{aligned}
\varphi(n) &amp; = \sum_{d \mid n} d \cdot \mu(d,\;n) \\
&amp; = \sum_{d \mid n} d \cdot \mu(1,\;n / d) \\
&amp; = \sum_{d \mid n} d \cdot \mu(n / d) \\
&amp; = \sum_{d \mid n} \mu(d) \cdot n/d
\end{aligned}
$$</mathjax></p>
<p>考虑一下<mathjax>$\mu$</mathjax>函数的取值，对于因子<mathjax>$1$</mathjax>，和式中的结果为<mathjax>$n$</mathjax>。对于由素数相乘的因子，这些素因子必定来自<mathjax>$n$</mathjax>。而其它情况就都为<mathjax>$0$</mathjax>。<br />
设<mathjax>$n = p_1^{k_1}p_2^{k_2}\cdots p_m^{k_m}$</mathjax>。<br />
因此可以得到下面的式子：<br />
<mathjax>$$
\varphi(n) = n\left[1 - \sum \frac1{p_i} + \sum \frac1{p_ip_j} - \cdots + (-1)^{m}\sum \frac1{\prod_{i=1}^m p_i} \right] \tag{9.2}
$$</mathjax></p>
<p>这恰好是下面的式子展开的形式：<br />
<mathjax>$$
\varphi(n) = n\prod_{i=1}^m \left( 1 - \frac1{p_i} \right) \tag{9.3}
$$</mathjax></p>
<p>因此：<br />
<mathjax>$$
\varphi(n) = n\prod_{p \mid n,\;\varphi(p) = p - 1} \left( 1 - \frac1p\right) \tag{9.4}
$$</mathjax></p>
<h2 id="_7">反演示例：多重集合的循环排列</h2>
<blockquote>
<p>我们有一个多重集合<mathjax>$\{\infty \cdot 1,\;\infty \cdot 2,\;\dots,\;\infty \cdot k\}$</mathjax>。易知长度为<mathjax>$n$</mathjax>的全排列数为<mathjax>$k^n$</mathjax>。<br />
现在对于两个排列<mathjax>$A$</mathjax>和<mathjax>$B$</mathjax>，如果<mathjax>$A$</mathjax>通过&rdquo;旋转&rdquo; (即将最后一个变成第一个，并且把之前的全部后移) 能变成<mathjax>$B$</mathjax>，那么<mathjax>$A$</mathjax>和<mathjax>$B$</mathjax>是等价的。<br />
换言之，最小表示法相同的排列是等价。<br />
求不同的长度为<mathjax>$n$</mathjax>的<strong>循环排列</strong>数量。</p>
</blockquote>
<p>对于这个计数问题，我们记<mathjax>$h(n)$</mathjax>为长度为<mathjax>$n$</mathjax>时的答案，<mathjax>$f(n)$</mathjax>为长度为<mathjax>$n$</mathjax>并且<strong>旋转</strong><mathjax>$n$</mathjax>次才会变为原排列 (即循环节长度为<mathjax>$n$</mathjax>) 的排列的数量。显然，一个排列的循环节长度<mathjax>$m$</mathjax>必须满足<mathjax>$m \mid n$</mathjax>。<br />
那么可以知道：<br />
<mathjax>$$
h(n) = \sum_{d \mid n} \frac{f(d)}d \tag{10.1}
$$</mathjax></p>
<p>由于循环节长度小于<mathjax>$n$</mathjax>的排列都可以由循环节不断重复而得来。因此我们设：<br />
<mathjax>$$
g(n) = \sum_{d \mid n} f(d)
$$</mathjax></p>
<p><mathjax>$g(n)$</mathjax>就计数了所有长度为<mathjax>$n$</mathjax>的排列数量。<br />
所以：<br />
<mathjax>$$
g(n) = k^n \tag{10.2}
$$</mathjax></p>
<p>根据莫比乌斯反演公式可得：<br />
<mathjax>$$
\begin{aligned}
f(n) &amp; = \sum_{d \mid n} g(d)\mu(n/d) \\
&amp; = \sum_{d \mid n} k^d\mu(n/d)
\end{aligned}
\tag{10.3}
$$</mathjax></p>
<p>带入<mathjax>$h(n)$</mathjax>的计算公式可得：<br />
<mathjax>$$
h(n) = \sum_{d \mid n} \frac1d \sum_{e \mid d} k^e\mu(d/e) \tag{10.4}
$$</mathjax></p>
<p>由于<mathjax>$e \mid d$</mathjax>并且<mathjax>$d \mid n$</mathjax>，所以我们设<mathjax>$n = rd,\;d = me$</mathjax>，所以<mathjax>$n = rem$</mathjax>，这样将方便我们变换公式：<br />
<mathjax>$$
\begin{aligned}
\sum_{d \mid n} \frac1d \sum_{e \mid d} k^e\mu(d/e) &amp; = \sum_{e \mid n} k^e \sum_{m \mid (n/e)} \frac1{me}\mu(m) \\
&amp; =\sum_{e\mid n} \frac{k^e}n \sum_{r \mid (n/e)} r\cdot\mu(\frac{n}e/r)
\end{aligned}
$$</mathjax></p>
<p>由于：<br />
<mathjax>$$
\varphi(n) = \sum_{d \mid n} d \cdot \mu(n/d)
$$</mathjax></p>
<p>所以：<br />
<mathjax>$$
h(n) = \frac1n \sum_{d \mid n} k^d \varphi(n/d) \tag{10.5}
$$</mathjax></p>
<h2 id="_8">莫比乌斯函数示例：最大公约数</h2>
<p>除了莫比乌斯反演公式，莫比乌斯函数本身的性质也是很好的。<br />
考虑下面一个问题：</p>
<blockquote>
<p>给定<mathjax>$n$</mathjax>和<mathjax>$m$</mathjax>，求<mathjax>$\gcd(x,\;y)\;\;(1 \leqslant x \leqslant n,\;1 \leqslant y \leqslant m)$</mathjax>为<strong>素数</strong>的二元组<mathjax>$(x,\;y)$</mathjax>个数。</p>
</blockquote>
<p>换言之，我们要求的是这个：<br />
<mathjax>$$
\sum_{x=1}^n\sum_{y=1}^m \left[\varphi(\gcd(x,\;y)) = \gcd(x,\;y) - 1\right] \tag{11.1}
$$</mathjax></p>
<p>首先，我们可以换个思路，就是枚举最大公约数的答案：<br />
<mathjax>$$
\sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^n\sum_{y=1}^m \left[ \gcd(x,\;y) = p \right] \tag{11.2}
$$</mathjax></p>
<p>由于<mathjax>$\gcd(x,\;y) = p \Longrightarrow \gcd(x/p,\;y/p) = 1$</mathjax>，所以就变成了枚举互质的数的对数：<br />
<mathjax>$$
\sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^{\left\lfloor \frac{n}p\right\rfloor}\sum_{y=1}^{\left\lfloor \frac{m}p \right\rfloor} \left[ \gcd(x,\;y) = 1 \right] \tag{11.3}
$$</mathjax></p>
<p>由于莫比乌斯函数有这样的性质：<br />
<mathjax>$$
\sum_{d \mid n} \mu(d) = [n = 1] \tag{11.4}
$$</mathjax></p>
<p>所以可以使用莫比乌斯函数来测试一个数是否为<mathjax>$1$</mathjax>：<br />
<mathjax>$$
\sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^{\left\lfloor \frac{n}p\right\rfloor}\sum_{y=1}^{\left\lfloor \frac{m}p \right\rfloor} \sum_{d \mid \gcd(x,\;y)} \mu(d) \tag{11.5}
$$</mathjax></p>
<p>因为<mathjax>$d \mid \gcd(x,\;y)$</mathjax>当且仅当<mathjax>$d \mid x$</mathjax>并且<mathjax>$d \mid y$</mathjax>，所以可以变成这样：<br />
<mathjax>$$
\sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^{\left\lfloor \frac{n}p\right\rfloor}\sum_{y=1}^{\left\lfloor \frac{m}p \right\rfloor} \sum_{d \mid x \,\land\, d \mid y} \mu(d) \tag{11.6}
$$</mathjax></p>
<p>现在东西越来越多了，是时候考虑简化一下了。<br />
首先对于一堆和式的一个技巧就是<strong>调整枚举顺序</strong>。<br />
尝试先枚举<mathjax>$d$</mathjax>，这样合法的<mathjax>$d$</mathjax>就可以直接计算了：<br />
<mathjax>$$
\sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}} \sum_{d=1}^{\min\{n,\;m\}} \left\lfloor \frac{n}{dp} \right\rfloor \left\lfloor \frac{m}{dp} \right\rfloor \mu(d) \tag{11.7}
$$</mathjax></p>
<p>其实这个式子已经可以用来计算答案了。注意到对于一个数<mathjax>$n$</mathjax>，<mathjax>$\lfloor n / i \rfloor$</mathjax>的取值最多有<mathjax>$O(\sqrt{n})$</mathjax>种，因为：</p>
<ol>
<li>如果<mathjax>$i \leqslant \sqrt{n}$</mathjax>，这样的<mathjax>$i$</mathjax>只有<mathjax>$O(\sqrt{n})$</mathjax>种。</li>
<li>如果<mathjax>$i &gt; \sqrt{n}$</mathjax>，那么<mathjax>$\lfloor n / i \rfloor \leqslant \sqrt{n}$</mathjax>，这样的取值只有<mathjax>$O(\sqrt{n})$</mathjax>种。</li>
</ol>
<p>所以两个向下取整的乘积最多有<mathjax>$O(\sqrt{n} + \sqrt{m})$</mathjax>个不同的取值，左边枚举的素数约为<mathjax>$O({n \over \ln n})$</mathjax>个，故根据此公式计算的时间复杂度为<mathjax>$O({n (\sqrt{n} + \sqrt{m}) \over \ln n})$</mathjax>。<br />
然而我们可以做得更快一些。<br />
设<mathjax>$T = dp$</mathjax>，现在改成先枚举<mathjax>$T$</mathjax>：<br />
<mathjax>$$
\sum_{T = 1}^{\min\{n,\;m\}} \left\lfloor \frac{n}T \right\rfloor \left\lfloor \frac{m}T \right\rfloor \sum_{p \mid T,\;\varphi(p) = p - 1} \mu(T / p) \tag{11.8}
$$</mathjax></p>
<p>这样左边就可以在<mathjax>$O(\sqrt{n} + \sqrt{m})$</mathjax>的时间内进行枚举。<br />
枚举大概是这样的一个过程：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>lastpos = 0
i = 1
while i &lt;= min(n, m):
    lastpos = min(n / (n / i), m / (m / i))
    # Do something...
    i = lastpos + 1
</pre></div>
</td></tr></table>

<p>我们企图能使右边快速计算。因此我们来研究一下右边这个玩意。<br />
设：<br />
<mathjax>$$
g(x) = \sum_{p \mid x,\;\varphi(p) = p - 1} \mu(x/p) \tag{11.9}
$$</mathjax></p>
<p>考虑使用线性筛来计算<mathjax>$g(x)$</mathjax>。</p>
<ol>
<li>当<mathjax>$x = 1$</mathjax>时，<mathjax>$g(x) = 0$</mathjax>。</li>
<li>当<mathjax>$x$</mathjax>为素数时，<mathjax>$g(x) = 1$</mathjax>。</li>
<li>在线性筛的处理过程中，设当前数为<mathjax>$i$</mathjax>，枚举到的素数为<mathjax>$p$</mathjax>，我们将要计算<mathjax>$g(ip)$</mathjax>：<ol>
<li>当<mathjax>$\mu(i) = 0$</mathjax>时，说明<mathjax>$i$</mathjax>的质因数分解中至少存在一个一个素因子的次数大于<mathjax>$1$</mathjax>。<br />
   在这种情况下，除非<strong>只有一个</strong>素因子的次数为<mathjax>$2$</mathjax>，其它均为<mathjax>$1$</mathjax>，否则无论如何<mathjax>$g$</mathjax>的函数值都为<mathjax>$0$</mathjax>。<br />
   假设只存在一个素因子的次数为<mathjax>$2$</mathjax>，记这个素因子为<mathjax>$f(i)$</mathjax>。<ol>
<li>若<mathjax>$p \mid i$</mathjax>，那么将会导致无论是哪个素因子，<mathjax>$\mu$</mathjax>函数的值都为<mathjax>$0$</mathjax>。因此<mathjax>$g$</mathjax>函数的值为<mathjax>$0$</mathjax>。</li>
<li>若<mathjax>$p \not\mid i$</mathjax>，那么就只有除以<mathjax>$f(i)$</mathjax>时会有值，此时的值为<mathjax>$\mu(i / f(i) \cdot p)$</mathjax>。</li>
</ol>
</li>
<li>当<mathjax>$\mu(i) \neq 0$</mathjax>时，意味着<mathjax>$i$</mathjax>将是多个素数之积。同样我们来考虑两种情况：<ol>
<li>若<mathjax>$p \mid i$</mathjax>，那么就只有<mathjax>$p$</mathjax>的次数为<mathjax>$2$</mathjax>，此时<mathjax>$g(ip) = \mu(i)$</mathjax>。</li>
<li>若<mathjax>$p \not\mid i$</mathjax>，那么<mathjax>$\mu(ip)$</mathjax>依然不为<mathjax>$0$</mathjax>。假设<mathjax>$i$</mathjax>有<mathjax>$r$</mathjax>个素因子，那么<mathjax>$g(i) = r(-1)^{r-1}$</mathjax>，并且<mathjax>$g(ip) = (r + 1)(-1)^r = -r(-1)^{r-1} + (-1)^{r+1}$</mathjax>，这意味着它们符号相反且绝对值差<mathjax>$1$</mathjax>。这样就可以直接计算。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>经过一番分类讨论，我们总算成功地找到了预处理<mathjax>$g(x)$</mathjax>的方法。<br />
在这中间有一个问题还亟待解决，就是我们需要计算<mathjax>$f(x)$</mathjax>，事实上它也可以用线性筛计算。<br />
假设存在这样的素因子<mathjax>$p$</mathjax>，就记<mathjax>$f(x) = p$</mathjax>。如果<mathjax>$x$</mathjax>还是多个素数相乘，就记<mathjax>$f(x) = 1$</mathjax>。否则记作<mathjax>$0$</mathjax>，又称为&rdquo;没救了&rdquo;。这样就只有<mathjax>$f(x) \gt 1$</mathjax>时才有我们需要的结果。</p>
<ol>
<li>当<mathjax>$x = 1$</mathjax>或<mathjax>$x$</mathjax>为质数时，<mathjax>$f(x) = 1$</mathjax>。</li>
<li>每次往一个数<mathjax>$i$</mathjax>加入一个素数<mathjax>$p$</mathjax>时，需要考虑下面的情况：<ol>
<li>若<mathjax>$f(i) = 0$</mathjax>，那么没救了。</li>
<li>若<mathjax>$p \mid i$</mathjax>，并且<mathjax>$f(i) = 1$</mathjax>，那么<mathjax>$ip$</mathjax>将不再是素数连乘的形式，此时可以记下<mathjax>$f(ip) = p$</mathjax>。如果<mathjax>$f(i) &gt; 1$</mathjax>，那么它没救了。</li>
<li>若<mathjax>$p \not\mid i$</mathjax>，那么<mathjax>$f$</mathjax>函数值不会改变。</li>
</ol>
</li>
</ol>
<p>这样就可以欢快地计算<mathjax>$f$</mathjax>函数啦~<br />
回到之前的问题，我们能够计算<mathjax>$g(x)$</mathjax>函数后，预处理出它的前缀和，就可以在前面伪代码中展示的迭代过程计算答案了。时间复杂度是<mathjax>$O(\sqrt{n} + \sqrt{m})$</mathjax>。</p>
<h2 id="divcnt2">莫比乌斯函数示例：DIVCNT2</h2>
<p><a href="http://www.spoj.com/problems/DIVCNT2">SPOJ DIVCNT2</a></p>
<blockquote>
<p>要求求出：<br />
<mathjax>$$ \sum_{a = 1}^n \sigma(a^2) $$</mathjax></p>
<p>的值。其中<mathjax>$\sigma(n)$</mathjax>表示<mathjax>$n$</mathjax>的因子个数。</p>
</blockquote>
<p>考虑这么几个等式关系：<br />
<mathjax>$$
\sigma(n^2) = \sum_{d \mid n} 2^{\omega(d)}
\tag{12.1}
$$</mathjax></p>
<p>其中<mathjax>$\omega(n)$</mathjax>表示<mathjax>$n$</mathjax>的质因子个数。为什么这是正确的呢？考虑每个<mathjax>$n$</mathjax>的因子<mathjax>$d$</mathjax>，<mathjax>$d^2$</mathjax>都是<mathjax>$n^2$</mathjax>的因子。另外，对于任意<mathjax>$n$</mathjax>的任意两个不同的因子，它们的质因数分解中至少有一个素数的次数的差不小于<mathjax>$1$</mathjax>，那么经过平方后，这个差值将不小于<mathjax>$2$</mathjax>。于是它们的平方任意删去一个素数后，是不会冲突的。这样，我们只要对每个<mathjax>$d^2$</mathjax>，都枚举一下删去素数的方案，就可以得到<mathjax>$n^2$</mathjax>的所有因子。答案也就是上式。</p>
<p><mathjax>$$
2^{\omega(n)} = \sum_{d \mid n} \mu^2(d)
\tag{12.2}
$$</mathjax></p>
<p>考虑到<mathjax>$\mu$</mathjax>函数的取值：<br />
<mathjax>$$
\mu(n) =
\begin{cases}
1 &amp; (n = 1) \\
(-1)^k &amp; (n = p_1p_2\cdots p_k, \;\;\varphi(p_i) = p_i - 1) \\
0 &amp; (\text{otherwise})
\end{cases}
$$</mathjax></p>
<p>因此：<br />
<mathjax>$$
\mu^2(n) =
\begin{cases}
1 &amp; (n = 1) \\
1 &amp; (n = p_1p_2\cdots p_k, \;\;\varphi(p_i) = p_i - 1) \\
0 &amp; (\text{otherwise})
\end{cases}
$$</mathjax></p>
<p>即只要是<mathjax>$d$</mathjax>是素数连乘的形式，就会对答案贡献。否则没有贡献。这也正是<mathjax>$2^{\omega(n)}$</mathjax>想要统计的。</p>
<p>对于省去了第一维的数论函数<mathjax>$f$</mathjax>和<mathjax>$g$</mathjax>，定义它们的<strong>狄利克雷卷积</strong>是下面的形式：<br />
<mathjax>$$
(f \times g)(n) = \sum_{d \mid n} f(d)g\left(\frac{n}{d}\right)
\tag{12.3}
$$</mathjax></p>
<p>也就是在偏序集<mathjax>$(X_n, \;\mid)$</mathjax>上的卷积。令<mathjax>$f(n) = \sigma(n^2)$</mathjax>，<mathjax>$g(n) = 2^{\omega(n)}$</mathjax>，<mathjax>$h(n) = \mu^2(n)$</mathjax>以及<mathjax>$\epsilon(n) = 1$</mathjax>，这样我们可以把之前的结果简写为：<br />
<mathjax>$$
f = g \times \epsilon \\
g = h \times \epsilon
$$</mathjax></p>
<p>利用卷积的结合律，可以得到：<br />
<mathjax>$$
\begin{aligned}
f &amp; = (h \times \epsilon) \times \epsilon \\
&amp; = h \times (\epsilon \times \epsilon)
\end{aligned}
$$</mathjax></p>
<p>注意到：<br />
<mathjax>$$
\begin{aligned}
\epsilon \times \epsilon &amp; = \sum_{d \mid n} 1 \\
&amp; = \sigma(n)
\end{aligned}
$$</mathjax></p>
<p>所以，我们要求的东西也就是：<br />
<mathjax>$$
\begin{aligned}
\sum_{i = 1}^n f(i) &amp; = \sum_{i = 1}^n \sum_{d \mid i} \mu^2(d) \sigma\left({i \over d}\right) \\
&amp; = \sum_{i = 1}^n \mu^2(i) \sum_{j = 1}^{\left\lfloor {n \over i} \right\rfloor} \sigma(j)
\end{aligned}
$$</mathjax></p>
<p>首先考虑<mathjax>$\sigma(n)$</mathjax>的前缀和如何计算：<br />
<mathjax>$$
\sum_{i = 1}^n \sigma(i) = \sum_{i = 1}^n \left\lfloor {n \over i} \right\rfloor
\tag{12.4}
$$</mathjax></p>
<p>由于下取整可以分段，所以可以在<mathjax>$O(\sqrt{n})$</mathjax>的复杂度内计算。</p>
<p>然后考虑<mathjax>$\mu^2(n)$</mathjax>的前缀和如何计算：<br />
<mathjax>$$
\sum_{i = 1}^n \mu^2(i) = \sum_{i = 1}^{\sqrt{n}} \mu(i)\left\lfloor {n \over i^2} \right\rfloor
\tag{12.5}
$$</mathjax></p>
<p>这是为什么？结合<mathjax>$\mu^2(n)$</mathjax>的意义，这个前缀和就是统计前<mathjax>$n$</mathjax>个数里面，有多少个数是素数连乘的形式。当<mathjax>$i = 1$</mathjax>时，所有数字均被统计了一遍。然后枚举<mathjax>$1$</mathjax>到<mathjax>$\sqrt{n}$</mathjax>的每个数字，如果不是素数连乘的形式，<mathjax>$\mu(i)$</mathjax>会返回<mathjax>$0$</mathjax>。如果是素数连乘的形式，那么它的任意大于<mathjax>$1$</mathjax>的次数的幂都不是答案，此时应当删去。于是<mathjax>$\mu$</mathjax>函数在此充当了容斥系数。</p>
<p>回到之前的式子：<br />
<mathjax>$$
\sum_{i = 1}^n \mu^2(i) \sum_{j = 1}^{\left\lfloor {n \over i} \right\rfloor} \sigma(j)
$$</mathjax></p>
<p>对于<mathjax>$\sigma(n)$</mathjax>的前缀和的上标也是可以分段的，这样就需要用到<mathjax>$\mu^2(n)$</mathjax>的前缀和。</p>
<p>所以最后的复杂度可以这样估计：<br />
<mathjax>$$
\sum_{k = 1}^{\sqrt{n}} \sqrt{k} + \sum_{k = 1}^{\sqrt{n}} \sqrt{{n \over k}}
\tag{12.6}
$$</mathjax></p>
<p>显然右边的代价更高。用积分可以估计一下：<br />
<mathjax>$$
\sum_{k = 1}^{\lfloor \sqrt{n} \rfloor} \sqrt{n \over k} \leqslant \int_0^{\lfloor \sqrt{n} \rfloor} \sqrt{n \over x} \;\mathrm{d}x = O(n^{3/4})
$$</mathjax></p>
<p>如果预处理前<mathjax>$S$</mathjax>个前缀和的答案，当询问<mathjax>$\mu^2(n)$</mathjax>和<mathjax>$\sigma(n)$</mathjax>的前缀和时，如果<mathjax>$n \leqslant S$</mathjax>，就直接返回预处理的值。那么复杂度大约为：<br />
<mathjax>$$
\sum_{k = 1}^{\min\{\lfloor \sqrt{n} \rfloor, \lfloor n / S \rfloor\}} \sqrt{n \over x}
\tag{12.7}
$$</mathjax></p>
<p>当<mathjax>$S \lt \sqrt{n}$</mathjax>时，时间复杂度的分析不变。否则时间复杂度上界变为：<br />
<mathjax>$$
O\left(S + {n \over \sqrt{S}}\right)
$$</mathjax></p>
<p>当<mathjax>$S = n / \sqrt{S}$</mathjax>时取得最小值，此时<mathjax>$S = n^{2/3}$</mathjax>，时间复杂度为<mathjax>$O(n^{2/3})$</mathjax>。注意，这里空间上也要付出同样的代价。</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:possible">
<p>在偏序集<mathjax>$(X_n,\;\mid\;)$</mathjax>上简化后的卷积 (即狄利克雷卷积)，会满足交换律。&#160;<a class="footnote-backref" href="#fnref:possible" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
          <hr/>
          <div id="comments"></div>
          <script type="text/javascript">
            const gitment = new Gitment({
              id: '4040224722c8bc957a9a714393a4c385',
              owner: 'riteme',
              repo: 'riteme.github.io',
              oauth: {
                client_id: 'd4fcffa25858a7a58e1a',
                client_secret: 'e0c8e08beb95497871f8355416c69390634cec76',
              },
              perPage: 10,
            })
            gitment.render('comments')
          </script>
       </div>
     </div>

     <div class="mdl-cell mdl-cell--3-col mdl-cell--hide-tablet mdl-cell--hide-phone">
       <div class="article">
        <div class="mdl-card mdl-shadow--3dp" style="width: 100%">
          <div class="mdl-card__supporting-text">
            标签: <a href="/search.html?q=数学"><span class="label">数学</span></a> <a href="/search.html?q=组合数学"><span class="label">组合数学</span></a> <a href="/search.html?q=莫比乌斯反演"><span class="label">莫比乌斯反演</span></a><br/>
            创建时间: 2016.08.18<br/>
            上次修改: 2017.03.18<br />
            统计: 21128 字 / 约 1 小时 24 分钟
          </div>
        </div>
        <br />
        
<div class="mdl-card mdl-shadow--3dp" style="width: 100%">
  <div class="mdl-card__title mdl-card--border">
    <h4 class="mdl-card__title-text">目录</h4>
  </div>
  <div class="mdl-card__supporting-text">
    <div class="toc">
<ul>
<li><a href="#_1">莫比乌斯反演</a><ul>
<li><a href="#_2">偏序集</a></li>
<li><a href="#_3">卷积</a></li>
<li><a href="#_4">莫比乌斯反演公式</a></li>
<li><a href="#_5">偏序集直积</a></li>
<li><a href="#x_nleqslant">在$(X_n,\;\leqslant)$上的莫比乌斯函数</a></li>
<li><a href="#x_nsubseteq">在$(X_n,\;\subseteq)$上的莫比乌斯函数</a></li>
<li><a href="#x_nmid">在$(X_n,\;\mid)$上的莫比乌斯函数</a></li>
<li><a href="#_6">反演示例：容斥原理</a></li>
<li><a href="#varphin">反演示例：$\varphi(n)$通项公式</a></li>
<li><a href="#_7">反演示例：多重集合的循环排列</a></li>
<li><a href="#_8">莫比乌斯函数示例：最大公约数</a></li>
<li><a href="#divcnt2">莫比乌斯函数示例：DIVCNT2</a></li>
</ul>
</li>
</ul>
</div>
  </div>
</div>

        <br />
        <div class="mdl-card mdl-shadow--3dp" style="width: 100%">
          <div class="mdl-card__supporting-text">
            <span class="mathopt-head">数学公式渲染引擎：</span>
            <form name="mathopt">
              <label class="mdl-radio mdl-js-radio mdl-js-ripple-effect" for="option-1">
                <input type="radio" id="option-1" class="mdl-radio__button" name="sel" value="mathjax">
                <span class="mdl-radio__label">MathJax (推荐)</span>
              </label><br />
              <div id="tip-1">
                <label class="mdl-radio mdl-js-radio mdl-js-ripple-effect" for="option-2">
                  <input type="radio" id="option-2" class="mdl-radio__button" name="sel" value="katex">
                  <span class="mdl-radio__label">KaTeX</span>
                </label>
              </div>
              <div id="tip-2">
                <label class="mdl-radio mdl-js-radio mdl-js-ripple-effect" for="option-3">
                  <input type="radio" id="option-3" class="mdl-radio__button" name="sel" value="katex&mathjax">
                  <span class="mdl-radio__label">Mixed</span>
                </label>
              </div>
            </form>
          </div>
        </div>
        <div class="mdl-tooltip" data-mdl-for="tip-1">
        KaTeX 渲染效率很高，但是目前 KaTeX 容错性不强，因此使用 KaTeX 时可能会存在一些数学公式无法渲染的情况
        </div>
        <div class="mdl-tooltip" data-mdl-for="tip-2">
        先使用 KaTeX 渲染，再使用 MathJax 渲染
        </div>
      </div>
      <div class="return-up-button">
        <a href="javascript:$('main').animate( { scrollTop: 0 } , 'fast')">
          <button class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect mdl-button--colored">
            <i class="material-icons">vertical_align_top</i>
          </button>
        </a>
      </div>
    </div>
  </div>

  <footer class="mdl-mega-footer">
    <div class="mdl-mega-footer__middle-section">
      <div class="mdl-mega-footer__drop-down-section">
        <input class="mdl-mega-footer__heading-checkbox" type="checkbox" checked>
        <h1 class="mdl-mega-footer__heading">RITEME.SITE</h1>
        一个从不乱说话的博客...
      </div>

      <div class="mdl-mega-footer__drop-down-section">
        <input class="mdl-mega-footer__heading-checkbox" type="checkbox" checked>
        <h1 class="mdl-mega-footer__heading">POWERED BY</h1>
        <ul class="mdl-mega-footer__link-list">
          <li><a href="http://pythonhosted.org/Markdown/">Python Markdown</a></li>
          <li><a href="http://getmdl.io/">Material Design Lite</a></li>
          <li><a href="http://www.tipue.com/search/">Tipuesearch</a></li>
          <li><a href="http://www.mathjax.org/">MathJax</a> & <a href="http://khan.github.io/KaTeX/">KaTeX</a></li>
          <li><a href="https://github.com/imsun/gitment">Gitment</a></li>
        </ul>
      </div>

      <div class="mdl-mega-footer__drop-down-section">
        <input class="mdl-mega-footer__heading-checkbox" type="checkbox" checked>
        <h1 class="mdl-mega-footer__heading">友情链接</h1>
        <ul class="mdl-mega-footer__link-list">
          <li><a href="http://ruanx.pw/">ruanxingzhi</a></li>
          <li><a href="http://haogram.hol.es/">Haogram</a></li>
          <li><a href="http://hjwjbsr.is-programmer.com/">HJWJBSR</a></li>
          <li><a href="http://www.micdz.cn/">MicDZ</a></li>
          <li><a href="http://blog.linyxus.xyz/">Linyxus</a></li>
          <li><a href="http://memset0.cf/">memset0</a></li>
        </ul>
      </div>
    </div>

    <div class="mdl-mega-footer__bottom-section">
      Theme based on <a href="https://getmdl.io/">MDL</a> | Copyright © 2015-2018 riteme. All rights reserved.
    </div>
  </footer>
</main>
</div>
</body>
</html>
