<!DOCTYPE html>
<html>
<head>
  <title>莫比乌斯反演 - riteme.site</title>
  <meta charset="UTF-8">
  <meta name="robots" content="none">
  <link rel="stylesheet" type="text/css" href="../../css/site.min.css">
  <script type="text/javascript" async src="../../mathjax/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>

<h1 id="_1">莫比乌斯反演</h1>
<blockquote>
<p>我把《组合数学》抄了一遍，免得我记不住......</p>
</blockquote>
<h2 id="_2">偏序集</h2>
<p>这里的莫比乌斯反演是从关联代数的角度来介绍的。首先介绍一个基础的概念：偏序集。<br />
它通常写作<mathjax>$(X_n,\;\le)$</mathjax>，其中<mathjax>$X_n$</mathjax>是一个有限或者无限的集合，<mathjax>$\le$</mathjax>是代指偏序关系，而<strong>不是特指小于等于符号</strong>。<br />
所谓偏序关系，就是指<mathjax>$a,\;b,\;c \in X_n$</mathjax>并且<mathjax>$a \le b,\;b \le c$</mathjax>，有<mathjax>$a \le c$</mathjax>的性质的关系。<br />
这种偏序关系一般是比较符<mathjax>$\le$</mathjax>、集合的<mathjax>$\subseteq$</mathjax>符号和整除<mathjax>$\;\mid\;$</mathjax>。</p>
<h2 id="_3">卷积</h2>
<p>对于定义在偏序集<mathjax>$(X_n,\;\le)$</mathjax>上的二元函数<mathjax>$f(x,\;y)$</mathjax>，我们假定当<mathjax>$x \not\le y$</mathjax>时，<mathjax>$f(x,\;y)$</mathjax>均为<mathjax>$0$</mathjax>，这样是为了方便我们之后的讨论。<br />
考虑偏序集<mathjax>$(X_n, \le)$</mathjax>上的二元函数<mathjax>$f(x,\;y)$</mathjax>和<mathjax>$g(x,\;y)$</mathjax>，定义它们的卷积为：<br />
<mathjax>$$
(f \times g)(x,\;y) = \sum_{x \le z \le y} f(x,\;z)g(z,\;y) \tag{2.1}
$$</mathjax></p>
<p>这个卷积满足结合律：<br />
<mathjax>$$
(f \times g) \times h = f \times (g \times h) \tag{2.2}
$$</mathjax></p>
<p>注意，这个卷积<strong>不一定<sup id="fnref:possible"><a class="footnote-ref" href="#fn:possible" rel="footnote">1</a></sup>满足交换律</strong>。</p>
<p>以及三种强行定义的莫名其妙的函数：<br />
<mathjax>$\delta$</mathjax> (delta) 函数：<br />
<mathjax>$$
\delta(x,\;y) = [x = y] \tag{2.3}
$$</mathjax></p>
<p>任意函数卷<mathjax>$\delta$</mathjax>函数均会得到原函数。</p>
<p><mathjax>$\zeta$</mathjax> (zeta) 函数：<br />
<mathjax>$$
\zeta(x,\;y) = [x \le y] \tag{2.4}
$$</mathjax></p>
<p>以及莫比乌斯<mathjax>$\mu$</mathjax>函数是定义为<mathjax>$\zeta$</mathjax>函数的<strong>逆函数</strong>，即：<br />
<mathjax>$$
\mu \times \zeta = \zeta \times \mu = \delta \tag{2.5}
$$</mathjax></p>
<p>展开卷积可得：<br />
<mathjax>$$
\begin{align}
\delta = \mu \times \zeta \Longrightarrow \delta(x,\;y) &amp; = \sum_{x \le z \le y} \mu(x,\;z)\zeta(z,\;y) \\
&amp; = \sum_{x \le z \le y} \mu(x,\;z)
\end{align}
$$</mathjax></p>
<p>因此，当<mathjax>$x \neq y$</mathjax>时：<br />
<mathjax>$$
\mu(x,\;y) = - \sum_{x \le z \lt y} \mu(x,\;z) \tag{2.6}
$$</mathjax></p>
<h2 id="_4">莫比乌斯反演公式</h2>
<blockquote>
<p><strong>(莫比乌斯反演公式)</strong><br />
对于有限偏序集<mathjax>$(X_n,\;\le)$</mathjax>上的两个函数<mathjax>$F(x,\;y)$</mathjax>和<mathjax>$G(x,\;y)$</mathjax>，如果：<br />
<mathjax>$$ G(x,\;y) = \sum_{x \le z \le y} F(x,\;z) \tag{3.1}$$</mathjax></p>
<p>那么：<br />
<mathjax>$$F(x,\;y) = \sum_{x \le z \le y} G(x,\;z)\mu(z,\;y)  = (G \times \mu)(x,\;y) \tag{3.2}$$</mathjax></p>
</blockquote>
<p><strong>证明</strong> 首先将式子展开：<br />
<mathjax>$$
\begin{align}
F(x,\;y) &amp; = \sum_{x \le z \le y} G(x,\;z)\mu(z,\;y) \\
&amp; = \sum_{x \le z \le y} \mu(z,\;y) \sum_{x \le m \le z} F(x,\;m)
\end{align}
$$</mathjax></p>
<p>我们使用<mathjax>$\zeta$</mathjax>函数来表示上下界，于是式子改写为以下形式：<br />
<mathjax>$$
\sum_{x \le z \le y} \mu(z,\;y) \sum_{m \in X_n} F(x,\;m)\zeta(x,\;m)\zeta(m,\;z)
$$</mathjax></p>
<p>改变求和的枚举顺序，先枚举<mathjax>$m$</mathjax>，其值依然不变：<br />
<mathjax>$$
\sum_{m \in X_n} \sum_{x \le z \le y} \zeta(m,\;z)\mu(z,\;y)\zeta(x,\;m)F(x,\;m)
$$</mathjax></p>
<p>由于当<mathjax>$m \lt x$</mathjax>的时候<mathjax>$\zeta(x,\;m)$</mathjax>为<mathjax>$0$</mathjax>，因此只用考虑<mathjax>$m \ge x$</mathjax>。<br />
并且当<mathjax>$m \ge x$</mathjax>时，<mathjax>$z \ge m$</mathjax>必需成立。<br />
因此可以改写下界：<br />
<mathjax>$$
\sum_{m \in X_n} \sum_{m \le z \le y} \zeta(m,\;z)\mu(z,\;y)F(x,\;m)
$$</mathjax></p>
<p>然后变成了卷积的形式：<br />
<mathjax>$$
\begin{align}
\sum_{m \in X_n} F(x,\;m) \sum_{m \le z \le y} \zeta(m,\;z)\mu(z,\;y) &amp; = \sum_{m \in X_n} F(x,\;m) \delta(m,\;y) \\
&amp; = F(x,\;y)
\end{align}
$$</mathjax></p>
<p>当<mathjax>$m = y$</mathjax>时，<mathjax>$\delta(m,\;y)$</mathjax>才为<mathjax>$1$</mathjax>，所以综上所述：<br />
<mathjax>$$
F(x,\;y) = \sum_{x \le z \le y} G(x,\;z)\mu(z,\;y) \tag{3.2}
$$</mathjax></p>
<h2 id="_5">偏序集直积</h2>
<p>对于两个偏序集<mathjax>$(A,\;\le_1)$</mathjax>和<mathjax>$(B,\;\le_2)$</mathjax>，它们的直积<mathjax>$C = A \times B = (A \times B,\;\le)$</mathjax>也是偏序集，其中的元素为<mathjax>$(x,\;y)\;\;(x \in A,\;y \in B)$</mathjax>。其关系<mathjax>$\le$</mathjax>的定义如下：<br />
<mathjax>$$
(x_1,\;y_1) \le (x_2,\;y_2) \Longleftrightarrow x_1 \le_1 x_2 \land y_1 \le_2 y_2
$$</mathjax></p>
<p>对于偏序集的直积，我们有以下定理：</p>
<blockquote>
<p>设<mathjax>$A$</mathjax>和<mathjax>$B$</mathjax>的莫比乌斯函数分别为<mathjax>$\mu_1$</mathjax>和<mathjax>$\mu_2$</mathjax>，那么<mathjax>$C$</mathjax>的莫比乌斯函数满足：<br />
<mathjax>$$\mu((x_1,\;y_1),\;(x_2,\;y_2)) = \mu_1(x_1,\;x_2)\mu(y_1,\;y_2) \tag{4.1}$$</mathjax></p>
</blockquote>
<p><strong>证明</strong> 对于<mathjax>$(x_1,\;y_1) \not\le (x_2,\;y_2)$</mathjax>和<mathjax>$(x_1,\;y_1) = (x_2,\;y_2)$</mathjax>的情况，上式显然成立。<br />
假设对于满足<mathjax>$(x_1,\;y_1) \le (u,\;v) \lt (x_2,\;y_2)$</mathjax>的二元组均满足，那么有：<br />
<mathjax>$$
\begin{align}
\mu((x_1,\;y_1),\;(x_2,\;y_2)) &amp; = - \sum_{(x_1,\;y_1) \le (u,\;v) \lt (x_2,\;y_2)} \mu((x_1,\;y_1),\;(u,\;v)) \\
&amp; = - \sum_{(x_1,\;y_1) \le (u,\;v) \lt (x_2,\;y_2)} \mu_1(x_1,\;u)\mu_2(y_1,\;v) &amp; (\text{根据归纳假设}) \\
&amp; = - \sum_{x_1 \le_1 u \lt_1 x_2} \sum_{y_1 \le_2 v \lt_2 y_2} \mu_1(x_1,\;u)\mu_2(y_1,\;v) &amp; (\text{分别枚举}) \\
&amp; =  - \sum_{x_1 \le_1 u \le_1 x_2} \sum_{y_1 \le_2 v \le_2 y_2} \mu_1(x_1,\;u)\mu_2(y_1,\;v) \\
&amp;\;\;\;\, + \mu_1(x_1,\;x_2)\sum_{y_1 \le_2 v \le_2 y_2} \mu_2(y_1,\;v) \\
&amp;\;\;\;\, + \mu_2(y_1,\;y_2)\sum_{x_1 \le_1 u \le_1 x_2} \mu_1(x_1,\;u) \\
&amp;\;\;\;\, + \mu_1(x_1,\;x_2)\mu_2(y_1,\;y_2) &amp; (\text{扩展上界})
\end{align}
$$</mathjax></p>
<p>由于：<br />
<mathjax>$$
\begin{align}
0
&amp; = \sum_{y_1 \le_2 v \le_2 y_2} \mu_2(y_1,\;v) \\
&amp; = \sum_{x_1 \le_1 u \le_1 x_2} \mu_1(x_1,\;u)  \\ 
&amp; = \sum_{x_1 \le_1 u \le_1 x_2} \sum_{y_1 \le_2 v \le_2 y_2} \mu_1(x_1,\;u)\mu_2(y_1,\;v) 
\end{align}
$$</mathjax></p>
<p>所以定理成立。</p>
<h2 id="x_nle">在<mathjax>$(X_n,\;\le)$</mathjax>上的莫比乌斯函数</h2>
<p>注意这里的是真正的小于等于号了......<br />
这个比较智障，分析一下就好了：<br />
对于<mathjax>$y = x$</mathjax>，我们有：<br />
<mathjax>$$
\mu(x,\;y) = \mu(x,\;x) = 1
$$</mathjax></p>
<p>对于<mathjax>$y = x + 1$</mathjax>，我们有：<br />
<mathjax>$$
\mu(x,\;y) = \mu(x,\;x + 1) = -\mu(x,\;x) = -1
$$</mathjax></p>
<p>对于<mathjax>$y = x + 2$</mathjax>，我们有：<br />
<mathjax>$$
\mu(x,\;y) = \mu(x,\;x + 2) = -\left[\mu(x,\;x) + \mu(x,\;x + 1)\right] = 0
$$</mathjax></p>
<p>不难发现，对于<mathjax>$y \gt x + 1$</mathjax>的函数值就全都变为<mathjax>$0$</mathjax>了。<br />
总结一下就是：<br />
<mathjax>$$
\mu(x,\;y) = 
\begin{cases}
1 &amp; (y = x) \\
-1 &amp; (y = x + 1) \\
0 &amp; (\text{otherwise})
\end{cases}
\tag{5.1}
$$</mathjax></p>
<h2 id="x_nsubseteq">在<mathjax>$(X_n,\;\subseteq)$</mathjax>上的莫比乌斯函数</h2>
<blockquote>
<p>试证明：<br />
偏序集<mathjax>$(X_n,\;\subseteq)$</mathjax>的莫比乌斯函数是：<br />
<mathjax>$$\mu(A,\;B) = (-1)^{|B| - |A|} \tag{6.1}$$</mathjax></p>
</blockquote>
<p>运用归纳法证明：<br />
首先对于<mathjax>$A = B$</mathjax>，显然成立：<br />
<mathjax>$$
\mu(A, B) = \mu(A, A) = 1 = (-1)^0
$$</mathjax></p>
<p>假设对于<mathjax>$|B| - |A| \le k$</mathjax>均成立，尝试证明对于<mathjax>$|B| - |A| = k + 1$</mathjax>也成立：<br />
<mathjax>$$
\begin{align}
\mu(A,\;B) &amp; = -\sum_{A \subseteq C \subset B} \mu(A,\;C) \\
&amp; = -\sum_{A \subseteq C \subset B} (-1)^{|C| - |A|} \\
&amp; = -\sum_{i = 0}^{k} {k + 1 \choose i}(-1)^i \\
&amp; = -\left[(1 - 1)^{k + 1} - (-1)^{k + 1} \right] \\
&amp; = (-1)^{k + 1} \\
&amp; = (-1)^{|B| - |A|}
\end{align}
$$</mathjax></p>
<h2 id="x_nmid">在<mathjax>$(X_n,\;\mid)$</mathjax>上的莫比乌斯函数</h2>
<p>首先我<strong>不会</strong>证这玩意：<br />
<mathjax>$$
a \mid b \Longrightarrow \mu(a,\;b) = \mu(1,\;\frac{b}a) \tag{7.1}
$$</mathjax></p>
<p>不管了......<br />
反正它是对的......</p>
<p>由于有上面的式子，所以我们只用关心<mathjax>$\mu(1,\;n)$</mathjax>。<br />
首先可以递归计算：<br />
<mathjax>$$
\mu(1,\;n) = -\sum_{a \mid n,\;a\neq n} \mu(1,\;a)
$$</mathjax></p>
<p>考虑对<mathjax>$n$</mathjax>进行质因数分解：<br />
<mathjax>$$
n = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_m^{\alpha_m}
$$</mathjax></p>
<p>对于<mathjax>$n$</mathjax>的任意一个因子<mathjax>$d$</mathjax>都有：<br />
<mathjax>$$
d = p_1^{\beta_1}p_2^{\beta_2}\cdots p_m^{\beta_m} \;\;\;\; (0 \le \beta_i \le \alpha_i)
$$</mathjax></p>
<p>相当于可以看作<mathjax>$m$</mathjax>个大小为<mathjax>$\alpha_1 + 1,\;\alpha_2 + 1,\;\dots,\;\alpha_m + 1$</mathjax>的偏序集的直积的结果。<br />
于是可以得到：<br />
<mathjax>$$
\mu(1,\;n) = \prod_{i=1}^m\mu(1,\;p_i^{\alpha_i}) \tag{7.2}
$$</mathjax></p>
<p>注意到，对于<mathjax>$\varphi(p) = p - 1$</mathjax>：<br />
<mathjax>$$
\mu(1,\;1) = 1 \\
\mu(1,\;p) = -\mu(1,\;1) = -1 \;\; \\
\mu(1,\;p^2) = -\left[ \mu(1,\;1) + \mu(1,\;p) \right] = 0 \\
\dots
$$</mathjax></p>
<p>总结一下就是：<br />
<mathjax>$$
\mu(1,\;p^k) = 
\begin{cases}
1 &amp; (k = 0) \\
-1 &amp; (k = 1) \\ 
0 &amp; (\text{otherwise})
\end{cases}
\tag{7.3}
$$</mathjax></p>
<p>运用直积，可以知道：<br />
<mathjax>$$
\mu(1,\;n) = 
\begin{cases}
1 &amp; (n = 1) \\
(-1)^k &amp; (n = p_1p_2\cdots p_k, \;\;\varphi(p_i) = p_i - 1) \\
0 &amp; (\text{otherwise})
\end{cases}
\tag{7.4}
$$</mathjax></p>
<p>为了方便，通常把<mathjax>$\mu(1,\;n)$</mathjax>记作<mathjax>$\mu(n)$</mathjax>，就变成常见的莫比乌斯函数了。</p>
<p>据此，我们可以证明莫比乌斯函数是积性函数，即：<br />
<mathjax>$$
a \bot b \Longrightarrow \mu(ab) = \mu(a)\mu(b) \tag{7.5}
$$</mathjax></p>
<p><strong>证明</strong>：<br />
1. 如果<mathjax>$a$</mathjax>、<mathjax>$b$</mathjax>中有一者为<mathjax>$1$</mathjax>，结论显然成立。<br />
2. 如果<mathjax>$a$</mathjax>、<mathjax>$b$</mathjax>中有一者不为素数连乘的形式，它们的积也一定不会是素数连乘的形式，故等于<mathjax>$0$</mathjax>。<br />
3. 此时假设<mathjax>$a$</mathjax>、<mathjax>$b$</mathjax>都是素数连乘的形式，又因为<mathjax>$a$</mathjax>与<mathjax>$b$</mathjax>互质，所以它们的素因子中没有相同的。设<mathjax>$a = p_1p_2\cdots p_m$</mathjax>和<mathjax>$b = q_1q_2\cdots q_n$</mathjax>所以可以知道<mathjax>$\mu(ab) = (-1)^{n + m} = \mu(a)\mu(b)$</mathjax>。</p>
<h2 id="_6">反演示例：容斥原理</h2>
<p>设<mathjax>$S$</mathjax>为有限集，<mathjax>$A_1,\;A_2,\;\dots,\;A_n$</mathjax>是<mathjax>$S$</mathjax>的子集，<mathjax>$K \subseteq \{1,\;2,\;\dots,\;n\}$</mathjax>。<br />
定义函数<mathjax>$F(K)$</mathjax>计数<mathjax>$s$</mathjax><strong>同时</strong>满足下列条件：<br />
<mathjax>$$
s \not\in \bigcup_{i \in K} A_i \\
s \in \bigcap_{i \not\in K} A_i
$$</mathjax></p>
<p>即：<br />
<mathjax>$$
F(K) = \left| \bigcap_{i \not\in K} A_i - \bigcup_{i \in K} A_i \right| \tag{8.1}
$$</mathjax></p>
<p>如何脑补这个函数？可以想象成是用<mathjax>$K$</mathjax>把<mathjax>$S$</mathjax>中的很多东西挖走了，然后剩下的集合再求交集。<br />
对于此，再定义函数<mathjax>$G(K)$</mathjax>：<br />
<mathjax>$$
G(K) = \sum_{L \subseteq K} F(L) \tag{8.2}
$$</mathjax></p>
<p>这货居然计数的是：<br />
<mathjax>$$
G(K) = \left| \bigcap_{i \not\in K} A_i \right| \tag{8.3}
$$</mathjax></p>
<p>如何脑补其正确性？可以想象是一个智障用<mathjax>$K$</mathjax>把本来属于它们交集的东西挖去了，然后又一个一个吐出来，于是就还原了原本的交集......<br />
根据莫比乌斯反演公式可以知道：<br />
<mathjax>$$
G(K) = \sum_{L \subseteq K} F(K) \Longrightarrow F(K) = \sum_{L \subseteq K} (-1)^{|K| - |L|} G(L)
$$</mathjax></p>
<p>所以取<mathjax>$K = \{1,\;2,\;\dots,\;n\}$</mathjax>可以得到：<br />
<mathjax>$$
F(K) = \sum_{L \subseteq K} (-1)^{n - |L|} G(L) \tag{8.4}
$$</mathjax></p>
<p>这个时候的<mathjax>$F(K)$</mathjax>计数的东西有了新的含义：<br />
<mathjax>$$
F(K) = \left|\bigcup_{i \in K} A_i\right| = \left|\bigcap_{i \in K} \overline{A}_i \right| \tag{8.5}
$$</mathjax></p>
<p>用<mathjax>$F(K)$</mathjax>和<mathjax>$G(K)$</mathjax>本身的含义来替换，就可以得到<strong>容斥原理</strong> (感觉好神奇)：<br />
<mathjax>$$
\left|\bigcap_{i = 1}^n \overline{A}_i \right| = \sum_{K \subseteq \{1,\;,2,\;,\dots,\;n\}} (-1)^{|K|} \left| \bigcap_{i \in K} A_i \right| \tag{8.6}
$$</mathjax></p>
<h2 id="varphin">反演示例：<mathjax>$\varphi(n)$</mathjax>通项公式</h2>
<p>欧拉<mathjax>$\varphi(n)$</mathjax>函数计数的是不大于<mathjax>$n$</mathjax>的与<mathjax>$n$</mathjax>互质的正整数个数。<br />
对于欧拉<mathjax>$\varphi$</mathjax>函数，我们有如下的定理：<br />
<mathjax>$$
n = \sum_{d \mid n} \varphi(d) \tag{9.1}
$$</mathjax></p>
<p>有两种证明方法：<br />
第一种考虑不与<mathjax>$n$</mathjax>互质的数，如果存在一个数<mathjax>$d$</mathjax>与<mathjax>$n$</mathjax>不互质，那么必有<mathjax>$\gcd(d, n) = a \gt 1$</mathjax>，换言之<mathjax>$\gcd(d / a, n / a) = 1$</mathjax>，所以一个数不与<mathjax>$n$</mathjax>互质，那么必定与<mathjax>$n$</mathjax>的一个因子互质。所以上式成立。</p>
<p>另一种是使用归纳法证明：<br />
首先考虑<mathjax>$1$</mathjax>，是显然成立的。<br />
然后考虑质数<mathjax>$p$</mathjax>，<mathjax>$\varphi(1) + \varphi(p) = p$</mathjax>，所以也是成立的。<br />
考虑质数<mathjax>$p$</mathjax>的幂<mathjax>$p^k$</mathjax>，它的因子有<mathjax>$1,\;p,\;p^2,\;\dots,\;p^k$</mathjax>，由于：<br />
<mathjax>$$
\varphi(p^k) = (p - 1)p^{k-1} \;\;\;\; (\varphi(p) = p - 1)
$$</mathjax></p>
<p>所以我们对其进行等比数列求和：<br />
<mathjax>$$
\begin{align}
\sum_{d \mid n} \varphi(d) &amp; = 1 + (p - 1)\sum_{i=0}^{k-1} p^i \\
&amp; = 1 + (p - 1) \cdot {1 - p^k \over 1 - p} \\
&amp; = 1 + p^k - 1 \\
&amp; = p^k
\end{align}
$$</mathjax></p>
<p>故对质数的幂也成立。<br />
假设对于一个数<mathjax>$c$</mathjax>，所有小于<mathjax>$c$</mathjax>的数均成立，那么选取<mathjax>$n$</mathjax>的两个互质的因子<mathjax>$a$</mathjax>、<mathjax>$b$</mathjax>使得<mathjax>$ab = c$</mathjax>，那么有：<br />
<mathjax>$$
\sum_{n \mid a} \varphi(n) \sum_{m \mid b} \varphi(m) = a \cdot b = c
$$</mathjax></p>
<p>下面证明<mathjax>$\sum_{n \mid a} \varphi(n) \sum_{m \mid b} \varphi(m) = \sum_{d \mid c} \varphi(d)$</mathjax>，即可证明原式：<br />
<mathjax>$$
\begin{align}
\sum_{n \mid a} \varphi(n) \sum_{m \mid b} \varphi(m) &amp; = \sum_{n \mid a}\sum_{m \mid b}\varphi(n)\varphi(m) &amp; (\text{改变枚举顺序}) \\
&amp; = \sum_{n \mid a}\sum_{m \mid b} \varphi(nm) &amp; (\text{由于}n \bot m) \\
&amp; = \sum_{nm \mid ab} \varphi(nm) &amp; (\text{由于}a \bot b) \\
&amp; = \sum_{d \mid c} \varphi(d) &amp; (\text{等价代换}) \\
&amp; = c
\end{align}
$$</mathjax></p>
<p>注意到<mathjax>$(9.1)$</mathjax>式是一个明显的莫比乌斯反演的形式。根据莫比乌斯反演公式，我们可以得到：<br />
<mathjax>$$
\begin{align}
\varphi(n) &amp; = \sum_{d \mid n} d \cdot \mu(d,\;n) \\
&amp; = \sum_{d \mid n} d \cdot \mu(1,\;n / d) \\
&amp; = \sum_{d \mid n} d \cdot \mu(n / d) \\
&amp; = \sum_{d \mid n} \mu(d) \cdot n/d
\end{align}
$$</mathjax></p>
<p>考虑一下<mathjax>$\mu$</mathjax>函数的取值，对于因子<mathjax>$1$</mathjax>，和式中的结果为<mathjax>$n$</mathjax>。对于由素数相乘的因子，这些素因子必定来自<mathjax>$n$</mathjax>。而其它情况就都为<mathjax>$0$</mathjax>。<br />
设<mathjax>$n = p_1^{k_1}p_2^{k_2}\cdots p_m^{k_m}$</mathjax>。<br />
因此可以得到下面的式子：<br />
<mathjax>$$
\varphi(n) = n\left[1 - \sum \frac1{p_i} + \sum \frac1{p_ip_j} - \cdots + (-1)^{m}\sum \frac1{\prod_{i=1}^m p_i} \right] \tag{9.2}
$$</mathjax></p>
<p>这恰好是下面的式子展开的形式：<br />
<mathjax>$$
\varphi(n) = n\prod_{i=1}^m \left( 1 - \frac1{p_i} \right) \tag{9.3}
$$</mathjax></p>
<p>因此：<br />
<mathjax>$$
\varphi(n) = n\prod_{p \mid n,\;\varphi(p) = p - 1} \left( 1 - \frac1p\right) \tag{9.4}
$$</mathjax></p>
<h2 id="_7">反演示例：多重集合的循环排列</h2>
<blockquote>
<p>我们有一个多重集合<mathjax>$\{\infty \cdot 1,\;\infty \cdot 2,\;\dots,\;\infty \cdot k\}$</mathjax>。易知长度为<mathjax>$n$</mathjax>的全排列数为<mathjax>$k^n$</mathjax>。<br />
现在对于两个排列<mathjax>$A$</mathjax>和<mathjax>$B$</mathjax>，如果<mathjax>$A$</mathjax>通过&rdquo;旋转&rdquo; (即将最后一个变成第一个，并且把之前的全部后移) 能变成<mathjax>$B$</mathjax>，那么<mathjax>$A$</mathjax>和<mathjax>$B$</mathjax>是等价的。<br />
换言之，最小表示法相同的排列是等价。<br />
求不同的长度为<mathjax>$n$</mathjax>的<strong>循环排列</strong>数量。</p>
</blockquote>
<p>对于这个计数问题，我们记<mathjax>$h(n)$</mathjax>为长度为<mathjax>$n$</mathjax>时的答案，<mathjax>$f(n)$</mathjax>为长度为<mathjax>$n$</mathjax>并且<strong>旋转</strong><mathjax>$n$</mathjax>次才会变为原排列 (即循环节长度为<mathjax>$n$</mathjax>) 的排列的数量。显然，一个排列的循环节长度<mathjax>$m$</mathjax>必须满足<mathjax>$m \mid n$</mathjax>。<br />
那么可以知道：<br />
<mathjax>$$
h(n) = \sum_{d \mid n} \frac{f(d)}d \tag{10.1}
$$</mathjax></p>
<p>由于循环节长度小于<mathjax>$n$</mathjax>的排列都可以由循环节不断重复而得来。因此我们设：<br />
<mathjax>$$
g(n) = \sum_{d \mid n} f(d)
$$</mathjax></p>
<p><mathjax>$g(n)$</mathjax>就计数了所有长度为<mathjax>$n$</mathjax>的排列数量。<br />
所以：<br />
<mathjax>$$
g(n) = k^n \tag{10.2}
$$</mathjax></p>
<p>根据莫比乌斯反演公式可得：<br />
<mathjax>$$
\begin{align}
f(n) &amp; = \sum_{d \mid n} g(d)\mu(n/d) \\
&amp; = \sum_{d \mid n} k^d\mu(n/d)
\end{align}
\tag{10.3}
$$</mathjax></p>
<p>带入<mathjax>$h(n)$</mathjax>的计算公式可得：<br />
<mathjax>$$
h(n) = \sum_{d \mid n} \frac1d \sum_{e \mid d} k^e\mu(d/e) \tag{10.4}
$$</mathjax></p>
<p>由于<mathjax>$e \mid d$</mathjax>并且<mathjax>$d \mid n$</mathjax>，所以我们设<mathjax>$n = rd,\;d = me$</mathjax>，所以<mathjax>$n = rem$</mathjax>，这样将方便我们变换公式：<br />
<mathjax>$$
\begin{align}
\sum_{d \mid n} \frac1d \sum_{e \mid d} k^e\mu(d/e) &amp; = \sum_{e \mid n} k^e \sum_{m \mid (n/e)} \frac1{me}\mu(m) \\
&amp; =\sum_{e\mid n} \frac{k^e}n \sum_{r \mid (n/e)} r\cdot\mu(\frac{n}e/r)
\end{align}
$$</mathjax></p>
<p>由于：<br />
<mathjax>$$
\varphi(n) = \sum_{d \mid n} d \cdot \mu(n/d)
$$</mathjax></p>
<p>所以：<br />
<mathjax>$$
h(n) = \frac1n \sum_{d \mid n} k^d \varphi(n/d) \tag{10.5}
$$</mathjax></p>
<h2 id="_8">莫比乌斯函数示例：最大公约数</h2>
<p>除了莫比乌斯反演公式，莫比乌斯函数本身的性质也是很好的。<br />
考虑下面一个问题：</p>
<blockquote>
<p>给定<mathjax>$n$</mathjax>和<mathjax>$m$</mathjax>，求<mathjax>$\gcd(x,\;y)\;\;(1 \le x \le n,\;1 \le y \le m)$</mathjax>为<strong>素数</strong>的二元组<mathjax>$(x,\;y)$</mathjax>个数。</p>
</blockquote>
<p>换言之，我们要求的是这个：<br />
<mathjax>$$
\sum_{x=1}^n\sum_{y=1}^m \left[\varphi(\gcd(x,\;y)) = \gcd(x,\;y) - 1\right] \tag{11.1}
$$</mathjax></p>
<p>首先，我们可以换个思路，就是枚举最大公约数的答案：<br />
<mathjax>$$
\sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^n\sum_{y=1}^m \left[ \gcd(x,\;y) = p \right] \tag{11.2}
$$</mathjax></p>
<p>由于<mathjax>$\gcd(x,\;y) = p \Longrightarrow \gcd(x/p,\;y/p) = 1$</mathjax>，所以就变成了枚举互质的数的对数：<br />
<mathjax>$$
\sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^{\left\lfloor \frac{n}p\right\rfloor}\sum_{y=1}^{\left\lfloor \frac{m}p \right\rfloor} \left[ \gcd(x,\;y) = 1 \right] \tag{11.3}
$$</mathjax></p>
<p>由于莫比乌斯函数有这样的性质：<br />
<mathjax>$$
\sum_{d \mid n} \mu(d) = [n = 1] \tag{11.4}
$$</mathjax></p>
<p>所以可以使用莫比乌斯函数来测试一个数是否为<mathjax>$1$</mathjax>：<br />
<mathjax>$$
\sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^{\left\lfloor \frac{n}p\right\rfloor}\sum_{y=1}^{\left\lfloor \frac{m}p \right\rfloor} \sum_{d \mid \gcd(x,\;y)} \mu(d) \tag{11.5}
$$</mathjax></p>
<p>因为<mathjax>$d \mid \gcd(x,\;y)$</mathjax>当且仅当<mathjax>$d \mid x$</mathjax>并且<mathjax>$d \mid y$</mathjax>，所以可以变成这样：<br />
<mathjax>$$
\sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}}\sum_{x=1}^{\left\lfloor \frac{n}p\right\rfloor}\sum_{y=1}^{\left\lfloor \frac{m}p \right\rfloor} \sum_{d \mid x \,\land\, d \mid y} \mu(d) \tag{11.6}
$$</mathjax></p>
<p>现在东西越来越多了，是时候考虑简化一下了。<br />
首先对于一堆和式的一个技巧就是<strong>调整枚举顺序</strong>。<br />
尝试先枚举<mathjax>$d$</mathjax>，这样合法的<mathjax>$d$</mathjax>就可以直接计算了：<br />
<mathjax>$$
\sum_{\varphi(p) = p - 1}^{\min\{n,\;m\}} \sum_{d=1}^{\min\{n,\;m\}} \left\lfloor \frac{n}{dp} \right\rfloor \left\lfloor \frac{m}{dp} \right\rfloor \mu(d) \tag{11.7}
$$</mathjax></p>
<p>其实这个式子已经可以用来计算答案了。因为两个向下取整的乘积最多有<mathjax>$O(\sqrt{n} + \sqrt{m})$</mathjax>个不同的取值，左边枚举的素数约为<mathjax>$O({n \over \ln n})$</mathjax>个，故根据此公式计算的时间复杂度为<mathjax>$O({n (\sqrt{n} + \sqrt{m}) \over \ln n})$</mathjax>。<br />
然而我们可以做得更快一些。<br />
设<mathjax>$T = dp$</mathjax>，现在改成先枚举<mathjax>$T$</mathjax>：<br />
<mathjax>$$
\sum_{T = 1}^{\min\{n,\;m\}} \left\lfloor \frac{n}T \right\rfloor \left\lfloor \frac{m}T \right\rfloor \sum_{p \mid T,\;\varphi(p) = p - 1} \mu(T / p) \tag{11.8}
$$</mathjax></p>
<p>这样左边就可以在<mathjax>$O(\sqrt{n} + \sqrt{m})$</mathjax>的时间内进行枚举。<br />
枚举大概是这样的一个过程：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>lastpos = 0
i = 1
while i &lt;= min(n, m):
    lastpos = min(n / (n / i), m / (m / i))
    # Do something...
    i = lastpos + 1
</pre></div>
</td></tr></table>

<p>我们企图能使右边快速计算。因此我们来研究一下右边这个玩意。<br />
设：<br />
<mathjax>$$
g(x) = \sum_{p \mid x,\;\varphi(p) = p - 1} \mu(p) \tag{11.9}
$$</mathjax></p>
<p>考虑使用线性筛来计算<mathjax>$g(x)$</mathjax>。</p>
<ol>
<li>当<mathjax>$x = 1$</mathjax>时，<mathjax>$g(x) = 0$</mathjax>。</li>
<li>当<mathjax>$x$</mathjax>为素数时，<mathjax>$g(x) = -1$</mathjax>。</li>
<li>在线性筛的处理过程中，设当前数为<mathjax>$i$</mathjax>，枚举到的素数为<mathjax>$p$</mathjax>，我们将要计算<mathjax>$g(ip)$</mathjax>：<ol>
<li>当<mathjax>$\mu(i) = 0$</mathjax>时，说明<mathjax>$i$</mathjax>的质因数分解中至少存在一个一个素因子的次数大于<mathjax>$1$</mathjax>。<br />
   在这种情况下，除非<strong>只有一个</strong>素因子的次数为<mathjax>$2$</mathjax>，其它均为<mathjax>$1$</mathjax>，否则无论如何<mathjax>$g$</mathjax>的函数值都为<mathjax>$0$</mathjax>。<br />
   假设只存在一个素因子的次数为<mathjax>$2$</mathjax>，记这个素因子为<mathjax>$f(i)$</mathjax>。<ol>
<li>若<mathjax>$p \mid i$</mathjax>，那么将会导致无论是哪个素因子，<mathjax>$\mu$</mathjax>函数的值都为<mathjax>$0$</mathjax>。因此<mathjax>$g$</mathjax>函数的值为<mathjax>$0$</mathjax>。</li>
<li>若<mathjax>$p \not\mid i$</mathjax>，那么就只有除以<mathjax>$f(i)$</mathjax>时会有值，此时的值为<mathjax>$\mu(i / f(i) \cdot p)$</mathjax>。</li>
</ol>
</li>
<li>当<mathjax>$\mu(i) \neq 0$</mathjax>时，意味着<mathjax>$i$</mathjax>将是多个素数之积。同样我们来考虑两种情况：<ol>
<li>若<mathjax>$p \mid i$</mathjax>，那么就只有<mathjax>$p$</mathjax>的次数为<mathjax>$2$</mathjax>，此时<mathjax>$g(ip) = \mu(i)$</mathjax>。</li>
<li>若<mathjax>$p \not\mid i$</mathjax>，那么<mathjax>$\mu(ip)$</mathjax>依然不为<mathjax>$0$</mathjax>。假设<mathjax>$i$</mathjax>有<mathjax>$r$</mathjax>个素因子，那么<mathjax>$g(i) = r(-1)^{r-1}$</mathjax>，并且<mathjax>$g(ip) = (r + 1)(-1)^r = -r(-1)^{r-1} + (-1)^{r+1}$</mathjax>，这意味着它们符号相反且绝对值差<mathjax>$1$</mathjax>。这样就可以直接计算。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>经过一番分类讨论，我们总算成功地找到了预处理<mathjax>$g(x)$</mathjax>的方法。<br />
在这中间有一个问题还亟待解决，就是我们需要计算<mathjax>$f(x)$</mathjax>，事实上它也可以用线性筛计算。<br />
假设存在这样的素因子<mathjax>$p$</mathjax>，就记<mathjax>$f(x) = p$</mathjax>。如果<mathjax>$x$</mathjax>还是多个素数相乘，就记<mathjax>$f(x) = 1$</mathjax>。否则记作<mathjax>$0$</mathjax>，又称为&rdquo;没救了&rdquo;。这样就只有<mathjax>$f(x) \gt 1$</mathjax>时才有我们需要的结果。</p>
<ol>
<li>当<mathjax>$x = 1$</mathjax>或<mathjax>$x$</mathjax>为质数时，<mathjax>$f(x) = 1$</mathjax>。</li>
<li>每次往一个数<mathjax>$i$</mathjax>加入一个素数<mathjax>$p$</mathjax>时，需要考虑下面的情况：<ol>
<li>若<mathjax>$f(i) = 0$</mathjax>，那么没救了。</li>
<li>若<mathjax>$p \mid i$</mathjax>，并且<mathjax>$f(i) = 1$</mathjax>，那么<mathjax>$ip$</mathjax>将不再是素数连乘的形式，此时可以记下<mathjax>$f(ip) = p$</mathjax>。如果<mathjax>$f(i) &gt; 1$</mathjax>，那么它没救了。</li>
<li>若<mathjax>$p \not\mid i$</mathjax>，那么<mathjax>$f$</mathjax>函数值不会改变。</li>
</ol>
</li>
</ol>
<p>这样就可以欢快地计算<mathjax>$f$</mathjax>函数啦~<br />
回到之前的问题，我们能够计算<mathjax>$g(x)$</mathjax>函数后，预处理出它的前缀和，就可以在前面伪代码中展示的迭代过程计算答案了。时间复杂度是<mathjax>$O(\sqrt{n} + \sqrt{m})$</mathjax>。</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:possible">
<p>在偏序集<mathjax>$(X_n,\;\mid\;)$</mathjax>上简化后的卷积 (即狄利克雷卷积)，会满足交换律。&#160;<a class="footnote-backref" href="#fnref:possible" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
</body>
</html>
