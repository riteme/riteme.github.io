<!DOCTYPE html>
<html>
<head>
  <title>排列与组合 - riteme.site</title>
  <meta charset="UTF-8">
  <meta name="robots" content="none">
  <link rel="stylesheet" type="text/css" href="../../css/site.min.css">
  <script type="text/javascript" async src="../../mathjax/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>

<h1 id="_1">排列与组合</h1>
<p>排列与组合是组合数学中最基础的东西了。在此做一点记录。</p>
<h2 id="_2">阶乘</h2>
<p>在组合数学中，阶乘随处可见，它极大的简化了公式的形式。<br />
我们将<mathjax>$n!$</mathjax>记作<mathjax>$n$</mathjax>的阶乘，其定义如下：<br />
<mathjax>$$ n! = \prod^n_{i=1} i \tag{1.1} $$</mathjax></p>
<p>特别的，<mathjax>$0! = 1$</mathjax>。之所以<mathjax>$0$</mathjax>的阶乘这样定义，是为了使后面的公式更具有普遍性。</p>
<p>我们来看一下阶乘函数的增长：<br />
<img alt="factorial-function" src="http://git.oschina.net/riteme/blogimg/raw/master/permutation-and-combination/factorial.png" /><br />
上图中，红色的阶乘函数<mathjax>$ f(x) = x! $</mathjax>，蓝色的是<mathjax>$g(x) = x^2 $</mathjax>，而绿色的是<mathjax>$ h(x) = x^3 $</mathjax>。<br />
由此可见阶乘函数的增长比平方快。与三次方相比，阶乘函数在之后也将赶超。<br />
因此如果时间复杂度里面出现了阶乘，那将是一件可怕的事情。</p>
<h2 id="_3">排列</h2>
<p>对于一个集合<mathjax>$S$</mathjax>，其排列是<mathjax>$S$</mathjax>中的元素的<strong>有序放置</strong>。<br />
例如集合<mathjax>$S = \{ a, b, c \}$</mathjax>，它的<strong>1排列</strong>为：<br />
<mathjax>$$ a, b, c $$</mathjax></p>
<p>其<strong>2排列</strong>为：<br />
<mathjax>$$ ab, ac, ba, bc, ca, cb $$</mathjax></p>
<p><strong>3排列</strong>为：<br />
<mathjax>$$ abc, acb, bac, bca, cab, cba $$</mathjax></p>
<p>由于<mathjax>$|S| &lt; 4$</mathjax>，所以<mathjax>$S$</mathjax>没有<strong>4排列</strong>。</p>
<p>为了方便计数，我们将一个含有<mathjax>$n$</mathjax>个元素的集合的<mathjax>$r$</mathjax>排列个数记为<mathjax>$ P(n, r) $</mathjax><sup id="fnref:permutation"><a class="footnote-ref" href="#fn:permutation" rel="footnote">1</a></sup>。<br />
如：<mathjax>$P(3,1)=3, \; P(3,2)=P(3,3)=6 $</mathjax>。<br />
特别的，我们定义<mathjax>$P(n,0)=1$</mathjax>。</p>
<p>如何计算这个值呢？当然我们是有公式的：<br />
<strong>定理</strong> 对于任意的<mathjax>$n, r \in N_+$</mathjax>，并且<mathjax>$ r \le n$</mathjax>，有：<br />
<mathjax>$$ P(n, r) = {n! \over (n-r)!} \tag{2.1} $$</mathjax></p>
<p><strong>证明</strong> 我们有<mathjax>$r$</mathjax>个空位来摆放元素。在第一个空位我们有<mathjax>$n$</mathjax>种选择，在第二个空位我们有<mathjax>$n - 1$</mathjax>中选择......由此可以得知：<br />
<mathjax>$$ P(n, r) = \prod^n_{i=n-r+1} i = {n! \over (n-r)!} $$</mathjax></p>
<p>现在我们来运用一下排列。<br />
首先来计数<strong>由<mathjax>$1$</mathjax>至<mathjax>$9$</mathjax>的数构成的每一位均不同的<mathjax>$7$</mathjax>位数</strong>有多少个。<br />
这个非常简单，就是<mathjax>$P(9, 7) = 181440$</mathjax>。</p>
<p>如果现在要求<strong><mathjax>$5$</mathjax>和<mathjax>$6$</mathjax>不能连续出现</strong>，那么这样的数又有多少个？<br />
我们考虑将连续出现的数给计数出来，这样就可以得到答案。<br />
我们发现，通过向一个<mathjax>$5$</mathjax>位数中插入两个数就可以得到一个<mathjax>$7$</mathjax>位数，因此我们来考虑将<mathjax>$5$</mathjax>和<mathjax>$6$</mathjax>连续的插入一个<mathjax>$5$</mathjax>位数中。我们只会插入<mathjax>$56$</mathjax>或<mathjax>$65$</mathjax>，它们在一个<mathjax>$5$</mathjax>位数中一共有<mathjax>$6$</mathjax>个位置可以插入。因此<mathjax>$5$</mathjax>和<mathjax>$6$</mathjax>连续出现的数共有<mathjax>$ 2 \times 6 \times P(7, 5) = 30240 $</mathjax>个。<br />
因此最终的答案为<mathjax>$ 181440 - 30240 = 151200 $</mathjax>。</p>
<h2 id="_4">组合</h2>
<p>与排列相对，一个集合的组合<sup id="fnref:combination"><a class="footnote-ref" href="#fn:combination" rel="footnote">2</a></sup>是其元素的<strong>无序放置</strong>。<br />
其含义就是从集合中&rdquo;选取&rdquo;出几个元素。由于不考虑位置关系，所以像<mathjax>$abc$</mathjax>和<mathjax>$bac$</mathjax><sup id="fnref:represent"><a class="footnote-ref" href="#fn:represent" rel="footnote">3</a></sup>是等价的。</p>
<p>组合这一概念在整个组合数学中用处十分巨大。接下来我们先看到如何计数它。<br />
首先我们将组合数记为<mathjax>${n \choose r}$</mathjax><sup id="fnref:exp"><a class="footnote-ref" href="#fn:exp" rel="footnote">4</a></sup>，表示一个大小为<mathjax>$n$</mathjax>的集合的<mathjax>$r$</mathjax>组合的个数。例如，一个大小为<mathjax>$4$</mathjax>的集合<mathjax>$ S = \{ a,b,c,d\}$</mathjax>的<strong>3组合</strong>为：<br />
<mathjax>$$ \{a,b,c\}, \{a,b,d\}, \{a,c,d\}, \{b,c,d\} $$</mathjax></p>
<p>因此<mathjax>${4 \choose 3} = 4$</mathjax>。</p>
<p>同样，为了能够更加方便的计数它，我们当然也是有公式的。<br />
我们发现，任意一个<mathjax>$r$</mathjax>组合，都会有<mathjax>$P(r,r) = r! $</mathjax>种排列。而每一种排列，都会对应到一个组合。因此，一个集合的<mathjax>$r$</mathjax>组合与排列之间存在以下关系：<br />
<mathjax>$$ {n \choose r}r! = P(n,r) \tag{3.1} $$</mathjax></p>
<p>将排列数展开，我们可以得到下面的公式：<br />
<mathjax>$$ {n \choose r} = {n! \over (n-r)!r! } \tag{3.2} $$</mathjax></p>
<p>其中，<mathjax>$n,r \in N_+$</mathjax>，且<mathjax>$r\le n$</mathjax>。</p>
<h2 id="_5">组合数的基本性质</h2>
<p>组合数有着许多非常有用的性质。首先一个非常基本的等式就是：<br />
<mathjax>$$ {n \choose r} = {n \choose n-r} \tag{4.1} $$</mathjax></p>
<p>直接利用组合数的公式可以得证这一性质。</p>
<p>通过对组合数进行求和，我们可以得知一个集合的子集数量：<br />
<mathjax>$$ \sum^n_{i=0} {n\choose i} = 2^n \tag{4.2} $$</mathjax></p>
<p>这个等式当然可以用求和来得出。我们可以换个角度来考量它。一个集合的子集中，某些元素要么没有出现，要么就出现了。因此对于每个元素一共有两种选择，因此子集的总数为<mathjax>$2^n$</mathjax>个。</p>
<p>接下来是比较重要的<strong>帕斯卡公式</strong>：<br />
<strong>定理</strong> 对于所有的<mathjax>$ 1 \le k \le n-1$</mathjax>的整数<mathjax>$n$</mathjax>和<mathjax>$k$</mathjax>：<br />
<mathjax>$$ {n\choose k} = {n-1\choose k} + {n-1\choose k-1} \tag{4.3} $$</mathjax></p>
<p><strong>证明</strong> 尝试将右式化为左式即可。<br />
<mathjax>$$
\begin{align}
{n-1\choose k} + {n-1\choose k-1} &amp;= {(n-1)! \over k!(n-k-1)!} + {(n-1)! \over (k-1)!(n-k)!} \\
&amp;= {(n-1)!(n-k) \over k!(n-k)!} + {(n-1)!k \over k!(n-k)!} \\
&amp;= {(n-1)!n \over k!(n-k)!} \\
&amp;= {n! \over k!(n-k)!} \\
&amp;= {n \choose k}
\end{align}
$$</mathjax></p>
<p>这样就完成了证明。注意，在上面的证明中，利用到了阶乘的性质：<mathjax>$(n-1)!\cdot n=n!$</mathjax>。</p>
<p>不难发现，帕斯卡公式实际上是组合数的一个递推公式。<br />
<img alt="pascal-dp" src="http://git.oschina.net/riteme/blogimg/raw/master/permutation-and-combination/dp.svg" /><br />
上图是由帕斯卡公式得到的一个递推的关系图，这里以<mathjax>${4 \choose 3}$</mathjax>为例。其中灰色的节点是无效的值。为了方便，直接将其设为<mathjax>$0$</mathjax>。除了<mathjax>${1 \choose 0} = {1 \choose 1} = 1$</mathjax>为初始值外，其它的值都是由其所指向的节点的值求和而来。<br />
上面的步骤就是动态规划中的状态转移的过程。利用这个公式，我们可以在<mathjax>$\Theta(nr)$</mathjax>的时间来计算大量的组合数。因此可以将此作为一个预处理。<br />
在具体实现的时候只需注意一些无效的特殊情况，其中包括<mathjax>$ r &gt; n $</mathjax>和<mathjax>$n &lt; 0$</mathjax>或<mathjax>$r &lt; 0$</mathjax>。这些情况下的值均设为<mathjax>$0$</mathjax>。然后通过<mathjax>${1 \choose 0}$</mathjax>和<mathjax>${1 \choose 1}$</mathjax>这两个初始值就可以完成递推。</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:permutation">
<p>当然也可记作<mathjax>$_nP_r$</mathjax>或<mathjax>$P^n_r$</mathjax>。&#160;<a class="footnote-backref" href="#fnref:permutation" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:combination">
<p>《组合数学》中称之为&rdquo;子集&rdquo;，也许更为恰当。&#160;<a class="footnote-backref" href="#fnref:combination" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:represent">
<p>下面将使用集合的方式表示组合，如<mathjax>$\{a,b,c\}$</mathjax>。&#160;<a class="footnote-backref" href="#fnref:represent" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:exp">
<p>也可记作<mathjax>$_nC_r$</mathjax>或<mathjax>$C(n,r)$</mathjax>或<mathjax>$C^n_r$</mathjax>。&#160;<a class="footnote-backref" href="#fnref:exp" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>
</body>
</html>
