<!DOCTYPE html> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1.0"> <title>最小树形图 - riteme.site</title> <link rel="shortcut icon" href="/favicon.png" type="image/png"> <link rel=stylesheet  href="/material/material-icons.css"> <link rel=stylesheet  href="/material/material.min.css" > <link rel=stylesheet  href="/gitment/gitment.css"> <link rel=stylesheet  href="/math-renderer/katex/katex.min.css"> <link rel=stylesheet  href="/css/site.css"> <script src="/js/jquery.min.js"></script> <script src="/js/jump.js"></script> <script src="/js/js-cookie.js"></script> <script src="/js/quicklink.umd.js"></script> <script defer src="/material/material.min.js"></script> <script src="/math-renderer/selector.js"></script> <script src="/gitment/gitment.js"></script> <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header"> <header class=mdl-layout__header > <div class=mdl-layout__header-row > <span class=mdl-layout-title >最小树形图</span> <div class=mdl-layout-spacer ></div> <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right"> <label class="mdl-button mdl-js-button mdl-button--icon" for=fixed-header-drawer-exp ><i class=material-icons >search</i></label> <div class=mdl-textfield__expandable-holder > <form action="/search.html"><input type=text  class=mdl-textfield__input  placeholder="Search Here" name=q  id=fixed-header-drawer-exp  autocomplete=off  required></form> </div> </div> </div> </header> <div class=mdl-layout__drawer > <span class="mdl-layout-title drawer-title"> <a href="/index.html" style="color: inherit; font-weight: inherit;text-decoration: none;"><img src="/favicon.png" width=32 height=32> riteme.site</a> </span> <nav class=mdl-navigation > <a class=mdl-navigation__link  href="/index.html"><i class="material-icons drawer-icon">home</i> 首页</a> <a class=mdl-navigation__link  href="/posts.html"><i class="material-icons drawer-icon">library_books</i> 所有文章</a> <a class=mdl-navigation__link  href="/about.html"><i class="material-icons drawer-icon">info</i> 关于</a> <a class=mdl-navigation__link  href="/links.html"><i class="material-icons drawer-icon">link</i> 友链</a> <a class=mdl-navigation__link  href="/search.html"><i class="material-icons drawer-icon">search</i> 搜索</a> <a class=mdl-navigation__link  href="https://github.com/riteme/riteme.github.io"><i class="material-icons drawer-icon">class</i> GitHub 项目</a> </nav> </div> <main class=mdl-layout__content > <div class=mdl-grid > <div class="mdl-cell main-cell"> <div class="article main-article" lang=en-US > <h1 id=_1 >最小树形图</h1> <h2 id=_2 >问题引入</h2> <p>在带权无向图中，<strong>最小生成树</strong>是一个广为人知的问题。对应的，在有向图中，我们也可以定义<strong>有向生成树</strong>（<strong>D</strong>irected <strong>S</strong>panning <strong>T</strong>rees，简称 DST）。在有向图 <tex>$G = (V,\ E)$</tex> 中，我们选定一个生成树的根节点 <tex>$r$</tex>，以 <tex>$r$</tex> 为根的有向生成树是图 <tex>$G$</tex> 的一个子图 <tex>$T$</tex>，并且子图 <tex>$T$</tex> 中 <tex>$r$</tex> 到任意非 <tex>$r$</tex> 节点 <tex>$u$</tex> 的路径<strong>存在且唯一</strong>。根据树的定义，子图 <tex>$T$</tex> 的形状就是一棵以 <tex>$r$</tex> 为根的树，只不过所有的边都是从父亲指向儿子的有向边。所以也称为 “树形图”。</p> <p>需要注意的是，并非图 <tex>$G$</tex> 中任意一个节点都能成为某个 DST 的根。具体而言，必须要满足从 <tex>$r$</tex> 出发能够到达其它的顶点。如果将图 <tex>$G$</tex> 的所有强连通分量缩点，得到一张拓扑图，且拓扑图中只有一个入度为 <tex>$0$</tex> 的点 <tex>$u$</tex>，则 <tex>$r$</tex> 必须来自 <tex>$u$</tex> 所代表的强连通分量中。</p> <p>类比最小生成树，最小树形图就是带权有向图 <tex>$G = (V,\ E,\ w)$</tex> 中边权总和最小的 DST，简称 MDST（<strong>M</strong>inimum DST）。虽然定义类似，但算法却不尽相同。因为<strong>在有向图中，给定 DST 的根 <tex>$r$</tex>，有一些边可能不能成为任何一个 DST 的树边</strong>。例如，在下面的左图中，以绿色节点为根，红色边是无法存在于任何一棵 DST 中的。当然，如果再加入其它边，它还是有机会进入某棵 DST 的，如右图所示。</p> <p><img alt=invalid-edges  src="https://gitee.com/riteme/blogimg/raw/master/mdst/invalid-edges.svg" /></p> <p><center><strong>Fig.1.</strong> 无效边的示意图。蓝色边是树边。</center></p> <p>这导致对于无向图的算法（Kruskal 算法、Prim 算法等等）都无法在有向图上算出最小树形图。</p> <p>1965 年，朱永津和刘振宏 <a href="#references-1">[1]</a> 最先提出了最小树形图时间复杂度为 <tex>$O(VE)$</tex> 的算法。两年后，也就是 1967 年，Edmonds <a href="#references-2">[2]</a> 也独立发现了同样的算法。可能 Edmonds 名气比较大，现在英文资料里面关于这个算法的叫法总少不了 Edmonds 的名字 QAQ</p> <h2 id=_3 >算法流程</h2> <p>首先，DST 有一个特点：除根节点外，其它节点的入度为 <tex>$1$</tex>。此外，DST 是不存在环的。一个非常奇怪的想法就是，对于每个非根节点，选择<strong>入边中边权最小的</strong>。因为这样选择之后，如果图中没有环，不难发现就构成了一棵 DST，并且显然它的边权之和也是最小的，因此直接找到了 MDST。</p> <p>当然现实没有那么美好，很大概率下，这样选择会出现环。现在来考虑其中的一个简单环 <tex>$C$</tex>，这个环上至少有一条边是不能选的。但可能还有更多的边在真正的 MDST 中也不能选？然而事实却非常巧，注意到环 <tex>$C$</tex> 不是一般的环，它是由边权最小的入边组成的环。我们可以证明，存在一棵 MDST，其中环 <tex>$C$</tex> 只有一条边被替换了。</p> <p><img alt=cycle-example  src="https://gitee.com/riteme/blogimg/raw/master/mdst/cycle.svg" /></p> <p><center><strong>Fig.2.</strong> 含有 <tex>$7$</tex> 个点的环 <tex>$C$</tex> 示意图。其中虚线边是不在 MDST 中的边，红色是其在 MDST 中被替换为的边。上图中，从根节点 <tex>$r$</tex> 出发，到达 <tex>$v_2$</tex>，发现 <tex>$v_2 \rightarrow v_3$</tex> 不在树中，之后将进行边的替换。</center></p> <p>考虑任意一棵 MDST，设其树根为 <tex>$r$</tex>，环 <tex>$C$</tex> 上的节点依次为 <tex>$v_1,\ v_2,\ \dots,\ v_n$</tex>。从根节点 <tex>$r$</tex> 开始，在树上向环 <tex>$C$</tex> 行走，至少能走到环 <tex>$C$</tex> 上的一个点，不妨设其为 <tex>$v_1$</tex>，然后检查边 <tex>$v_1 \rightarrow v_2$</tex> 是否在 MDST 中，如果有，就沿着这条边走到 <tex>$v_2$</tex>。如果没有，那么树上就有另外一条边 <tex>$u \rightarrow v_2$</tex>。首先，我们是从根节点一路走过来，所以 <tex>$v_1$</tex> 不会是 <tex>$v_2$</tex> 在树上的儿子，所以将边 <tex>$u \rightarrow v_2$</tex> 更换为 <tex>$v_1 \rightarrow v_2$</tex> 不会导致树上出现环，保证更换后依然是一棵树。其次，<tex>$v_1 \rightarrow v_2$</tex> 是 <tex>$v_2$</tex> 的入边中边权最小者，所以更换后 DST 的边权之和不会变大，故其也是 MDST。之后依次操作直到检查完 <tex>$v_{n - 1} \rightarrow v_n$</tex> 为止，这时我们就保证了环 <tex>$C$</tex> 上 <tex>$n - 1$</tex> 条边都在 MDST 上了。</p> <p>从另一个更直接的角度来看，在 DST 中，原图中任意一个简单环最多包含树上一条返祖边。而我们的更换过程只对返祖边无效，所以这个简单环的其它边都可以换成环上的边 <a href="#references-6">[6]</a>。</p> <p>换句话说，我们可以只用考虑删去环 <tex>$C$</tex> 的一条边的情况。想象一下，相当于环 <tex>$C$</tex> 只有一条入边。这又与 DST 有相似之处。考虑将<strong>环 <tex>$C$</tex> 缩成一个点</strong>，在得到的新图 <tex>$G'$</tex> 中，图 <tex>$G'$</tex> 中的一个 DST 可以对应我们所需要的考虑的一个 DST。这启发着我们进行一次递归的操作：假定原来我们选择了环 <tex>$C$</tex> 中所有的边，但由于 DST 定义的要求，我们需要从中替换掉一条边 <tex>$e_1$</tex>，换成环 <tex>$C$</tex> 外的一条边 <tex>$e_2$</tex>，此时边权之和会多增加 <tex>$w(e_2) - w(e_1)$</tex>。所以，将环 <tex>$C$</tex> 缩为一个点 <tex>$c$</tex> 时，设环 <tex>$C$</tex> 中进入点 <tex>$x$</tex> 的边为 <tex>$\mathrm{in}(x)$</tex>，对图 <tex>$G$</tex> 中的所有边 <tex>$e:\ u \rightarrow v$</tex> 作如下处理：</p> <ol> <li>如果 <tex>$u,\ v \notin C$</tex>，即环外一条边，该边保持不变。 <li>如果 <tex>$u,\ v \in C$</tex>，即内接在环上的一条边，将这条边删去。 <li>如果 <tex>$u \in C$</tex> 而 <tex>$v \notin C$</tex>，相当于从环 <tex>$C$</tex> 出发的边，则将 <tex>$u$</tex> 改为 <tex>$c$</tex>。 <li>否则就是进入环 <tex>$C$</tex> 的边，此时将 <tex>$v$</tex> 改为 <tex>$c$</tex>，且边权变为 <tex>$w(e) - w(\mathrm{in}(v))$</tex>。 </ol> <p>在得到的新图 <tex>$G'$</tex> 中计算 MDST，得到 <tex>$T'$</tex>，根据 <tex>$T'$</tex> 进入 <tex>$c$</tex> 的边的 “前身” 就可以知道环 <tex>$C$</tex> 中应该抛弃哪一条边了。将原图 <tex>$G$</tex> 中的自环删去后，每次这样的操作至少可以减少一个点，所以总的时间复杂度为 <tex>$O(VE)$</tex>。</p> <h2 id=_4 >快速实现</h2> <p>我们知道，无向图中最小生成树的时间复杂度取决与排序的复杂度，即 <tex>$O(E \log E)$</tex> 或比这更好的 <tex>$O(E + V \log V)$</tex>。相比之下，之前的算法实在是太慢了。于是伟大的 Tarjan 老爷子 <a href="#references-3">[3]</a> 就出现了。Tarjan 在 1977 年提出了一个时间复杂度为 <tex>$O(E \log V)$</tex> 的实现，他将上述算进行了调整，使用一个迭代式的过程完成了算法。首先，为了方便，我们假定带权有向图 <tex>$G$</tex> 是强连通的。即使没有强连通，可以添加 <tex>$V$</tex> 条边将每个点顺次连成一个环，并且每条边的边权足够大，使得它们不会出现在 MDST 中，这样就可以保证强连通。</p> <p>算法开始时，选取图中任意一个点 <tex>$x$</tex>，然后选取 <tex>$x$</tex> 的入边中边权最小的边 <tex>$e:\ u \rightarrow x$</tex>，如果 之前没有访问过 <tex>$u$</tex>，则将 <tex>$u$</tex> 追加到 <tex>$x$</tex> 后面，构成一条链，然后继续从 <tex>$u$</tex> 开始执行同样的步骤。如果 <tex>$u$</tex> 已经被访问过，说明在链中形成了一个环，此时则执行缩环操作。最后，由于强连通的特性，整张图会被缩成一个点。在此期间，我们可以存下缩环的操作结果，这用一棵树来表示：</p> <p><img alt=tree-example  src="https://gitee.com/riteme/blogimg/raw/master/mdst/tree.svg" /></p> <p><center><strong>Fig.3.</strong> 左边是一个 <tex>$4$</tex> 个点的强连通图，右边是算法完成后所给出的树结构。首先将环 <tex>$1 \rightarrow 2 \rightarrow 3 \rightarrow 1$</tex> 缩为了点 <tex>$5$</tex>，然后将环 <tex>$5 \rightarrow 4 \rightarrow 5$</tex> 缩为了点 <tex>$6$</tex>。这棵树展示了环与环之间嵌套的关系。</center></p> <p>得到这棵树之后，我们就可以从任意合法的根节点开始展开整个 MDST 了。上述过程中缩点一般采用并查集数据结构，而为了能够既完成缩点，又能随时从某个点中抽出边权最小的入边，这里则需要可并堆来高效实现。上面说的比较粗糙，因为讲起来就太细节化了。我实现了朴素的 <tex>$O(VE)$</tex> 算法和 Tarjan 的快速算法，用 <a href="http://poj.org/problem?id=3164">POJ 3164</a> 测试了下，如果细节上有问题的可以参考一下：</p> <p><a href="https://github.com/riteme/test/blob/master/oi/Code/poj/P3164/nm.cpp"><tex>$O(VE)$</tex> 版本</a>、<a href="https://github.com/riteme/test/blob/master/oi/Code/poj/P3164/main.cpp"><tex>$O(E \log V)$</tex> 版本</a></p> <p>另外，我是看的 Uri Zwick 教授 <a href="#references-4">[4]</a> 的讲稿写的算法，里面的实现部分写的比较详细。</p> <h2 id=_5 >相关问题</h2> <p>上面的讨论中，MDST 的树根都是给定了的。而在有些问题中，可能没有给定树根（更类似于无向图的最小生成树了）。解决这类问题并不需要进行 <tex>$O(V)$</tex> 次展开。我们可以给图新增一个点 <tex>$x$</tex>，向原图中每一个点连一条边权足够大的边，这样以 <tex>$x$</tex> 为根的 MDST 中，算法只会选择一条 <tex>$x$</tex> 的出边，毕竟选择这样的边非常不划算。而此时 <tex>$x$</tex> 的出边所指向的点就是原问题中 MDST 的树根。</p> <h2 id=_6 >参考资料</h2> <p><span id=references-1 >[1]. Chu, Y. J.; Liu, T. H. (1965), <em>On the Shortest Arborescence of a Directed Graph</em>, Science Sinica, 14: 1396–1400</span><br /> <span id=references-2 >[2]. Edmonds, J. (1967), <em>Optimum Branchings</em>, J. Res. Nat. Bur. Standards, 71B: 233–240, <a href="https://en.wikipedia.org/wiki/Digital_object_identifier">doi</a>:<a href="https://doi.org/10.6028%2Fjres.071b.032">10.6028/jres.071b.032</a></span><br /> <span id=references-3 >[3]. R.E. Tarjan. (1977), <em>Finding optimum branchings</em>, Networks, 7:25–35<span><br /> <span id=references-4 >[4]. Uri Zwick. (2013), <a href="http://www.cs.tau.ac.il/~zwick/grad-algo-13/directed-mst.pdf"><em>Directed Minimum Spanning Trees</em></a>, Lecture notes on “Analysis of Algorithms”</span><br /> [5]. H.N. Gabow, Z. Galil, T.H. Spencer, and R.E. Tarjan. (1986), <em>Efficient algorithms for finding minimum spanning trees in undirected and directed graphs</em>, Combinatorica, 6:109–122<br /> <span id=references-6 >[6]. CMXRYNP, <a href="https://cmxrynp.github.io/2019/01/03/%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE-%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E7%90%86%E8%A7%A3%E5%8F%8A%E8%AF%81%E6%98%8E">最小树形图 朱刘算法学习笔记</a></p> <hr/> <div id=comments ></div> <script> window.addEventListener('load', () => { quicklink(); }); const gitment = new Gitment({id: '9b89e7d9152ef5a29a77b21978c539e0', owner: 'riteme', repo: 'riteme.github.io', oauth: { client_id: 'd4fcffa25858a7a58e1a', client_secret: 'e0c8e08beb95497871f8355416c69390634cec76' }, perPage: 10, }); gitment.render('comments'); </script> </div> </div> <div class="mdl-cell sidebar"> <div class=article > <div class="mdl-card mdl-shadow--3dp sidebar-card"> <div class="mdl-card__actions sidebar-title">页面信息</div> <div class=mdl-card__supporting-text > 标签: <a href="/search.html?q=图论"><span class=label >图论</span></a> <a href="/search.html?q=数据结构"><span class=label >数据结构</span></a> <a href="/search.html?q=并查集"><span class=label >并查集</span></a> <a href="/search.html?q=可并堆"><span class=label >可并堆</span></a> <a href="/search.html?q=最小树形图"><span class=label >最小树形图</span></a><br/> 创建时间: 2018.06.18<br/> 上次修改: 2019.01.05<br/> 字数统计: 4450 字 / 约 17 分钟 </div> </div> <br/> <div class="mdl-card mdl-shadow--3dp sidebar-card"> <div class="mdl-card__actions sidebar-title">目录</div> <div class=mdl-card__supporting-text > <div class=toc > <ul> <li><a href="#_1">最小树形图</a><ul> <li><a href="#_2">问题引入</a> <li><a href="#_3">算法流程</a> <li><a href="#_4">快速实现</a> <li><a href="#_5">相关问题</a> <li><a href="#_6">参考资料</a> </ul> </ul> </div> </div> </div> <br/> <div class="mdl-card mdl-shadow--3dp sidebar-card"> <div class="mdl-card__actions sidebar-title">数学公式渲染</div> <div class=mdl-card__supporting-text > <form name=mathopt > <label class="mdl-radio mdl-js-radio mdl-js-ripple-effect" for=option-1 > <input type=radio  id=option-1  class=mdl-radio__button  name=sel  value=mathjax > <span class=mdl-radio__label >MathJax (推荐)</span> </label><br/> <div id=tip-1 > <label class="mdl-radio mdl-js-radio mdl-js-ripple-effect" for=option-2 > <input type=radio  id=option-2  class=mdl-radio__button  name=sel  value=katex > <span class=mdl-radio__label >KaTeX</span> </label> </div> <div id=tip-2 > <label class="mdl-radio mdl-js-radio mdl-js-ripple-effect" for=option-3 > <input type=radio  id=option-3  class=mdl-radio__button  name=sel  value="katex&mathjax"> <span class=mdl-radio__label >Mixed</span> </label> </div> </form> </div> </div> <div class=mdl-tooltip  data-mdl-for=tip-1 >KaTeX 渲染效率很高，但是目前 KaTeX 容错性不强，因此使用 KaTeX 时可能会存在一些数学公式无法渲染的情况</div> <div class=mdl-tooltip  data-mdl-for=tip-2 >先使用 KaTeX 渲染，再使用 MathJax 渲染</div> <br/> <div class="nano mdl-card mdl-shadow--3dp sidebar-card"> <a class=nano-ref  target=_new  href="http://nichijou.wikia.com/wiki/Nano_Shinonome"></a> <div class=mdl-card__actions > <div class=nano-shell ><span class=shell-start >$</span> nano <a href="https://github.com/riteme/riteme.github.io/blob/master/blog/2018-6-18/mdst.md" id=nano-link >mdst.md</a></div> </div> </div> <div class=mdl-tooltip  data-mdl-for=nano-link >查看原始 Markdown 文档</div> </div> </div> </div> <footer class=mdl-mega-footer > <div class=mdl-mega-footer__middle-section > <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h1 class=mdl-mega-footer__heading >RITEME.SITE</h1><del>一个从不乱说话的博客</del> </div> <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h1 class=mdl-mega-footer__heading >POWERED BY</h1> <ul class=mdl-mega-footer__link-list > <li><a href="http://pythonhosted.org/Markdown/">Python Markdown</a> <li><a href="http://getmdl.io/">Material Design Lite</a> <li><a href="http://www.tipue.com/search/">Tipuesearch</a> <li><a href="http://www.mathjax.org/">MathJax</a> & <a href="http://khan.github.io/KaTeX/">KaTeX</a> <li><a href="https://github.com/imsun/gitment">Gitment</a> </ul> </div> <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h1 class=mdl-mega-footer__heading >友情链接</h1> <ul class=mdl-mega-footer__link-list > <li><a href="http://ruanx.pw/">ruanxingzhi</a> <li><a href="https://blog.xehoth.cc/">xehoth</a> <li><a href="http://hjwjbsr.is-programmer.com/">HJWJBSR</a> <li><a href="http://www.micdz.cn/">MicDZ</a> <li><a href="https://cmxrynp.github.io/">CMXRYNP</a> <li><a href="http://memset0.cn/">memset0</a> </ul> </div> </div> <div class=mdl-mega-footer__bottom-section >Theme based on <a href="https://getmdl.io/">MDL</a> | Copyright © 2015-2019 riteme. All rights reserved.</div> </footer> </main> </div>