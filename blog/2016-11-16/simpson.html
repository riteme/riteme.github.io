<!DOCTYPE html> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1.0"> <meta name=referrer  content=no-referrer  /> <title>辛普森积分法 - riteme.site</title> <link rel="shortcut icon" href="/favicon.png" type="image/png"> <link rel=stylesheet  href="/styles/material-icons.css"> <link rel=stylesheet  href="/styles/material.min.css" > <link rel=stylesheet  href="/styles/gitment.css"> <link rel=stylesheet  href="/math-renderer/katex/katex.min.css"> <link rel=stylesheet  href="/styles/site.css"> <script src="/scripts/jquery.min.js"></script> <script src="/scripts/js-cookie.js"></script> <script src="/scripts/quicklink.umd.js"></script> <script defer src="/scripts/material.min.js"></script> <script src="/scripts/site.js"></script> <script src="/scripts/gitment.js"></script> <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header"> <header class=mdl-layout__header > <div class=mdl-layout__header-row > <span class=mdl-layout-title >辛普森积分法</span> <div class=mdl-layout-spacer ></div> <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right"> <label class="mdl-button mdl-js-button mdl-button--icon" for=fixed-header-drawer-exp ><i class=material-icons >search</i></label> <div class=mdl-textfield__expandable-holder > <form action="/search.html"><input type=text  class=mdl-textfield__input  placeholder="Search Here" name=q  id=fixed-header-drawer-exp  autocomplete=off  required></form> </div> </div> </div> </header> <div class=mdl-layout__drawer > <span class="mdl-layout-title drawer-title"> <a href="/index.html" style="color: inherit; font-weight: inherit;text-decoration: none;"><img src="/favicon.png" width=32 height=32> riteme.site</a> </span> <nav class=mdl-navigation > <a class=mdl-navigation__link  href="/index.html"><i class="material-icons drawer-icon">home</i> 首页</a> <a class=mdl-navigation__link  href="/posts.html"><i class="material-icons drawer-icon">library_books</i> 所有文章</a> <a class=mdl-navigation__link  href="/about.html"><i class="material-icons drawer-icon">info</i> 关于</a> <a class=mdl-navigation__link  href="/links.html"><i class="material-icons drawer-icon">link</i> 友链</a> <a class=mdl-navigation__link  href="/search.html"><i class="material-icons drawer-icon">search</i> 搜索</a> <a class=mdl-navigation__link  href="https://github.com/riteme/riteme.github.io"><i class="material-icons drawer-icon">class</i> GitHub 项目</a> </nav> </div> <main class=mdl-layout__content > <div class=mdl-grid > <div class="mdl-cell main-cell"> <div class="article main-article" lang=en-US > <h1 id=_1 >辛普森积分法</h1> <p>辛普森积分法是一种快速求函数定积分的方法。与普通的直线拟合方法相比，辛普森积分法采用的是二次函数来拟合函数，而效果十分显著。</p> <h2 id=_2 >用抛物线拟合</h2> <p>假设我们有三个不重合的点，那么可以唯一确定一个抛物线经过这三个点。如下图所示：</p> <p><img alt=quadratic  src="https://riteme.site/blogimg/simpson/simpson1.svg" /></p> <p>辛普森积分法就是在积分区间<tex>$[a,\;b]$</tex>上去三个点<tex>$a$</tex>、<tex>$b$</tex>和<tex>$m = (a + b) / 2$</tex>，计算其原函数的在此处的值，然后用抛物线来拟合原函数，即使用该二次函数的积分值代替原函数的积分值，达到近似积分的效果。</p> <p>如何计算这个二次函数？我们自然可以解三元三次方程组，但更方便的方法是拉格朗日差值公式：<br /> <tex>$$ g(x) = {(x - m)(x - b) \over (a - m)(a - b)}f(a) + {(x - a)(a - b) \over (m - a)(m - b)}f(m) + {(x - a)(x - m) \over (b - a)(b - m)}f(b) $$</tex></p> <p>其中<tex>$f(x)$</tex>是原函数，<tex>$g(x)$</tex>是拟合后的函数。下文中<tex>$f$</tex>和<tex>$g$</tex>也表示同样的意义，不再复述。</p> <h2 id=_3 >二次函数的积分</h2> <p>有了二次函数后，计算其积分是十分简单的事，但是这一切还不够完美。下面我们将推导出一个更简单的公式。</p> <p>设：<br /> <tex>$$ g(x) = Ax^2 + Bx + C \\ m = \frac{(a + b)}2 \\ f(a) = g(a), \; f(m) = g(m), \; f(b) = g(b) $$</tex></p> <p>那么：<br /> <tex>$$ \int_a^b f(x) \;\mathrm{d}x \approx \int_a^b (Ax^2 + Bx + C)\;\mathrm{d}x $$</tex></p> <p>所以：<br /> <tex>$$ \int_a^b (Ax^2 + Bx + C)\;\mathrm{d}x = \frac{A}3(b^3-a^3) + \frac{B}2(b^2-a^2) + C(b-a) $$</tex></p> <p>因为：<br /> <tex>$$ b^3 - a^3 = (b^2 + ab + a^2)(b-a)\\ b^2 - a^2 = (b+a)(b-a) $$</tex></p> <p>所以之前的式子可变为：<br /> <tex>$$ {b-a \over 6}[2A(b^2 + ab + a^2) + 3B(b+a) + 6C] $$</tex></p> <p>调整可得：<br /> <tex>$$ {b-a \over 6}\left[(Aa^2 + Ba + C) + (Ab^2 + Bb + C) + 4A\left({b+a \over 2}\right)^2 + 4B\left({b+a \over 2}\right) + 4C\right] $$</tex></p> <p>于是就是：<br /> <tex>$$ \int_a^b f(x) \;\mathrm{d}x = {b - a \over 6}(f(a) + 4f(m) + f(b)) $$</tex></p> <p>这就是辛普森法则。</p> <h2 id=_4 >辛普森积分</h2> <p>下面将用Python简单实现一下辛普森积分，首先我们需要一个计算积分的函数：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal >1</span>
<span class=normal >2</span>
<span class=normal >3</span>
<span class=normal >4</span>
<span class=normal >5</span>
<span class=normal >6</span>
<span class=normal >7</span>
<span class=normal >8</span></pre></div><td class=code ><div class=codehilite ><pre><span></span><span class=k >def</span> <span class=nf >sample</span><span class=p >(</span><span class=n >f</span><span class=p >,</span> <span class=n >a</span><span class=p >,</span> <span class=n >b</span><span class=p >):</span>
    <span class=sd >&quot;&quot;&quot;用二次函数近似计算函数f的积分</span>
<span class=sd >    f: 函数</span>
<span class=sd >    a: 积分下界</span>
<span class=sd >    b: 积分上界</span>
<span class=sd >    &quot;&quot;&quot;</span>

    <span class=k >return</span> <span class=p >(</span><span class=n >b</span> <span class=o >-</span> <span class=n >a</span><span class=p >)</span> <span class=o >*</span> <span class=p >(</span><span class=n >f</span><span class=p >(</span><span class=n >a</span><span class=p >)</span> <span class=o >+</span> <span class=mf >4.0</span> <span class=o >*</span> <span class=n >f</span><span class=p >((</span><span class=n >a</span> <span class=o >+</span> <span class=n >b</span><span class=p >)</span> <span class=o >*</span> <span class=mf >0.5</span><span class=p >)</span> <span class=o >+</span> <span class=n >f</span><span class=p >(</span><span class=n >b</span><span class=p >))</span> <span class=o >*</span> <span class=mf >0.5</span>
</pre></div> </table> <p>然后就是对<code>f</code>分成<code>n</code>段，每一段使用二次函数近似计算：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal > 1</span>
<span class=normal > 2</span>
<span class=normal > 3</span>
<span class=normal > 4</span>
<span class=normal > 5</span>
<span class=normal > 6</span>
<span class=normal > 7</span>
<span class=normal > 8</span>
<span class=normal > 9</span>
<span class=normal >10</span>
<span class=normal >11</span>
<span class=normal >12</span>
<span class=normal >13</span>
<span class=normal >14</span>
<span class=normal >15</span>
<span class=normal >16</span>
<span class=normal >17</span></pre></div><td class=code ><div class=codehilite ><pre><span></span><span class=k >def</span> <span class=nf >simpson</span><span class=p >(</span><span class=n >f</span><span class=p >,</span> <span class=n >a</span><span class=p >,</span> <span class=n >b</span><span class=p >,</span> <span class=n >n</span> <span class=o >=</span> <span class=mi >1000</span><span class=p >):</span>
    <span class=sd >&quot;&quot;&quot;计算定积分</span>
<span class=sd >    f: 原函数</span>
<span class=sd >    a: 积分下界</span>
<span class=sd >    b: 积分上界</span>
<span class=sd >    n: 划分的区间数</span>
<span class=sd >    &quot;&quot;&quot;</span>

    <span class=n >delta</span> <span class=o >=</span> <span class=p >(</span><span class=n >b</span> <span class=o >-</span> <span class=n >a</span><span class=p >)</span> <span class=o >/</span> <span class=n >n</span>
    <span class=n >result</span> <span class=o >=</span> <span class=mi >0</span>

    <span class=k >for</span> <span class=n >i</span> <span class=ow >in</span> <span class=nb >range</span><span class=p >(</span><span class=mi >0</span><span class=p >,</span> <span class=n >n</span><span class=p >):</span>
        <span class=n >left</span> <span class=o >=</span> <span class=n >a</span> <span class=o >+</span> <span class=n >i</span> <span class=o >*</span> <span class=n >delta</span>
        <span class=n >right</span> <span class=o >=</span> <span class=n >left</span> <span class=o >+</span> <span class=n >delta</span>
        <span class=n >result</span> <span class=o >+=</span> <span class=n >sample</span><span class=p >(</span><span class=n >f</span><span class=p >,</span> <span class=n >left</span><span class=p >,</span> <span class=n >right</span><span class=p >)</span>

    <span class=k >return</span> <span class=n >result</span>
</pre></div> </table> <p>用它来试着算一下圆周率：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal >1</span>
<span class=normal >2</span></pre></div><td class=code ><div class=codehilite ><pre><span></span><span class=n >In</span> <span class=p >[</span><span class=mi >1</span><span class=p >]:</span> <span class=n >simpson</span><span class=p >(</span><span class=k >lambda</span> <span class=n >x</span> <span class=p >:</span> <span class=mf >2.0</span> <span class=o >*</span> <span class=n >sqrt</span><span class=p >(</span><span class=mi >1</span> <span class=o >-</span> <span class=n >x</span><span class=o >**</span><span class=mi >2</span><span class=p >),</span> <span class=o >-</span><span class=mi >1</span><span class=p >,</span> <span class=mi >1</span><span class=p >,</span> <span class=mi >100000</span><span class=p >)</span>
<span class=n >Out</span><span class=p >[</span><span class=mi >1</span><span class=p >]:</span> <span class=mf >3.1415926390691236</span>
</pre></div> </table> <p>可以发现分为<tex>$100000$</tex>个区间就获得了<tex>$7$</tex>位的精度。事实上，如果你将<code>sample</code>换为直线的拟合，你将只能得到<tex>$6$</tex>位的精度。</p> <h2 id=_5 >自适应辛普森积分</h2> <p>然而控制区间个数不是一个控制答案精度的好办法，通常我们将使用特定的<tex>$\varepsilon$</tex>来控制精度误差。</p> <p>如何让算法知道应当继续细分来达到特定精度呢？通常的方法就是将当前区间分为两半，用这两半的拟合值与当前计算的值做差。如果小于<tex>$\varepsilon$</tex>，那么我们就认为精度达到了要求。否则我们就递归下去，计算两个子区间的积分。注意，此时<tex>$\varepsilon$</tex>也应当缩小，从而避免累积的误差超过了<tex>$\varepsilon$</tex>。</p> <p>这样我们就将得到一个递归算法，具体实现如下：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal > 1</span>
<span class=normal > 2</span>
<span class=normal > 3</span>
<span class=normal > 4</span>
<span class=normal > 5</span>
<span class=normal > 6</span>
<span class=normal > 7</span>
<span class=normal > 8</span>
<span class=normal > 9</span>
<span class=normal >10</span>
<span class=normal >11</span>
<span class=normal >12</span>
<span class=normal >13</span>
<span class=normal >14</span>
<span class=normal >15</span>
<span class=normal >16</span>
<span class=normal >17</span>
<span class=normal >18</span>
<span class=normal >19</span>
<span class=normal >20</span>
<span class=normal >21</span>
<span class=normal >22</span>
<span class=normal >23</span>
<span class=normal >24</span>
<span class=normal >25</span>
<span class=normal >26</span>
<span class=normal >27</span>
<span class=normal >28</span></pre></div><td class=code ><div class=codehilite ><pre><span></span><span class=k >def</span> <span class=nf >_adaptive_simpson</span><span class=p >(</span><span class=n >f</span><span class=p >,</span> <span class=n >a</span><span class=p >,</span> <span class=n >b</span><span class=p >,</span> <span class=n >eps</span><span class=p >,</span> <span class=n >current</span><span class=p >):</span>
    <span class=sd >&quot;&quot;&quot;递归过程</span>
<span class=sd >    f: 原函数</span>
<span class=sd >    a: 积分下界</span>
<span class=sd >    b: 积分上界</span>
<span class=sd >    eps: 精度</span>
<span class=sd >    current: [a, b]的定积分近似值，用于减少计算量</span>
<span class=sd >    &quot;&quot;&quot;</span>

    <span class=n >mid</span> <span class=o >=</span> <span class=p >(</span><span class=n >a</span> <span class=o >+</span> <span class=n >b</span><span class=p >)</span> <span class=o >*</span> <span class=mf >0.5</span>
    <span class=n >leftans</span> <span class=o >=</span> <span class=n >sample</span><span class=p >(</span><span class=n >f</span><span class=p >,</span> <span class=n >a</span><span class=p >,</span> <span class=n >mid</span><span class=p >)</span>
    <span class=n >rightans</span> <span class=o >=</span> <span class=n >sample</span><span class=p >(</span><span class=n >f</span><span class=p >,</span> <span class=n >mid</span><span class=p >,</span> <span class=n >b</span><span class=p >)</span>

    <span class=k >if</span> <span class=nb >abs</span><span class=p >(</span><span class=n >leftans</span> <span class=o >+</span> <span class=n >rightans</span> <span class=o >-</span> <span class=n >current</span><span class=p >)</span> <span class=o >&lt;</span> <span class=n >eps</span><span class=p >:</span>  <span class=c1 ># 如果达到要求</span>
        <span class=k >return</span> <span class=n >current</span>
    <span class=k >else</span><span class=p >:</span>  <span class=c1 ># 否则将递归下去计算</span>
        <span class=k >return</span> <span class=p >(</span><span class=n >_adaptive_simpson</span><span class=p >(</span><span class=n >f</span><span class=p >,</span> <span class=n >a</span><span class=p >,</span> <span class=n >mid</span><span class=p >,</span> <span class=n >eps</span> <span class=o >*</span> <span class=mf >0.5</span><span class=p >,</span> <span class=n >leftans</span><span class=p >)</span> <span class=o >+</span>
                <span class=n >_adaptive_simpson</span><span class=p >(</span><span class=n >f</span><span class=p >,</span> <span class=n >mid</span><span class=p >,</span> <span class=n >b</span><span class=p >,</span> <span class=n >eps</span> <span class=o >*</span> <span class=mf >0.5</span><span class=p >,</span> <span class=n >rightans</span><span class=p >))</span>

<span class=k >def</span> <span class=nf >adaptive_simpson</span><span class=p >(</span><span class=n >f</span><span class=p >,</span> <span class=n >a</span><span class=p >,</span> <span class=n >b</span><span class=p >,</span> <span class=n >eps</span><span class=p >):</span>
    <span class=sd >&quot;&quot;&quot;自适应辛普森积分</span>
<span class=sd >    f: 原函数</span>
<span class=sd >    a: 积分下界</span>
<span class=sd >    b: 积分上界</span>
<span class=sd >    eps: 精度</span>
<span class=sd >    &quot;&quot;&quot;</span>

    <span class=k >return</span> <span class=n >_adaptive_simpson</span><span class=p >(</span><span class=n >f</span><span class=p >,</span> <span class=n >a</span><span class=p >,</span> <span class=n >b</span><span class=p >,</span> <span class=n >eps</span><span class=p >,</span> <span class=n >sample</span><span class=p >(</span><span class=n >f</span><span class=p >,</span> <span class=n >a</span><span class=p >,</span> <span class=n >b</span><span class=p >))</span>
</pre></div> </table> <p>我将其与线性拟合的算法对比了一下速度。他们共用一个递归的框架，只是<code>sample</code>函数有二次函数拟合和直线拟合两种：</p> <p>直线拟合：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal >1</span>
<span class=normal >2</span>
<span class=normal >3</span>
<span class=normal >4</span></pre></div><td class=code ><div class=codehilite ><pre><span></span><span class=n >In</span> <span class=p >[</span><span class=mi >1</span><span class=p >]:</span> <span class=o >%</span><span class=n >time</span> <span class=n >adaptive_simpson</span><span class=p >(</span><span class=n >sin</span><span class=p >,</span> <span class=mi >0</span><span class=p >,</span> <span class=mi >1000</span><span class=p >,</span> <span class=mf >0.00001</span><span class=p >)</span>
<span class=n >CPU</span> <span class=n >times</span><span class=p >:</span> <span class=n >user</span> <span class=mf >5.58</span> <span class=n >s</span><span class=p >,</span> <span class=n >sys</span><span class=p >:</span> <span class=mi >0</span> <span class=n >ns</span><span class=p >,</span> <span class=n >total</span><span class=p >:</span> <span class=mf >5.58</span> <span class=n >s</span>
<span class=n >Wall</span> <span class=n >time</span><span class=p >:</span> <span class=mf >5.58</span> <span class=n >s</span>
<span class=n >Out</span><span class=p >[</span><span class=mi >1</span><span class=p >]:</span> <span class=mf >0.4376209161316862</span>
</pre></div> </table> <p>二次函数拟合：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal >1</span>
<span class=normal >2</span>
<span class=normal >3</span>
<span class=normal >4</span></pre></div><td class=code ><div class=codehilite ><pre><span></span><span class=n >In</span> <span class=p >[</span><span class=mi >26</span><span class=p >]:</span> <span class=o >%</span><span class=n >time</span> <span class=n >adaptive_simpson</span><span class=p >(</span><span class=n >sin</span><span class=p >,</span> <span class=mi >0</span><span class=p >,</span> <span class=mi >1000</span><span class=p >,</span> <span class=mf >0.00001</span><span class=p >)</span>
<span class=n >CPU</span> <span class=n >times</span><span class=p >:</span> <span class=n >user</span> <span class=mi >60</span> <span class=n >ms</span><span class=p >,</span> <span class=n >sys</span><span class=p >:</span> <span class=mi >0</span> <span class=n >ns</span><span class=p >,</span> <span class=n >total</span><span class=p >:</span> <span class=mi >60</span> <span class=n >ms</span>
<span class=n >Wall</span> <span class=n >time</span><span class=p >:</span> <span class=mf >59.6</span> <span class=n >ms</span>
<span class=n >Out</span><span class=p >[</span><span class=mi >26</span><span class=p >]:</span> <span class=mf >0.43762092534838204</span>
</pre></div> </table> <p>可见辛普森积分法是相当迅速的。</p> <h2 id=_6 >异常情况</h2> <p>由于是使用二次函数拟合，所以辛普森积分法对光滑的函数效果较好。但下面几种情况需要谨慎考虑：</p> <ul> <li>上下震荡十分剧烈的函数（如<tex>$y = \sin(1/x)$</tex>）不适用，事实上这种函数一般都不好积。 <li>突变的函数（如<tex>$y = |x|$</tex>，在<tex>$x = 0$</tex>处无导数）不适用。 </ul> <p>对于存在没有导数的点的函数，通常的解决方法就是从这些点分开，然后就可以分段计算了。</p> <hr/> <div id=comments ></div> <script> window.addEventListener('load', () => { quicklink(); }); const gitment = new Gitment({id: '3dbd975db9b085f029020584fa00eed3', owner: 'riteme', repo: 'riteme.github.io', oauth: { client_id: 'd4fcffa25858a7a58e1a', client_secret: 'e0c8e08beb95497871f8355416c69390634cec76' }, perPage: 10, }); gitment.render('comments'); </script> </div> </div> <div class="mdl-cell sidebar"> <div class=article > <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">页面信息</div> <div class=mdl-card__supporting-text > 标签: <a href="/search.html?q=辛普森积分法"><span class=label >辛普森积分法</span></a><br/> 创建时间: 2016.11.16<br/> 上次修改: 2016.11.16<br/> 字数统计: 3757 字 / 约 15 分钟 </div> </div> <br/> <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">目录</div> <div class=mdl-card__supporting-text > <div class=toc > <ul> <li><a href="#_1">辛普森积分法</a><ul> <li><a href="#_2">用抛物线拟合</a> <li><a href="#_3">二次函数的积分</a> <li><a href="#_4">辛普森积分</a> <li><a href="#_5">自适应辛普森积分</a> <li><a href="#_6">异常情况</a> </ul> </ul> <ul><li><a href="#comments">评论区</a></ul></div> </div> </div> <br/> <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">数学公式渲染</div> <div class=mdl-card__supporting-text > <form name=mathopt > <label class="mdl-radio mdl-js-radio" for=option-1 > <input type=radio  id=option-1  class=mdl-radio__button  name=sel  value=mathjax > <span class=mdl-radio__label >MathJax</span> </label><br/> <label class="mdl-radio mdl-js-radio" for=option-2 > <input type=radio  id=option-2  class=mdl-radio__button  name=sel  value=katex > <span class=mdl-radio__label >KaTeX</span> </label> <div id=tip-1 > <label class="mdl-radio mdl-js-radio" for=option-3 > <input type=radio  id=option-3  class=mdl-radio__button  name=sel  value="katex&mathjax"> <span class=mdl-radio__label >Mixed</span> </label> </div> </form> <div id=tip-2 > <label class="mdl-checkbox mdl-js-checkbox" for=mathopt-align > <input type=checkbox  id=mathopt-align  class=mdl-checkbox__input > <span class=mdl-checkbox__label >居中显示</span> </label> </div> </div> </div> <div class=mdl-tooltip  data-mdl-for=tip-1 >先使用 KaTeX 渲染，再使用 MathJax 渲染</div> <div class=mdl-tooltip  data-mdl-for=tip-2 >该选项目前仅支持 KaTeX 渲染的公式<br/>点击公式可以切换单个公式的对齐方式</div> <br/> <div class="nano mdl-card mdl-shadow--2dp sidebar-card"> <div class=mdl-card__actions > <div class=nano-shell ><span class=shell-start >$</span> nano <a href="https://github.com/riteme/riteme.github.io/blob/master/blog/2016-11-16/simpson.md" id=nano-link >simpson.md</a></div> </div> </div> <div class=mdl-tooltip  data-mdl-for=nano-link >查看原始 Markdown 文档</div> </div> </div> </div> <footer class=mdl-mega-footer > <div class=mdl-mega-footer__middle-section > <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >RITEME.SITE</h2><del>一个从不乱说话的博客</del> </div> <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >POWERED BY</h2> <ul class=mdl-mega-footer__link-list > <li><a href="http://pythonhosted.org/Markdown/">Python Markdown</a> <li><a href="http://getmdl.io/">Material Design Lite</a> <li><a href="http://www.tipue.com/search/">Tipuesearch</a> <li><a href="http://www.mathjax.org/">MathJax</a> & <a href="http://khan.github.io/KaTeX/">KaTeX</a> <li><a href="https://github.com/imsun/gitment">Gitment</a> </ul> </div> <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >友情链接</h2> <ul class=mdl-mega-footer__link-list > <li><a href="http://ruanx.pw/">ruanxingzhi</a> <li><a href="https://blog.xehoth.cc/">xehoth</a> <li><a href="http://hjwjbsr.is-programmer.com/">HJWJBSR</a> <li><a href="http://www.micdz.cn/">MicDZ</a> <li><a href="https://cmxrynp.github.io/">CMXRYNP</a> <li><a href="http://memset0.cn/">memset0</a> </ul> </div> </div> <div class=mdl-mega-footer__bottom-section >Theme based on <a href="https://getmdl.io/">MDL</a> | <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" class=cc  src="/assets/cc-by-nc-sa-4.png" /></a> CC BY-NC-SA 4.0 </div> </footer> </main> </div>
