<!DOCTYPE html> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1.0"> <title>诱导排序与SA-IS算法 - riteme.site</title> <link rel="shortcut icon" href="/favicon.png" type="image/png"> <link rel=stylesheet  href="/styles/material-icons.css"> <link rel=stylesheet  href="/styles/material.min.css" > <link rel=stylesheet  href="/styles/gitment.css"> <link rel=stylesheet  href="/math-renderer/katex/katex.min.css"> <link rel=stylesheet  href="/styles/site.css"> <script src="/scripts/jquery.min.js"></script> <script src="/scripts/js-cookie.js"></script> <script src="/scripts/quicklink.umd.js"></script> <script defer src="/scripts/material.min.js"></script> <script src="/scripts/site.js"></script> <script src="/scripts/gitment.js"></script> <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header"> <header class=mdl-layout__header > <div class=mdl-layout__header-row > <span class=mdl-layout-title >诱导排序与SA-IS算法</span> <div class=mdl-layout-spacer ></div> <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right"> <label class="mdl-button mdl-js-button mdl-button--icon" for=fixed-header-drawer-exp ><i class=material-icons >search</i></label> <div class=mdl-textfield__expandable-holder > <form action="/search.html"><input type=text  class=mdl-textfield__input  placeholder="Search Here" name=q  id=fixed-header-drawer-exp  autocomplete=off  required></form> </div> </div> </div> </header> <div class=mdl-layout__drawer > <span class="mdl-layout-title drawer-title"> <a href="/index.html" style="color: inherit; font-weight: inherit;text-decoration: none;"><img src="/favicon.png" width=32 height=32> riteme.site</a> </span> <nav class=mdl-navigation > <a class=mdl-navigation__link  href="/index.html"><i class="material-icons drawer-icon">home</i> 首页</a> <a class=mdl-navigation__link  href="/posts.html"><i class="material-icons drawer-icon">library_books</i> 所有文章</a> <a class=mdl-navigation__link  href="/about.html"><i class="material-icons drawer-icon">info</i> 关于</a> <a class=mdl-navigation__link  href="/links.html"><i class="material-icons drawer-icon">link</i> 友链</a> <a class=mdl-navigation__link  href="/search.html"><i class="material-icons drawer-icon">search</i> 搜索</a> <a class=mdl-navigation__link  href="https://github.com/riteme/riteme.github.io"><i class="material-icons drawer-icon">class</i> GitHub 项目</a> </nav> </div> <main class=mdl-layout__content > <div class=mdl-grid > <div class="mdl-cell main-cell"> <div class="article main-article" lang=en-US > <h1 id=sa-is >诱导排序与 SA-IS 算法</h1> <p>SA-IS 是一种在实际运用中相当快速的、线性时间构建字符串的后缀数组的算法。本文将通过对原论文<sup id="fnref:paper"><a class=footnote-ref  href="#fn:paper" rel=footnote >1</a></sup>进行一些翻译和总结来介绍该算法。最后会提供一个 SA-IS 算法的 C++ 实现。</p> <h2 id=1 >1. 记号</h2> <p>现在先规定一些记号，以方便之后的讨论。</p> <p>我们通常使用大写字母 <tex>$S, A, B, \dots$</tex> 来表示一个字符串，小写字母 <tex>$a, b, c, \dots$</tex> 表示单个的字符。字符通常被认为是一个整数。字符在一定条件下数量是有限的，我们将所有会用到的字符放入字符集 <tex>$\Sigma$</tex> 中，此时 <tex>$|\Sigma|$</tex> 表示字符集的大小。字符串之间可以任意连接，如 <tex>$AB$</tex> 表示字符串 <tex>$A$</tex> 与字符串 <tex>$B$</tex> 依次连接而成的新字符串。字符串与单个字符之间也是如此。特别的，我们将空串记为 <tex>$\epsilon$</tex>。</p> <p>对于一个字符串我们可以访问其中的任意字符，用 <tex>$S[x]$</tex> 表示 <tex>$S$</tex> 中下标为 <tex>$x$</tex> 的字符。下标从 <tex>$0$</tex> 开始。我们用 <tex>$S[a, b]$</tex> 表示 <tex>$S$</tex> 的一个子串，即下标为 <tex>$a$</tex> 的字符开始一直到下标为 <tex>$b$</tex> 的字符依次连接而成的字符串，其中必须满足 <tex>$0 \le a \le b \lt |S|$</tex>。定义一个字符串 <tex>$S$</tex> 的前缀为 <tex>$\text{prefix}(S, i) = S[0, i]$</tex>，其后缀为 <tex>$\text{suffix}(S, i) = S[i, |S| - 1]$</tex>。</p> <p>两个字符串 <tex>$A$</tex> 和 <tex>$B$</tex> 之间存在比较关系。当 <tex>$A$</tex> 与 <tex>$B$</tex> 的长度相同，且其中对应下标的字符也相同时，则为 <tex>$A = B$</tex>。当从左至右出现第一对不相同的字符时，则以这两个字符的大小关系作为 <tex>$A$</tex> 和 <tex>$B$</tex> 间的大小关系，这称为字典序。为了简化一些操作，定义 <tex>$\#$</tex> 是字典序最小的字符，并且将其默认作为每个字符串的最后一个字符<sup id="fnref:dollar"><a class=footnote-ref  href="#fn:dollar" rel=footnote >2</a></sup>，即作为 <tex>$S[|S|]$</tex>。<br /> 另外，定义函数 <tex>$\text{lcp}(A, B)$</tex> 表示 <tex>$A$</tex> 和 <tex>$B$</tex> 的最长公共前缀的长度，即两者所有相同的前缀中，最长的一个的长度。由此我们可以得知字典序的一个性质：</p> <p><strong>定理 1.1</strong> <tex>$A &lt; B$</tex> 当且仅当 <tex>$A[\text{lcp}(A, B)] &lt; B[\text{lcp}(A, B)]$</tex>。</p> <p><strong>证明</strong>　这个结论显然成立，因为 <tex>$\text{prefix}(A, \text{lcp}(A, B) - 1) = \text{prefix}(B, \text{lcp}(A, B) - 1)$</tex>。</p> <h2 id=2-sa-is >2. SA-IS 算法</h2> <p>SA-IS 算法是基于诱导排序这种思想。基本想法就是将问题的规模缩小，通过解决更小的问题，获取足够信息，就可以快速的解决原始问题。从这里也可以看出，这一过程需要递归处理子问题。</p> <p>在介绍 SA-IS 算法前，我们先来看一下该算法的基本框架：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div><td class=code ><div class=codehilite ><pre><span></span>function SA-IS(S):
    t = bool[]
    S1 = int[]
    P = int[]
    bucket = int[]
    扫描倒序字符串确定每一个后缀的类型 -&gt; t
    扫描t数组确定所有的 LMS 子串 -&gt; P
    对所有的 LMS 子串进行诱导排序
    对每一个 LMS 子串重新命名，生成新的串 S1

    if S1 中的每一个字符都不一样:
        直接计算 SA1
    else
        SA1 = SA-IS(S1)  # 递归计算 SA1

    利用 SA1 来进行诱导排序，计算 SA
    return SA
</pre></div> </table> <p>现在你不会明白这里面都写了些什么东西，因为这只是一个简单的流程。接下来将会介绍其中的每一步并证明其正确性。</p> <h3 id=21 >2.1 后缀类型</h3> <p>在第 6 行中，确定后缀的类型可能会令人无法理解，这是因为我们还没有定义什么是后缀的类型......</p> <p>对于每一个后缀 <tex>$\text{suffix}(S, i)$</tex>，当 <tex>$\text{suffix}(S, i) &lt; \text{suffix}(S, i + 1)$</tex> 时，是 <tex>$S$</tex> 型后缀。当 <tex>$\text{suffix}(S, i) &gt; \text{suffix}(S, i + 1)$</tex> 时，是 <tex>$L$</tex> 型后缀。对于特殊的后缀 <tex>$\text{suffix}(S, |S|) = \#$</tex>，它默认为 <tex>$S$</tex> 型。<br /> 例如，对于字符串 <code>mmiissiissiippii</code>，每一后缀的类型为：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre>1
2
3</pre></div><td class=code ><div class=codehilite ><pre><span></span>      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #
t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S
</pre></div> </table> <p>既然我们需要得知每一个后缀类型，就需要一个快速的算法来计算。在此之前，我们发现它们有如下的性质：</p> <p><strong>引理 2.1</strong>　(后缀类型递推性质) 对于任意的 <tex>$i \in [0, |S| - 1]$</tex>:<br /> 如果 <tex>$t[i] = \text{S-type}$</tex>，当且仅当下面任意一项成立：</p> <ol> <li><tex>$S[i] &lt; S[i + 1]$</tex> <li><tex>$S[i] = S[i + 1]$</tex> 且 <tex>$t[i + 1] = \text{S-type}$</tex> </ol> <p>如果 <tex>$t[i] = \text{L-type}$</tex>，当且仅当下面任意一项成立：</p> <ol> <li><tex>$S[i] &gt; S[i + 1]$</tex> <li><tex>$S[i] = S[i + 1]$</tex> 且 <tex>$t[i + 1] = \text{L-type}$</tex> </ol> <p><strong>证明</strong>　这里证明 <tex>$S$</tex> 型的，<tex>$L$</tex> 型是类似的。对于第一种情况，显然是成立的。对于第二种情况，我们设 <tex>$\text{suffix}(S, i) = aA, \text{suffix}(S, i + 1) = aB$</tex>。由于第一个字符是相同的，因此我们需要比较 <tex>$A$</tex> 和 <tex>$B$</tex> 的大小。因为它们是连续的后缀，所以 <tex>$A = \text{suffix}(S, i + 1), B = \text{suffix}(S, i + 2)$</tex>。由于我们是从右往左推出 <tex>$t$</tex>，所以 <tex>$A$</tex> 与 <tex>$B$</tex> 的关系实际上可以由 <tex>$t[i + 1]$</tex> 给出。故 <tex>$t[i] = t[i + 1]$</tex>。</p> <p>因此，我们可以在 <tex>$\Theta(|S|)$</tex> 的时间内，推出整个 <tex>$t$</tex> 数组。</p> <p>关于后缀类型，我们还可得出另外一个比较重要的性质：</p> <p><strong>引理 2.2</strong>　(后缀类型指导排序) 对于两个后缀 <tex>$A$</tex> 和 <tex>$B$</tex>，如果 <tex>$A[0] = B[0]$</tex> 且 <tex>$A$</tex> 是 <tex>$S$</tex> 型，<tex>$B$</tex> 是 <tex>$L$</tex> 型，则 <tex>$A &gt; B$</tex>。</p> <p><strong>证明</strong>　设 <tex>$A = abX, B = acY$</tex>，这里假设 <tex>$a \neq b$</tex>，<tex>$a \neq c$</tex>。因为 <tex>$A$</tex> 是 <tex>$S$</tex> 型，所以可知 <tex>$a &lt; b$</tex>。同理，<tex>$B$</tex> 是 <tex>$L$</tex> 型，可知 <tex>$a &gt; c$</tex>。故 <tex>$ c &lt; a &lt; b$</tex>，所以 <tex>$A &gt; B$</tex>。如果 <tex>$a = b$</tex> 但 <tex>$a \neq c$</tex>，那么 <tex>$b = a &gt; c$</tex> 即 <tex>$A &gt; B$</tex>，对于 <tex>$a = c$</tex>，<tex>$a \neq b$</tex> 同理。如果 <tex>$a = b = c$</tex>，则我们可以将 <tex>$A$</tex> 和 <tex>$B$</tex> 的第一个字符去掉，用新的后缀来进行比较。根据引理 2.1，去掉第一个字符后的后缀类型不变。因此我们可以通过这样的操作直到变为第一种情况。</p> <h3 id=22-lms >2.2 LMS 子串</h3> <p>然而光有后缀类型，还不足以进行排序。因此我们在后缀类型的 <tex>$S$</tex> 型中挑出特别的一类，记为 <tex>$*$</tex> 型。<tex>$*$</tex> 型是 <tex>$S$</tex> 型的一种，它的特殊之处在于它要求它的左边的后缀必须是 <tex>$L$</tex> 型的。依然以 <code>mmiissiissiippii</code> 为例：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre>1
2
3
4</pre></div><td class=code ><div class=codehilite ><pre><span></span>      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #
t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S
            *           *           *                 *
</pre></div> </table> <p>可以将其理解为一连串的 <tex>$S$</tex> 型中最靠左的一个。LMS (<strong>L</strong>eft<strong>M</strong>ost <strong>S</strong>-type) 也正是这个意思。同时我们注意到，后缀 <tex>$\#$</tex> 始终是 <tex>$*$</tex> 型的。<br /> 对于每一个 <tex>$*$</tex> 型所对应上的字符，我们称为 LMS 字符。上面的示例中，下标为 <tex>$2, 6, 10, 16$</tex> 都是 LMS 字符。<br /> 位置相邻的两个 LMS 字符中间(包括这两个字符)所构成的子串，称为 LMS 子串。对于 <code>mmiissiissiippii</code>，其 LMS 子串依次为 <code>iissi</code>、<code>iissi</code>、<code>iippii#</code> 和 <code>#</code>。</p> <p>通过观察，我们发现 LMS 子串具有以下的性质：<br /> <strong>引理 2.3</strong> <code>#</code> 是最短的 LMS 子串。</p> <p><strong>引理 2.4</strong>　对于任意的非 <code>#</code> 的 LMS 子串，其长度大于 <tex>$2$</tex>。</p> <p><strong>证明</strong>　因为两个 LMS 字符中间必定有一个 <tex>$L$</tex> 型的后缀。</p> <p><strong>引理 2.5</strong>　(原串折半) 一个字符串中 LMS 子串的数量不超过 <tex>$\left\lceil{|S| / 2}\right\rceil$</tex>。</p> <p><strong>证明</strong>　根据引理 2.4 可知。</p> <p><strong>引理 2.6</strong>　一个字符串的所有 LMS 子串的长度之和为 <tex>$O(|S|)$</tex>。</p> <p>此外，对于 LMS 子串间的大小比较，除了对每个字符的字典序进行比较外，还要对比每个字符所对应的后缀类型。<tex>$S$</tex> 型的有更高的优先权，因为根据引理 2.2 可得，首字符相同的情况下，<tex>$S$</tex> 型的后缀字典序更大。只有当每一个字符与其后缀类型都相同时，这两个 LMS 子串才被称为是相同的。<br /> 之所以这样定义，是因为在之后我们会利用 LMS 子串来进行对后缀的排序。如果缺少后缀类型的信息，就不能够胜任。<br /> 根据引理 2.6，我们可以利用<strong>基数排序</strong>在 <tex>$O(|S|)$</tex> 的时间内对所有的 LMS 子串排序<sup id="fnref:lms-sort"><a class=footnote-ref  href="#fn:lms-sort" rel=footnote >3</a></sup>。对 LMS 子串排序完后，我们按照字典序依次重新命名<sup id="fnref:lms-name"><a class=footnote-ref  href="#fn:lms-name" rel=footnote >4</a></sup>，注意，如果两个 LMS 子串相同，则使用同样的名称<sup id="fnref:lms-compare"><a class=footnote-ref  href="#fn:lms-compare" rel=footnote >5</a></sup>。这样给每个 LMS 子串命名后，按照其子串原有的顺序排出一个新串 <tex>$S_1$</tex>。继续以 <code>mmiissiissiippii</code> 为例：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre>1
2
3
4
5
6</pre></div><td class=code ><div class=codehilite ><pre><span></span>      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #
t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S
            *           *           *                 *
新名称      2           2           1                 0
S1:   2 2 1 0
</pre></div> </table> <p>这样有什么用呢？我们发现，这实际上是将所有 <tex>$*$</tex> 型的后缀进行了缩减，从而减小了问题的规模。对于这一点，我们有如下的引理：</p> <p><strong>引理 2.7</strong>　(问题缩减) <tex>$S_1$</tex> 中两个后缀的字典序关系，就是 <tex>$S$</tex> 中对应的 <tex>$*$</tex> 型后缀的字典序关系。</p> <p><strong>证明</strong>　我们可以将 <tex>$S_1$</tex> 视为是将 <tex>$*$</tex> 后缀中不重合的部分进行切割并缩减。这样每一个 LMS 子串就可作为一个整体来进行比较。从而保持了这两者的一致性。</p> <p>需要注意的是这里只是 <tex>$*$</tex> 型后缀的字典序关系，与其它后缀无关。</p> <h3 id=23-sa1-sa >2.3 从 SA1 诱导至 SA</h3> <p>从上面的引理 2.7 我们得知，只要获得了 <tex>$S_1$</tex> 的后缀数组 <tex>$SA_1$</tex>，就可以得到所有 <tex>$*$</tex> 型后缀的相对顺序。如果我们可以利用 <tex>$*$</tex> 型后缀的相对顺序来对其它的 <tex>$L$</tex> 型和 <tex>$S$</tex> 型后缀<sup id="fnref:star-in-S"><a class=footnote-ref  href="#fn:star-in-S" rel=footnote >6</a></sup>进行排序，就可以完成后缀数组的计算。</p> <p>在这里我们先假定 <tex>$SA_1$</tex> 已经计算出来，只需考虑如何计算 <tex>$SA$</tex>。在这之前，我们先观察一下后缀数组的形式。以 <code>aabaaaab</code> 为例，它的后缀数组是这样的：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre>1
2
3
4
5
6
7
8
9</pre></div><td class=code ><div class=codehilite ><pre><span></span>#
aaaab#
aaab#
aab#
aabaaaab#
ab#
abaaaab#
b#
baaaab#
</pre></div> </table> <p>不难发现，首字母相同的后缀是连续排布的，这一点可以用反证法来证明。因此我们可以利用桶排序的思想，为每一个出现过的字符建立一个桶，用 <tex>$SA$</tex> 数组来存储这些桶，每个桶之间按照字典序排列，这样就可以使后缀数组初步有序。<br /> 我们对每个后缀都赋予了一个后缀类型，那么在首字母一样的情况下，<tex>$S$</tex> 型或 <tex>$L$</tex> 型会连续分布吗？答案是肯定的。因为根据引理 2.2，首字母相同的后缀如果后缀类型不同，则相对顺序是确定的。因此易知不会出现 <tex>$S$</tex> 型和 <tex>$L$</tex> 型交替出现的情况。更进一步，由于 <tex>$L$</tex> 型后缀更小，因此总是先排布 <tex>$L$</tex> 型后缀，再排布 <tex>$S$</tex> 型后缀。因此每一个字符的桶可以分为两部分，一个用于放置 <tex>$L$</tex> 型后缀，另一个则用于 <tex>$S$</tex> 型后缀。为了方便确定每一个桶的起始位置，<tex>$S$</tex> 型后缀的桶的放置是倒序的。<br /> 但是如果首字母和后缀类型都一致，我们不能直接快速地判断大小关系。在这里就要利用到诱导排序了。</p> <p>诱导排序的过程分为以下几步：</p> <ol> <li>将 <tex>$SA$</tex> 数组初始化为每个元素都为 <tex>$-1$</tex> 的数组。 <li>确定每个桶 <tex>$S$</tex> 型桶的起始位置。将 <tex>$SA_1$</tex> 中的每一个 <tex>$*$</tex> 型后缀按照 <tex>$SA_1$</tex> 中的顺序放入相应的桶内。 <li>确定每个桶 <tex>$L$</tex> 型桶的起始位置。在 <tex>$SA$</tex> 数组中从左往右扫一遍。如果 <tex>$SA[i] &gt; 0$</tex> 且 <tex>$t[SA[i] - 1] = \text{L-type}$</tex>，则将 <tex>$SA[i] - 1$</tex> 所代表的后缀放入对应的桶中。 <li>重新确定每个桶 <tex>$S$</tex> 型桶的起始位置，因为所有的 <tex>$*$</tex> 型后缀要重新被排序。由于 <tex>$S$</tex> 型桶是逆序排放的，所以这次从右至左地扫描一遍 <tex>$SA$</tex>。如果 <tex>$SA[i] &gt; 0$</tex> 且 <tex>$t[SA[i] - 1] = \text{S-type}$</tex>，则将 <tex>$SA[i] - 1$</tex> 所代表的后缀放入对应的桶中。 </ol> <p>这样我们就可以完成从 <tex>$SA_1$</tex> 诱导到 <tex>$SA$</tex> 的排序工作。这里简单说明一下为什么这样做是正确的：首先对于所有的 <tex>$*$</tex> 型后缀，都是有序排放的。从左至右扫描 <tex>$SA$</tex> 数组实际上就是按照字典序扫描现有的已排序的后缀。对于两个相邻的 <tex>$L$</tex> 型后缀 <tex>$A$</tex> 和 <tex>$B$</tex>，这里假设 <tex>$|A| &gt; |B|$</tex>，则必定有 <tex>$A &gt; B$</tex>。由于 <tex>$B$</tex> 会被先加入 <tex>$SA$</tex> 中，所以我们保证了 <tex>$A$</tex> 和 <tex>$B$</tex> 之间的有序性。又因为 <tex>$L$</tex> 型桶是从左往右的顺序加入的，所以所有的 <tex>$L$</tex> 型后缀会逐步地按顺序加入到 <tex>$SA$</tex> 中。最后所有的 <tex>$L$</tex> 型后缀将会有序。<br /> 对于<tex>$S$</tex>型后缀，除了要注意是相反的顺序和需要重新对<tex>$*$</tex>型后缀排序外，其余的原理与<tex>$L$</tex>型的排序类似。</p> <p>之前的讨论都是基于我们已知<tex>$SA_1$</tex>的情况下进行的。现在我们来考虑如何计算<tex>$SA_1$</tex>。由于<tex>$S_1$</tex>也是一个字符串，计算其后缀数组时可以考虑两种情况：</p> <ol> <li>如果<tex>$S_1$</tex>中每一个字符都不一样，则可以直接利用桶排序直接计算<tex>$SA_1$</tex>。 <li>否则，递归计算<tex>$SA_1$</tex>。就如之前的算法框架所展示的一样。 </ol> <h3 id=24-lms >2.4 对LMS子串排序</h3> <p>到这里，SA-IS算法几乎已经结束了，只是还有一个问题需要解决，就是对LMS子串的排序。<br /> 之前我们所提及的，我们可以利用基数排序。虽然可以在<tex>$O(|S|)$</tex>的时间内完成，但是事实上，这个基数排序不但常熟大，而且十分复杂(请想象一下对字符串进行基数排序......)。这个排序直接成为了整个算法的性能瓶颈。因此我们急切的需要一种新的算法来胜任这一任务。<br /> 这个算法依然是<strong>诱导排序</strong>。</p> <p>与之前从<tex>$SA_1$</tex>诱导到<tex>$SA$</tex>的算法一样，只是我们这里将第二步改为：</p> <blockquote> <p>确定每个桶<tex>$S$</tex>型桶的起始位置。将每一个LMS子串的首字母按照<strong>任意顺序</strong>放入对应的桶中。</p> </blockquote> <p>待算法完成，我们会获得一个<tex>$SA$</tex>数组，其中LMS子串之间是排好了序的。</p> <p>为什么这个算法是正确的，我们需要扯到一个新的概念：LMS前缀。<br /> 规定LMS前缀函数<tex>$\text{pre}(S, i)$</tex>表示 (1) 如果<tex>$\text{suffix}(S, i)$</tex>是<tex>$*$</tex>型的，则<tex>$\text{pre}(S, i) = S[i]$</tex>，即LMS字符的LMS前缀就是自己。 (2) 否则是从<tex>$S[i]$</tex>开始，到下一个LMS字符之间(包括首尾)的子串。同样的，按照<tex>$\text{suffix}(S, i)$</tex>的后缀类型的不同，LMS前缀也同样分为<tex>$S$</tex>型和<tex>$L$</tex>型。<br /> 例如，在<code>mmiissiissiippii</code>中，<tex>$\text{pre}(S, 2) = S[2] =$</tex> <code>i</code>，而<tex>$\text{pre}(S, 3) = S[3, 6] =$</tex> <code>issi</code>。<br /> 因此上面的算法实际上是在对每个LMS前缀进行排序。</p> <p>接下来将证明2-4步都是正确的，即每一步完成时<tex>$SA$</tex>数组中，LMS前缀都是有序的。</p> <ol> <li>对于第二步，由于放入的LMS前缀都只有一个字符，因为桶的排列是按照字典序的，所以保证放置后一定有序。 <li>对于第三步，当放入第一个<tex>$L$</tex>型LMS前缀时，<tex>$SA$</tex>数组必定是有序的(根据引理2.2)。假设我们已经放置了<tex>$k$</tex>个<tex>$L$</tex>型LMS前缀，且它们在<tex>$SA$</tex>数组中保持有序，现在考虑放入的第<tex>$k + 1$</tex>个LMS前缀是否会保证有序。我们设这个LMS前缀为<tex>$\text{pre}(S, i)$</tex>，因为首字母不同的LMS前缀一定是保持有序的，因此我们只需要考虑它与其首字母相同的LMS前缀之间的关系。因为我们是从左至右扫描来使<tex>$L$</tex>型LMS前缀从小至大放置，那么对于所有之前放置的且首字母与其相同的LMS前缀<tex>$\text{pre}(S, j)$</tex>，应该都有<tex>$\text{pre}(S, j) &lt; \text{pre}(S, i)$</tex>。假设我们存在一个这样的LMS前缀，使得<tex>$\text{pre}(S, j) &gt; \text{pre}(S, i)$</tex>，由于<tex>$\text{pre}(S, j)[0] = \text{pre}(S, i)[0]$</tex>，所以我们得知<tex>$\text{pre}(S, j + 1) &gt; \text{pre}(S, i + 1)$</tex>。而<tex>$\text{pre}(S, j + 1)$</tex>与<tex>$\text{pre}(S, i + 1)$</tex>都是之前所加入过的，因此它们之间应当保持有序。而<tex>$\text{pre}(S, j) &gt; \text{pre}(S, i)$</tex>告诉我们之前的<tex>$SA$</tex>数组不是有序的，与假设相反，故不存在这样的<tex>$\text{pre}(S, j)$</tex>。因此，当<tex>$\text{pre}(S, i)$</tex>放置后，<tex>$SA$</tex>数组保持有序。直到所有的<tex>$L$</tex>型LMS前缀加入完毕。 <li>对于第四步的正确性的证明，与第三步的证明是类似的。读者可以自行推理一下。 </ol> <p>这样，我们就完成了对这个诱导排序的正确性的证明。但我们需要注意的是，这只是对LMS前缀的排序，我们期望是对LMS子串进行排序。我们注意到每一个LMS子串都可以视为是一个LMS字符与一个LMS前缀连接而成的，因此我们只需要判断两个LMS字符和其后一位对应的LMS前缀的大小关系，就可以判断LMS子串之间的大小关系。<br /> 然而，我们其实可以做得更简单。下面的引理说明了上面的算法结束后的<tex>$SA$</tex>数组就是排好序的LMS子串的数组。</p> <p><strong>引理 2.8</strong> (LMS子串排序) <tex>$SA$</tex>数组中每一个LMS字符所对应的LMS前缀已经按照其对应的LMS子串的顺序排好。</p> <p><strong>证明</strong> 对于首字母不同的LMS子串，这个结论是显然的。<br /> 对于首字母相同的LMS子串，它必定是由一个<tex>$L$</tex>型LMS前缀从右至左的推导过来的。由于不同的LMS子串必定对应着不同的递推的顺序，并且在第二步中，所有的<tex>$L$</tex>型LMS前缀已经排好了序。所以结论成立。</p> <p>根据这个引理，我们可以直接对<tex>$SA$</tex>数组扫描一遍，就可以得到LMS子串的字典序，同时对它们进行命名。</p> <h2 id=3 >3. 时空复杂度分析</h2> <p>在之前的讨论中，我们已经成功的运用诱导排序使每一步都是<tex>$\Theta(|S|)$</tex>。但是由于有一个递归的过程，时间复杂度似乎并不一定是线性的。<br /> 我们注意到，每次递归都是计算<tex>$S_1$</tex>的后缀数组。如果我们能够知道<tex>$S_1$</tex>的规模，就能够计算SA-IS的事件复杂度。<br /> 根据引理2.5，我们得知<tex>$|S_1| \le \left\lceil|S| / 2\right\rceil$</tex>。因此每一层的递归的问题规模都会减半。因此我们可以用以下的递归式来表示时间复杂度：<br /> <tex>$$ T(n) = T(\left\lceil n/2\right\rceil) + \Theta(n) \tag{3.1} $$</tex></p> <p>求解可得：<br /> <tex>$$ T(n) = \Theta(n) \tag{3.2} $$</tex></p> <p>因此总时间复杂度是<tex>$\Theta(n)$</tex>的。<br /> 对于这个递归式，我们可以理解为是递归了<tex>$O(\log n)$</tex>层，其中每一层的问题规模从小到大排序是<tex>$2^0, 2^1, 2^2, \dots, 2^{\left\lfloor\log n\right\rfloor}$</tex>。因此总复杂度就是对它们进行求和：<br /> <tex>$$ \sum^{\left\lfloor\log n\right\rfloor}_{k=0} 2^k = 2 \times 2^{\left\lfloor\log n\right\rfloor} = \Theta(2^{\left\lfloor\log n\right\rfloor}) = \Theta(n) \tag{3.3} $$</tex></p> <p>对于空间复杂度的分析，与时间复杂度是如出一辙的。</p> <h2 id=4 >4. 运行示例</h2> <p>下面将用<code>aabaaaab</code>作为输入字符串，展示计算其后缀数组的每一步。希望能通过这个示例能够更清晰地展现SA-IS算法的运作流程。由于涉及到对桶的操作，这里用<code>@</code>表示正在被处理的元素，而用<code>^</code>表示每个桶的起始位置。</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83</pre></div><td class=code ><div class=codehilite ><pre><span></span>           0  1  2  3  4  5  6  7  8
S:         a  a  b  a  a  a  a  b  #
扫描后缀类型
t:         S  S  L  S  S  S  S  L  S
LMS characters:     *              *
         |# |       a         |  b  |  # 桶的名称
SA:       -1|-1 -1 -1 -1 -1 -1|-1 -1
对LMS子串进行排序
1. 放入LMS子串
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
2. 从*型LMS前缀诱导到L型LMS前缀
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
          @^  ^                 ^
SA:       08|-1 -1 -1 -1 -1 03|07 -1
           ^  ^             @      ^
SA:       08|-1 -1 -1 -1 -1 03|07 02  # pre(S, 6)不是L型的
           ^  ^                @   ^
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^  ^                   @^
SA:       08|-1 -1 -1 -1 -1 03|07 02
3. 从L型LMS前缀诱导到S型前缀
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^                 ^    @^
SA:       08|-1 -1 -1 -1 -1 01|07 02
           ^              ^    @   ^
SA:       08|-1 -1 -1 -1 06 01|07 02
           ^           ^    @      ^
SA:       08|-1 -1 -1 00 06 01|07 02
           ^        ^    @         ^
SA:       08|-1 -1 05 00 06 01|07 02  # 不存在pre(S, -1)
           ^     ^    @            ^
SA:       08|-1 -1 05 00 06 01|07 02
           ^     ^ @               ^
SA:       08|-1 04 05 00 06 01|07 02
           ^  ^ @                  ^
SA:       08|03 04 05 00 06 01|07 02
           ^ @^                    ^
SA:       08|03 04 05 00 06 01|07 02  # pre(S, 7)不是S型的
          @^  ^                    ^
SA:       08|03 04 05 00 06 01|07 02
扫描并重命名LMS子串
name:      1  2
S1:       2 1 0
由于每一个字符都不一样，直接计算SA1
SA1：     2 1 0
从SA1诱导到SA
         |$ |       a         |  b  |
SA:       -1|-1 -1 -1 -1 -1 -1|-1 -1
1. 按照SA1的原顺序放入(忽略S1最后的字符)
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
           ^  ^                 ^
2. 从*型后缀诱导到L型后缀
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
          @^  ^                 ^
SA:       08|-1 -1 -1 -1 -1 03|07 -1
           ^  ^             @      ^
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^  ^                @   ^
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^  ^                   @^
3. 从L型后缀诱导到S型后缀
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^                 ^    @^
SA:       08|-1 -1 -1 -1 -1 01|07 02
           ^              ^    @   ^
SA:       08|-1 -1 -1 -1 06 01|07 02
           ^           ^    @      ^
SA:       08|-1 -1 -1 00 06 01|07 02
           ^        ^    @         ^
SA:       08|-1 -1 05 00 06 01|07 02
           ^     ^    @            ^
SA:       08|-1 -1 05 00 06 01|07 02
           ^     ^ @               ^
SA:       08|-1 04 05 00 06 01|07 02
           ^  ^ @                  ^
SA:       08|03 04 05 00 06 01|07 02  # pre(S, 2)是L型
           ^ @^                    ^
SA:       08|03 04 05 00 06 01|07 02
          @^  ^                    ^
后缀数组构造完毕
SA: 8 3 4 5 0 6 1 7 2

return SA
</pre></div> </table> <h2 id=5 >5. 具体实现及性能对比</h2> <p>在原论文中说道SA-IS算法可以在100行左右的代码完成。我试了一下，基本符合这个要求。下面将会给出一个C++实现。需要注意的是，为了方便，这份代码中并没有回收分配的内存。</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130</pre></div><td class=code ><div class=codehilite ><pre><span></span><span class=c1 >// 后缀类型</span>
<span class=cp >#define L_TYPE 0</span>
<span class=cp >#define S_TYPE 1</span>

<span class=c1 >// 判断一个字符是否为LMS字符</span>
<span class=kr >inline</span> <span class=kt >bool</span> <span class=nf >is_lms_char</span><span class=p >(</span><span class=kt >int</span> <span class=o >*</span><span class=n >type</span><span class=p >,</span> <span class=kt >int</span> <span class=n >x</span><span class=p >)</span> <span class=p >{</span>
    <span class=k >return</span> <span class=n >x</span> <span class=o >&gt;</span> <span class=mi >0</span> <span class=o >&amp;&amp;</span> <span class=n >type</span><span class=p >[</span><span class=n >x</span><span class=p >]</span> <span class=o >==</span> <span class=n >S_TYPE</span> <span class=o >&amp;&amp;</span> <span class=n >type</span><span class=p >[</span><span class=n >x</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]</span> <span class=o >==</span> <span class=n >L_TYPE</span><span class=p >;</span>
<span class=p >}</span>

<span class=c1 >// 判断两个LMS子串是否相同</span>
<span class=kr >inline</span> <span class=kt >bool</span> <span class=nf >equal_substring</span><span class=p >(</span><span class=kt >int</span> <span class=o >*</span><span class=n >S</span><span class=p >,</span> <span class=kt >int</span> <span class=n >x</span><span class=p >,</span> <span class=kt >int</span> <span class=n >y</span><span class=p >,</span> <span class=kt >int</span> <span class=o >*</span><span class=n >type</span><span class=p >)</span> <span class=p >{</span>
    <span class=k >do</span> <span class=p >{</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >S</span><span class=p >[</span><span class=n >x</span><span class=p >]</span> <span class=o >!=</span> <span class=n >S</span><span class=p >[</span><span class=n >y</span><span class=p >])</span>
            <span class=k >return</span> <span class=nb >false</span><span class=p >;</span>
        <span class=n >x</span><span class=o >++</span><span class=p >,</span> <span class=n >y</span><span class=o >++</span><span class=p >;</span>
    <span class=p >}</span> <span class=k >while</span> <span class=p >(</span><span class=o >!</span><span class=n >is_lms_char</span><span class=p >(</span><span class=n >type</span><span class=p >,</span> <span class=n >x</span><span class=p >)</span> <span class=o >&amp;&amp;</span> <span class=o >!</span><span class=n >is_lms_char</span><span class=p >(</span><span class=n >type</span><span class=p >,</span> <span class=n >y</span><span class=p >));</span>

    <span class=k >return</span> <span class=n >S</span><span class=p >[</span><span class=n >x</span><span class=p >]</span> <span class=o >==</span> <span class=n >S</span><span class=p >[</span><span class=n >y</span><span class=p >];</span>
<span class=p >}</span>

<span class=c1 >// 诱导排序(从*型诱导到L型、从L型诱导到S型)</span>
<span class=c1 >// 调用之前应将*型按要求放入SA中</span>
<span class=kr >inline</span> <span class=kt >void</span> <span class=nf >induced_sort</span><span class=p >(</span><span class=kt >int</span> <span class=o >*</span><span class=n >S</span><span class=p >,</span> <span class=kt >int</span> <span class=o >*</span><span class=n >SA</span><span class=p >,</span> <span class=kt >int</span> <span class=o >*</span><span class=n >type</span><span class=p >,</span> <span class=kt >int</span> <span class=o >*</span><span class=n >bucket</span><span class=p >,</span> <span class=kt >int</span> <span class=o >*</span><span class=n >lbucket</span><span class=p >,</span>
                         <span class=kt >int</span> <span class=o >*</span><span class=n >sbucket</span><span class=p >,</span> <span class=kt >int</span> <span class=n >n</span><span class=p >,</span> <span class=kt >int</span> <span class=n >SIGMA</span><span class=p >)</span> <span class=p >{</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >&gt;</span> <span class=mi >0</span> <span class=o >&amp;&amp;</span> <span class=n >type</span><span class=p >[</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]</span> <span class=o >==</span> <span class=n >L_TYPE</span><span class=p >)</span>
            <span class=n >SA</span><span class=p >[</span><span class=n >lbucket</span><span class=p >[</span><span class=n >S</span><span class=p >[</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]]</span><span class=o >++</span><span class=p >]</span> <span class=o >=</span> <span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >SIGMA</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>  <span class=c1 >// Reset S-type bucket</span>
        <span class=n >sbucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span> <span class=o >&gt;=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span><span class=o >--</span><span class=p >)</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >&gt;</span> <span class=mi >0</span> <span class=o >&amp;&amp;</span> <span class=n >type</span><span class=p >[</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]</span> <span class=o >==</span> <span class=n >S_TYPE</span><span class=p >)</span>
            <span class=n >SA</span><span class=p >[</span><span class=n >sbucket</span><span class=p >[</span><span class=n >S</span><span class=p >[</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]]</span><span class=o >--</span><span class=p >]</span> <span class=o >=</span> <span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
<span class=p >}</span>

<span class=c1 >// SA-IS主体</span>
<span class=c1 >// S是输入字符串，length是字符串的长度, SIGMA是字符集的大小</span>
<span class=k >static</span> <span class=kt >int</span> <span class=o >*</span><span class=nf >SAIS</span><span class=p >(</span><span class=kt >int</span> <span class=o >*</span><span class=n >S</span><span class=p >,</span> <span class=kt >int</span> <span class=n >length</span><span class=p >,</span> <span class=kt >int</span> <span class=n >SIGMA</span><span class=p >)</span> <span class=p >{</span>
    <span class=kt >int</span> <span class=n >n</span> <span class=o >=</span> <span class=n >length</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >type</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>  <span class=c1 >// 后缀类型</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >position</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>  <span class=c1 >// 记录LMS子串的起始位置</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >name</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>  <span class=c1 >// 记录每个LMS子串的新名称</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >SA</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>  <span class=c1 >// SA数组</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >bucket</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >SIGMA</span><span class=p >];</span>  <span class=c1 >// 每个字符的桶</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >lbucket</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >SIGMA</span><span class=p >];</span>  <span class=c1 >// 每个字符的L型桶的起始位置</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >sbucket</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >SIGMA</span><span class=p >];</span>  <span class=c1 >// 每个字符的S型桶的起始位置</span>

    <span class=c1 >// 初始化每个桶</span>
    <span class=n >memset</span><span class=p >(</span><span class=n >bucket</span><span class=p >,</span> <span class=mi >0</span><span class=p >,</span> <span class=k >sizeof</span><span class=p >(</span><span class=kt >int</span><span class=p >)</span> <span class=o >*</span> <span class=p >(</span><span class=n >SIGMA</span> <span class=o >+</span> <span class=mi >1</span><span class=p >));</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
        <span class=n >bucket</span><span class=p >[</span><span class=n >S</span><span class=p >[</span><span class=n >i</span><span class=p >]]</span><span class=o >++</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >SIGMA</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span> <span class=p >{</span>
        <span class=n >bucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >+=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span> <span class=o >-</span> <span class=mi >1</span><span class=p >];</span>
        <span class=n >lbucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span> <span class=o >-</span> <span class=mi >1</span><span class=p >];</span>
        <span class=n >sbucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
    <span class=p >}</span>

    <span class=c1 >// 确定后缀类型(利用引理2.1)</span>
    <span class=n >type</span><span class=p >[</span><span class=n >n</span><span class=p >]</span> <span class=o >=</span> <span class=n >S_TYPE</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=n >n</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&gt;=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span><span class=o >--</span><span class=p >)</span> <span class=p >{</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >S</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >&lt;</span> <span class=n >S</span><span class=p >[</span><span class=n >i</span> <span class=o >+</span> <span class=mi >1</span><span class=p >])</span>
            <span class=n >type</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >S_TYPE</span><span class=p >;</span>
        <span class=k >else</span> <span class=k >if</span> <span class=p >(</span><span class=n >S</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >&gt;</span> <span class=n >S</span><span class=p >[</span><span class=n >i</span> <span class=o >+</span> <span class=mi >1</span><span class=p >])</span>
            <span class=n >type</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >L_TYPE</span><span class=p >;</span>
        <span class=k >else</span>
            <span class=n >type</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >type</span><span class=p >[</span><span class=n >i</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>
    <span class=p >}</span>

    <span class=c1 >// 寻找每个LMS子串</span>
    <span class=kt >int</span> <span class=n >cnt</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >type</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >==</span> <span class=n >S_TYPE</span> <span class=o >&amp;&amp;</span> <span class=n >type</span><span class=p >[</span><span class=n >i</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]</span> <span class=o >==</span> <span class=n >L_TYPE</span><span class=p >)</span>
            <span class=n >position</span><span class=p >[</span><span class=n >cnt</span><span class=o >++</span><span class=p >]</span> <span class=o >=</span> <span class=n >i</span><span class=p >;</span>

    <span class=c1 >// 对LMS子串进行排序</span>
    <span class=n >fill</span><span class=p >(</span><span class=n >SA</span><span class=p >,</span> <span class=n >SA</span> <span class=o >+</span> <span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >,</span> <span class=o >-</span><span class=mi >1</span><span class=p >);</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;</span> <span class=n >cnt</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
        <span class=n >SA</span><span class=p >[</span><span class=n >sbucket</span><span class=p >[</span><span class=n >S</span><span class=p >[</span><span class=n >position</span><span class=p >[</span><span class=n >i</span><span class=p >]]]</span><span class=o >--</span><span class=p >]</span> <span class=o >=</span> <span class=n >position</span><span class=p >[</span><span class=n >i</span><span class=p >];</span>
    <span class=n >induced_sort</span><span class=p >(</span><span class=n >S</span><span class=p >,</span> <span class=n >SA</span><span class=p >,</span> <span class=n >type</span><span class=p >,</span> <span class=n >bucket</span><span class=p >,</span> <span class=n >lbucket</span><span class=p >,</span> <span class=n >sbucket</span><span class=p >,</span> <span class=n >n</span><span class=p >,</span> <span class=n >SIGMA</span><span class=p >);</span>

    <span class=c1 >// 为每个LMS子串命名</span>
    <span class=n >fill</span><span class=p >(</span><span class=n >name</span><span class=p >,</span> <span class=n >name</span> <span class=o >+</span> <span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >,</span> <span class=o >-</span><span class=mi >1</span><span class=p >);</span>
    <span class=kt >int</span> <span class=n >lastx</span> <span class=o >=</span> <span class=o >-</span><span class=mi >1</span><span class=p >,</span> <span class=n >namecnt</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span>  <span class=c1 >// 上一次处理的LMS子串与名称的计数</span>
    <span class=kt >bool</span> <span class=n >flag</span> <span class=o >=</span> <span class=nb >false</span><span class=p >;</span>  <span class=c1 >// 这里顺便记录是否有重复的字符</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span> <span class=p >{</span>
        <span class=kt >int</span> <span class=n >x</span> <span class=o >=</span> <span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >];</span>

        <span class=k >if</span> <span class=p >(</span><span class=n >is_lms_char</span><span class=p >(</span><span class=n >type</span><span class=p >,</span> <span class=n >x</span><span class=p >))</span> <span class=p >{</span>
            <span class=k >if</span> <span class=p >(</span><span class=n >lastx</span> <span class=o >&gt;=</span> <span class=mi >0</span> <span class=o >&amp;&amp;</span> <span class=o >!</span><span class=n >equal_substring</span><span class=p >(</span><span class=n >S</span><span class=p >,</span> <span class=n >x</span><span class=p >,</span> <span class=n >lastx</span><span class=p >,</span> <span class=n >type</span><span class=p >))</span>
                <span class=n >namecnt</span><span class=o >++</span><span class=p >;</span>
            <span class=c1 >// 因为只有相同的LMS子串才会有同样的名称</span>
            <span class=k >if</span> <span class=p >(</span><span class=n >lastx</span> <span class=o >&gt;=</span> <span class=mi >0</span> <span class=o >&amp;&amp;</span> <span class=n >namecnt</span> <span class=o >==</span> <span class=n >name</span><span class=p >[</span><span class=n >lastx</span><span class=p >])</span>
                <span class=n >flag</span> <span class=o >=</span> <span class=nb >true</span><span class=p >;</span>

            <span class=n >name</span><span class=p >[</span><span class=n >x</span><span class=p >]</span> <span class=o >=</span> <span class=n >namecnt</span><span class=p >;</span>
            <span class=n >lastx</span> <span class=o >=</span> <span class=n >x</span><span class=p >;</span>
        <span class=p >}</span>
    <span class=p >}</span>  <span class=c1 >// for</span>
    <span class=n >name</span><span class=p >[</span><span class=n >n</span><span class=p >]</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span>

    <span class=c1 >// 生成S1</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >S1</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >cnt</span><span class=p >];</span>
    <span class=kt >int</span> <span class=n >pos</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >name</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >&gt;=</span> <span class=mi >0</span><span class=p >)</span>
            <span class=n >S1</span><span class=p >[</span><span class=n >pos</span><span class=o >++</span><span class=p >]</span> <span class=o >=</span> <span class=n >name</span><span class=p >[</span><span class=n >i</span><span class=p >];</span>

    <span class=kt >int</span> <span class=o >*</span><span class=n >SA1</span><span class=p >;</span>
    <span class=k >if</span> <span class=p >(</span><span class=o >!</span><span class=n >flag</span><span class=p >)</span> <span class=p >{</span>
        <span class=c1 >// 直接计算SA1</span>
        <span class=n >SA1</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >cnt</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>

        <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;</span> <span class=n >cnt</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
            <span class=n >SA1</span><span class=p >[</span><span class=n >S1</span><span class=p >[</span><span class=n >i</span><span class=p >]]</span> <span class=o >=</span> <span class=n >i</span><span class=p >;</span>
    <span class=p >}</span> <span class=k >else</span>
        <span class=n >SA1</span> <span class=o >=</span> <span class=n >SAIS</span><span class=p >(</span><span class=n >S1</span><span class=p >,</span> <span class=n >cnt</span><span class=p >,</span> <span class=n >namecnt</span><span class=p >);</span>  <span class=c1 >// 递归计算SA1</span>

    <span class=c1 >// 从SA1诱导到SA</span>
    <span class=n >lbucket</span><span class=p >[</span><span class=mi >0</span><span class=p >]</span> <span class=o >=</span> <span class=n >sbucket</span><span class=p >[</span><span class=mi >0</span><span class=p >]</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >SIGMA</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span> <span class=p >{</span>
        <span class=n >lbucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span> <span class=o >-</span> <span class=mi >1</span><span class=p >];</span>
        <span class=n >sbucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
    <span class=p >}</span>
    <span class=n >fill</span><span class=p >(</span><span class=n >SA</span><span class=p >,</span> <span class=n >SA</span> <span class=o >+</span> <span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >,</span> <span class=o >-</span><span class=mi >1</span><span class=p >);</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=n >cnt</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&gt;=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span><span class=o >--</span><span class=p >)</span>  <span class=c1 >// 这里是逆序扫描SA1，因为SA中S型桶是倒序的</span>
        <span class=n >SA</span><span class=p >[</span><span class=n >sbucket</span><span class=p >[</span><span class=n >S</span><span class=p >[</span><span class=n >position</span><span class=p >[</span><span class=n >SA1</span><span class=p >[</span><span class=n >i</span><span class=p >]]]]</span><span class=o >--</span><span class=p >]</span> <span class=o >=</span> <span class=n >position</span><span class=p >[</span><span class=n >SA1</span><span class=p >[</span><span class=n >i</span><span class=p >]];</span>
    <span class=n >induced_sort</span><span class=p >(</span><span class=n >S</span><span class=p >,</span> <span class=n >SA</span><span class=p >,</span> <span class=n >type</span><span class=p >,</span> <span class=n >bucket</span><span class=p >,</span> <span class=n >lbucket</span><span class=p >,</span> <span class=n >sbucket</span><span class=p >,</span> <span class=n >n</span><span class=p >,</span> <span class=n >SIGMA</span><span class=p >);</span>

    <span class=c1 >// 后缀数组计算完毕</span>
    <span class=k >return</span> <span class=n >SA</span><span class=p >;</span>
<span class=p >}</span>
</pre></div> </table> <p>SA-IS的实现还可以参考一篇很好的博文: <a href="http://zork.net/~st/jottings/sais.html">A walk through the SA-IS Suffix Array Construction Algorithm</a>，这篇文章的作者使用Python一步一步地介绍了如何实现一个基础的SA-IS算法。</p> <p>我们看到SA-IS作为一个后缀排序的算法，代码量也并不小，然而实际上它速度非常快，其中一个重要的原因就是SA-IS算法几乎所有的操作都是<strong>顺序访问</strong>的，这样就可以很好地<strong>提高缓存命中率</strong><sup id="fnref:cache"><a class=footnote-ref  href="#fn:cache" rel=footnote >7</a></sup>。原论文中实测SA-IS算法击败了KA算法，不愧为目前为止速度最快的后缀数组的构建算法。</p> <p>对中学OI界，构造后缀数组通常是使用倍增法和DC3算法。倍增法速度比DC3算法慢是众所周知的了，下面我将用不同规模的<strong>随机字符串</strong>来比较DC3算法与SA-IS算法。</p> <table> <thead> <tr> <th align=center >数据规模 <th align=center >DC3 <th align=center >SA-IS <tr> <td align=center ><tex>$10^4$</tex> <td align=center ><tex>$0.015\text{s}$</tex> <td align=center ><tex>$0.011\text{s}$</tex> <tr> <td align=center ><tex>$10^5$</tex> <td align=center ><tex>$0.055\text{s}$</tex> <td align=center ><tex>$0.036\text{s}$</tex> <tr> <td align=center ><tex>$10^6$</tex> <td align=center ><tex>$0.365\text{s}$</tex> <td align=center ><tex>$0.270\text{s}$</tex> <tr> <td align=center ><tex>$2\times 10^6$</tex> <td align=center ><tex>$0.997\text{s}$</tex> <td align=center ><tex>$0.593\text{s}$</tex> <tr> <td align=center ><tex>$5\times 10^6$</tex> <td align=center ><tex>$2.803\text{s}$</tex> <td align=center ><tex>$2.085\text{s}$</tex> <tr> <td align=center ><tex>$10^7$</tex> <td align=center ><tex>$4.012\text{s}$</tex> <td align=center ><tex>$3.326\text{s}$</tex> </table> <p>编译命令: <code>g++ SAIS.cpp/DC3.cpp -o sais/dc3 -O3</code><br /> 运行环境: Ubuntu 14.04 LTS x64 / CPU: 2.0GHz 奔腾某CPU / 4GB内存 / 未启动X window</p> <p>从上面的结果可以看出，SA-IS算法速度上明显优于DC3算法，并且数据规模越大，两者的速度差距越明显。<br /> 总而言之，SA-IS算法是一个相当不错的后缀数组的构建算法。似乎SA-IS算法所利用的诱导排序的思想还可以解决其它的一些字符串的问题，如计算LCP数组<sup id="fnref:lcp"><a class=footnote-ref  href="#fn:lcp" rel=footnote >8</a></sup>，我并没有对此做过多的了解了。</p> <div class=footnote > <hr /> <ol> <li id="fn:paper"> <p>Nong, Ge; Zhang, Sen; Chan, Wai Hong (2009): <a href="https://local.ugene.unipro.ru/tracker/secure/attachment/12144/Linear+Suffix+Array+Construction+by+Almost+Pure+Induced-Sorting.pdf">Linear Suffix Array Construction by Almost Pure Induced-Sorting</a>&#160;<a class=footnote-backref  href="#fnref:paper" rev=footnote  title="Jump back to footnote 1 in the text">&#8617;</a></p> <li id="fn:dollar"> <p>这里的 <tex>$\#$</tex> 并不是指“井号”，而是一个特殊记号。字符串中不会出现这个字符。&#160;<a class=footnote-backref  href="#fnref:dollar" rev=footnote  title="Jump back to footnote 2 in the text">&#8617;</a></p> <li id="fn:lms-sort"> <p>后面我们将会有更好的算法来对 LMS 子串排序，时间复杂度一致，但在实际运用中速度快很多。&#160;<a class=footnote-backref  href="#fnref:lms-sort" rev=footnote  title="Jump back to footnote 3 in the text">&#8617;</a></p> <li id="fn:lms-name"> <p>注意之后会创建新字符串<tex>$ S_1$</tex>，其字符集 <tex>$\Sigma$</tex> 是不同的。&#160;<a class=footnote-backref  href="#fnref:lms-name" rev=footnote  title="Jump back to footnote 4 in the text">&#8617;</a></p> <li id="fn:lms-compare"> <p>判断两个 LMS 子串是否相等可以暴力判断，基于引理 2.6，可以证明其总复杂度为 <tex>$O(|S|)$</tex>。&#160;<a class=footnote-backref  href="#fnref:lms-compare" rev=footnote  title="Jump back to footnote 5 in the text">&#8617;</a></p> <li id="fn:star-in-S"> <p>注意 <tex>$*$</tex> 型后缀也属于 <tex>$S$</tex> 型后缀，因此会对它们进行重排，从而确保新加入的 <tex>$S$</tex> 型后缀的顺序是对的。&#160;<a class=footnote-backref  href="#fnref:star-in-S" rev=footnote  title="Jump back to footnote 6 in the text">&#8617;</a></p> <li id="fn:cache"> <p>即降低cache-missing。&#160;<a class=footnote-backref  href="#fnref:cache" rev=footnote  title="Jump back to footnote 7 in the text">&#8617;</a></p> <li id="fn:lcp"> <p>Johannes Fischer (2011): <a href="https://arxiv.org/pdf/1101.3448.pdf">Inducing the LCP-Array</a>&#160;<a class=footnote-backref  href="#fnref:lcp" rev=footnote  title="Jump back to footnote 8 in the text">&#8617;</a></p> </ol> </div> <hr/> <div id=comments ></div> <script> window.addEventListener('load', () => { quicklink(); }); const gitment = new Gitment({id: '9269fdafdb0cc04fe631d3d5c6d5625a', owner: 'riteme', repo: 'riteme.github.io', oauth: { client_id: 'd4fcffa25858a7a58e1a', client_secret: 'e0c8e08beb95497871f8355416c69390634cec76' }, perPage: 10, }); gitment.render('comments'); </script> </div> </div> <div class="mdl-cell sidebar"> <div class=article > <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">页面信息</div> <div class=mdl-card__supporting-text > 标签: <a href="/search.html?q=数据结构"><span class=label >数据结构</span></a> <a href="/search.html?q=字符串"><span class=label >字符串</span></a> <a href="/search.html?q=后缀数组"><span class=label >后缀数组</span></a> <a href="/search.html?q=诱导排序"><span class=label >诱导排序</span></a> <a href="/search.html?q=SA-IS"><span class=label >SA-IS</span></a><br/> 创建时间: 2016.06.19<br/> 上次修改: 2019.04.05<br/> 字数统计: 18660 字 / 约 1 小时 14 分钟 </div> </div> <br/> <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">目录</div> <div class=mdl-card__supporting-text > <div class=toc > <ul> <li><a href="#sa-is">诱导排序与 SA-IS 算法</a><ul> <li><a href="#1">1. 记号</a> <li><a href="#2-sa-is">2. SA-IS 算法</a><ul> <li><a href="#21">2.1 后缀类型</a> <li><a href="#22-lms">2.2 LMS 子串</a> <li><a href="#23-sa1-sa">2.3 从 SA1 诱导至 SA</a> <li><a href="#24-lms">2.4 对LMS子串排序</a> </ul> <li><a href="#3">3. 时空复杂度分析</a> <li><a href="#4">4. 运行示例</a> <li><a href="#5">5. 具体实现及性能对比</a> </ul> </ul> <ul><li><a href="#comments">评论区</a></ul></div> </div> </div> <br/> <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">数学公式渲染</div> <div class=mdl-card__supporting-text > <form name=mathopt > <label class="mdl-radio mdl-js-radio" for=option-1 > <input type=radio  id=option-1  class=mdl-radio__button  name=sel  value=mathjax > <span class=mdl-radio__label >MathJax</span> </label><br/> <label class="mdl-radio mdl-js-radio" for=option-2 > <input type=radio  id=option-2  class=mdl-radio__button  name=sel  value=katex > <span class=mdl-radio__label >KaTeX</span> </label> <div id=tip-1 > <label class="mdl-radio mdl-js-radio" for=option-3 > <input type=radio  id=option-3  class=mdl-radio__button  name=sel  value="katex&mathjax"> <span class=mdl-radio__label >Mixed</span> </label> </div> </form> <div id=tip-2 > <label class="mdl-checkbox mdl-js-checkbox" for=mathopt-align > <input type=checkbox  id=mathopt-align  class=mdl-checkbox__input > <span class=mdl-checkbox__label >居中显示</span> </label> </div> </div> </div> <div class=mdl-tooltip  data-mdl-for=tip-1 >先使用 KaTeX 渲染，再使用 MathJax 渲染</div> <div class=mdl-tooltip  data-mdl-for=tip-2 >该选项目前仅支持 KaTeX 渲染的公式<br/>点击公式可以切换单个公式的对齐方式</div> <br/> <div class="nano mdl-card mdl-shadow--2dp sidebar-card"> <a class=nano-ref  target=_new  href="http://nichijou.wikia.com/wiki/Nano_Shinonome"></a> <div class=mdl-card__actions > <div class=nano-shell ><span class=shell-start >$</span> nano <a href="https://github.com/riteme/riteme.github.io/blob/master/blog/2016-6-19/sais.md" id=nano-link >sais.md</a></div> </div> </div> <div class=mdl-tooltip  data-mdl-for=nano-link >查看原始 Markdown 文档</div> </div> </div> </div> <footer class=mdl-mega-footer > <div class=mdl-mega-footer__middle-section > <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >RITEME.SITE</h2><del>一个从不乱说话的博客</del> </div> <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >POWERED BY</h2> <ul class=mdl-mega-footer__link-list > <li><a href="http://pythonhosted.org/Markdown/">Python Markdown</a> <li><a href="http://getmdl.io/">Material Design Lite</a> <li><a href="http://www.tipue.com/search/">Tipuesearch</a> <li><a href="http://www.mathjax.org/">MathJax</a> & <a href="http://khan.github.io/KaTeX/">KaTeX</a> <li><a href="https://github.com/imsun/gitment">Gitment</a> </ul> </div> <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >友情链接</h2> <ul class=mdl-mega-footer__link-list > <li><a href="http://ruanx.pw/">ruanxingzhi</a> <li><a href="https://blog.xehoth.cc/">xehoth</a> <li><a href="http://hjwjbsr.is-programmer.com/">HJWJBSR</a> <li><a href="http://www.micdz.cn/">MicDZ</a> <li><a href="https://cmxrynp.github.io/">CMXRYNP</a> <li><a href="http://memset0.cn/">memset0</a> </ul> </div> </div> <div class=mdl-mega-footer__bottom-section >Theme based on <a href="https://getmdl.io/">MDL</a> | <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" class=cc  src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> CC BY-NC-SA 4.0 </div> </footer> </main> </div>