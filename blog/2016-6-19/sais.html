<!DOCTYPE html> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1.0"> <title>诱导排序与SA-IS算法 - riteme.site</title> <link rel="shortcut icon" href="/favicon.png" type="image/png"> <link rel=stylesheet  href="/styles/material-icons.css"> <link rel=stylesheet  href="/styles/material.min.css" > <link rel=stylesheet  href="/styles/gitment.css"> <link rel=stylesheet  href="/math-renderer/katex/katex.min.css"> <link rel=stylesheet  href="/styles/site.css"> <script src="/scripts/jquery.min.js"></script> <script src="/scripts/js-cookie.js"></script> <script src="/scripts/quicklink.umd.js"></script> <script defer src="/scripts/material.min.js"></script> <script src="/scripts/site.js"></script> <script src="/scripts/gitment.js"></script> <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header"> <header class=mdl-layout__header > <div class=mdl-layout__header-row > <span class=mdl-layout-title >诱导排序与SA-IS算法</span> <div class=mdl-layout-spacer ></div> <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right"> <label class="mdl-button mdl-js-button mdl-button--icon" for=fixed-header-drawer-exp ><i class=material-icons >search</i></label> <div class=mdl-textfield__expandable-holder > <form action="/search.html"><input type=text  class=mdl-textfield__input  placeholder="Search Here" name=q  id=fixed-header-drawer-exp  autocomplete=off  required></form> </div> </div> </div> </header> <div class=mdl-layout__drawer > <span class="mdl-layout-title drawer-title"> <a href="/index.html" style="color: inherit; font-weight: inherit;text-decoration: none;"><img src="/favicon.png" width=32 height=32> riteme.site</a> </span> <nav class=mdl-navigation > <a class=mdl-navigation__link  href="/index.html"><i class="material-icons drawer-icon">home</i> 首页</a> <a class=mdl-navigation__link  href="/posts.html"><i class="material-icons drawer-icon">library_books</i> 所有文章</a> <a class=mdl-navigation__link  href="/about.html"><i class="material-icons drawer-icon">info</i> 关于</a> <a class=mdl-navigation__link  href="/links.html"><i class="material-icons drawer-icon">link</i> 友链</a> <a class=mdl-navigation__link  href="/search.html"><i class="material-icons drawer-icon">search</i> 搜索</a> <a class=mdl-navigation__link  href="https://github.com/riteme/riteme.github.io"><i class="material-icons drawer-icon">class</i> GitHub 项目</a> </nav> </div> <main class=mdl-layout__content > <div class=mdl-grid > <div class="mdl-cell main-cell"> <div class="article main-article" lang=en-US > <h1 id=sa-is >诱导排序与 SA-IS 算法</h1> <p>SA-IS 是一种在实际运用中相当快速的、线性时间构建字符串的后缀数组的算法。本文将通过对原论文<sup id="fnref:paper"><a class=footnote-ref  href="#fn:paper" rel=footnote >1</a></sup>进行一些翻译和总结来介绍该算法。最后会提供一个 SA-IS 算法的 C++ 实现。</p> <h2 id=1 >1. 记号</h2> <p>现在先规定一些记号，以方便之后的讨论。</p> <p>我们通常使用大写字母 <tex>$S, A, B, \dots$</tex> 来表示一个字符串，小写字母 <tex>$a, b, c, \dots$</tex> 表示单个的字符。字符通常可以用整数来表示，例如 ASCII 码。字符在一定条件下数量是有限的，我们将所有会用到的字符放入字符集 <tex>$\Sigma$</tex> 中，此时 <tex>$|\Sigma|$</tex> 表示字符集的大小。字符串之间可以任意连接，如 <tex>$AB$</tex> 表示字符串 <tex>$A$</tex> 与字符串 <tex>$B$</tex> 依次连接而成的新字符串。字符串与单个字符之间也是如此。特别的，我们将空串记为 <tex>$\epsilon$</tex>。</p> <p>对于一个字符串我们可以访问其中的任意字符，用 <tex>$S[x]$</tex> 表示 <tex>$S$</tex> 中下标为 <tex>$x$</tex> 的字符。下标从 <tex>$0$</tex> 开始。我们用 <tex>$S[a, b]$</tex> 表示 <tex>$S$</tex> 的一个子串，即下标为 <tex>$a$</tex> 的字符开始一直到下标为 <tex>$b$</tex> 的字符依次连接而成的字符串，其中必须满足 <tex>$0 \le a \le b \lt |S|$</tex>。定义一个字符串 <tex>$S$</tex> 的前缀为 <tex>$\text{prefix}(S, i) = S[0, i]$</tex>，其后缀为 <tex>$\text{suffix}(S, i) = S[i, |S| - 1]$</tex>。</p> <p>两个字符串 <tex>$A$</tex> 和 <tex>$B$</tex> 之间存在比较关系。当 <tex>$A$</tex> 与 <tex>$B$</tex> 的长度相同，且其中对应下标的字符也相同时，则为 <tex>$A = B$</tex>。当从左至右出现第一对不相同的字符时，则以这两个字符的大小关系作为 <tex>$A$</tex> 和 <tex>$B$</tex> 间的大小关系，这称为字典序。为了简化一些操作，定义 <tex>$\#$</tex> 是字典序最小的字符，其字典序小于 <tex>$\Sigma$</tex> 中的任意字符，并且将其默认作为每个字符串的最后一个字符<sup id="fnref:dollar"><a class=footnote-ref  href="#fn:dollar" rel=footnote >2</a></sup>，即作为 <tex>$S[|S|]$</tex>。<br /> 另外，定义函数 <tex>$\text{lcp}(A, B)$</tex> 表示 <tex>$A$</tex> 和 <tex>$B$</tex> 的最长公共前缀的长度，即两者所有相同的前缀中，最长的一个的长度。由此我们可以得知字典序的一个性质：</p> <p><strong>定理 1.1</strong> <tex>$A &lt; B$</tex> 当且仅当 <tex>$A[\text{lcp}(A, B)] &lt; B[\text{lcp}(A, B)]$</tex>。</p> <p><strong>证明</strong>　这个结论显然成立，因为 <tex>$\text{prefix}(A, \text{lcp}(A, B) - 1) = \text{prefix}(B, \text{lcp}(A, B) - 1)$</tex>。</p> <h2 id=2-sa-is >2. SA-IS 算法</h2> <p>SA-IS 算法是基于诱导排序这种思想。基本想法就是将问题的规模缩小，通过解决更小的问题，获取足够信息，就可以快速的解决原始问题。从这里也可以看出，这一过程需要递归处理子问题。</p> <p>在介绍 SA-IS 算法前，我们先来看一下该算法的基本框架：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal > 1</span>
<span class=normal > 2</span>
<span class=normal > 3</span>
<span class=normal > 4</span>
<span class=normal > 5</span>
<span class=normal > 6</span>
<span class=normal > 7</span>
<span class=normal > 8</span>
<span class=normal > 9</span>
<span class=normal >10</span>
<span class=normal >11</span>
<span class=normal >12</span>
<span class=normal >13</span>
<span class=normal >14</span>
<span class=normal >15</span>
<span class=normal >16</span>
<span class=normal >17</span></pre></div><td class=code ><div class=codehilite ><pre><span></span>function SA-IS(S):
    t = bool[]
    S1 = int[]
    P = int[]
    bucket = int[]
    扫描倒序字符串确定每一个后缀的类型 -&gt; t
    扫描t数组确定所有的 LMS 子串 -&gt; P
    对所有的 LMS 子串进行诱导排序
    对每一个 LMS 子串重新命名，生成新的串 S1

    if S1 中的每一个字符都不一样:
        直接计算 SA1
    else
        SA1 = SA-IS(S1)  # 递归计算 SA1

    利用 SA1 来进行诱导排序，计算 SA
    return SA
</pre></div> </table> <p>现在你不会明白这里面都写了些什么东西，因为这只是一个简单的流程。接下来将会介绍其中的每一步并证明其正确性。</p> <h3 id=21 >2.1 后缀类型</h3> <p>在第 6 行中，确定后缀的类型可能会令人无法理解，这是因为我们还没有定义什么是后缀的类型......</p> <p>对于每一个后缀 <tex>$\text{suffix}(S, i)$</tex>，当 <tex>$\text{suffix}(S, i) &lt; \text{suffix}(S, i + 1)$</tex> 时，是 <tex>$S$</tex> 型后缀。当 <tex>$\text{suffix}(S, i) &gt; \text{suffix}(S, i + 1)$</tex> 时，是 <tex>$L$</tex> 型后缀。对于特殊的后缀 <tex>$\text{suffix}(S, |S|) = \#$</tex>，它默认为 <tex>$S$</tex> 型。<br /> 例如，对于字符串 <code>mmiissiissiippii</code>，每一后缀的类型为：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal >1</span>
<span class=normal >2</span>
<span class=normal >3</span></pre></div><td class=code ><div class=codehilite ><pre><span></span>      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #
t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S
</pre></div> </table> <p>既然我们需要得知每一个后缀类型，就需要一个快速的算法来计算。在此之前，我们发现它们有如下的性质：</p> <p><strong>引理 2.1</strong>　(后缀类型递推性质) 对于任意的 <tex>$i \in [0, |S| - 1]$</tex>:<br /> 如果 <tex>$t[i] = \text{S-type}$</tex>，当且仅当下面任意一项成立：</p> <ol> <li><tex>$S[i] &lt; S[i + 1]$</tex> <li><tex>$S[i] = S[i + 1]$</tex> 且 <tex>$t[i + 1] = \text{S-type}$</tex> </ol> <p>如果 <tex>$t[i] = \text{L-type}$</tex>，当且仅当下面任意一项成立：</p> <ol> <li><tex>$S[i] &gt; S[i + 1]$</tex> <li><tex>$S[i] = S[i + 1]$</tex> 且 <tex>$t[i + 1] = \text{L-type}$</tex> </ol> <p><strong>证明</strong>　这里证明 <tex>$S$</tex> 型的，<tex>$L$</tex> 型是类似的。对于第一种情况，显然是成立的。对于第二种情况，我们设 <tex>$\text{suffix}(S, i) = aA, \text{suffix}(S, i + 1) = aB$</tex>。由于第一个字符是相同的，因此我们需要比较 <tex>$A$</tex> 和 <tex>$B$</tex> 的大小。因为它们是连续的后缀，所以 <tex>$A = \text{suffix}(S, i + 1), B = \text{suffix}(S, i + 2)$</tex>。由于我们是从右往左推出 <tex>$t$</tex>，所以 <tex>$A$</tex> 与 <tex>$B$</tex> 的关系实际上可以由 <tex>$t[i + 1]$</tex> 给出。故 <tex>$t[i] = t[i + 1]$</tex>。</p> <p>因此，我们可以在 <tex>$\Theta(|S|)$</tex> 的时间内，推出整个 <tex>$t$</tex> 数组。</p> <p>关于后缀类型，我们还可得出另外一个比较重要的性质：</p> <p><strong>引理 2.2</strong>　(后缀类型指导排序) 对于两个后缀 <tex>$A$</tex> 和 <tex>$B$</tex>，如果 <tex>$A[0] = B[0]$</tex> 且 <tex>$A$</tex> 是 <tex>$S$</tex> 型，<tex>$B$</tex> 是 <tex>$L$</tex> 型，则 <tex>$A &gt; B$</tex>。</p> <p><strong>证明</strong>　设 <tex>$A = abX, B = acY$</tex>，这里假设 <tex>$a \neq b$</tex>，<tex>$a \neq c$</tex>。因为 <tex>$A$</tex> 是 <tex>$S$</tex> 型，所以可知 <tex>$a &lt; b$</tex>。同理，<tex>$B$</tex> 是 <tex>$L$</tex> 型，可知 <tex>$a &gt; c$</tex>。故 <tex>$ c &lt; a &lt; b$</tex>，所以 <tex>$A &gt; B$</tex>。如果 <tex>$a = b$</tex> 但 <tex>$a \neq c$</tex>，那么 <tex>$b = a &gt; c$</tex> 即 <tex>$A &gt; B$</tex>，对于 <tex>$a = c$</tex>，<tex>$a \neq b$</tex> 同理。如果 <tex>$a = b = c$</tex>，则我们可以将 <tex>$A$</tex> 和 <tex>$B$</tex> 的第一个字符去掉，用新的后缀来进行比较。根据引理 2.1，去掉第一个字符后的后缀类型不变。因此我们可以通过这样的操作直到变为第一种情况。</p> <h3 id=22-lms >2.2 LMS 子串</h3> <p>然而光有后缀类型，还不足以进行排序。因此我们在后缀类型的 <tex>$S$</tex> 型中挑出特别的一类，记为 <tex>$*$</tex> 型。<tex>$*$</tex> 型是 <tex>$S$</tex> 型的一种，它的特殊之处在于它要求它的左边的后缀必须是 <tex>$L$</tex> 型的。依然以 <code>mmiissiissiippii</code> 为例：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal >1</span>
<span class=normal >2</span>
<span class=normal >3</span>
<span class=normal >4</span></pre></div><td class=code ><div class=codehilite ><pre><span></span>      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #
t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S
            *           *           *                 *
</pre></div> </table> <p>可以将其理解为一连串的 <tex>$S$</tex> 型中最靠左的一个。LMS (<strong>L</strong>eft<strong>M</strong>ost <strong>S</strong>-type) 也正是这个意思。同时我们注意到，后缀 <tex>$\#$</tex> 始终是 <tex>$*$</tex> 型的。<br /> 对于每一个 <tex>$*$</tex> 型所对应上的字符，我们称为 LMS 字符。上面的示例中，下标为 <tex>$2, 6, 10, 16$</tex> 都是 LMS 字符。<br /> 位置相邻的两个 LMS 字符中间（包括这两个字符）所构成的子串，称为 LMS 子串。特殊的，最后一个字符 <code>#</code> 单独作为一个平凡的 LMS 子串。对于 <code>mmiissiissiippii</code>，其 LMS 子串依次为 <code>iissi</code>、<code>iissi</code>、<code>iippii#</code> 和 <code>#</code>。</p> <p>通过观察，我们发现 LMS 子串具有以下的性质：</p> <p><strong>引理 2.3</strong> <code>#</code> 是最短的 LMS 子串。</p> <p><strong>引理 2.4</strong>　对于任意的非 <code>#</code> 的 LMS 子串，其长度大于 <tex>$2$</tex>。</p> <p><strong>证明</strong>　因为两个 LMS 字符中间必定有一个 <tex>$L$</tex> 型的后缀。</p> <p><strong>引理 2.5</strong>　(原串折半) 一个字符串中 LMS 子串的数量不超过 <tex>$\left\lceil{|S| / 2}\right\rceil$</tex>。</p> <p><strong>证明</strong>　根据引理 2.4 可知。</p> <p><strong>引理 2.6</strong>　一个字符串的所有 LMS 子串的长度之和为 <tex>$O(|S|)$</tex>。</p> <p><strong>证明</strong>　除了 <tex>$*$</tex> 型后缀对应的字符最多出现在两个 LMS 子串内，其余字符只会出现在一个 LMS 子串内。因此总长不超过 <tex>$2n$</tex>。</p> <p>对于 LMS 子串间的大小比较，除了对每个字符的字典序进行比较外，还要对比每个字符所对应的后缀类型。字符相同的情况下，<tex>$S$</tex> 型的字典序更大，因为根据引理 2.2 可得，首字符相同的情况下，<tex>$S$</tex> 型的后缀字典序更大。只有当每一个字符以及后缀类型都相同时，这两个 LMS 子串才被称为是相同的。<br /> 换言之，两个 LMS 子串之间的字典序比较是将原串转为 <code>(字符，后缀类型)</code> 的序列后再比较的。<br /> 之所以这样定义，是因为在之后我们会利用 LMS 子串来进行对后缀的排序。如果缺少后缀类型的信息，就会出现问题。</p> <p><strong>引理 2.7</strong>　对任意两个 LMS 子串，不存在一个 LMS 子串是另外一个 LMS 子串的真前缀。</p> <p><strong>证明</strong>　如果其中一个 LMS 子串是 <code>#</code>，由于 <code>#</code> 只出现了一次，并且对于非平凡的 LMS 子串，<code>#</code> 只能出现在最后，所以不会有真前缀的关系。否则假设这两个 LMS 子串分别为 <tex>$A$</tex> 和 <tex>$B$</tex>，并且 <tex>$A$</tex> 是 <tex>$B$</tex> 的真前缀，由于 <tex>$A$</tex> 的最后一个字符是 <tex>$*$</tex> 型，那么易知 <tex>$B$</tex> 内部包含了一个 <tex>$*$</tex> 型后缀，这与 LMS 子串的定义矛盾。</p> <p>举个例子：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal >1</span>
<span class=normal >2</span>
<span class=normal >3</span></pre></div><td class=code ><div class=codehilite ><pre><span></span>acbbccbbccbab#
SLSSLLSSLLLSLS
  *   *    * *
</pre></div> </table> <p>（来自 <a href="https://github.com/Wild-Donkey">@Wild-Donkey</a> 的评论）</p> <p>注意第一个 LMS 子串 <code>bbccb</code> 和第二个子串 <code>bbccba</code>。虽然 <code>bbccb</code> 是 <code>bbccba</code> 的真前缀，但是 <code>bbccb</code> 最后一个 <code>b</code> 的后缀类型是 <tex>$S$</tex> 型，而 <code>bbccba</code> 的最后一个 <code>b</code> 是 <tex>$L$</tex> 型，所以第一个 LMS 子串不算第二个 LMS 子串的前缀。</p> <p>根据引理 2.6，我们可以利用<strong>基数排序</strong>在 <tex>$O(|S|)$</tex> 的时间内对所有的 LMS 子串排序<sup id="fnref:lms-sort"><a class=footnote-ref  href="#fn:lms-sort" rel=footnote >3</a></sup>。对 LMS 子串排序完后，我们按照字典序依次重新命名<sup id="fnref:lms-name"><a class=footnote-ref  href="#fn:lms-name" rel=footnote >4</a></sup>，注意，如果两个 LMS 子串相同，则使用同样的名称<sup id="fnref:lms-compare"><a class=footnote-ref  href="#fn:lms-compare" rel=footnote >5</a></sup>。这样给每个 LMS 子串命名后，按照其子串原有的顺序排出一个新串 <tex>$S_1$</tex>。继续以 <code>mmiissiissiippii</code> 为例：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal >1</span>
<span class=normal >2</span>
<span class=normal >3</span>
<span class=normal >4</span>
<span class=normal >5</span>
<span class=normal >6</span></pre></div><td class=code ><div class=codehilite ><pre><span></span>      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #
t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S
            *           *           *                 *
新名称       2           2           1                 0
S1:   2 2 1 0
</pre></div> </table> <p>这样有什么用呢？我们发现，这实际上是将所有 <tex>$*$</tex> 型的后缀进行了缩减，从而减小了问题的规模。对于这一点，我们有如下的引理：</p> <p><strong>引理 2.8</strong>　(问题缩减) <tex>$S_1$</tex> 中两个后缀的字典序关系，就是 <tex>$S$</tex> 中对应的 <tex>$*$</tex> 型后缀的字典序关系。</p> <p><strong>证明</strong>　我们可以想象一下字符串比较的过程。在 <tex>$S_1$</tex> 中比较两个字符，相当于在 <tex>$S$</tex> 中比较两个 LMS 子串。由于不存在两个 LMS 子串，满足其中一个是另外一个子串的真前缀，所以被比较的两个 LMS 子串要么完全相同，要么存在一个位置上对应字符不同，或者在对应位置字符相同时，对应的后缀类型不同。由于我们将 <tex>$S$</tex> 型的后缀设置了更高的优先级，因此结合引理 2.2，在对应字符相同时，<tex>$S$</tex> 型的后缀确实字典序更大。由此不难得处 <tex>$S$</tex> 中的字典序关系和 <tex>$S_1$</tex> 中是相同的。</p> <p>需要注意的是这里只是 <tex>$*$</tex> 型后缀的字典序关系，与其它后缀无关。</p> <h3 id=23-sa1-sa >2.3 从 SA1 诱导至 SA</h3> <p>从上面的引理 2.8 我们得知，只要获得了 <tex>$S_1$</tex> 的后缀数组 <tex>$SA_1$</tex>，就可以得到所有 <tex>$*$</tex> 型后缀的相对顺序。如果我们可以利用 <tex>$*$</tex> 型后缀的相对顺序来对其它的 <tex>$L$</tex> 型和 <tex>$S$</tex> 型后缀<sup id="fnref:star-in-S"><a class=footnote-ref  href="#fn:star-in-S" rel=footnote >6</a></sup>进行排序，就可以完成后缀数组的计算。</p> <p>在这里我们先假定 <tex>$SA_1$</tex> 已经计算出来，只需考虑如何计算 <tex>$SA$</tex>。在这之前，我们先观察一下后缀数组的形式。以 <code>aabaaaab</code> 为例，它的后缀数组是这样的：</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal >1</span>
<span class=normal >2</span>
<span class=normal >3</span>
<span class=normal >4</span>
<span class=normal >5</span>
<span class=normal >6</span>
<span class=normal >7</span>
<span class=normal >8</span>
<span class=normal >9</span></pre></div><td class=code ><div class=codehilite ><pre><span></span>#
aaaab#
aaab#
aab#
aabaaaab#
ab#
abaaaab#
b#
baaaab#
</pre></div> </table> <p>不难发现，首字母相同的后缀是连续排布的，这一点可以用反证法来证明。因此我们可以利用桶排序的思想，为每一个出现过的字符建立一个桶，用 <tex>$SA$</tex> 数组来存储这些桶，每个桶之间按照字典序排列，这样就可以使后缀数组初步有序。<br /> 我们对每个后缀都赋予了一个后缀类型，那么在首字母一样的情况下，<tex>$S$</tex> 型或 <tex>$L$</tex> 型会连续分布吗？答案是肯定的。因为根据引理 2.2，首字母相同的后缀如果后缀类型不同，则相对顺序是确定的。因此易知不会出现 <tex>$S$</tex> 型和 <tex>$L$</tex> 型交替出现的情况。更进一步，由于 <tex>$L$</tex> 型后缀更小，因此总是先排布 <tex>$L$</tex> 型后缀，再排布 <tex>$S$</tex> 型后缀。因此每一个字符的桶可以分为两部分，一个用于放置 <tex>$L$</tex> 型后缀，另一个则用于 <tex>$S$</tex> 型后缀。为了方便确定每一个桶的起始位置，<tex>$S$</tex> 型后缀的桶的放置是倒序的。<br /> 但是如果首字母和后缀类型都一致，我们不能直接快速地判断大小关系。在这里就要利用到诱导排序了。</p> <p>诱导排序的过程分为以下几步：</p> <ol> <li>将 <tex>$SA$</tex> 数组初始化为每个元素都为 <tex>$-1$</tex> 的数组。 <li>确定每个桶 <tex>$S$</tex> 型桶的起始位置。将 <tex>$SA_1$</tex> 中的每一个 <tex>$*$</tex> 型后缀按照 <tex>$SA_1$</tex> 中的顺序放入相应的桶内。 <li>确定每个桶 <tex>$L$</tex> 型桶的起始位置。在 <tex>$SA$</tex> 数组中从左往右扫一遍。如果 <tex>$SA[i] &gt; 0$</tex> 且 <tex>$t[SA[i] - 1] = \text{L-type}$</tex>，则将 <tex>$SA[i] - 1$</tex> 所代表的后缀放入对应的桶中。 <li>重新确定每个桶 <tex>$S$</tex> 型桶的起始位置，因为所有的 <tex>$*$</tex> 型后缀要重新被排序。由于 <tex>$S$</tex> 型桶是逆序排放的，所以这次从右至左地扫描一遍 <tex>$SA$</tex>。如果 <tex>$SA[i] &gt; 0$</tex> 且 <tex>$t[SA[i] - 1] = \text{S-type}$</tex>，则将 <tex>$SA[i] - 1$</tex> 所代表的后缀放入对应的桶中。 </ol> <p>这样我们就可以完成从 <tex>$SA_1$</tex> 诱导到 <tex>$SA$</tex> 的排序工作。这里简单说明一下为什么这样做是正确的：首先对于所有的 <tex>$*$</tex> 型后缀，都是有序排放的。从左至右扫描 <tex>$SA$</tex> 数组实际上就是按照字典序扫描现有的已排序的后缀。对于两个相邻的 <tex>$L$</tex> 型后缀 <tex>$A$</tex> 和 <tex>$B$</tex>，这里假设 <tex>$|A| &gt; |B|$</tex>，则必定有 <tex>$A &gt; B$</tex>。由于 <tex>$B$</tex> 会被先加入 <tex>$SA$</tex> 中，所以我们保证了 <tex>$A$</tex> 和 <tex>$B$</tex> 之间的有序性。又因为 <tex>$L$</tex> 型桶是从左往右的顺序加入的，所以所有的 <tex>$L$</tex> 型后缀会逐步地按顺序加入到 <tex>$SA$</tex> 中。最后所有的 <tex>$L$</tex> 型后缀将会有序。<br /> 对于 <tex>$S$</tex> 型后缀，除了要注意是相反的顺序和需要重新对 <tex>$*$</tex> 型后缀排序外，其余的原理与 <tex>$L$</tex> 型的排序类似。</p> <p>之前的讨论都是基于我们已知 <tex>$SA_1$</tex> 的情况下进行的。现在我们来考虑如何计算 <tex>$SA_1$</tex>。由于 <tex>$S_1$</tex> 也是一个字符串，计算其后缀数组时可以考虑两种情况：</p> <ol> <li>如果 <tex>$S_1$</tex> 中每一个字符都不一样，则可以直接利用桶排序直接计算 <tex>$SA_1$</tex>。 <li>否则，递归计算 <tex>$SA_1$</tex>。就如之前的算法框架所展示的一样。 </ol> <h3 id=24-lms >2.4 对 LMS 子串排序</h3> <p>到这里，SA-IS 算法几乎已经结束了，只是还有一个问题需要解决，就是对 LMS 子串的排序。<br /> 之前我们所提及的，我们可以利用基数排序。虽然可以在 <tex>$O(|S|)$</tex> 的时间内完成，但是事实上，这个基数排序不但常数大，而且十分复杂（请想象一下对字符串进行基数排序&hellip;）。这个排序直接成为了整个算法的性能瓶颈。因此我们急需一种新的算法来完成这一任务。<br /> 这个算法依然是<strong>诱导排序</strong>。</p> <p>与之前从 <tex>$SA_1$</tex> 诱导到 <tex>$SA$</tex> 的算法一样，只是我们这里将第二步改为：</p> <blockquote> <p>确定每个桶 <tex>$S$</tex> 型桶的起始位置。将每一个 LMS 后缀的首字母（即 LMS 字符）按照<strong>任意顺序</strong>放入对应的桶中。</p> </blockquote> <p>待算法完成，我们会获得一个 <tex>$SA$</tex> 数组，其中 LMS 子串之间是排好了序的。</p> <p>为什么这个算法是正确的，我们需要扯到一个新的概念：LMS 前缀<sup id="fnref:lms-prefix"><a class=footnote-ref  href="#fn:lms-prefix" rel=footnote >7</a></sup>。<br /> 规定 LMS 前缀函数 <tex>$\text{pre}(S, i)$</tex> 表示 (1) 如果 <tex>$\text{suffix}(S, i)$</tex> 是 <tex>$*$</tex> 型的，则 <tex>$\text{pre}(S, i) = S[i]$</tex>，即 LMS 字符的 LMS 前缀就是自己。所以上面说到的步骤就是将所有长度为 <tex>$1$</tex> 的 LMS 前缀按任意顺序放入对应的桶中。 (2) 否则是从 <tex>$S[i]$</tex> 开始，到右边第一个 LMS 字符之间（包括首尾）的子串。同样的，按照 <tex>$\text{suffix}(S, i)$</tex> 的后缀类型的不同，LMS 前缀 <tex>$\text{pre}(S, i)$</tex> 也同样分为 <tex>$S$</tex> 型和 <tex>$L$</tex> 型。<br /> 例如，在 <code>mmiissiissiippii</code> 中，<tex>$\text{pre}(S, 2) = S[2] =$</tex> <code>i</code>，而 <tex>$\text{pre}(S, 3) = S[3, 6] =$</tex> <code>issi</code>。<br /> LMS 前缀之间的字典序比较遵循 LMS 子串中的规定（即考虑后缀类型），毕竟它们是 LMS 子串的子串。</p> <p>接下来将证明 2-4 步都是正确的：</p> <ol> <li>对于第二步，由于放入的 LMS 前缀都只有一个字符，因为桶的排列是按照字典序的，所以保证放置后一定有序。 <li>对于第三步，当放入第一个 <tex>$L$</tex> 型 LMS 前缀时，由于 <tex>$SA$</tex> 中还只有 <tex>$S$</tex> 型的 LMS 前缀，所以 <tex>$SA$</tex> 数组必定是有序的。假设我们已经放置了 <tex>$k$</tex> 个 <tex>$L$</tex> 型 LMS 前缀，且它们在 <tex>$SA$</tex> 数组中保持有序，现在考虑放入的第 <tex>$k + 1$</tex> 个 LMS 前缀是否会保证有序。我们设这个 LMS 前缀为 <tex>$\text{pre}(S, i)$</tex>，因为首字母不同的 LMS 前缀之间一定是保持有序的，因此我们只需要考虑它与其首字母相同的 LMS 前缀之间的关系。因为我们是从左至右扫描来使 <tex>$L$</tex> 型 LMS 前缀从小至大放置，那么对于所有之前放置的且首字母与其相同的 LMS 前缀 <tex>$\text{pre}(S, j)$</tex>，应该都有 <tex>$\text{pre}(S, j) &lt; \text{pre}(S, i)$</tex>。假设我们存在一个这样的 LMS 前缀，满足 <tex>$\text{pre}(S, j) &gt; \text{pre}(S, i)$</tex>，由于 <tex>$\text{pre}(S, j)[0] = \text{pre}(S, i)[0]$</tex>，所以我们得知 <tex>$\text{pre}(S, j + 1) &gt; \text{pre}(S, i + 1)$</tex>。而 <tex>$\text{pre}(S, j + 1)$</tex> 与 <tex>$\text{pre}(S, i + 1)$</tex> 一定是之前加入过的（也可能是第二步中的 <tex>$S$</tex> 型 LMS 前缀），因此它们之间应当保持有序。而 <tex>$\text{pre}(S, j) &gt; \text{pre}(S, i)$</tex> 告诉我们之前的 <tex>$SA$</tex> 数组不是有序的，与假设相反，故不存在这样的 <tex>$\text{pre}(S, j)$</tex>。因此，当 <tex>$\text{pre}(S, i)$</tex> 放置后，<tex>$SA$</tex> 数组保持有序。上述归纳直到所有的 <tex>$L$</tex> 型LMS前缀加入完毕，可以推出所有的 <tex>$L$</tex> 型 LMS 前缀之间都是有序的。 <li>先总结一下前面的步骤：首先是对所有 <tex>$L$</tex> 型的 LMS 前缀排序，然后用排好序的 <tex>$L$</tex> 型 LMS 前缀接着对 <tex>$S$</tex> 型 LMS 前缀排序。对于第四步的正确性的证明，与第三步的证明是类似的。不过这里需要注意一点，实际上这个地方的排序相当于不断地在左侧加字符，并且诱导排序会覆盖第二步里面放好的 <tex>$S$</tex> 型前缀，所以当 LMS 后缀 <tex>$\text{suffix}(S, i)$</tex> 再一次被加入到 <tex>$SA$</tex> 数组的时候，它已经不是代表 <tex>$\text{pre}(S, i)$</tex> 这个 LMS 前缀了，而是就代表以 <tex>$S[i]$</tex> 为首字母的 LMS 子串。相当于这个 LMS 子串是从其右边第一个 LMS 字符开始，一步一步向左加字符得到的。换句话说，当第四步完成时，所有的 LMS 子串就已经完成排序了。 </ol> <p>我们可以直接对 <tex>$SA$</tex> 数组扫描一遍，就可以得到 LMS 子串的字典序，同时对它们进行命名。</p> <h2 id=3 >3. 时空复杂度分析</h2> <p>在之前的讨论中，我们已经成功的运用诱导排序使每一步都是 <tex>$\Theta(|S|)$</tex>。但是由于有一个递归的过程，时间复杂度似乎并不一定是线性的。<br /> 我们注意到，每次递归都是计算 <tex>$S_1$</tex> 的后缀数组。如果我们能够知道 <tex>$S_1$</tex> 的规模，就能够计算 SA-IS 的事件复杂度。<br /> 根据引理 2.5，我们得知 <tex>$|S_1| \le \left\lceil|S| / 2\right\rceil$</tex>。因此每一层的递归的问题规模都会减半。因此我们可以用以下的递归式来表示时间复杂度：</p> <p><tex>$$ T(n) = T(\left\lceil n/2\right\rceil) + \Theta(n) \tag{3.1} $$</tex></p> <p>求解可得：</p> <p><tex>$$ T(n) = \Theta(n) \tag{3.2} $$</tex></p> <p>因此总时间复杂度是 <tex>$\Theta(n)$</tex> 的。<br /> 对于这个递归式，我们可以理解为是递归了 <tex>$O(\log n)$</tex> 层，其中每一层的问题规模从小到大排序是 <tex>$2^0, 2^1, 2^2, \dots, 2^{\left\lfloor\log n\right\rfloor}$</tex>。因此总复杂度就是对它们进行求和：</p> <p><tex>$$ \sum^{\left\lfloor\log n\right\rfloor}_{k=0} 2^k = 2 \times 2^{\left\lfloor\log n\right\rfloor} = \Theta(2^{\left\lfloor\log n\right\rfloor}) = \Theta(n) \tag{3.3} $$</tex></p> <p>对于空间复杂度的分析，与时间复杂度是如出一辙的。</p> <h2 id=4 >4. 运行示例</h2> <p>下面将用 <code>aabaaaab</code> 作为输入字符串，展示计算其后缀数组的每一步。希望能通过这个示例能够更清晰地展现 SA-IS 算法的运作流程。由于涉及到对桶的操作，这里用 <code>@</code> 表示正在被处理的元素，而用 <code>^</code> 表示每个桶的起始位置。</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal > 1</span>
<span class=normal > 2</span>
<span class=normal > 3</span>
<span class=normal > 4</span>
<span class=normal > 5</span>
<span class=normal > 6</span>
<span class=normal > 7</span>
<span class=normal > 8</span>
<span class=normal > 9</span>
<span class=normal >10</span>
<span class=normal >11</span>
<span class=normal >12</span>
<span class=normal >13</span>
<span class=normal >14</span>
<span class=normal >15</span>
<span class=normal >16</span>
<span class=normal >17</span>
<span class=normal >18</span>
<span class=normal >19</span>
<span class=normal >20</span>
<span class=normal >21</span>
<span class=normal >22</span>
<span class=normal >23</span>
<span class=normal >24</span>
<span class=normal >25</span>
<span class=normal >26</span>
<span class=normal >27</span>
<span class=normal >28</span>
<span class=normal >29</span>
<span class=normal >30</span>
<span class=normal >31</span>
<span class=normal >32</span>
<span class=normal >33</span>
<span class=normal >34</span>
<span class=normal >35</span>
<span class=normal >36</span>
<span class=normal >37</span>
<span class=normal >38</span>
<span class=normal >39</span>
<span class=normal >40</span>
<span class=normal >41</span>
<span class=normal >42</span>
<span class=normal >43</span>
<span class=normal >44</span>
<span class=normal >45</span>
<span class=normal >46</span>
<span class=normal >47</span>
<span class=normal >48</span>
<span class=normal >49</span>
<span class=normal >50</span>
<span class=normal >51</span>
<span class=normal >52</span>
<span class=normal >53</span>
<span class=normal >54</span>
<span class=normal >55</span>
<span class=normal >56</span>
<span class=normal >57</span>
<span class=normal >58</span>
<span class=normal >59</span>
<span class=normal >60</span>
<span class=normal >61</span>
<span class=normal >62</span>
<span class=normal >63</span>
<span class=normal >64</span>
<span class=normal >65</span>
<span class=normal >66</span>
<span class=normal >67</span>
<span class=normal >68</span>
<span class=normal >69</span>
<span class=normal >70</span>
<span class=normal >71</span>
<span class=normal >72</span>
<span class=normal >73</span>
<span class=normal >74</span>
<span class=normal >75</span>
<span class=normal >76</span>
<span class=normal >77</span>
<span class=normal >78</span>
<span class=normal >79</span>
<span class=normal >80</span>
<span class=normal >81</span>
<span class=normal >82</span>
<span class=normal >83</span></pre></div><td class=code ><div class=codehilite ><pre><span></span>           0  1  2  3  4  5  6  7  8
S:         a  a  b  a  a  a  a  b  #
扫描后缀类型
t:         S  S  L  S  S  S  S  L  S
LMS characters:     *              *
         |# |       a         |  b  |  # 桶的名称
SA:       -1|-1 -1 -1 -1 -1 -1|-1 -1
对LMS子串进行排序
1. 放入LMS子串
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
2. 从*型LMS前缀诱导到L型LMS前缀
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
          @^  ^                 ^
SA:       08|-1 -1 -1 -1 -1 03|07 -1
           ^  ^             @      ^
SA:       08|-1 -1 -1 -1 -1 03|07 02  # pre(S, 6)不是L型的
           ^  ^                @   ^
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^  ^                   @^
SA:       08|-1 -1 -1 -1 -1 03|07 02
3. 从L型LMS前缀诱导到S型前缀
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^                 ^    @^
SA:       08|-1 -1 -1 -1 -1 01|07 02
           ^              ^    @   ^
SA:       08|-1 -1 -1 -1 06 01|07 02
           ^           ^    @      ^
SA:       08|-1 -1 -1 00 06 01|07 02
           ^        ^    @         ^
SA:       08|-1 -1 05 00 06 01|07 02  # 不存在pre(S, -1)
           ^     ^    @            ^
SA:       08|-1 -1 05 00 06 01|07 02
           ^     ^ @               ^
SA:       08|-1 04 05 00 06 01|07 02
           ^  ^ @                  ^
SA:       08|03 04 05 00 06 01|07 02
           ^ @^                    ^
SA:       08|03 04 05 00 06 01|07 02  # pre(S, 7)不是S型的
          @^  ^                    ^
SA:       08|03 04 05 00 06 01|07 02
扫描并重命名LMS子串
name:      1  2
S1:       2 1 0
由于每一个字符都不一样，直接计算SA1
SA1：     2 1 0
从SA1诱导到SA
         |$ |       a         |  b  |
SA:       -1|-1 -1 -1 -1 -1 -1|-1 -1
1. 按照SA1的原顺序放入(忽略S1最后的字符)
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
           ^  ^                 ^
2. 从*型后缀诱导到L型后缀
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
          @^  ^                 ^
SA:       08|-1 -1 -1 -1 -1 03|07 -1
           ^  ^             @      ^
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^  ^                @   ^
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^  ^                   @^
3. 从L型后缀诱导到S型后缀
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^                 ^    @^
SA:       08|-1 -1 -1 -1 -1 01|07 02
           ^              ^    @   ^
SA:       08|-1 -1 -1 -1 06 01|07 02
           ^           ^    @      ^
SA:       08|-1 -1 -1 00 06 01|07 02
           ^        ^    @         ^
SA:       08|-1 -1 05 00 06 01|07 02
           ^     ^    @            ^
SA:       08|-1 -1 05 00 06 01|07 02
           ^     ^ @               ^
SA:       08|-1 04 05 00 06 01|07 02
           ^  ^ @                  ^
SA:       08|03 04 05 00 06 01|07 02  # pre(S, 2)是L型
           ^ @^                    ^
SA:       08|03 04 05 00 06 01|07 02
          @^  ^                    ^
后缀数组构造完毕
SA: 8 3 4 5 0 6 1 7 2

return SA
</pre></div> </table> <h2 id=5 >5. 具体实现及性能对比</h2> <p>在原论文中说道 SA-IS 算法可以在 100 行左右的代码完成。我试了一下，基本符合这个要求。下面将会给出一个 C++ 实现。需要注意的是，为了方便，这份代码中并没有回收分配的内存。</p> <table class=codehilitetable ><tr><td class=linenos ><div class=linenodiv ><pre><span class=normal >  1</span>
<span class=normal >  2</span>
<span class=normal >  3</span>
<span class=normal >  4</span>
<span class=normal >  5</span>
<span class=normal >  6</span>
<span class=normal >  7</span>
<span class=normal >  8</span>
<span class=normal >  9</span>
<span class=normal > 10</span>
<span class=normal > 11</span>
<span class=normal > 12</span>
<span class=normal > 13</span>
<span class=normal > 14</span>
<span class=normal > 15</span>
<span class=normal > 16</span>
<span class=normal > 17</span>
<span class=normal > 18</span>
<span class=normal > 19</span>
<span class=normal > 20</span>
<span class=normal > 21</span>
<span class=normal > 22</span>
<span class=normal > 23</span>
<span class=normal > 24</span>
<span class=normal > 25</span>
<span class=normal > 26</span>
<span class=normal > 27</span>
<span class=normal > 28</span>
<span class=normal > 29</span>
<span class=normal > 30</span>
<span class=normal > 31</span>
<span class=normal > 32</span>
<span class=normal > 33</span>
<span class=normal > 34</span>
<span class=normal > 35</span>
<span class=normal > 36</span>
<span class=normal > 37</span>
<span class=normal > 38</span>
<span class=normal > 39</span>
<span class=normal > 40</span>
<span class=normal > 41</span>
<span class=normal > 42</span>
<span class=normal > 43</span>
<span class=normal > 44</span>
<span class=normal > 45</span>
<span class=normal > 46</span>
<span class=normal > 47</span>
<span class=normal > 48</span>
<span class=normal > 49</span>
<span class=normal > 50</span>
<span class=normal > 51</span>
<span class=normal > 52</span>
<span class=normal > 53</span>
<span class=normal > 54</span>
<span class=normal > 55</span>
<span class=normal > 56</span>
<span class=normal > 57</span>
<span class=normal > 58</span>
<span class=normal > 59</span>
<span class=normal > 60</span>
<span class=normal > 61</span>
<span class=normal > 62</span>
<span class=normal > 63</span>
<span class=normal > 64</span>
<span class=normal > 65</span>
<span class=normal > 66</span>
<span class=normal > 67</span>
<span class=normal > 68</span>
<span class=normal > 69</span>
<span class=normal > 70</span>
<span class=normal > 71</span>
<span class=normal > 72</span>
<span class=normal > 73</span>
<span class=normal > 74</span>
<span class=normal > 75</span>
<span class=normal > 76</span>
<span class=normal > 77</span>
<span class=normal > 78</span>
<span class=normal > 79</span>
<span class=normal > 80</span>
<span class=normal > 81</span>
<span class=normal > 82</span>
<span class=normal > 83</span>
<span class=normal > 84</span>
<span class=normal > 85</span>
<span class=normal > 86</span>
<span class=normal > 87</span>
<span class=normal > 88</span>
<span class=normal > 89</span>
<span class=normal > 90</span>
<span class=normal > 91</span>
<span class=normal > 92</span>
<span class=normal > 93</span>
<span class=normal > 94</span>
<span class=normal > 95</span>
<span class=normal > 96</span>
<span class=normal > 97</span>
<span class=normal > 98</span>
<span class=normal > 99</span>
<span class=normal >100</span>
<span class=normal >101</span>
<span class=normal >102</span>
<span class=normal >103</span>
<span class=normal >104</span>
<span class=normal >105</span>
<span class=normal >106</span>
<span class=normal >107</span>
<span class=normal >108</span>
<span class=normal >109</span>
<span class=normal >110</span>
<span class=normal >111</span>
<span class=normal >112</span>
<span class=normal >113</span>
<span class=normal >114</span>
<span class=normal >115</span>
<span class=normal >116</span>
<span class=normal >117</span>
<span class=normal >118</span>
<span class=normal >119</span>
<span class=normal >120</span>
<span class=normal >121</span>
<span class=normal >122</span>
<span class=normal >123</span>
<span class=normal >124</span>
<span class=normal >125</span>
<span class=normal >126</span>
<span class=normal >127</span>
<span class=normal >128</span>
<span class=normal >129</span>
<span class=normal >130</span></pre></div><td class=code ><div class=codehilite ><pre><span></span><span class=c1 >// 后缀类型</span>
<span class=cp >#define L_TYPE 0</span>
<span class=cp >#define S_TYPE 1</span>

<span class=c1 >// 判断一个字符是否为LMS字符</span>
<span class=kr >inline</span> <span class=kt >bool</span> <span class=n >is_lms_char</span><span class=p >(</span><span class=kt >int</span> <span class=o >*</span><span class=n >type</span><span class=p >,</span> <span class=kt >int</span> <span class=n >x</span><span class=p >)</span> <span class=p >{</span>
    <span class=k >return</span> <span class=n >x</span> <span class=o >&gt;</span> <span class=mi >0</span> <span class=o >&amp;&amp;</span> <span class=n >type</span><span class=p >[</span><span class=n >x</span><span class=p >]</span> <span class=o >==</span> <span class=n >S_TYPE</span> <span class=o >&amp;&amp;</span> <span class=n >type</span><span class=p >[</span><span class=n >x</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]</span> <span class=o >==</span> <span class=n >L_TYPE</span><span class=p >;</span>
<span class=p >}</span>

<span class=c1 >// 判断两个LMS子串是否相同</span>
<span class=kr >inline</span> <span class=kt >bool</span> <span class=n >equal_substring</span><span class=p >(</span><span class=kt >int</span> <span class=o >*</span><span class=n >S</span><span class=p >,</span> <span class=kt >int</span> <span class=n >x</span><span class=p >,</span> <span class=kt >int</span> <span class=n >y</span><span class=p >,</span> <span class=kt >int</span> <span class=o >*</span><span class=n >type</span><span class=p >)</span> <span class=p >{</span>
    <span class=k >do</span> <span class=p >{</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >S</span><span class=p >[</span><span class=n >x</span><span class=p >]</span> <span class=o >!=</span> <span class=n >S</span><span class=p >[</span><span class=n >y</span><span class=p >])</span>
            <span class=k >return</span> <span class=nb >false</span><span class=p >;</span>
        <span class=n >x</span><span class=o >++</span><span class=p >,</span> <span class=n >y</span><span class=o >++</span><span class=p >;</span>
    <span class=p >}</span> <span class=k >while</span> <span class=p >(</span><span class=o >!</span><span class=n >is_lms_char</span><span class=p >(</span><span class=n >type</span><span class=p >,</span> <span class=n >x</span><span class=p >)</span> <span class=o >&amp;&amp;</span> <span class=o >!</span><span class=n >is_lms_char</span><span class=p >(</span><span class=n >type</span><span class=p >,</span> <span class=n >y</span><span class=p >));</span>

    <span class=k >return</span> <span class=n >S</span><span class=p >[</span><span class=n >x</span><span class=p >]</span> <span class=o >==</span> <span class=n >S</span><span class=p >[</span><span class=n >y</span><span class=p >];</span>
<span class=p >}</span>

<span class=c1 >// 诱导排序(从*型诱导到L型、从L型诱导到S型)</span>
<span class=c1 >// 调用之前应将*型按要求放入SA中</span>
<span class=kr >inline</span> <span class=kt >void</span> <span class=n >induced_sort</span><span class=p >(</span><span class=kt >int</span> <span class=o >*</span><span class=n >S</span><span class=p >,</span> <span class=kt >int</span> <span class=o >*</span><span class=n >SA</span><span class=p >,</span> <span class=kt >int</span> <span class=o >*</span><span class=n >type</span><span class=p >,</span> <span class=kt >int</span> <span class=o >*</span><span class=n >bucket</span><span class=p >,</span> <span class=kt >int</span> <span class=o >*</span><span class=n >lbucket</span><span class=p >,</span>
                         <span class=kt >int</span> <span class=o >*</span><span class=n >sbucket</span><span class=p >,</span> <span class=kt >int</span> <span class=n >n</span><span class=p >,</span> <span class=kt >int</span> <span class=n >SIGMA</span><span class=p >)</span> <span class=p >{</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >&gt;</span> <span class=mi >0</span> <span class=o >&amp;&amp;</span> <span class=n >type</span><span class=p >[</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]</span> <span class=o >==</span> <span class=n >L_TYPE</span><span class=p >)</span>
            <span class=n >SA</span><span class=p >[</span><span class=n >lbucket</span><span class=p >[</span><span class=n >S</span><span class=p >[</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]]</span><span class=o >++</span><span class=p >]</span> <span class=o >=</span> <span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >SIGMA</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>  <span class=c1 >// Reset S-type bucket</span>
        <span class=n >sbucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span> <span class=o >&gt;=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span><span class=o >--</span><span class=p >)</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >&gt;</span> <span class=mi >0</span> <span class=o >&amp;&amp;</span> <span class=n >type</span><span class=p >[</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]</span> <span class=o >==</span> <span class=n >S_TYPE</span><span class=p >)</span>
            <span class=n >SA</span><span class=p >[</span><span class=n >sbucket</span><span class=p >[</span><span class=n >S</span><span class=p >[</span><span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]]</span><span class=o >--</span><span class=p >]</span> <span class=o >=</span> <span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
<span class=p >}</span>

<span class=c1 >// SA-IS主体</span>
<span class=c1 >// S是输入字符串，length是字符串的长度, SIGMA是字符集的大小</span>
<span class=k >static</span> <span class=kt >int</span> <span class=o >*</span><span class=n >SAIS</span><span class=p >(</span><span class=kt >int</span> <span class=o >*</span><span class=n >S</span><span class=p >,</span> <span class=kt >int</span> <span class=n >length</span><span class=p >,</span> <span class=kt >int</span> <span class=n >SIGMA</span><span class=p >)</span> <span class=p >{</span>
    <span class=kt >int</span> <span class=n >n</span> <span class=o >=</span> <span class=n >length</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >type</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>  <span class=c1 >// 后缀类型</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >position</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>  <span class=c1 >// 记录LMS子串的起始位置</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >name</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>  <span class=c1 >// 记录每个LMS子串的新名称</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >SA</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>  <span class=c1 >// SA数组</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >bucket</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >SIGMA</span><span class=p >];</span>  <span class=c1 >// 每个字符的桶</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >lbucket</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >SIGMA</span><span class=p >];</span>  <span class=c1 >// 每个字符的L型桶的起始位置</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >sbucket</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >SIGMA</span><span class=p >];</span>  <span class=c1 >// 每个字符的S型桶的起始位置</span>

    <span class=c1 >// 初始化每个桶</span>
    <span class=n >memset</span><span class=p >(</span><span class=n >bucket</span><span class=p >,</span> <span class=mi >0</span><span class=p >,</span> <span class=k >sizeof</span><span class=p >(</span><span class=kt >int</span><span class=p >)</span> <span class=o >*</span> <span class=p >(</span><span class=n >SIGMA</span> <span class=o >+</span> <span class=mi >1</span><span class=p >));</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
        <span class=n >bucket</span><span class=p >[</span><span class=n >S</span><span class=p >[</span><span class=n >i</span><span class=p >]]</span><span class=o >++</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >SIGMA</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span> <span class=p >{</span>
        <span class=n >bucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >+=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span> <span class=o >-</span> <span class=mi >1</span><span class=p >];</span>
        <span class=n >lbucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span> <span class=o >-</span> <span class=mi >1</span><span class=p >];</span>
        <span class=n >sbucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
    <span class=p >}</span>

    <span class=c1 >// 确定后缀类型(利用引理2.1)</span>
    <span class=n >type</span><span class=p >[</span><span class=n >n</span><span class=p >]</span> <span class=o >=</span> <span class=n >S_TYPE</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=n >n</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&gt;=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span><span class=o >--</span><span class=p >)</span> <span class=p >{</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >S</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >&lt;</span> <span class=n >S</span><span class=p >[</span><span class=n >i</span> <span class=o >+</span> <span class=mi >1</span><span class=p >])</span>
            <span class=n >type</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >S_TYPE</span><span class=p >;</span>
        <span class=k >else</span> <span class=nf >if</span> <span class=p >(</span><span class=n >S</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >&gt;</span> <span class=n >S</span><span class=p >[</span><span class=n >i</span> <span class=o >+</span> <span class=mi >1</span><span class=p >])</span>
            <span class=n >type</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >L_TYPE</span><span class=p >;</span>
        <span class=k >else</span>
            <span class=n >type</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >type</span><span class=p >[</span><span class=n >i</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>
    <span class=p >}</span>

    <span class=c1 >// 寻找每个LMS子串</span>
    <span class=kt >int</span> <span class=n >cnt</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >type</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >==</span> <span class=n >S_TYPE</span> <span class=o >&amp;&amp;</span> <span class=n >type</span><span class=p >[</span><span class=n >i</span> <span class=o >-</span> <span class=mi >1</span><span class=p >]</span> <span class=o >==</span> <span class=n >L_TYPE</span><span class=p >)</span>
            <span class=n >position</span><span class=p >[</span><span class=n >cnt</span><span class=o >++</span><span class=p >]</span> <span class=o >=</span> <span class=n >i</span><span class=p >;</span>

    <span class=c1 >// 对LMS子串进行排序</span>
    <span class=n >fill</span><span class=p >(</span><span class=n >SA</span><span class=p >,</span> <span class=n >SA</span> <span class=o >+</span> <span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >,</span> <span class=mi >-1</span><span class=p >);</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;</span> <span class=n >cnt</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
        <span class=n >SA</span><span class=p >[</span><span class=n >sbucket</span><span class=p >[</span><span class=n >S</span><span class=p >[</span><span class=n >position</span><span class=p >[</span><span class=n >i</span><span class=p >]]]</span><span class=o >--</span><span class=p >]</span> <span class=o >=</span> <span class=n >position</span><span class=p >[</span><span class=n >i</span><span class=p >];</span>
    <span class=n >induced_sort</span><span class=p >(</span><span class=n >S</span><span class=p >,</span> <span class=n >SA</span><span class=p >,</span> <span class=n >type</span><span class=p >,</span> <span class=n >bucket</span><span class=p >,</span> <span class=n >lbucket</span><span class=p >,</span> <span class=n >sbucket</span><span class=p >,</span> <span class=n >n</span><span class=p >,</span> <span class=n >SIGMA</span><span class=p >);</span>

    <span class=c1 >// 为每个LMS子串命名</span>
    <span class=n >fill</span><span class=p >(</span><span class=n >name</span><span class=p >,</span> <span class=n >name</span> <span class=o >+</span> <span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >,</span> <span class=mi >-1</span><span class=p >);</span>
    <span class=kt >int</span> <span class=n >lastx</span> <span class=o >=</span> <span class=mi >-1</span><span class=p >,</span> <span class=n >namecnt</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span>  <span class=c1 >// 上一次处理的LMS子串与名称的计数</span>
    <span class=kt >bool</span> <span class=n >flag</span> <span class=o >=</span> <span class=nb >false</span><span class=p >;</span>  <span class=c1 >// 这里顺便记录是否有重复的字符</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span> <span class=p >{</span>
        <span class=kt >int</span> <span class=n >x</span> <span class=o >=</span> <span class=n >SA</span><span class=p >[</span><span class=n >i</span><span class=p >];</span>

        <span class=k >if</span> <span class=p >(</span><span class=n >is_lms_char</span><span class=p >(</span><span class=n >type</span><span class=p >,</span> <span class=n >x</span><span class=p >))</span> <span class=p >{</span>
            <span class=k >if</span> <span class=p >(</span><span class=n >lastx</span> <span class=o >&gt;=</span> <span class=mi >0</span> <span class=o >&amp;&amp;</span> <span class=o >!</span><span class=n >equal_substring</span><span class=p >(</span><span class=n >S</span><span class=p >,</span> <span class=n >x</span><span class=p >,</span> <span class=n >lastx</span><span class=p >,</span> <span class=n >type</span><span class=p >))</span>
                <span class=n >namecnt</span><span class=o >++</span><span class=p >;</span>
            <span class=c1 >// 因为只有相同的LMS子串才会有同样的名称</span>
            <span class=k >if</span> <span class=p >(</span><span class=n >lastx</span> <span class=o >&gt;=</span> <span class=mi >0</span> <span class=o >&amp;&amp;</span> <span class=n >namecnt</span> <span class=o >==</span> <span class=n >name</span><span class=p >[</span><span class=n >lastx</span><span class=p >])</span>
                <span class=n >flag</span> <span class=o >=</span> <span class=nb >true</span><span class=p >;</span>

            <span class=n >name</span><span class=p >[</span><span class=n >x</span><span class=p >]</span> <span class=o >=</span> <span class=n >namecnt</span><span class=p >;</span>
            <span class=n >lastx</span> <span class=o >=</span> <span class=n >x</span><span class=p >;</span>
        <span class=p >}</span>
    <span class=p >}</span>  <span class=c1 >// for</span>
    <span class=n >name</span><span class=p >[</span><span class=n >n</span><span class=p >]</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span>

    <span class=c1 >// 生成S1</span>
    <span class=kt >int</span> <span class=o >*</span><span class=n >S1</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >cnt</span><span class=p >];</span>
    <span class=kt >int</span> <span class=n >pos</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >n</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
        <span class=k >if</span> <span class=p >(</span><span class=n >name</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >&gt;=</span> <span class=mi >0</span><span class=p >)</span>
            <span class=n >S1</span><span class=p >[</span><span class=n >pos</span><span class=o >++</span><span class=p >]</span> <span class=o >=</span> <span class=n >name</span><span class=p >[</span><span class=n >i</span><span class=p >];</span>

    <span class=kt >int</span> <span class=o >*</span><span class=n >SA1</span><span class=p >;</span>
    <span class=k >if</span> <span class=p >(</span><span class=o >!</span><span class=n >flag</span><span class=p >)</span> <span class=p >{</span>
        <span class=c1 >// 直接计算SA1</span>
        <span class=n >SA1</span> <span class=o >=</span> <span class=k >new</span> <span class=kt >int</span><span class=p >[</span><span class=n >cnt</span> <span class=o >+</span> <span class=mi >1</span><span class=p >];</span>

        <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;</span> <span class=n >cnt</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span>
            <span class=n >SA1</span><span class=p >[</span><span class=n >S1</span><span class=p >[</span><span class=n >i</span><span class=p >]]</span> <span class=o >=</span> <span class=n >i</span><span class=p >;</span>
    <span class=p >}</span> <span class=k >else</span>
        <span class=n >SA1</span> <span class=o >=</span> <span class=n >SAIS</span><span class=p >(</span><span class=n >S1</span><span class=p >,</span> <span class=n >cnt</span><span class=p >,</span> <span class=n >namecnt</span><span class=p >);</span>  <span class=c1 >// 递归计算SA1</span>

    <span class=c1 >// 从SA1诱导到SA</span>
    <span class=n >lbucket</span><span class=p >[</span><span class=mi >0</span><span class=p >]</span> <span class=o >=</span> <span class=n >sbucket</span><span class=p >[</span><span class=mi >0</span><span class=p >]</span> <span class=o >=</span> <span class=mi >0</span><span class=p >;</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&lt;=</span> <span class=n >SIGMA</span><span class=p >;</span> <span class=n >i</span><span class=o >++</span><span class=p >)</span> <span class=p >{</span>
        <span class=n >lbucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span> <span class=o >-</span> <span class=mi >1</span><span class=p >];</span>
        <span class=n >sbucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >=</span> <span class=n >bucket</span><span class=p >[</span><span class=n >i</span><span class=p >]</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span>
    <span class=p >}</span>
    <span class=n >fill</span><span class=p >(</span><span class=n >SA</span><span class=p >,</span> <span class=n >SA</span> <span class=o >+</span> <span class=n >n</span> <span class=o >+</span> <span class=mi >1</span><span class=p >,</span> <span class=mi >-1</span><span class=p >);</span>
    <span class=k >for</span> <span class=p >(</span><span class=kt >int</span> <span class=n >i</span> <span class=o >=</span> <span class=n >cnt</span> <span class=o >-</span> <span class=mi >1</span><span class=p >;</span> <span class=n >i</span> <span class=o >&gt;=</span> <span class=mi >0</span><span class=p >;</span> <span class=n >i</span><span class=o >--</span><span class=p >)</span>  <span class=c1 >// 这里是逆序扫描SA1，因为SA中S型桶是倒序的</span>
        <span class=n >SA</span><span class=p >[</span><span class=n >sbucket</span><span class=p >[</span><span class=n >S</span><span class=p >[</span><span class=n >position</span><span class=p >[</span><span class=n >SA1</span><span class=p >[</span><span class=n >i</span><span class=p >]]]]</span><span class=o >--</span><span class=p >]</span> <span class=o >=</span> <span class=n >position</span><span class=p >[</span><span class=n >SA1</span><span class=p >[</span><span class=n >i</span><span class=p >]];</span>
    <span class=n >induced_sort</span><span class=p >(</span><span class=n >S</span><span class=p >,</span> <span class=n >SA</span><span class=p >,</span> <span class=n >type</span><span class=p >,</span> <span class=n >bucket</span><span class=p >,</span> <span class=n >lbucket</span><span class=p >,</span> <span class=n >sbucket</span><span class=p >,</span> <span class=n >n</span><span class=p >,</span> <span class=n >SIGMA</span><span class=p >);</span>

    <span class=c1 >// 后缀数组计算完毕</span>
    <span class=k >return</span> <span class=n >SA</span><span class=p >;</span>
<span class=p >}</span>
</pre></div> </table> <p>SA-IS 的实现还可以参考一篇很好的博文: <a href="http://zork.net/~st/jottings/sais.html">A walk through the SA-IS Suffix Array Construction Algorithm</a>，这篇文章的作者使用 Python 一步一步地介绍了如何实现一个基础的 SA-IS 算法。</p> <p>我们看到 SA-IS 作为一个后缀排序的算法，代码量也并不小，然而实际上它速度非常快，其中一个重要的原因就是 SA-IS 算法几乎所有的操作都是<strong>顺序访问</strong>的，这样就可以很好地<strong>提高缓存命中率</strong><sup id="fnref:cache"><a class=footnote-ref  href="#fn:cache" rel=footnote >8</a></sup>。原论文中实测 SA-IS 算法击败了 KA 算法，不愧为目前为止速度最快的后缀数组的构建算法。</p> <p>对中学 OI 界，构造后缀数组通常是使用倍增法和 DC3 算法。倍增法速度比 DC3 算法慢是众所周知的了，下面我将用不同规模的<strong>随机字符串</strong>来比较 DC3 算法与 SA-IS 算法。</p> <table> <thead> <tr> <th align=center >数据规模 <th align=center >DC3 <th align=center >SA-IS <tr> <td align=center ><tex>$10^4$</tex> <td align=center ><tex>$0.015\text{s}$</tex> <td align=center ><tex>$0.011\text{s}$</tex> <tr> <td align=center ><tex>$10^5$</tex> <td align=center ><tex>$0.055\text{s}$</tex> <td align=center ><tex>$0.036\text{s}$</tex> <tr> <td align=center ><tex>$10^6$</tex> <td align=center ><tex>$0.365\text{s}$</tex> <td align=center ><tex>$0.270\text{s}$</tex> <tr> <td align=center ><tex>$2\times 10^6$</tex> <td align=center ><tex>$0.997\text{s}$</tex> <td align=center ><tex>$0.593\text{s}$</tex> <tr> <td align=center ><tex>$5\times 10^6$</tex> <td align=center ><tex>$2.803\text{s}$</tex> <td align=center ><tex>$2.085\text{s}$</tex> <tr> <td align=center ><tex>$10^7$</tex> <td align=center ><tex>$4.012\text{s}$</tex> <td align=center ><tex>$3.326\text{s}$</tex> </table> <p>编译命令: <code>g++ SAIS.cpp/DC3.cpp -o sais/dc3 -O3</code><br /> 运行环境: Ubuntu 14.04 LTS x64 / CPU: 2.0GHz 奔腾某 CPU / 4GB 内存 / 未启动 X window</p> <p>从上面的结果可以看出，SA-IS 算法速度上明显优于 DC3 算法，并且数据规模越大，两者的速度差距越明显。<br /> 总而言之，SA-IS 算法是一个相当不错的后缀数组的构建算法。似乎 SA-IS 算法所利用的诱导排序的思想还可以解决其它的一些字符串的问题，如计算 LCP 数组<sup id="fnref:lcp"><a class=footnote-ref  href="#fn:lcp" rel=footnote >9</a></sup>，我并没有对此做过多的了解了。</p> <div class=footnote > <hr /> <ol> <li id="fn:paper"> <p>Nong, Ge; Zhang, Sen; Chan, Wai Hong (2009): <a href="https://local.ugene.unipro.ru/tracker/secure/attachment/12144/Linear+Suffix+Array+Construction+by+Almost+Pure+Induced-Sorting.pdf">Linear Suffix Array Construction by Almost Pure Induced-Sorting</a>&#160;<a class=footnote-backref  href="#fnref:paper" rev=footnote  title="Jump back to footnote 1 in the text">&#8617;</a></p> <li id="fn:dollar"> <p>这里的 <tex>$\#$</tex> 并不是指“井号”，而是一个特殊记号。字符串中不会出现这个字符。&#160;<a class=footnote-backref  href="#fnref:dollar" rev=footnote  title="Jump back to footnote 2 in the text">&#8617;</a></p> <li id="fn:lms-sort"> <p>后面我们将会有更好的算法来对 LMS 子串排序，时间复杂度一致，但在实际运用中速度快很多。&#160;<a class=footnote-backref  href="#fnref:lms-sort" rev=footnote  title="Jump back to footnote 3 in the text">&#8617;</a></p> <li id="fn:lms-name"> <p>注意之后会创建新字符串<tex>$ S_1$</tex>，其字符集 <tex>$\Sigma$</tex> 是不同的。&#160;<a class=footnote-backref  href="#fnref:lms-name" rev=footnote  title="Jump back to footnote 4 in the text">&#8617;</a></p> <li id="fn:lms-compare"> <p>判断两个 LMS 子串是否相等可以暴力判断，基于引理 2.6，可以证明其总复杂度为 <tex>$O(|S|)$</tex>。&#160;<a class=footnote-backref  href="#fnref:lms-compare" rev=footnote  title="Jump back to footnote 5 in the text">&#8617;</a></p> <li id="fn:star-in-S"> <p>注意 <tex>$*$</tex> 型后缀也属于 <tex>$S$</tex> 型后缀，因此会对它们进行重排，从而确保新加入的 <tex>$S$</tex> 型后缀的顺序是对的。&#160;<a class=footnote-backref  href="#fnref:star-in-S" rev=footnote  title="Jump back to footnote 6 in the text">&#8617;</a></p> <li id="fn:lms-prefix"> <p>这个概念看上去应该是个后缀&hellip;但是原论文就是把它叫做前缀，这里也就尊重原论文的说法。&#160;<a class=footnote-backref  href="#fnref:lms-prefix" rev=footnote  title="Jump back to footnote 7 in the text">&#8617;</a></p> <li id="fn:cache"> <p>即降低 cache-missing。&#160;<a class=footnote-backref  href="#fnref:cache" rev=footnote  title="Jump back to footnote 8 in the text">&#8617;</a></p> <li id="fn:lcp"> <p>Johannes Fischer (2011): <a href="https://arxiv.org/pdf/1101.3448.pdf">Inducing the LCP-Array</a>&#160;<a class=footnote-backref  href="#fnref:lcp" rev=footnote  title="Jump back to footnote 9 in the text">&#8617;</a></p> </ol> </div> <hr/> <div id=comments ></div> <script> window.addEventListener('load', () => { quicklink(); }); const gitment = new Gitment({id: '9269fdafdb0cc04fe631d3d5c6d5625a', owner: 'riteme', repo: 'riteme.github.io', oauth: { client_id: 'd4fcffa25858a7a58e1a', client_secret: 'e0c8e08beb95497871f8355416c69390634cec76' }, perPage: 10, }); gitment.render('comments'); </script> </div> </div> <div class="mdl-cell sidebar"> <div class=article > <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">页面信息</div> <div class=mdl-card__supporting-text > 标签: <a href="/search.html?q=数据结构"><span class=label >数据结构</span></a> <a href="/search.html?q=字符串"><span class=label >字符串</span></a> <a href="/search.html?q=后缀数组"><span class=label >后缀数组</span></a> <a href="/search.html?q=诱导排序"><span class=label >诱导排序</span></a> <a href="/search.html?q=SA-IS"><span class=label >SA-IS</span></a><br/> 创建时间: 2016.06.19<br/> 上次修改: 2021.04.20<br/> 字数统计: 19759 字 / 约 1 小时 19 分钟 </div> </div> <br/> <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">目录</div> <div class=mdl-card__supporting-text > <div class=toc > <ul> <li><a href="#sa-is">诱导排序与 SA-IS 算法</a><ul> <li><a href="#1">1. 记号</a> <li><a href="#2-sa-is">2. SA-IS 算法</a><ul> <li><a href="#21">2.1 后缀类型</a> <li><a href="#22-lms">2.2 LMS 子串</a> <li><a href="#23-sa1-sa">2.3 从 SA1 诱导至 SA</a> <li><a href="#24-lms">2.4 对 LMS 子串排序</a> </ul> <li><a href="#3">3. 时空复杂度分析</a> <li><a href="#4">4. 运行示例</a> <li><a href="#5">5. 具体实现及性能对比</a> </ul> </ul> <ul><li><a href="#comments">评论区</a></ul></div> </div> </div> <br/> <div class="mdl-card mdl-shadow--2dp sidebar-card"> <div class="mdl-card__actions sidebar-title">数学公式渲染</div> <div class=mdl-card__supporting-text > <form name=mathopt > <label class="mdl-radio mdl-js-radio" for=option-1 > <input type=radio  id=option-1  class=mdl-radio__button  name=sel  value=mathjax > <span class=mdl-radio__label >MathJax</span> </label><br/> <label class="mdl-radio mdl-js-radio" for=option-2 > <input type=radio  id=option-2  class=mdl-radio__button  name=sel  value=katex > <span class=mdl-radio__label >KaTeX</span> </label> <div id=tip-1 > <label class="mdl-radio mdl-js-radio" for=option-3 > <input type=radio  id=option-3  class=mdl-radio__button  name=sel  value="katex&mathjax"> <span class=mdl-radio__label >Mixed</span> </label> </div> </form> <div id=tip-2 > <label class="mdl-checkbox mdl-js-checkbox" for=mathopt-align > <input type=checkbox  id=mathopt-align  class=mdl-checkbox__input > <span class=mdl-checkbox__label >居中显示</span> </label> </div> </div> </div> <div class=mdl-tooltip  data-mdl-for=tip-1 >先使用 KaTeX 渲染，再使用 MathJax 渲染</div> <div class=mdl-tooltip  data-mdl-for=tip-2 >该选项目前仅支持 KaTeX 渲染的公式<br/>点击公式可以切换单个公式的对齐方式</div> <br/> <div class="nano mdl-card mdl-shadow--2dp sidebar-card"> <div class=mdl-card__actions > <div class=nano-shell ><span class=shell-start >$</span> nano <a href="https://github.com/riteme/riteme.github.io/blob/master/blog/2016-6-19/sais.md" id=nano-link >sais.md</a></div> </div> </div> <div class=mdl-tooltip  data-mdl-for=nano-link >查看原始 Markdown 文档</div> </div> </div> </div> <footer class=mdl-mega-footer > <div class=mdl-mega-footer__middle-section > <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >RITEME.SITE</h2><del>一个从不乱说话的博客</del> </div> <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >POWERED BY</h2> <ul class=mdl-mega-footer__link-list > <li><a href="http://pythonhosted.org/Markdown/">Python Markdown</a> <li><a href="http://getmdl.io/">Material Design Lite</a> <li><a href="http://www.tipue.com/search/">Tipuesearch</a> <li><a href="http://www.mathjax.org/">MathJax</a> & <a href="http://khan.github.io/KaTeX/">KaTeX</a> <li><a href="https://github.com/imsun/gitment">Gitment</a> </ul> </div> <div class=mdl-mega-footer__drop-down-section > <input class=mdl-mega-footer__heading-checkbox  type=checkbox  checked> <h2 class=mdl-mega-footer__heading >友情链接</h2> <ul class=mdl-mega-footer__link-list > <li><a href="http://ruanx.pw/">ruanxingzhi</a> <li><a href="https://blog.xehoth.cc/">xehoth</a> <li><a href="http://hjwjbsr.is-programmer.com/">HJWJBSR</a> <li><a href="http://www.micdz.cn/">MicDZ</a> <li><a href="https://cmxrynp.github.io/">CMXRYNP</a> <li><a href="http://memset0.cn/">memset0</a> </ul> </div> </div> <div class=mdl-mega-footer__bottom-section >Theme based on <a href="https://getmdl.io/">MDL</a> | <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" class=cc  src="/assets/cc-by-nc-sa-4.png" /></a> CC BY-NC-SA 4.0 </div> </footer> </main> </div>