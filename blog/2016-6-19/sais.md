---
title: 诱导排序与SA-IS算法
create: 2016.6.19
modified: 2016.6.19
tags: 数据结构
      字符串
      后缀数组
      诱导排序
      SA-IS
---

[TOC]
# 诱导排序与SA-IS算法
SA-IS是一种在实际运用中相当快速的线性时间构建字符串的后缀数组的算法。本文将通过对原论文[^paper]进行一些翻译和总结来介绍该算法。最后会提供一个SA-IS算法的C++实现。

[^paper]: Nong, Ge; Zhang, Sen; Chan, Wai Hong (2009): [Linear Suffix Array Construction by Almost Pure Induced-Sorting](https://local.ugene.unipro.ru/tracker/secure/attachment/12144/Linear+Suffix+Array+Construction+by+Almost+Pure+Induced-Sorting.pdf)

## 1. 记号
现在先规定一些记号，以方便之后的讨论。

我们通常使用大写字母$S, A, B, \dots$来表示一个字符串，小写字母$a, b, c, \dots$表示单个的字符。字符通常被认为是一个整数。字符在一定条件下数量是有限的，我们将所有会用到的字符放入字符集$\Sigma$中，此时$|\Sigma|$表示字符集的大小。字符串之间可以任意连接，如$AB$表示字符串$A$与字符串$B$依次连接而成的新字符串。字符串与单个字符之间也是如此。特别的，我们将空串记为$\epsilon$。

对于一个字符串我们可以访问其中的任意字符，用$S[x]$表示$S$中下标为$x$的字符。下标从$0$开始。我们用$S[a, b]$表示$S$的一个子串，即下标为$a$的字符开始一直到下标为$b$的字符依次连接而成的字符串，其中必须满足$0 \le a \le b \lt |S|$。定义一个字符串$S$的前缀为$\text{prefix}(S, i) = S[0, i]$，其后缀为$\text{suffix}(S, i) = S[i, |S| - 1]$。

两个字符串$A$和$B$之间存在比较关系。当$A$与$B$的长度相同，且其中对应下标的字符也相同时，则为$A = B$。当从左至右出现第一对不相同的字符时，则以这两个字符的大小关系作为$A$和$B$间的大小关系，这称为字典序。为了简化一些操作，定义$\#$是字典序最小的字符，并且将其默认作为每个字符串的最后一个字符[^dollar]，即作为$S[|S|]$。
另外，定义函数$\text{lcp}(A, B)$表示$A$和$B$的最长公共前缀的长度，即两者所有相同的前缀中，最长的一个的长度。由此我们可以得知字典序的一个性质：

**定理 1.1** $A < B$当且仅当$A[\text{lcp}(A, B)] < B[\text{lcp}(A, B)]$。
**证明** 这个结论显然成立，因为$\text{prefix}(A, \text{lcp}(A, B) - 1) = \text{prefix}(B, \text{lcp}(A, B) - 1)$。

[^dollar]: 这里的$\#$并不是指井号，而是一个特殊记号。字符串中不会出现这个字符。

## 2. SA-IS算法
SA-IS算法是基于诱导排序这种思想。基本想法就是将问题的规模缩小，通过解决更小的问题，获取足够信息，就可以快速的解决原始问题。从这里也可以看出，这一过程需要递归处理子问题。

在介绍SA-IS算法前，我们先来看一下该算法的基本框架：

```
function SA-IS(S):
    t = bool[]
    S1 = int[]
    P = int[]
    bucket = int[]
    扫描倒序字符串确定每一个后缀的类型 -> t
    扫描t数组确定所有的LMS子串 -> P
    对所有的LMS子串进行诱导排序
    对每一个LMS子串重新命名，生成新的串S1
    
    if S1中的每一个字符都不一样:
        直接计算SA1
    else
        SA1 = SA-IS(S1)  # 递归计算SA1
    
    利用SA1来进行诱导排序，计算SA
    return SA
```

现在你不会明白这里面都写了些什么东西，因为这只是一个简单的流程。接下来将会介绍其中的每一步并证明其正确性。

### 2.1 后缀类型
在第6行中，确定后缀的类型可能会令人无法理解，这是因为我们还没有定义什么是后缀的类型......

对于每一个后缀$\text{suffix}(S, i)$，当$\text{suffix}(S, i) < \text{suffix}(S, i + 1)$时，是$S$型后缀。当$\text{suffix}(S, i) > \text{suffix}(S, i + 1)$时，是$L$型后缀。对于特殊的后缀$\text{suffix}(S, |S|) = \#$，它默认为$S$型。
例如，对于字符串`mmiissiissiippii`，每一后缀的类型为：

```
      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #
t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S
```

既然我们需要得知每一个后缀类型，就需要一个快速的算法来计算。在此之前，我们发现它们有如下的性质：

**引理 2.1** (后缀类型递推性质) 对于任意的$i \in [0, |S| - 1]$:
如果$t[i] = \text{S-type}$，当且仅当下面任意一项成立：

 1. $S[i] < S[i + 1]$
 2. $S[i] = S[i + 1]$且$t[i + 1] = \text{S-type}$

如果$t[i] = \text{L-type}$，当且仅当下面任意一项成立：
 
 1. $S[i] > S[i + 1]$
 2. $S[i] = S[i + 1]$且$t[i + 1] = \text{L-type}$

**证明** 这里证明$S$型的，$L$型是类似的。对于第一种情况，显然是成立的。对于第二种情况，我们设$\text{suffix}(S, i) = aA, \text{suffix}(S, i + 1) = aB$。由于第一个字符是相同的，因此我们需要比较$A$和$B$的大小。因为它们是连续的后缀，所以$A = \text{suffix}(S, i + 1), B = \text{suffix}(S, i + 2)$。由于我们是从右往左推出$t$，所以$A$与$B$的关系实际上可以由$t[i + 1]$给出。故$t[i] = t[i + 1]$。

因此，我们可以在$\Theta(|S|)$的时间内，推出整个$t$数组。

关于后缀类型，我们还可得出另外一个比较重要的性质：

**引理 2.2** (后缀类型指导排序) 对于两个后缀$A$和$B$，如果$A[0] = B[0]$且$A$是$L$型，$B$是$S$型，则$A < B$。
**证明** 设$A = abX, B = acY$，这里假设$a \neq b, a \neq c$。因为$A$是$S$型，所以可知$a < b$。同理，$B$是$L$型，可知$a > c$。故$ c < a < b$，所以$A < B$。如果$a = b, a = c$，则我们可以将第一个字符去掉，得到新的后缀来进行比较。根据引理 2.1，去掉第一个字符后的后缀类型不变。因此我们可以通过这样的操作从而变为第一种情况。

### 2.2 LMS子串
然而光有后缀类型，还不足以进行排序。因此我们在后缀类型的$S$型中挑出特别的一类，记为$*$型。$*$型是$S$型的一种，它的特殊之处在于它要求它的左边的后缀必须是$L$型的。依然以`mmiissiissiippii`为例：

```
      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #
t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S
            *           *           *                 *
```

可以将其理解为一连串的$S$型中最靠左的一个。LMS (<strong>L</strong>eft<strong>M</strong>ost <strong>S</strong>-type)也正是这个意思。同时我们注意到，后缀$\#$始终是$*$型的。
对于每一个$*$型所对应上的字符，我们称为LMS字符。上面的示例中，下标为$2, 6, 10, 16$都是LMS字符。
位置相邻的两个LMS字符中间(包括这两个字符)所构成的子串，称为LMS子串。对于`mmiissiissiippii`，其LMS子串依次为`iissi`、`iissi`、`iippii#`和`#`。

通过观察，我们发现LMS子串具有以下的性质：
**引理 2.3** `#`是最短的LMS子串。
**引理 2.4** 对于任意的非`#`的LMS子串，其长度大于$2$。
**证明** 因为两个LMS字符中间必定有一个$L$型的后缀。
**引理 2.5** (原串折半) 一个字符串中LMS子串的数量不超过$\left\lceil{|S| / 2}\right\rceil$。
**证明** 根据引理2.4可知。
**引理 2.6** 一个字符串的所有LMS子串的长度之和为$O(|S|)$。

此外，对于LMS子串间的大小比较，除了对每个字符的字典序进行比较外，还要对比每个字符所对应的后缀类型。$S$型的有更高的优先权，因为根据引理2.2可得，$S$型的后缀字典序更大。只有当每一个字符与其后缀类型都相同时，这两个LMS子串才被称为是相同的。
之所以这样定义，是因为在之后我们会利用LMS子串来进行对后缀的排序。如果缺少后缀类型的信息，就不能够任务。
根据引理2.6，我们可以利用**基数排序**在$O(|S|)$的时间内对所有的LMS子串排序[^lms-sort]。对LMS子串排序完后，我们按照字典序依次重新命名[^lms-name]，注意，如果两个LMS子串相同，则使用同样的名称[^lms-compare]。这样给每个LMS子串命名后，按照其子串原有的顺序排出一个新串$S_1$。继续以`mmiissiissiippii`为例：

```
      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #
t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S
            *           *           *                 *
新名称      2           2           1                 0
S1:   2 2 1 0
```

[^lms-sort]: 后面我们将会有更好的算法来对LMS子串排序，时间复杂度一致，但在实际运用中速度快很多。

[^lms-name]: 注意之后会创建新字符串$S_1$，其字符集$\Sigma$是不同的。

[^lms-compare]: 判断两个LMS子串是否相等可以暴力判断，基于引理2.6，可以证明其总复杂度为$O(|S|)$。

这样有什么用呢？我们发现，这实际上是将所有$*$型的后缀进行了缩减，从而减小了问题的规模。对于这一点，我们有如下的引理：

**引理 2.7** (问题缩减) $S_1$中两个后缀的字典序关系，就是$S$中对应的$*$型后缀的字典序关系。
**证明** 我们可以将$S_1$视为是将$*$后缀中不重合的部分进行切割并缩减。这样每一个LMS子串就可作为一个整体来进行比较。从而保持了这两者的一致性。

需要注意的是这里只是$*$型后缀的字典序关系，与其它后缀无关。

### 2.3 从SA1诱导至SA
从上面的引理2.7我们得知，只要获得了$S_1$的后缀数组$SA_1$，就可以得到所有$*$型后缀的相对顺序。如果我们可以利用$*$型后缀的相对顺序来对其它的$L$型和$S$型后缀[^star-in-S]进行排序，就可以完成后缀数组的计算。

[^star-in-S]: 注意$*$型后缀也属于$S$型后缀，因此会对它们进行重排，从而确保新加入的$S$型后缀的顺序是对的。

在这里我们先假定$SA_1$已经计算出来，只需考虑如何计算$SA$。在这之前，我们先观察一下后缀数组的形式。以`aabaaaab`为例，它的后缀数组是这样的：

```
#
aaaab#
aaab#
aab#
aabaaaab#
ab#
abaaaab#
b#
baaaab#
```

不难发现，首字母相同的后缀是连续排布的，这一点可以用反证法来证明。因此我们可以利用桶排序的思想，为每一个出现过的字符建立一个桶，用$SA$数组来存储这些桶，每个桶之间按照字典序排列，这样就可以使后缀数组初步有序。
我们对每个后缀都赋予了一个后缀类型，那么在首字母一样的情况下，$S$型或$L$型会连续分布吗？答案是肯定的。因为根据引理2.2，首字母相同的后缀如果后缀类型不同，则相对顺序是确定的。因此易知不会出现$S$型和$L$型交替出现的情况。更进一步，由于$L$型后缀更小，因此总是先排布$L$型后缀，再排布$S$型后缀。因此每一个字符的桶可以分为两部分，一个用于放置$L$型后缀，另一个则用于$S$型后缀。为了方便确定每一个桶的起始位置，$S$型后缀的桶的放置是倒序的。
但是如果首字母和后缀类型都一致，我们不能直接快速地判断大小关系。在这里就要利用到诱导排序了。

诱导排序的过程分为以下几步：

1. 将$SA$数组初始化为每个元素都为$-1$的数组。
2. 确定每个桶$S$型桶的起始位置。将$SA_1$中的每一个$*$型后缀按照$SA_1$中的顺序放入相应的桶内。
3. 确定每个桶$L$型桶的起始位置。在$SA$数组中从左往右扫一遍。如果$SA[i] > 0$且$t[SA[i] - 1] = \text{L-type}$，则将$SA[i] - 1$所代表的后缀放入对应的桶中。
4. 重新确定每个桶$S$型桶的起始位置，因为所有的$*$型后缀要重新被排序。由于$S$型桶是逆序排放的，所以这次从右至左地扫描一遍$SA$。如果$SA[i] > 0$且$t[SA[i] - 1] = \text{S-type}$，则将$SA[i] - 1$所代表的后缀放入对应的桶中。

这样我们就可以完成从$SA_1$诱导到$SA$的排序工作。这里简单说明一下为什么这样做是正确的：首先对于所有的$*$型后缀，都是有序排放的。从左至右扫描$SA$数组实际上就是按照字典序扫描现有的已排序的后缀。对于两个相邻的$L$型后缀$A$和$B$，这里假设$|A| > |B|$，则必定有$A > B$。由于$B$会被先加入$SA$中，所以我们保证了$A$和$B$之间的有序性。又因为$L$型桶是从左往右的顺序加入的，所以所有的$L$型后缀会逐步地按顺序加入到$SA$中。最后所有的$L$型后缀将会有序。
对于$S$型后缀，除了要注意是相反的顺序和需要重新对$*$型后缀排序外，其余的原理与$L$型的排序类似。

之前的讨论都是基于我们已知$SA_1$的情况下进行的。现在我们来考虑如何计算$SA_1$。由于$S_1$也是一个字符串，计算其后缀数组时可以考虑两种情况：

1. 如果$S_1$中每一个字符都不一样，则可以直接利用桶排序直接计算$SA_1$。
2. 否则，递归计算$SA_1$。就如之前的算法框架所展示的一样。

### 2.4 对LMS子串排序
到这里，SA-IS算法几乎已经结束了，只是还有一个问题需要解决，就是对LMS子串的排序。
之前我们所提及的，我们可以利用基数排序。虽然可以在$O(|S|)$的时间内完成，但是事实上，这个基数排序不但常熟大，而且十分复杂(请想象一下对字符串进行基数排序......)。这个排序直接成为了整个算法的性能瓶颈。因此我们急切的需要一种新的算法来胜任这一任务。
这个算法依然是**诱导排序**。

与之前从$SA_1$诱导到$SA$的算法一样，只是我们这里将第二步改为：

> 确定每个桶$S$型桶的起始位置。将每一个LMS子串的首字母按照**任意顺序**放入对应的桶中。

待算法完成，我们会获得一个$SA$数组，其中LMS子串之间是排好了序的。

为什么这个算法是正确的，我们需要扯到一个新的概念：LMS前缀。
规定LMS前缀函数$\text{pre}(S, i)$表示 (1) 如果$\text{suffix}(S, i)$是$*$型的，则$\text{pre}(S, i) = S[i]$，即LMS字符的LMS前缀就是自己。 (2) 否则是从$S[i]$开始，到下一个LMS字符之间(包括首尾)的子串。同样的，按照$\text{suffix}(S, i)$的后缀类型的不同，LMS前缀也同样分为$S$型和$L$型。
例如，在`mmiissiissiippii`中，$\text{pre}(S, 2) = S[2] =$ `i`，而$\text{pre}(S, 3) = S[3, 6] =$ `issi`。
因此上面的算法实际上是在对每个LMS前缀进行排序。

接下来将证明2-4步都是正确的，即每一步完成时$SA$数组中，LMS前缀都是有序的。

1. 对于第二步，由于放入的LMS前缀都只有一个字符，因为桶的排列是按照字典序的，所以保证放置后一定有序。
2. 对于第三步，当放入第一个$L$型LMS前缀时，$SA$数组必定是有序的(根据引理2.2)。假设我们已经放置了$k$个$L$型LMS前缀，且它们在$SA$数组中保持有序，现在考虑放入的第$k + 1$个LMS前缀是否会保证有序。我们设这个LMS前缀为$\text{pre}(S, i)$，因为首字母不同的LMS前缀一定是保持有序的，因此我们只需要考虑它与其首字母相同的LMS前缀之间的关系。因为我们是从左至右扫描来使$L$型LMS前缀从小至大放置，那么对于所有之前放置的且首字母与其相同的LMS前缀$\text{pre}(S, j)$，应该都有$\text{pre}(S, j) < \text{pre}(S, i)$。假设我们存在一个这样的LMS前缀，使得$\text{pre}(S, j) > \text{pre}(S, i)$，由于$\text{pre}(S, j)[0] = \text{pre}(S, i)[0]$，所以我们得知$\text{pre}(S, j + 1) > \text{pre}(S, i + 1)$。而$\text{pre}(S, j + 1)$与$\text{pre}(S, i + 1)$都是之前所加入过的，因此它们之间应当保持有序。而$\text{pre}(S, j) > \text{pre}(S, i)$告诉我们之前的$SA$数组不是有序的，与假设相反，故不存在这样的$\text{pre}(S, j)$。因此，当$\text{pre}(S, i)$放置后，$SA$数组保持有序。直到所有的$L$型LMS前缀加入完毕。
3. 对于第四步的正确性的证明，与第三步的证明是类似的。读者可以自行推理一下。

这样，我们就完成了对这个诱导排序的正确性的证明。但我们需要注意的是，这只是对LMS前缀的排序，我们期望是对LMS子串进行排序。我们注意到每一个LMS子串都可以视为是一个LMS字符与一个LMS前缀连接而成的，因此我们只需要判断两个LMS字符和其后一位对应的LMS前缀的大小关系，就可以判断LMS子串之间的大小关系。
然而，我们其实可以做得更简单。下面的引理说明了上面的算法结束后的$SA$数组就是排好序的LMS子串的数组。

**引理 2.8** (LMS子串排序) $SA$数组中每一个LMS字符所对应的LMS前缀已经按照其对应的LMS子串的顺序排好。
**证明** 对于首字母不同的LMS子串，这个结论是显然的。
对于首字母相同的LMS子串，它必定是由一个$L$型LMS前缀从右至左的推导过来的。由于不同的LMS子串必定对应着不同的递推的顺序，并且在第二步中，所有的$L$型LMS前缀已经排好了序。所以结论成立。

根据这个引理，我们可以直接对$SA$数组扫描一遍，就可以得到LMS子串的字典序，同时对它们进行命名。

## 3. 时空复杂度分析
在之前的讨论中，我们已经成功的运用诱导排序使每一步都是$\Theta(|S|)$。但是由于有一个递归的过程，时间复杂度似乎并不一定是线性的。
我们注意到，每次递归都是计算$S_1$的后缀数组。如果我们能够知道$S_1$的规模，就能够计算SA-IS的事件复杂度。
根据引理2.5，我们得知$|S_1| \le \left\lceil|S| / 2\right\rceil$。因此每一层的递归的问题规模都会减半。因此我们可以用以下的递归式来表示时间复杂度：
$$ T(n) = T(\left\lceil n/2\right\rceil) + \Theta(n) \tag{3.1} $$

求解可得：
$$ T(n) = \Theta(n) \tag{3.2} $$

因此总时间复杂度是$\Theta(n)$的。
对于这个递归式，我们可以理解为是递归了$O(\log n)$层，其中每一层的问题规模从小到大排序是$2^0, 2^1, 2^2, \dots, 2^{\left\lfloor\log n\right\rfloor}$。因此总复杂度就是对它们进行求和：
$$ \sum^{\left\lfloor\log n\right\rfloor}_{k=0} 2^k = 2 \times 2^{\left\lfloor\log n\right\rfloor} = \Theta(2^{\left\lfloor\log n\right\rfloor}) = \Theta(n) \tag{3.3} $$

对于空间复杂度的分析，与时间复杂度是如出一辙的。

## 4. 运行示例
下面将用`aabaaaab`作为输入字符串，展示计算其后缀数组的每一步。希望能通过这个示例能够更清晰地展现SA-IS算法的运作流程。由于涉及到对桶的操作，这里用`@`表示正在被处理的元素，而用`^`表示每个桶的起始位置。

```
           0  1  2  3  4  5  6  7  8
S:         a  a  b  a  a  a  a  b  #
扫描后缀类型
t:         S  S  L  S  S  S  S  L  S
LMS characters:     *              *
         |# |       a         |  b  |  # 桶的名称
SA:       -1|-1 -1 -1 -1 -1 -1|-1 -1
对LMS子串进行排序
1. 放入LMS子串
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
2. 从*型LMS前缀诱导到L型LMS前缀
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
          @^  ^                 ^
SA:       08|-1 -1 -1 -1 -1 03|07 -1
           ^  ^             @      ^
SA:       08|-1 -1 -1 -1 -1 03|07 02  # pre(S, 6)不是L型的
           ^  ^                @   ^
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^  ^                   @^
SA:       08|-1 -1 -1 -1 -1 03|07 02
3. 从L型LMS前缀诱导到S型前缀
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^                 ^    @^
SA:       08|-1 -1 -1 -1 -1 01|07 02
           ^              ^    @   ^
SA:       08|-1 -1 -1 -1 06 01|07 02
           ^           ^    @      ^
SA:       08|-1 -1 -1 00 06 01|07 02
           ^        ^    @         ^
SA:       08|-1 -1 05 00 06 01|07 02  # 不存在pre(S, -1)
           ^     ^    @            ^
SA:       08|-1 -1 05 00 06 01|07 02
           ^     ^ @               ^
SA:       08|-1 04 05 00 06 01|07 02
           ^  ^ @                  ^
SA:       08|03 04 05 00 06 01|07 02
           ^ @^                    ^
SA:       08|03 04 05 00 06 01|07 02  # pre(S, 7)不是S型的
          @^  ^                    ^
SA:       08|03 04 05 00 06 01|07 02
扫描并重命名LMS子串
name:      1  2
S1:       2 1 0
由于每一个字符都不一样，直接计算SA1
SA1：     2 1 0
从SA1诱导到SA
         |$ |       a         |  b  |
SA:       -1|-1 -1 -1 -1 -1 -1|-1 -1
1. 按照SA1的原顺序放入(忽略S1最后的字符)
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
           ^  ^                 ^
2. 从*型后缀诱导到L型后缀
SA:       08|-1 -1 -1 -1 -1 03|-1 -1
          @^  ^                 ^
SA:       08|-1 -1 -1 -1 -1 03|07 -1
           ^  ^             @      ^
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^  ^                @   ^
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^  ^                   @^
3. 从L型后缀诱导到S型后缀
SA:       08|-1 -1 -1 -1 -1 03|07 02
           ^                 ^    @^
SA:       08|-1 -1 -1 -1 -1 01|07 02
           ^              ^    @   ^
SA:       08|-1 -1 -1 -1 06 01|07 02
           ^           ^    @      ^
SA:       08|-1 -1 -1 00 06 01|07 02
           ^        ^    @         ^
SA:       08|-1 -1 05 00 06 01|07 02
           ^     ^    @            ^
SA:       08|-1 -1 05 00 06 01|07 02
           ^     ^ @               ^
SA:       08|-1 04 05 00 06 01|07 02
           ^  ^ @                  ^
SA:       08|03 04 05 00 06 01|07 02  # pre(S, 2)是L型
           ^ @^                    ^
SA:       08|03 04 05 00 06 01|07 02
          @^  ^                    ^
后缀数组构造完毕
SA: 8 3 4 5 0 6 1 7 2

return SA
```

## 5. 具体实现及性能对比
在原论文中说道SA-IS算法可以在100行左右的代码完成。我试了一下，基本符合这个要求。
在进行具体实现之前，你可能需要先考虑下面几个问题，避免陷入一些陷阱......

* 我真的**理解**了SA-IS算法了吗？
* 如何为每一层递归**申请空间**？
* 诱导排序的过程被**调用了两次**，可以用一个函数封装起来吗？
* 后缀类型可以用**`bool`数组**存储吗？
* 字符集是否是**动态**的？
* 如何通过一遍扫描**为LMS子串命名**？
* 如何快速判断S1中是否有**重复的字符**？
* 如果每个字符都**不一样**，如何快速计算后缀数组？
* 实际工程中，需要考虑**内存回收**。

如果说你考虑清楚了上面的问题，基本上写出SA-IS也只是时间的问题了。下面将会给出一个C++实现。需要注意的是，为了方便，这份代码中并没有回收分配的内存。

```c++
// 后缀类型
#define L_TYPE 0
#define S_TYPE 1

// 判断一个字符是否为LMS字符
inline bool is_lms_char(int *type, int x) {
    return x > 0 && type[x] == S_TYPE && type[x - 1] == L_TYPE;
}

// 判断两个LMS子串是否相同
inline bool equal_substring(int *S, int x, int y, int *type) {
    do {
        if (S[x] != S[y])
            return false;
        x++, y++;
    } while (!is_lms_char(type, x) && !is_lms_char(type, y));

    return S[x] == S[y];
}

// 诱导排序(从*型诱导到L型、从L型诱导到S型)
// 调用之前应将*型按要求放入SA中
inline void induced_sort(int *S, int *SA, int *type, int *bucket, int *lbucket,
                         int *sbucket, int n, int SIGMA) {
    for (int i = 0; i <= n; i++)
        if (SA[i] > 0 && type[SA[i] - 1] == L_TYPE)
            SA[lbucket[S[SA[i] - 1]]++] = SA[i] - 1;
    for (int i = 1; i <= SIGMA; i++)  // Reset S-type bucket
        sbucket[i] = bucket[i] - 1;
    for (int i = n; i >= 0; i--)
        if (SA[i] > 0 && type[SA[i] - 1] == S_TYPE)
            SA[sbucket[S[SA[i] - 1]]--] = SA[i] - 1;
}

// SA-IS主体
// S是输入字符串，length是字符串的长度, SIGMA是字符集的大小
static int *SAIS(int *S, int length, int SIGMA) {
    int n = length - 1;
    int *type = new int[n + 1];  // 后缀类型
    int *position = new int[n + 1];  // 记录LMS子串的起始位置
    int *name = new int[n + 1];  // 记录每个LMS子串的新名称
    int *SA = new int[n + 1];  // SA数组
    int *bucket = new int[SIGMA];  // 每个字符的桶
    int *lbucket = new int[SIGMA];  // 每个字符的L型桶的起始位置
    int *sbucket = new int[SIGMA];  // 每个字符的S型桶的起始位置

    // 初始化每个桶
    memset(bucket, 0, sizeof(int) * (SIGMA + 1));
    for (int i = 0; i <= n; i++)
        bucket[S[i]]++;
    for (int i = 1; i <= SIGMA; i++) {
        bucket[i] += bucket[i - 1];
        lbucket[i] = bucket[i - 1];
        sbucket[i] = bucket[i] - 1;
    }

    // 确定后缀类型(利用引理2.1)
    type[n] = S_TYPE;
    for (int i = n - 1; i >= 0; i--) {
        if (S[i] < S[i + 1])
            type[i] = S_TYPE;
        else if (S[i] > S[i + 1])
            type[i] = L_TYPE;
        else
            type[i] = type[i + 1];
    }

    // 寻找每个LMS子串
    int cnt = 0;
    for (int i = 1; i <= n; i++)
        if (type[i] == S_TYPE && type[i - 1] == L_TYPE)
            position[cnt++] = i;

    // 对LMS子串进行排序
    fill(SA, SA + n + 1, -1);
    for (int i = 0; i < cnt; i++)
        SA[sbucket[S[position[i]]]--] = position[i];
    induced_sort(S, SA, type, bucket, lbucket, sbucket, n, SIGMA);

    // 为每个LMS子串命名
    fill(name, name + n + 1, -1);
    int lastx = -1, namecnt = 1;  // 上一次处理的LMS子串与名称的计数
    bool flag = false;  // 这里顺便记录是否有重复的字符
    for (int i = 1; i <= n; i++) {
        int x = SA[i];

        if (is_lms_char(type, x)) {
            if (lastx >= 0 && !equal_substring(S, x, lastx, type))
                namecnt++;
            // 因为只有相同的LMS子串才会有同样的名称
            if (lastx >= 0 && namecnt == name[lastx])
                flag = true;

            name[x] = namecnt;
            lastx = x;
        }
    }  // for
    name[n] = 0;

    // 生成S1
    int *S1 = new int[cnt];
    int pos = 0;
    for (int i = 0; i <= n; i++)
        if (name[i] >= 0)
            S1[pos++] = name[i];

    int *SA1;
    if (!flag) {
        // 直接计算SA1
        SA1 = new int[cnt + 1];

        for (int i = 0; i < cnt; i++)
            SA1[S1[i]] = i;
    } else
        SA1 = SAIS(S1, cnt, namecnt);  // 递归计算SA1

    // 从SA1诱导到SA
    lbucket[0] = sbucket[0] = 0;
    for (int i = 1; i <= SIGMA; i++) {
        lbucket[i] = bucket[i - 1];
        sbucket[i] = bucket[i] - 1;
    }
    fill(SA, SA + n + 1, -1);
    for (int i = cnt - 1; i >= 0; i--)  // 这里是逆序扫描SA1，因为SA中S型桶是倒序的
        SA[sbucket[S[position[SA1[i]]]]--] = position[SA1[i]];
    induced_sort(S, SA, type, bucket, lbucket, sbucket, n, SIGMA);

    // 后缀数组计算完毕
    return SA;
}
```

SA-IS的实现还可以参考一篇很好的博文: [A walk through the SA-IS Suffix Array Construction Algorithm](http://zork.net/~st/jottings/sais.html)，这篇文章的作者使用Python一步一步地介绍了如何实现一个基础的SA-IS算法。

我们看到SA-IS作为一个后缀排序的算法，代码量也并不小，然而实际上它速度非常快，其中一个重要的原因就是SA-IS算法几乎所有的操作都是**顺序访问**的，这样就可以很好地**提高缓存命中率**[^cache]。原论文中实测SA-IS算法击败了KA算法，不愧为目前为止速度最快的后缀数组的构建算法。

[^cache]: 即降低cache-missing。

对中学OI界，构造后缀数组通常是使用倍增法和DC3算法。倍增法速度比DC3算法慢是众所周知的了，下面我将用不同规模的**随机字符串**来比较DC3算法与SA-IS算法。

| 数据规模  |   DC3    |    SA-IS    |
|:-----:|:--------:|:-----------:|
|$10^4$|$0.015\text{s}$|$0.011\text{s}$|
|$10^5$|$0.055\text{s}$|$0.036\text{s}$|
|$10^6$|$0.365\text{s}$|$0.270\text{s}$|
|$2\times 10^6$|$0.997\text{s}$|$0.593\text{s}$|
|$5\times 10^6$|$2.803\text{s}$|$2.085\text{s}$|
|$10^7$|$4.012\text{s}$|$3.326\text{s}$|

编译命令: `g++ SAIS.cpp/DC3.cpp -o sais/dc3 -O3`
运行环境: Ubuntu 14.04 LTS x64 / CPU: 2.0GHz 奔腾某CPU / 4GB内存 / 未启动X window

从上面的结果可以看出，SA-IS算法速度上明显优于DC3算法，并且数据规模越大，两者的速度差距越明显。
总而言之，SA-IS算法是一个相当不错的后缀数组的构建算法。似乎SA-IS算法所利用的诱导排序的思想还可以解决其它的一些字符串的问题，如计算LCP数组，我并没有对此做过多的了解了。
