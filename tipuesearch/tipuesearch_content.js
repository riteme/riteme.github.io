var tipuesearch = {"pages": [{"title": "$k$-SBK变换","text": "$k$-SBK变换 (ksbk.in/out/cpp)<br/>时间限制: 1 s / 内存限制: 512 MB / 打开O2优化<br/>题目描述<br/>数学家Lunk最近发现了一种逗逼的SBK变换。在Lunk眼里，SBK变换是这样的：<br/><br/>给你一个$1$至$n$的排列$A$和一个$1$至$n$的排列$P$，$P$对$A$做一次SBK变换后将得到一个新的排列$B$，其中：<br/>$$ B_{P_i} = A_i \\tag{SBK Transformation}$$<br/><br/>然而做一次SBK变换太过无聊，于是Lunk决定连续做多次SBK变换。即将每次变换后的结果$B$变为$A$，然后继续用$P$对$A$做SBK变换。Lunk想知道连续对$A$做$k$次SBK变换后的结果。<br/>输入格式<br/>第一行输入两个整数$n$和$k$，表示排列的长度和连续做SBK变换的次数。<br/>第二行输入$n$个整数表示排列$A$。<br/>第三行输入$n$个整数表示排列$P$。<br/>输出格式<br/>一行输出$n$个整数，表示$k$次SBK变换后的结果。<br/>样例输入<br/>1<br/>2<br/>35 2<br/>1 2 3 4 5<br/>2 3 4 5 1<br/><br/><br/>样例输出<br/>14 5 1 2 3<br/><br/><br/>样例解释<br/>做完第一次SBK变换后： 5 1 2 3 4<br/>做完第二次SBK变换后： 4 5 1 2 3<br/>数据范围及约定<br/>共$10$个测试点，每个测试点的数据范围如下表所示：<br/><br/><br/><br/>数据点<br/>$n$的规模<br/>$k$的规模<br/><br/><br/><br/><br/>1<br/>$\\le10^3$<br/>$\\le10^3$<br/><br/><br/>2<br/>$\\le10^3$<br/>$\\le10^3$<br/><br/><br/>3<br/>$\\le10^4$<br/>$\\le10^5$<br/><br/><br/>4<br/>$\\le10^4$<br/>$\\le2\\times10^5$<br/><br/><br/>5<br/>$\\le4\\times10^5$<br/>$\\le2^{30}$<br/><br/><br/>6<br/>$\\le4\\times10^5$<br/>$\\le2^{33}$<br/><br/><br/>7<br/>$\\le6\\times10^5$<br/>$\\le2^{63}$<br/><br/><br/>8<br/>$\\le6\\times10^5$<br/>$\\le2^{63}$<br/><br/><br/>9<br/>$\\le10^6$<br/>$\\le2^{63}$<br/><br/><br/>10<br/>$\\le2.3\\times10^6$<br/>$\\le2^{63}$<br/><br/><br/>","tags": "Problems","url": "blog/2016-7-28/ksbk.html"},
{"title": "$n = p \\mathrm{\\;mod\\;} n$递推次数的上界？","text": "$n = p \\mathrm{\\;mod\\;} n$递推次数的上界？<br/>原问题<br/>这个问题我最开始是从知乎1上看到的，里面提到了一种求逆元的方法，但是现在暂时没有方法能证明其复杂度。<br/>众所周知，当我们选取一个质数$p$作为模数时，$1..n$的每个数都存在一个模$p$意义下的逆元。如何求出这些逆元呢？最简单粗暴的方法就是使用单个数求逆元的方法对$1..n$都用一遍。自然这种方法现在无法做到线性复杂度。但是我们有一种直接递推的办法来求出$1..n$的所有逆元。具体的，我们先考虑下$n$和$r = p \\mathrm{\\;mod\\;} n$的关系。<br/>首先，根据余数的定义，我们有：<br/>$$<br/>r = p - \\left\\lfloor \\frac{p}n \\right\\rfloor n<br/>$$<br/>将其放在模$p$意义下：<br/>$$<br/>r \\equiv -\\left\\lfloor \\frac{p}n \\right\\rfloor n \\pmod{p}<br/>$$<br/>如果$r^{-1}$和$n^{-1}$都存在（如果$p$是质数则显然成立），那么上式可以变为：<br/>$$<br/>n^{-1} \\equiv -\\left\\lfloor \\frac{p}n \\right\\rfloor r^{-1} \\pmod{p}<br/>$$<br/>又因为我们知道$1^{-1} = 1$并且$r < n$，所以我们可以以$1..n$的顺序递推出所有的逆元，时空复杂度均为$\\Theta(n)$。<br/>如果直接使用递推式来计算逆元，也就变成了下面的算法：<br/>1<br/>2<br/>3<br/>4function INVERSE(n, p):<br/>    if n == 1:<br/>        return 1<br/>    return -(p / n) * INVERSE(p %  n, p)<br/><br/><br/>需要注意一点，以上方法在$p$不是质数的时候很多情况下是无法使用的，即便$n$和$p$互质。一个反例就是当$n = 3$并且$p = 8$的时候。<br/>算法复杂度<br/>该算法的递归次数实际上就是$n = p \\mathrm{\\;mod\\;} n$这个递推式要达到$n \\leqslant 1$的次数，所以下面的分析都按照这个来。<br/>实验数据<br/>这个算法似乎并不能直接从表面上简单地看出它的迭代次数。通过对一个著名的质数$p = 10^9 + 7$做了一些测试后，得到了一些数据。<br/>随机$10^6$个数来计算逆元的平均递归次数是$21.9734742$次。<br/>强行计算出$1..p - 1$中每个数的递归次数，得到以下数据：<br/><br/><br/><br/>递归次数<br/>最小满足的$n$<br/>递归次数<br/>最小满足的$n$<br/><br/><br/><br/><br/>$1$<br/>$1$<br/>$26$<br/>$114378$<br/><br/><br/>$2$<br/>$2$<br/>$27$<br/>$207512$<br/><br/><br/>$3$<br/>$3$<br/>$28$<br/>$276557$<br/><br/><br/>$4$<br/>$4$<br/>$29$<br/>$434606$<br/><br/><br/>$5$<br/>$7$<br/>$30$<br/>$591809$<br/><br/><br/>$6$<br/>$8$<br/>$31$<br/>$871900$<br/><br/><br/>$7$<br/>$9$<br/>$32$<br/>$1381645$<br/><br/><br/>$8$<br/>$18$<br/>$33$<br/>$1595237$<br/><br/><br/>$9$<br/>$36$<br/>$34$<br/>$2661365$<br/><br/><br/>$10$<br/>$79$<br/>$35$<br/>$4510426$<br/><br/><br/>$11$<br/>$158$<br/>$36$<br/>$5525194$<br/><br/><br/>$12$<br/>$207$<br/>$37$<br/>$5954939$<br/><br/><br/>$13$<br/>$327$<br/>$38$<br/>$6098436$<br/><br/><br/>$14$<br/>$1063$<br/>$39$<br/>$9347131$<br/><br/><br/>$15$<br/>$1530$<br/>$40$<br/>$17080222$<br/><br/><br/>$16$<br/>$1675$<br/>$41$<br/>$38878508$<br/><br/><br/>$17$<br/>$3418$<br/>$42$<br/>$43540116$<br/><br/><br/>$18$<br/>$5935$<br/>$43$<br/>$72349030$<br/><br/><br/>$19$<br/>$10159$<br/>$44$<br/>$84331907$<br/><br/><br/>$20$<br/>$20343$<br/>$45$<br/>$91566810$<br/><br/><br/>$21$<br/>$21368$<br/>$46$<br/>$129776171$<br/><br/><br/>$22$<br/>$28592$<br/>$47$<br/>$145037306$<br/><br/><br/>$23$<br/>$40540$<br/>$48$<br/>$284987567$<br/><br/><br/>$24$<br/>$56017$<br/>$49$<br/>$357506220$<br/><br/><br/>$25$<br/>$96241$<br/>$50$<br/>$642493787$<br/><br/><br/><br/>可以看出似乎递归次数$ \\leqslant 2\\log n$？尝试了其它的一些质数发现也满足这个上界。但是我并不会证明。如果有知道证明方法或者相关资料的可以与我联系，或者直接去回答知乎上的那个问题。<br/>对于百度出来的一些答案，都是直接默认它每次$n \\mathrm{\\;mod\\;} p$都会减半。但是实际上并非如此。如果真的达到了每次操作完$n$都会减半，那么上面的数据中也就不会出现$50$次的情况。并且就以上面最大的数字$642493787$为例，它的迭代过程中出现了这样的东西：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7...<br/>188<br/>183<br/>167<br/>166<br/>71<br/>...<br/><br/><br/>当$n = 188$并且$p = 10^9 + 7$时，经过$3$次迭代才使得$n$的规模减半。<br/>根号上界<br/>根据知乎上@徐老丝的回答，我们有一个证明其递归次数$\\leqslant 2\\sqrt{p}$的方法。<br/>首先需要确定一个基本定理：<br/><br/>如果满足$\\frac1m p \\lt n \\leqslant \\frac1{m-1} p$，那么$p \\mathrm{\\;mod\\;} n \\lt \\frac1m p$。<br/><br/>证明 证明过程比较简单，只用确认$p - (m - 1)n$的范围即可：<br/>$$<br/>p - \\frac1m p \\lt (m - 1)n \\leqslant p \\\\<br/>\\frac1m p \\gt p - (m - 1)n \\geqslant 0<br/>$$<br/>由于$n \\gt \\frac1m p$，所以$p \\mathrm{\\;mod\\;} n = p - (m - 1)n \\lt \\frac1m p$。<br/>根据以上定理，我们可以得到，如果一开始$\\frac1m p \\lt n \\leqslant \\frac1{m-1} p$，那么经过$\\sqrt{p}$次迭代后，就有$n \\lt \\frac1{m + \\sqrt{p}} p$。所以对于任意的$1 \\leqslant n \\lt p$，经过$\\sqrt{p}$次迭代后都有$n \\lt \\frac1{\\sqrt{p}} p = \\sqrt{p}$。由于每次取模$n$至少减$1$，所以之后最多$\\sqrt{p}$步使得$n \\leqslant 1$。所以该算法的一个上界是$2\\sqrt{p}$的。<br/>期望次数分析<br/>我自己思考了一种思路，似乎可以提供一种为什么该算法的递归次数非常少的解释。<br/>首先注意到对于任意的$0 \\lt n \\lt p$，设$r = p \\mathrm{\\;mod\\;} n$，那么有$n \\mid (p - r)$。<br/>同时，对于任意的$0 \\leqslant r \\lt p$，所有满足$p \\mathrm{\\;mod\\;} n = r$的$n$是$p - r$中所有大于$r$的因子。<br/>更进一步，我们比较关注那种$r \\leqslant n / 2$的$n$，从$r$的角度而言，这样的$n$都是$p - r$的大于等于$2r$的因子。<br/>现在用一张图来划分这两种$n$：<br/><br/>上图是$p = 11$时的情况。图上的每一个黑点$(x,y)$表示$y \\mid x$。这样每一个横坐标上方的点的纵坐标就是它的因子。图中并没有画出$1$的所有倍数。红色的直线是$y = 11 - x$，蓝色的直线是$y = 2 \\times 11 - 2x$。此时红色直线和蓝色直线之间所夹的一片绿色区域（不包含蓝色直线和红色直线）中的点的纵坐标$n$满足$p \\mathrm{\\;mod\\;} n > n / 2$，而剩余的黄色区域（包括蓝色直线）中的点的纵坐标$n$则满足$p \\mathrm{\\;mod\\;} n \\leqslant n / 2$。<br/>从一个给定的$n$开始迭代，每次只能向下走到另外一个纵坐标。如果走到了黄色区域，那么此时$n$的规模减半。注意到对于固定的$n$，纵坐标为$n$的点之间的间距是相同的，而红线和蓝线之间的距离和蓝线到直线$y = p$的距离也是相同的。那么$p$随机的情况下，$p \\mathrm{\\;mod\\;} n \\leqslant n / 2$的概率可以近似为$1/2$。意思是在$n$和$p$都随机的情况下，期望$\\sum_{k = 1}^\\infty k/2^k = 2$步就可以使$n$规模减半。如果不那么严谨的话，可以认为期望步数是$O(\\log n)$的。<br/><br/><br/><br/><br/>关于一种求逆元的递归式的复杂度问题？ ↩<br/><br/><br/>","tags": "数论 逆元 时间复杂度","url": "blog/2017-5-8/nmodp.html"},
{"title": "2-3树与红黑树","text": "2-3树与红黑树<br/>概述<br/>红黑树<br/>红黑树1是一种平衡二叉树，其目标是为了优化二叉搜索树，防止极端情况下时间复杂度的退化。<br/><br/>红黑树的背后原型其实是2-3树。因此我们将先了解什么是2-3树。<br/>2-3树<br/>2-3树2是一种阶为3的B树3，可以简单的理解为3叉树。2-3树最大的特点就是它一定是一棵完全3叉树，即除了叶节点外，其它的节点没有空儿子。<br/><br/>接下来我们将探究2-3树的基本操作。之后再来观察2-3树与红黑树之间的联系。<br/>2-3树？<br/>树的表示<br/>从之前给出的图中可以看出，2-3树的每个节点不一定只有一个键4，同时儿子的数量也有不同。<br/>在2-3树中，共有两种节点。<br/>第一种是“2-节点”：<br/><br/>2-节点和普通的二叉查找树的节点没有什么不同。其左儿子表示比a小的子树，右儿子表示比a大的子树。<br/>接下来是不一样的“3-节点”：<br/><br/>3-节点有两个键。最左边的儿子表示比a小的子树，中间的儿子表示大于a但小于b的子树，右边的儿子表示比b大的子树。<br/>虽然这是2-3树，呈现给我们看的树中是不存在“4-节点”的。但是为了保持树的平衡性，我们将会利用4-节点来在插入和删除过程中保持树的完美平衡。下面是一个4-节点：<br/><br/>与3-节点类似，左边和右边的儿子分别表示小于a和大于c的子树。中间的两个儿子分别表示大于a且小于b的子树和大于b小于c的子树。<br/>查询操作<br/>2-3树具有和二叉查找树一样的有序性，使得查找操作和二叉查找树类似。<br/>我们先来看一棵2-3树：<br/><br/>使用和二叉查找树一样的方法，我们在向下递归这棵树的时候通过“打擂台”来确定查找的节点应该在哪棵子树中。<br/>例如我们要查找8,首先和根节点5做比较，发现比5大，于是在其右子树中查找。<br/>接下来7-9这个3-节点中，我们先和9比较，发现比9小，于是向左移一位，与7比较，发现比7大，因此查找的节点应当在中间的子树中。<br/>继续深入下去，我们发现2-节点8就是我们要找的。<br/>由于2-3树的完美平衡性质，因此所有查询操作均可在$ \\Theta(\\text{log}N) $的时间复杂度内完成。<br/>那么问题来了，为什么2-3树具有完美平衡的性质？<br/>插入操作<br/>2-3树之所以完美平衡，关键在于插入时的维护。<br/>我们首先来看2-节点、3-节点以及4-节点之间如何转换。<br/>节点合并<br/>当我们插入结点时，通常都是插入一个键，在2-3树中就是一个2-节点。<br/>与二叉查找树一样，我们将会在2-3树中找到一个合适位置来插入它，这个位置一定在树的底部。<br/>然而，在插入前，我们可以保证这棵2-3树是完美平衡的（空树也是如此）。在底部插入一个节点后，就会导致底部“多出”一个节点，导致2-3树不完美平衡。<br/>其解决方案就是把它与上面的节点相结合。<br/>与节点结合时，共有5种情况：<br/><br/>在一个2-节点的左边 <br/>在一个2-节点的右边 <br/>在一个3-节点的左边 <br/>在一个3-节点的中间 <br/>在一个3-节点的右边<br/><br/>嗯…这些情况很无聊，下面是它们的转换情况：<br/><br/>合并的过程是很直观的，就是将2-节点放到了一个合适的地方。<br/>由于2-3树中不存在4-节点，因此不需要考虑与4-节点的合并。<br/>节点分裂<br/>在上面的节点合并的操作中，我们发现出现了4-节点。然而4-节点是不能出现在最后的2-3树中的。<br/>因此我们需要将4-节点“肢解”，以确保这是一棵2-3树。<br/>通常情况下，一个4-节点可以分裂成3个2-节点：<br/><br/>分裂的过程十分简单，只需要将4-叉节点从中间分开，并将中间的两个儿子分别重新接在a的右儿子和c的左儿子即可。<br/>但是4-节点是在插入时出现的，并且是出现在树的底部。我们发现这样一分裂就导致高度加1，直接导致树的不平衡。为了解决这个问题，我们将a和c留在原处，把b向上传递，与父亲节点结合。这样就可以避免高度的增加了。<br/>但是父亲节点可能是一个3-节点，b向上结合时又会产生4-节点！但是不必慌张，我们只需要继续分解这个新生成的4-节点即可。<br/>那么问题又来了，如果父亲节点是3-节点并且它是树根呢？<br/>其实非常简单，我们依然可以分解4-节点，由于根节点没有父亲，因此向上传递的节点就没必要去结合了，此时整棵树的高度加1，保证了2-3树的完美平衡性。<br/>插入示例<br/>下面是一个完整的插入示例，依次向一棵空的2-3树中插入1到7：<br/><br/>在插入节点中，找到其正确的位置需要访问$ \\Theta(\\text{log}N) $个节点。回溯向上调整2-3树时，每个节点处的调整时间为$ \\Theta(1) $。因此，2-3树的插入操作的时间复杂度为$ \\Theta(\\text{log}N) $。<br/>删除操作<br/>可以看出，2-3树的插入操作是有点复杂的，然而删除操作更加麻烦。我们首先从简单的情况开始讨论。<br/>首先，我们确定一点：2-3树中的节点的儿子，要么都是空儿子，要么都不是空儿子。<br/>原因非常简单，我们用反证法来证明：如果存在一个节点，它既有非空儿子，又有空儿子，那么非空儿子在树中所处的深度肯定大于父节点的深度，那么以这个节点为根的子树不是完美平衡的。又因为2-3树必须是完美平衡的，因此2-3树需要它所有的子树也是完美平衡的，故这样的节点是不存在的。<br/>并且可以看出，只有树的底部节点才会没有儿子。<br/>由此，我们就可以方便的分情况讨论。<br/>删除底部节点<br/>我们先考虑底部节点是因为这些节点不需要和它的儿子们“纠缠不清”，并且它也是我们后续删除算法的一个基础。<br/>首先考虑3-节点。从3-结点删除一个键非常简单，只需要将其变成一个2-节点就可以保证2-3树的完美平衡。然而删除一个2-节点就麻烦了，因为这会导致留下一个空位，而且没有合适的节点来填补它。<br/>为了解决这个问题，我们考虑在删除之前能否将其变成一个3-节点。<br/>答案是肯定的，我们可以通过从根节点开始的一系列变换来实现这一点。<br/>为了在最后删除的时候的确是一个3-节点，我们必须确保在查找被删除的节点的路径上必须一直有3-节点。<br/>假设我们在寻找待删除节点的路径上已经处于一个3-节点处，我们需要考虑如何保证下一步也是一个3-节点。首先，我们确定要向下递归的方向，如果在该方向上已经有一个3-节点，那么我们无需变换就可安全地递归向下。如果该方向上没有3-节点，我们就需要想办法变出一个3-节点。<br/>如何才能变出一个3-节点呢？一个很好的想法就是当我们有很多的节点时，我们就有很大的自由来分配这些节点。因此，我们将当前的3-节点中的一个键拿出来，和它的儿子”团聚”一下，然后确定如何“发配”这些“聚在一起”的节点。如果其中一个儿子是3-节点，那么聚合后就会出现一个含有4个键的5-节点！5-节点是绝对不能出现的！但是我们可以从中取出两个键来构成一个3-节点，剩下的两个键则用于调整局部平衡。这样就既不损害2-3树的完美平衡性，又能在希望的地方创建一个3-节点了。当然，你也可以理解成公然从左儿子或右儿子中“抢来”了一个键。<br/>但如果两个儿子中没有一个是3-节点，那么我们现在就只凑到了3个键，还不足以分解出3-节点。因此，我们索性将从当前节点的分离出来的键和儿子们构成一个临时的4-节点。没错，就是4-节点，在4-节点中删除一个键也是很容易的，并且如果不是从中删除键，我们也有办法在删除完指定的键之后的回溯过程中来分解这个4-节点，从而保证2-3树中不会出现不该出现的东西。<br/>为了更清楚的说明上面这坨东西在讲什么，我放几张图解释一下：<br/>首先是可以从旁边“抢”节点的情况：<br/><br/>上图是准备向右递归之前的调整过程。首先取出e与它的儿子3-节点c-d和2-节点f结合生成了一个5-节点c-d-e-f，然后我们取出e和f在右边创建出一个3-节点，然后d代替原来3-节点b-e中e从而还原，然后被抢掉一个键的c就默默的留在原地…<br/>对于向左边和中间调整都是类似的做法。只是向中间递归的调整需要先判定是左边有3-节点还是右边有3-节点，从而确定被取出的键是谁。<br/>如果这个键的儿子都是2-节点，我们从这个节点中取出一个键向下合并，却只能创造出一个临时的4-节点，无法从中提取出3-节点。因此我们将其留在那里当作是3-节点。这个4-节点等到我们删除完之后再来处理。如果要删除的键就在这个节点中，我们就不需要管了。如果这个4-节点依然保留着，只需分解它即可。下面是合并的过程：<br/><br/>但是，上面的做法都是在假设当前正处在一个3-节点处而做的。倘若根节点就不是3-节点，那该怎么办呢？<br/>考虑到根节点的特殊性，我们可以直接将其和它的儿子合并为4-节点。<br/><br/>如果根节点和它的左右儿子都是2-节点，那么我们可以直接将它和儿子们结合，变成一个3-节点。这样会导致树的局部的高度降低。然而这是在根节点处，所以这样的变化是全局性的，不会影响2-3树的完美平衡性。同时有保证向下变换时有充足的键可取。同理，这个遗留的4-节点可以日后再来将其分解掉。<br/>这样，我们就能确保在删除操作必定是在3-节点内进行的了。于是我们完成了底部节点的删除操作。<br/>删除中间节点<br/>然而，我们不一定会去删除底部节点，而是会删除树中央的一个节点。这样似乎问题变得很棘手。<br/>然而我们可以将其转换为删除底部节点。我们模仿二叉搜索树的删除方式：当要被删除的节点有两个儿子时，用该节点的前趋或者后继节点来顶替它，并且将这个前趋或者后继节点删除。<br/>由于2-3树的非底部节点一定是有多个儿子的，因此，我们找到其后继节点，将这个后继节点的键和卫星数据5复制到要被删除的节点处，这样就实现了用后继节点来顶替原先节点的任务。因此我们就只需要将原来的后继节点删除即可。<br/>而一个节点的后继节点是它的右子树中的最小的节点，即右子树中最靠左的节点，因此它肯定没有儿子。所以我们可以使用删除底部节点的方法来删除它。<br/>删除示例<br/>为了使大家想得更明白，这里给出一个删除底部节点的示例。<br/>首先，下面是一棵高度为4的2-3树，我们准备删除i：<br/><br/>从根节点开始，发现i在右子树中，但发现根节点自己和左右儿子都是2-节点，于是它们合并为一个4-节点：<br/><br/>接下来在新的4-节点d-h-n中发现右儿子为3-节点，于是直接向下搜索。<br/>在3-节点j-l中我们发现i在其左子树中，并且左儿子不是3-节点，于是我们将j向下合并：<br/><br/>向下后来到4-节点i-j-k，发现目标i就在其中，我们直接将其删除：<br/><br/>删除完成，我们沿着递归向下的顺序向上回溯。回溯到根节点时，我们发现是一个4-节点，于是我们将其分解：<br/><br/>至此。删除操作就完成了。<br/>对于所有的删除操作，2-3树需要$ \\Theta(\\text{log}N) $的时间查找节点，并且以$ \\Theta(1) $的时间在每个回溯的节点处来作出适当的调整。故2-3树的删除操作是$ \\Theta(\\text{log}N) $的。<br/>2-3树到红黑树<br/>上面讲了那么多关于2-3树的操作，却从不提及其具体实现，是因为2-3树在实际中很少使用。<br/>由于其需要大量的节点变换（从2-节点到3-节点到4-节点甚至到5-节点…），这些变换在实际代码中是很复杂的。所以现在几乎没有2-3树的具体实现。<br/>但是由于2-3树的变化十分直观，因此前人在2-3树的理论基础上发明了红黑树。<br/>变化到红黑树<br/>红黑树是一种平衡二叉树，只有一种节点。这种节点有两个儿子，和2-3树中的2-节点对应。<br/><br/>如何表示3-节点呢？我们尝试一种特殊的边：默认情况下节点的颜色均为黑色。我们将某个节点染为红色，表示它和父亲的的链接是红色的，就像下图：<br/><br/>当我们将红链接画平时…<br/><br/>我们发现它和2-3树中的3-节点极为类似！<br/>事实上，我们完全可以用这样的方式来表示2-3树中的3-节点。<br/>下图是一棵典型的红黑树：<br/><br/>如果将红链接画平，将得到一棵完美平衡的“2-3树”：<br/><br/>从某种意义上来说，红黑树和2-3树是一种等同。<br/>同时，为了我们的操作方便，我们对红黑树作出以下规定：<br/><br/>红黑树是二叉搜索树。  <br/>根节点必须为黑色。毕竟根节点没有父亲。  <br/>红链接必须在左侧6。将红链接统一在一个方向是为了方便其它操作。如果不统一，3-节点就有两种情况，4-节点就有5中情况，非常不利于我们判定当前是什么节点。并且，对于右边的红链接，我们可以通过二叉搜索树的旋转操作来将其变为左链接。具体的会在之后解释。  <br/>不允许两个连续的红链接。因为连续的连个红链接表示的是4-节点。当然，跟2-3树一样，插入/删除的过程中还是允许临时的4-节点。  <br/>每一条树链上的黑色节点数量（称之为“黑高”）必须相等。原因非常简单，一个黑色节点就对应着2-3树中的一个2-节点或3-节点，而2-3树是完美平衡的。  <br/>空节点（NULL/None）为黑色。这样方便将方便我们识别没有儿子的2-节点。<br/><br/>查询操作<br/>由于红黑树是二叉搜索树，因此查询操作就是二叉搜索树的查询操作。时间复杂度为$ \\Theta(\\text{log}N) $。<br/>基本操作<br/>在介绍红黑树的插入和删除操作前，首先介绍红黑树的一些基本操作。<br/>旋转<br/>红黑树的旋转只有两种：顺时针旋转和逆时针旋转7。<br/>红黑树的旋转操作是为了在保证二叉搜索树和红黑树的性质的前提下，来转换红链接的位置。  <br/><br/>可以看出顺时针旋转就是将节点的左儿子提上来，将自己变做它的右儿子，将左儿子的右子树接到自己的左子树中，同时转变红链接。可以将其想象成把4->2这条边顺时针旋转了一下。逆时针旋转也是类似的做法。同时顺时针旋转和逆时针旋转可以视为一对逆操作，因为一次左旋和一次右旋可以变回原来的样子。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25# 顺时针旋转<br/>def cw_rotate(h):<br/>    assert h is not None and h.left is red  # h是非空节点并且左儿子为红色<br/><br/>    x = h.left<br/>    h.left = x.right<br/>    x.right = h<br/>    x.color = h.color<br/>    h.color = red<br/><br/>    return x  # 返回被提上来的左儿子<br/><br/># 逆时针旋转<br/>def ccw_rotate(h):<br/>    assert h is not None and h.right is red  # h是非空节点并且左儿子为红色<br/><br/>    x = h.right<br/>    h.right = x.left<br/>    x.left = h<br/>    x.color = h.color<br/>    h.color = red<br/><br/>    return x  # 返回被提上来的左儿子<br/><br/>h = cw_rotate(h)  # 将h顺时针旋转<br/><br/><br/>反色<br/>如同在2-3树中一样，红黑树要能够处理4-节点。<br/>对于4-节点，我们只有两种操作：合成一个4-节点和分解一个4-节点。<br/><br/>对照一下2-3树，这个操作就显而易见了。<br/><br/>也许你会注意到反色操作会将两个儿子的父节点变为红色，是因为在2-3树中，中间取出来的键要向上传递并结合进去。此外，反色操作会导致出现右边的红链接，然而这没有关系，因为4-节点是临时的，我们最终会通过逆时针旋转将其变为左边的红链接或者再次反色将这个4-节点分解。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10def flip_color(h):<br/>    assert h.color is different from h.children.color  # h的颜色和它的儿子相反<br/><br/>    h.color = (h.color == RED ? BLACK : RED)<br/>    h.left.color = (h.left.color == RED ? BLACK : RED)<br/>    h.right.color = (h.right.color == RED ? BLACK : RED)<br/><br/>    return h<br/><br/>h = flip_color(h)  # 将h反色<br/><br/><br/>插入操作<br/>为了探究红黑树的插入操作，我们依然回到2-3树。在2-3树中，我们将新插入的节点与上面的节点合并，然后再做调整。为了表示合并，我们将新插入的节点均设为红色，表示与上面的节点相连接。  <br/>然而插入后，新的红节点可能会违反我们的规定，因此需要在回溯的时候进行调整。<br/>情况一：调整右边的红链接<br/>当我们发现某个节点的左儿子是黑色但右儿子是红色时，我们要将右边的红色链接转到左边来：<br/><br/>如上图，通过对b逆时针旋转，完成了对红链接位置的纠正。<br/>这样做是为了方便接下来的操作。<br/>情况二：分解4-节点<br/>在情况一中，我们要求节点的左儿子是黑色。这是因为当左儿子和右儿子都是红色时，就代表着一个4-节点，为此我们可以直接将其反色来分解它：<br/><br/>如果该操作是在根节点上，那么整棵红黑树的黑高将会加1。<br/>情况三：连续的红色左儿子<br/>在情况一中，我们能够把所有的右边的红色节点转到左边来，这样就好判断是否存在4-节点。除了情况二中的4-节点外，连续的两个红色左儿子也将表示一个4-节点：<br/><br/>对此，我们的做法是将节点顺时针旋转，从而变为了情况二。<br/>平衡操作<br/>上面介绍了三种插入时的情况，实际上已经将插入的所有情况都概括到了。接下来我们将实现一个平衡操作。这个平衡操作就是通过对节点的情况进行判定并作出调整。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13def balance(h):<br/>    assert h is not None  # 当然不能为非空节点<br/><br/>    if h.right is red and h.left is not red:  # 情况一<br/>        h = ccw_rotate(h)<br/><br/>    if h.left is red and h.left.left is red:  # 情况三<br/>        h =.cw_rotate(h)<br/><br/>    if h.left is red and h.right is red:  # 情况二<br/>        h = flip_color(h)<br/><br/>    return h  # 返回调整后的h节点<br/><br/><br/>有了平衡操作后，我们就能直接改动一行二叉搜索树的插入代码，就能实现红黑树的插入了：<br/>1<br/>2<br/>3<br/>4<br/>5def insert(h, key, value):<br/>    # 二叉搜索树的插入实现<br/><br/>    # return h<br/>    return balance(h)  # 插入后回溯的过程中，先平衡节点，再返回<br/><br/><br/>这里需要注意一点，当所有操作完成以后，根节点可能变为红色，这是需要我们手动将根节点设置为黑色。<br/>由于balance操作是$ \\Theta(1) $的时间复杂度，故红黑树的插入操作是$ \\Theta(\\text{log}N) $的时间复杂度。<br/>删除操作<br/>正如你所见，红黑树的插入写起来也并不是那么难。然而删除操作就未必。根据我们在2-3树中所讨论的，红黑树删除节点也要保证一路上都有一个3-节点或4-节点。<br/>红节点的转移<br/>由于红黑树在向下递归的过程中只有向左边和向右两个方向，因此我们再弄两个操作：红色左移和红色右移。这两个操作用于在左儿子和右儿子处创造出一个3-节点或4-节点。<br/>我们先讨论红色左移的情况，毕竟红色右移也是类似的做法。<br/>当我们要在左儿子处造一个3-节点时，首先肯定左儿子不是3-节点。那么按照2-3树的做法，我们要么是从右儿子借一个节点，要么就是把自己“献身”。<br/>第一种情况是右儿子不是3-节点，我们直接在左儿子处创建4-节点：<br/><br/>上面就是利用了反色操作。<br/>另一种情况是右儿子是一个3-节点，那么操作就有点复杂了：<br/><br/>和2-3树一样，我们将b合并创建出一个5-节点。然后我们发现右儿子的左儿子是红色的，即右儿子为3-节点。为此，我们通过两次旋转操作将代替节点b的节点c旋转到曾经b的位置。最后我们分裂这个5-节点，此时左儿子已经是一个3-节点。<br/>这样我们就能把红色左移给写出来了：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13def move_red_to_left(h):<br/>    assert h is red and h.left is not red  # 左儿子必须为黑色，同时当前必须是红色<br/><br/>    h = flip_color(h)  # 与儿子节点结合<br/><br/>    if h.right.left is red:  # 如果右儿子为3-节点<br/>        # 通过两次旋转将替代者上移至h处<br/>        h.right = cw_rotate(h.right)<br/>        h = ccw_rotate(h)<br/><br/>        h = flip_color(h)  # 分裂5-节点<br/><br/>    return h<br/><br/><br/>同样红色右移也是一样的做法。先是节点结合，然后根据情况进行调整。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11def move_red_to_left(h):<br/>    assert h is red and h.right is not red<br/><br/>    h = flip_color(h)<br/><br/>    if h.left.left is red:<br/>        h = cw_rotate(h)  # h的左儿子就是替代者<br/><br/>        h = flip_color(h)<br/><br/>    return h<br/><br/><br/>处理根节点<br/>和2-3树一样，根节点可能为2-节点。为了方便处理，我们可以把根节点也看作是一个3-节点：<br/><br/>上图中，a是真正的根节点，而$ \\infty $是一个想象的节点，实际上不存在。这样根节点就变成了一个3-节点。<br/>并且，对于这个3-节点，无论红色左移和红色右移都不会关系到$ \\infty $，因此这样不会导致问题。<br/>实际中，我们直接将根节点设为红色即可。当删除操作完成后，再把根节点设为黑色。<br/>真正的删除<br/>解决了红色节点的转移的工作，删除操作也就变得清晰了。下面将介绍删除操作该如何进行。<br/>红黑树的删除过程和二叉搜索树类似。首先都要在树中找到这个节点，然后再着手处理。<br/>对于红黑树，它的节点也是要么都是空儿子，要么就没有空儿子。<br/><br/>对于没有儿子的节点，在保证向下递归的红色节点的变换完成之后，如果它是红节点，我们可以直接将其删除。如果不是红节点，那么它的左儿子必定是红色节点，因为我们保证它会在一个3-节点或4-节点中，并且我们的红色转移操作都是创建红链接在左的节点。这样我们可以直接将其顺时针旋转，使其变为红色节点，然后直接删除。  <br/>对于有儿子的节点，我们模仿二叉搜索树中的做法：在它的右子树中找到最小的节点来替代它的位置，然后在右子树中将这个节点删除即可。<br/><br/>下面是红黑树的删除操作的参考实现：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29<br/>30<br/>31<br/>32<br/>33<br/>34<br/>35<br/>36<br/>37<br/>38<br/>39<br/>40# 获取后继节点<br/>def min_node(h):<br/>    assert h is not None<br/><br/>    if h.left is not None:  # 一直沿左链接寻找<br/>        return min_node(h.left)<br/>    else:<br/>        return h<br/><br/>def delete(h, key):<br/>    assert h is not None  # 确认不是一棵空树<br/><br/>    if key < h.key:  # 在左子树中<br/>        if h.left is black and h.left.left is black:  # 如果左儿子不是3-节点<br/>            h = move_red_to_left(h)<br/><br/>        h.left = delete(h.left, key)<br/>    else:  # 在右子树中或已经找到<br/>        if h.left is red:<br/>            h = cw_rotate(h)  # 将左边的红链接变为右边的红链接<br/><br/>        if key == h.key and h.right is None:  # 如果已经查找到并且没有儿子<br/>            del h  # 直接删除<br/>            return None<br/><br/>        if h.right is black and h.right.left is black:  # 如果右儿子不是3-节点<br/>            h = move_red_to_right(h)<br/><br/>        if key == h.key:  # 如果已经查找到但有儿子<br/>            x = min_node(h.right)  # 找到后及节点<br/><br/>            # 交换键值和卫星数据<br/>            h.key = x.key<br/>            h.data = x.data<br/><br/>            h.right = delele(h.right, x.key)  # 在右子树中删除后继<br/>        else:  # 如果没有命中，则继续往右边寻找<br/>            h.right = delete(h.right, key)<br/><br/>    return balance(h)  # 完成删除后平衡当前的子树<br/><br/><br/><br/><br/><br/><br/>红黑树维基百科：https://zh.wikipedia.org/zh-cn/% E7% BA% A2% E9% BB% 91% E6% A0% 91 ↩<br/><br/><br/>2-3树（2-3-4树）维基百科：https://zh.wikipedia.org/wiki/2-3-4% E6% A0% 91 ↩<br/><br/><br/>B树维基百科：https://zh.wikipedia.org/wiki/B% E6% A0% 91 ↩<br/><br/><br/>键（Key）表示节点用于索引的值，同时也是确定节点在树中的位置的依据之一。 ↩<br/><br/><br/>卫星数据指存储在这个节点上的与树结构无关的数据，即这个节点的一些附加数据，例如假设每个节点表示一个人，那么性别、年龄、身高等就属于卫星数据。 ↩<br/><br/><br/>这是红黑树的一种实现。网络上有其它的实现，允许右儿子为红色。 ↩<br/><br/><br/>也称作左旋和右旋，但个人认为这样的名字晦涩并具有误导性，故使用顺时针旋转和逆时针旋转代替。 ↩<br/><br/><br/>","tags": "2-3树 红黑树 算法 数据结构","url": "blog/2016-3-12/2-3-tree-and-red-black-tree.html"},
{"title": "BST厂长","text": "BST厂长 (bst.in/out/cpp)<br/>时间限制: 1 s / 内存限制: 128 MB / 打开O2优化<br/>题目描述<br/><br/>二叉树真是迷人......<br/><br/>随着时代的进步，二叉搜索树(Binary Search Tree)发挥着越来越大的作用。作为HNSDFZ上机部长XL，担负着为学校制造各种BST的任务。它们会用于各种用途：成绩排名、薪水发放、PY**......<br/>本来学校对BST的需求并不是很大，但是自从ZY加入了上机组后，BST的需求越来越大......<br/>作为XL，早已按捺不住。于是XL利用通用技术教学楼建立了一个厂房，专门制造各种BST。<br/>这个厂子会收到各种各样的订单。每个订单都会是一个很长的数列，其中没有两个数是相同的。而XL要做的就是将这些数字依次插入到一棵空的BST中，然后将BST发送出去。<br/>然而人工干这件事实在是太麻烦了，因此XL将ZY抓过来造BST。然而ZY更懒，把Link抓过来要它帮<br/>ZY写个程序来构建BST。然而Link并不屑于写这个程序，于是这个任务莫名其妙地传到了你手上......<br/>当然XL不会就这样放手不管，XL会随时来检查这棵BST是否是正确的，以防你在乱造BST。<br/>输入格式<br/>第一行输入一个正整数$n$，表示订单中数列的长度。<br/>接下来$n$行，每行输入两个正整数$x$和$k$。表示将$x$插入到当前的BST中。初始时是空树。$k$则表示XL的检查。他会问你根节点到新插入的节点$x$的链上第$k$个节点是谁。默认从$1$开始数。<br/>输出格式<br/>对于每一次XL的检查，输出对应的答案。<br/>样例输入<br/>1<br/>2<br/>3<br/>43<br/>2 1<br/>1 1<br/>3 2<br/><br/><br/>样例输出<br/>1<br/>2<br/>32<br/>2<br/>3<br/><br/><br/>提示及数据约定<br/>对于第一次插入$2$，树的根节点为$2$，故答案为$2$。<br/>对于第二次插入$1$，因为$1 \\lt 2$，所以$1$是$2$的左儿子。$2$到$1$的链上的第一个节点为$2$<br/>对于最后一次插入$3$，因为$3 \\gt 2$，所以$3$是$2$的右儿子。$2$到$3$的链上的第二个节点是$3$。<br/>对于$10\\% $的数据，$n \\le 20,000$。<br/>对于$10\\% $的数据，$n \\le 90,000$。<br/>对于$20\\% $的数据，$n \\le 100,000$。<br/>对于另外$10\\% $的数据，数列完全随机。<br/>对于$100\\% $的数据，$n \\le 200,000$，$1 \\le x \\le n$，保证每次检查的节点存在。","tags": "Problems ZY XL LinkSBK","url": "blog/2016-5-30/riteme.html"},
{"title": "DevIL快速入门","text": "DevIL快速入门<br/>DevIL全名是“Developer’s Image Library”，它是一个多功能的图像库，能过很方便地载入、修改和保存图片。<br/>其原名是OpenIL，后来是因为SGI的要求才改名为DevIL1。<br/>本文主要介绍DevIL载入和保存图片的功能。DevIL虽然有处理图片的功能，但并不够强，不如使用Boost.GIL，<br/>因此不介绍DevIL处理图片的功能。<br/>特点<br/>DevIL具有几个非常好的特性：<br/><br/>支持包括PNG，JPG，TGA等30多种图片格式。  <br/>与OpenGL类似的API风格。  <br/>十分轻巧  <br/>有许多辅助函数（ilut）<br/><br/>安装<br/>理论上安装DevIL不会很艰难。对于Ubuntu 用户而言，可以直接使用下列命令来安装：<br/>1sudo apt-get install libdevil-dev<br/><br/><br/>具体的下载、编译、安装的页面在此。<br/>初始化<br/>接下来正式介绍如何使用DevIL。首先，我们需要添加头文件：<br/>1#include <IL/il.h><br/><br/><br/>一般情况下，动态链接的DevIL会自动加载，不必调用特定的函数。但在某些情况下可能不会。因此，为了兼容性，我们最好手动载入：<br/>1<br/>2// 在程序开始的地方<br/>ilInit();<br/><br/><br/>仅仅一行代码，并没有什么关系。<br/>加载图片<br/>DevIL中使用了和OpenGL一样的对象创建方式。为了加载图片，我们首先要创建一个图片对象：<br/>1<br/>2<br/>3ILuint image = 0;<br/>ilGenImages(1, &image);<br/>assert(image != 0);  // 检查是否创建成功<br/><br/><br/>也许你会发现第二行非常熟悉，确实和OpenGL中创建缓冲区的调用长得非常像，因此很多使用OpenGL的开发者能很快上手。<br/>当然，你如果觉得这还麻烦了，可以只创建一个：<br/>1ILuint image = ilGenImage();<br/><br/><br/>就像OpenGL一样，需要绑定当前的图片对象。绑定后，所有的操作都是在此图片对象上的，除非解绑：<br/>1<br/>2<br/>3<br/>4<br/>5ilBindImage(image);<br/><br/>// ...<br/><br/>ilBingImage(0);  // 解绑图片对象<br/><br/><br/>绑定好图片对象后，就可以直接使用ilLoad函数来加载图片了：<br/>1ilLoad(IL_PNG, \ sample.png\ );<br/><br/><br/>上面的IL_PNG是指定图片格式为PNG。<br/>当然，可以使用更简单的ilLoadImage：<br/>1ilLoadImage(\ sample.png\ );<br/><br/><br/>使用ilLoadImage就不需要手动指定图片格式了，DevIL会自动检测。<br/>我们可以使用ilGetError来查看错误。如果加载过程中没有出错，ilGetError会返回IL_NO_ERROR。<br/>1assert(ilGetError() == IL_NO_ERROR);<br/><br/><br/>注意<br/>当你不需要再使用图片对象时，应及时使用`ilDeleteImage`删除：<br/><br/>wzxhzdk:9<br/><br/><br/>创建材质<br/>加载完图片后，还只是将数据托管在DevIL内部。为了能够将数据提供给OpenGL或DirectX来创建材质，我们使用ilGetData()。<br/>同时，我们还需获取图片的相关的信息，如宽度、高度、图片存储格式等等，这些都可以使用ilGetInteger来获取。<br/>下面是在OpenGL中创建材质的过程：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9ilBindImage(image);                               // 绑定当前图片对象<br/>GLint    width  = ilGetInteger(IL_IMAGE_WIDTH);   // 获取图片宽度<br/>GLint    height = ilGetInteger(IL_IMAGE_HEIGHT);  // 获取图片高度<br/>GLenum   format = ilGetInteger(IL_IMAGE_FORMAT);  // 获取图片像素格式<br/>ILubyte *ptr    = ilGetData();                    // 获取图片数据的指针<br/>ilBindImage(0);<br/><br/>// 创建材质<br/>glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, ptr);<br/><br/><br/>提示<br/>DevIL中可以获取很多图片的信息，除了宽度、高度和像素格式外，还可以获取色深（IL_IMAGE_DEPTH）、<br/>图片数据的大小（IL_IMAGE_SIZE_OF_DATA）、BPP（”Bytes Per Pixel“，每个像素所占字节数，IL_IMAGE_BPP或IL_IMAGE_BYTES_PER_PIXEL）、<br/>Bit Per Pixel（每个像素所占位数，IL_IMAGE_BITS_PER_PIXEL）、图片格式（IL_IMAGE_TYPE）、<br/>水平/竖直平移量（IL_IMAGE_OFFX和IL_IMAGE_OFFY）、图片原点（IL_IMAGE_ORIGIN）、<br/>颜色通道数（IL_IMAGE_CHANNELS）等。<br/><br/>提示<br/>在上面的示例中，图片的像素格式被直接传到OpenGL的函数中是可以的，因为DevIL对应的值和OpenGL规定的是一样的，不会有问题。<br/>对于DirectX，需要手写switch来切换。<br/><br/>保存图片<br/>DevIL中保存图片很简单，只需要先绑定图片对象，指定保存路径就可直接保存。DevIL会自动通过文件后缀名来确定图片格式。<br/>1<br/>2<br/>3ilBindImage(image);<br/>ilSaveImage(\ output.png\ );<br/>ilBindImage(0);<br/><br/><br/>可是我们并没有对图片做什么处理啊，保存它有什么用？确实，我们不会去用DevIL来做什么特效。但有一个场景却很常用，就是保存截图。<br/>对于OpenGL，DevIL的工具库ilut已经帮我们做到了这一点。我们可以非常简单的写出保存截图的函数：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16#define ILUT_USE_OPENGL  // 通知ilut使用OpenGL<br/>#include <IL/ilut.h><br/><br/>// 保存截图<br/>bool TakeScreenshot(const std::string &filepath) {<br/>    ILuint image = ilGenImage();    <br/>    ilBindImage(image);<br/><br/>    ilutGLScreen();                // 将当前OpenGL的颜色缓冲区的数据复制到image中<br/>    ilSaveImage(filepath.data());  // 保存图片<br/><br/>    ilBindimage(0);<br/>    ilDeleteImage(image);          // 记得释放图片对象<br/><br/>    return ilGetError() == IL_NO_ERROR;<br/>}<br/><br/><br/>没错，ilutGLScreen帮我们做了一切。只是非常可惜，截图的函数是OpenGL专属的。<br/>但它是怎么工作的呢？我在GitHub上找到其源码，其过程非常简短。<br/>下面是GitHub上的源码：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22//! Takes a screenshot of the current OpenGL window.<br/>ILboolean ILAPIENTRY ilutGLScreen()<br/>{<br/>    ILuint  ViewPort[4];<br/><br/>    ilutCurImage = ilGetCurImage();<br/>    if (ilutCurImage == NULL) {<br/>        ilSetError(ILUT_ILLEGAL_OPERATION);<br/>        return IL_FALSE;<br/>    }<br/><br/>    glGetIntegerv(GL_VIEWPORT, (GLint*)ViewPort);<br/><br/>    if (!ilTexImage(ViewPort[2], ViewPort[3], 1, 3, IL_RGB, IL_UNSIGNED_BYTE, NULL))<br/>        return IL_FALSE;  // Error already set.<br/>    ilutCurImage->Origin = IL_ORIGIN_LOWER_LEFT;<br/><br/>    glPixelStorei(GL_PACK_ALIGNMENT, 1);<br/>    glReadPixels(0, 0, ViewPort[2], ViewPort[3], GL_RGB, GL_UNSIGNED_BYTE, ilutCurImage->Data);<br/><br/>    return IL_TRUE;<br/>}<br/><br/><br/>我们来简要分析下这个过程在干什么。<br/>首先是获取当前绑定的图片对象：<br/>1<br/>2<br/>3<br/>4<br/>5ilutCurImage = ilGetCurImage();<br/>if (ilutCurImage == NULL) {  // 检查并报错<br/>    ilSetError(ILUT_ILLEGAL_OPERATION);<br/>    return IL_FALSE;<br/>}<br/><br/><br/>然后获取当前OpenGL视图的信息：<br/>1<br/>2<br/>3<br/>4<br/>5ILuint  ViewPort[4];<br/><br/>// ...<br/><br/>glGetIntegerv(GL_VIEWPORT, (GLint*)ViewPort);<br/><br/><br/>此时，ViewPort中存储的分别是原点的X坐标和Y坐标，以及视图的宽度和高度。<br/>根据获取来的视图信息，就需要调整图片的参数：<br/>1<br/>2<br/>3<br/>4// ilTexImage分别设置的是图片的宽度、高度、BPP、颜色通道数量、像素格式和数据格式<br/>// 最后一个参数是图片数据的指针，但是图片数据要在之后读取，因此这里填nullptr<br/>if (!ilTexImage(ViewPort[2], ViewPort[3], 1, 3, IL_RGB, IL_UNSIGNED_BYTE, NULL))<br/>    return IL_FALSE;  // 设置失败<br/><br/><br/>然后是从OpenGL的颜色缓冲中读取数组：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8// 因为OpenGL的原点是在左下角，而屏幕坐标的原点却在左上角，因此此处做点调整<br/>ilutCurImage->Origin = IL_ORIGIN_LOWER_LEFT;<br/><br/>// 更改数据的内存对齐，避免读出来的数据格式不对<br/>glPixelStorei(GL_PACK_ALIGNMENT, 1);<br/><br/>// 读出数据<br/>glReadPixels(0, 0, ViewPort[2], ViewPort[3], GL_RGB, GL_UNSIGNED_BYTE, ilutCurImage->Data);<br/><br/><br/>那么此时截图的方法已经出来了。对于DirectX，只需先创建图片对象并重设其参数，<br/>然后读出颜色数据到图片中，最后保存即可。不过我不怎么熟悉DirectX，因此这里并没有给出DirectX的截图代码了。<br/>结尾<br/>从上面的文章我们已经了解了DevIL库，并且能够运用到实际工程中了。<br/>事实上类似的库还有很多，例如SOIL和FreeImage。<br/>如果你只是专注于一种格式，也许像libpng和libjpg更适合你。<br/>因此在实际中，需要我们酌情选择合适的库来提高自己的开发效率。<br/><br/><br/><br/><br/>官方说法在这里 ↩<br/><br/><br/>","tags": "C/C++ DevIL OpenGL","url": "blog/2016-2-5/devil-usage.html"},
{"title": "Graphviz: 可视化调试利器","text": "Graphviz: 可视化调试利器<br/>当你的各种树出现奇奇怪怪的问题时，你是如何找到错误的呢？<br/>printf？GDB？肉眼？<br/>当然这些方法当然可行，然而把它画出来岂不更秒？<br/>现在祭出利器：Graphviz<br/>简介<br/><br/>Graphviz is open source graph visualization software. Graph visualization is a way of representing structural information as diagrams of abstract graphs and networks. It has important applications in networking, bioinformatics,  software engineering, database and web design, machine learning, and in visual interfaces for other technical domains. <br/><br/><br/>翻译：<br/><br/>Graphviz是一个开源的图形可视化软件。图形可视化是表示诸如图表的结构化的抽象图形或网络。在网络技术、生物信息学、软件工程、数据库、网页设计、机器学习和可视化界面及其他可以领域大有用处。<br/><br/>详情参见Graphviz官网。<br/>安装<br/>这个不是本文的重点。我只知道对于Debian/Ubuntu用户可以按照以下方式安装：<br/>1sudo apt-get install graphviz<br/><br/><br/>使用<br/>Graphviz使用一种领域特定语言(Domain-Specific Language1)来描述一副图。这里的图就是指图论中的图。然后Graphviz通过自动布局器来绘制出这个图。由于布局不是由我们手动决定的，因此生成的图的质量依赖于布局算法。<br/>大多数情况下，Graphviz的默认布局器dot可以胜任布局这一任务。下面我们将使用dot。<br/>Hello, GRAPHVIZ!<br/>按照惯例，总得有个Hello, world!。<br/>当然不要着急，我们先创建一个dot脚本文件：<br/>1touch hello-world.dot<br/><br/><br/>用你喜欢的编辑器来编辑它：<br/>1vim hello-world.dot<br/><br/><br/>写入以下内容，保存：<br/>1<br/>2<br/>3<br/>4<br/>5digraph {<br/>    a -> b;<br/>    b -> c;<br/>    a -> c;<br/>}<br/><br/><br/>生成SVG图片：<br/>1dot hello-world.dot -Tsvg > hello-world.svg<br/><br/><br/>用你喜欢的图片查看器来看看效果：<br/>1eog hello-world.svg<br/><br/><br/>如果一路上不出意外，你可以看到下面的结果：<br/><br/>恭喜你成功创建了一张有向图。<br/>图的类型<br/>在上面，我们创建了一张带有三个顶点的有向图。然而我们有时候不一定要的就是有向图。<br/>如果需要无向图，将digraph换为graph，并把有向边换为无向边即可：<br/>1<br/>2<br/>3<br/>4<br/>5graph {  // <-- Here<br/>    a -- b;<br/>    b -- c;<br/>    a -- c;<br/>}<br/><br/><br/>此时的图是这样的：<br/><br/>当然我们可以添加坑爹的平行边和自环：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7graph {<br/>    a -- b;<br/>    b -- c;<br/>    a -- c;<br/>    c -- c;  // 自环 x 1<br/>    a -- c;  // 平行边 x 1<br/>}<br/><br/><br/>于是乎图长这样：<br/><br/>当然，如果你不想要它们出现，你可以利用strict将这张图变为严格的图：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7strict graph {  // <-- strict HERE<br/>    a -- b;<br/>    b -- c;<br/>    a -- c;<br/>    c -- c;<br/>    a -- c;<br/>}<br/><br/><br/>此时平行边已经不见了，毕竟它们的含义是一样的。但是自环还是会留下来的：<br/><br/>顶点<br/>个人感觉椭圆实在太难看，用来调试完全体现不出B格。<br/>把它换成圆形就好看多了：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9graph {<br/>    node [shape = circle];  // 所有顶点全部变成圆形<br/><br/>    a -- b;<br/>    b -- c;<br/>    a -- c;<br/>    c -- c;<br/>    a -- c;<br/>}<br/><br/><br/>就变成这样：<br/><br/><br/>啊！我想让c变成正方形！<br/><br/>当然也没有问题：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10graph {<br/>    node [shape = circle];  // 所有顶点全部变成圆形<br/>    c [shape = square];  // 指定c变为正方形<br/><br/>    a -- b;<br/>    b -- c;<br/>    a -- c;<br/>    c -- c;<br/>    a -- c;<br/>}<br/><br/><br/><br/><br/>不行我要三角形！<br/><br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10graph {<br/>    node [shape = circle];  // 所有顶点全部变成圆形<br/>    c [shape = triangle];  // 指定c变为三角形<br/><br/>    a -- b;<br/>    b -- c;<br/>    a -- c;<br/>    c -- c;<br/>    a -- c;<br/>}<br/><br/><br/><br/>好吧如果你还要其它的图形，可以参见http://www.graphviz.org/content/node-shapes。<br/>光有形状有卵用，加点颜色才好玩：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12graph {<br/>    node [shape = circle];<br/>    a [color = blue];  // 变蓝色<br/>    b [color = red];　// 变红色<br/>    c [fontcolor = green];  // 字体颜色变绿<br/><br/>    a -- b;<br/>    b -- c;<br/>    a -- c;<br/>    c -- c;<br/>    a -- c;<br/>}<br/><br/><br/><br/>更详细的颜色名称表在此：http://www.graphviz.org/content/color-names<br/>边<br/>现在我们来画一棵二叉搜索树：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12digraph {<br/>    node [shape = circle];<br/><br/>    3 -> 2;<br/>    3 -> 8;<br/>    2 -> 1;<br/>    8 -> 5;<br/>    8 -> 9;<br/>    5 -> 4;<br/>    5 -> 7;<br/>    7 -> 6;<br/>}<br/><br/><br/>得到的结果是这样的：<br/><br/>似乎并不尽人意，难以分辨左儿子和右儿子。<br/>因此我们可以通过顶点的方向来确定。<br/>每个顶点有八个方向：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12digraph {<br/>    node [shape = circle];<br/><br/>    x :e -> e;<br/>    x :ne -> ne;<br/>    x :n-> n;<br/>    x :nw -> nw;<br/>    x :w -> w;<br/>    x :sw -> sw;<br/>    x :s -> s;<br/>    x :se -> se;<br/>}<br/><br/><br/>下面的图片展示了顶点的八个方向2(这张图是用circo生成的，命令行参数一样)：<br/><br/>这些方向和东南西北的表示是一样的。<br/>刚才我们指定的是出发的方向，当然我们也可以指定进入的方向。<br/>因此我们来将左右儿子的边的出发方向修改一下，左孩子出发方向为:sw，右孩子的出发方向为:se：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12digraph {<br/>    node [shape = circle];<br/><br/>    3:sw -> 2;<br/>    3:se -> 8;<br/>    2:sw -> 1;<br/>    8:sw -> 5;<br/>    8:se -> 9;<br/>    5:sw -> 4;<br/>    5:se -> 7;<br/>    7:sw -> 6;<br/>}<br/><br/><br/><br/>虽然不是那么规整，但是足以分辨出左右儿子了。<br/>对于有些树，我们会记录父亲节点，因此我们加一条指向父亲的边：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20digraph {<br/>    node [shape = circle];<br/><br/>    3:sw -> 2;<br/>    2 -> 3;<br/>    3:se -> 8;<br/>    8 -> 3;<br/>    2:sw -> 1;<br/>    1 -> 2;<br/>    8:sw -> 5;<br/>    5 -> 8;<br/>    8:se -> 9;<br/>    9 -> 8;<br/>    5:sw -> 4;<br/>    4 -> 5;<br/>    5:se -> 7;<br/>    7 -> 5;<br/>    7:sw -> 6;<br/>    6 -> 7;<br/>}<br/><br/><br/>得到的效果是这样的：<br/><br/><br/>话说我分不清哪个是指向父亲的链接了！！！<br/><br/>呃…没关系，我们把左右儿子的链接加粗就分得清了：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20digraph {<br/>    node [shape = circle];<br/><br/>    3:sw -> 2 [style = bold];<br/>    2 -> 3;<br/>    3:se -> 8 [style = bold];<br/>    8 -> 3;<br/>    2:sw -> 1 [style = bold];<br/>    1 -> 2;<br/>    8:sw -> 5 [style = bold];<br/>    5 -> 8;<br/>    8:se -> 9 [style = bold];<br/>    9 -> 8;<br/>    5:sw -> 4 [style = bold];<br/>    4 -> 5;<br/>    5:se -> 7 [style = bold];<br/>    7 -> 5;<br/>    7:sw -> 6 [style = bold];<br/>    6 -> 7;<br/>}<br/><br/><br/><br/>上面是对边进行设置，将边加粗。<br/><br/>指向区别能更明显些吗？<br/><br/>干脆把它做成虚的吧：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20digraph {<br/>    node [shape = circle];<br/><br/>    3:sw -> 2 [style = bold];<br/>    2 -> 3 [style = dotted];<br/>    3:se -> 8 [style = bold];<br/>    8 -> 3 [style = dotted];<br/>    2:sw -> 1 [style = bold];<br/>    1 -> 2 [style = dotted];<br/>    8:sw -> 5 [style = bold];<br/>    5 -> 8 [style = dotted];<br/>    8:se -> 9 [style = bold];<br/>    9 -> 8 [style = dotted];<br/>    5:sw -> 4 [style = bold];<br/>    4 -> 5 [style = dotted];<br/>    5:se -> 7 [style = bold];<br/>    7 -> 5 [style = dotted];<br/>    7:sw -> 6 [style = bold];<br/>    6 -> 7 [style = dotted];<br/>}<br/><br/><br/><br/>像某些数据结构，可能会有Lazy标记之类的，我们可能需要对节点作特殊标记来标明。<br/>这当然也是可以实现的，只需提前声明好即可：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23digraph {<br/>    node [shape = circle];<br/><br/>    3 [color = red];<br/>    5 [color = red];<br/><br/>    3:sw -> 2 [style = bold];<br/>    2 -> 3 [style = dotted];<br/>    3:se -> 8 [style = bold];<br/>    8 -> 3 [style = dotted];<br/>    2:sw -> 1 [style = bold];<br/>    1 -> 2 [style = dotted];<br/>    8:sw -> 5 [style = bold];<br/>    5 -> 8 [style = dotted];<br/>    8:se -> 9 [style = bold];<br/>    9 -> 8 [style = dotted];<br/>    5:sw -> 4 [style = bold];<br/>    4 -> 5 [style = dotted];<br/>    5:se -> 7 [style = bold];<br/>    7 -> 5 [style = dotted];<br/>    7:sw -> 6 [style = bold];<br/>    6 -> 7 [style = dotted];<br/>}<br/><br/><br/><br/>用于调试<br/>经过上面的简单介绍，Graphviz已经可以用于调试了。<br/>dot脚本非常的便于程序生成，因此我们可以在程序运行中途生成脚本，然后使用dot将其处理后并展示出来。<br/>处理的代码大致是这个样子：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8function SHOW(x):<br/>    buffer = \ graph {\ <br/><br/>    // 读取数据并生成dot脚本<br/><br/>    buffer += \ }\ <br/>    write buffer to a dot file<br/>    SYSTEM \ dot a.dot -Tsvg > a.svg && eog a.svg\ <br/><br/><br/>小结<br/>Graphviz非常强大，这里只是介绍了一小部分功能，如想深入学习可以参见Graphviz官方文档或者Graphviz中文教程指南。<br/>利用Graphviz我们可以将图论算法、数据结构的调试过程可视化，从而更加方便我们找到错误所在。<br/>当然，可以利用Graphviz进行对算法过程的截图，从而生成整个算法的流程。<br/>如果你想利用Graphviz来制作插图，那么自动布局就可能不能使你满意。此时个人推荐ProcessOn或者其它的流程图制作软件来绘制，效果更好。<br/><br/><br/><br/><br/>维基页面https://en.wikipedia.org/wiki/Domain-specific_language ↩<br/><br/><br/>事实上，Graphviz中可以定义更加更加精确的方向。但大多数情况下，这几个方向足矣。 ↩<br/><br/><br/>","tags": "Graphviz 可视化 调试","url": "blog/2016-4-16/graphviz.html"},
{"title": "HNSDFZ #3","text": "<br/>HNSDFZ第3次欢乐互测<br/><br/><br/><br/><br/><br/>expression<br/>unstring<br/>gambler<br/>starcraft<br/><br/><br/><br/><br/>源文件<br/>expression.cpp<br/>unstring.cpp<br/>gambler.cpp<br/>starcraft.cpp<br/><br/><br/>输入文件<br/>expression.in<br/>unstring.in<br/>gambler.in<br/>starcraft.in<br/><br/><br/>输出文件<br/>expression.out<br/>unstring.out<br/>gambler.out<br/>starcraft.out<br/><br/><br/>时间限制<br/>$1\\text{s}$<br/>$1\\text{s}$<br/>$1\\text{s}$<br/>$1\\text{s}$<br/><br/><br/>空间限制<br/>$512\\text{MB}$<br/>$128\\text{MB}$<br/>$128\\text{MB}$<br/>$32\\text{MB}$<br/><br/><br/>题目类型<br/>传统型<br/>传统型<br/>传统型<br/>传统型<br/><br/><br/>出题人<br/>riteme<br/>Link<br/>ruanxingzhi<br/>Haogram<br/><br/><br/><br/><br/>拒绝Pascal程序。<br/>对于C\\C++程序，使用以下的编译命令：<br/>1g++ source.cpp -o exec -O2 -std=c++11<br/><br/><br/><br/>A. 密码锁<br/>题目描述<br/>dyx在家里玩耍时发现了一个神奇的密码锁。然而他早已忘记了这个锁的密码，于是他随便尝试了一下，结果锁就打开了......<br/>锁的内部有一个很长的字符串，机智的dyx马上就发现这就是密码锁的核心。于是他研究了一下午，探寻这把锁的奥秘。<br/>他发现这个字符串是一个表达式的形式，像下面这个样子：<br/>1a|b&(!c^d)<br/><br/><br/>其中，每一个由小写字母组成的单词是一个变量，对应着密码锁上的一个按钮。由于按钮只能按下或不按下，于是你可以认为每个变量是一个布尔类型的（即只有$\\text{true}$和$\\text{false}$之分）<br/>其余的字符就只有&、|、^、!和左右小括号。dyx发现括号是用来优先运算的，意思是这是一个会将所有变量进行计算的表达式，并且优先计算括号中的子表达式。同时，&、|、^、!都是运算符，它们分别对应的是逻辑与、逻辑或、逻辑异或和逻辑非。其中前三者运算优先级一致，当它们在同一级出现时会从左至右运算，逻辑非的优先级比它们高。当每一个变量都有相应的值时，整个表达式就会就会进行计算，并给出一个布尔值。dyx还发现，当整个表达式的值为$\\text{true}$时，密码锁就会打开。<br/>很明显，整个密码锁的输入方案共有$2^n$种，其中$n$是表达式中变量的数量。于是dyx瞬间明白为什么他一次就可以将这个密码锁解开了。然而dyx是一个勇于探究的人，他想知道到底有多少中方法可以解开一个密码锁。<br/>不知为何，dyx又发现了一火车的密码锁。坚持不懈的dyx不停的计算着每一个密码锁能解开的方案数......由于密码锁的表达式越来越长并且人脑计算量是$\\Theta(1)$的，dyx不得不需要一个程序来帮助他计算这个方案数。<br/>输入格式<br/>每个测试数据点有多个表达式。文件以EOF结束。<br/>每一个表达式占一行，且中间只有小写字母和&、|、^、!、(、)。<br/>对于&、|和^运算，它们左右会各有一个变量或子表达式。其运算规则如下：<br/><br/><br/><br/>$a$<br/>$b$<br/>$a$ & $b$ ($a \\land b$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/>$\\text{false}$<br/><br/><br/>$\\text{false}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/><br/><br/><br/><br/><br/>$a$<br/>$b$<br/>$a$ | $b$ ($a \\lor b$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/><br/><br/><br/><br/>$a$<br/>$b$<br/>$a$ ^ $b$ ($a \\oplus b$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{true}$<br/>$\\text{false}$<br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/><br/>对于!运算，它后面会有一个变量或子表达式。其运算规则如下：<br/><br/><br/><br/>$a$<br/>!$a$ ($\\lnot a$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/><br/><br/><br/>输入保证表达式是有效的，且表达式中不存在缺少参数的运算符和空的括号。<br/>为了防止此题变成不可做的NP-hard问题，输入保证表达式中每一个变量名只出现一次。<br/>输出格式<br/>对于每一个表达式，输出能够解开它的方案总数。由于答案可能过大，因此将答案对$10^9 + 7$取模后输出。<br/>一种方案即指对每一个变量给定一个值。<br/>两种方案不同当且仅当至少一个变量所给定的值不同。<br/>样例输入<br/>1<br/>2<br/>3a&b<br/>a|b|c<br/>a|!(b|c)<br/><br/><br/>样例输出<br/>1<br/>2<br/>31<br/>7<br/>5<br/><br/><br/>数据范围及提示<br/>对于第一个表达式，只有$a = \\text{true}, b = \\text{true}$才为$\\text{true}$。<br/>对于第二个表达式，只要三者有一个变量为$\\text{true}$就是$\\text{true}$。<br/>对于第三个表达式，先运算b|c，然后对其取反，最后与$a$做逻辑与。<br/>以下$n$表示变量数量，$T$表示测试数据组数，$L$表示表达式的总长度。<br/>对于$10\\% $的数据，$n \\le 10,\\; T = 15$。<br/>对于另外$10\\% $的数据，只有逻辑或运算，没有括号。<br/>对于另外$10\\% $的数据，不存在逻辑非和括号。<br/>对于另外$20\\% $的数据，不存在括号。<br/>对于另外$20\\% $的数据，$n \\le 500$。<br/>对于$100\\% $的数据，变量名长度$\\le 4$，$L \\le 10^6$，$n \\le 3\\times10^5$。<br/>其中$90\\% $的数据，$T \\le 5$。<br/><br/>B. UnString<br/>题目描述<br/>ZY很累。<br/>因为最近内网的服务器地址总是改来改去。<br/>然而ZY又非常想去捣乱。他必须知道内网的服务器的地址是啥。<br/>但是阴险的Blue却是给地址加了个密，还TM竟然隐藏了一些字符。<br/>但是ZY也是蛮机智的，他得到了一段被加密的地址<br/>还有Blue傻逼丢博客的字符对照表，如果地址和博客的字符对照表相似<br/>那么ZY就知道他得到的地址是对的，虽然他仍然不能知道地址是啥。<br/>输入格式<br/>第一行一个字符串$S$，字符串$S$是由a-b组成的字符串<br/>第二行一个字符串$C$，字符串$C$是由a-b和?组成的字符串<br/>输出格式<br/>我们将?认为是任何字符，询问$C$是否是$S$的子串<br/>输出YES或者NO<br/>样例输入<br/>1<br/>2abc<br/>a?c<br/><br/><br/>样例输出<br/>1YES<br/><br/><br/>数据范围及提示<br/>$30\\% $ $S$长度小于$2000$，$C$长度小于$20$<br/>$60\\% $ $S$长度小于$100000$，$C$长度小于$500$<br/>$100\\% $ $S$长度不超过$200000$,$C$长度不超过$2000$<br/><br/>C. 赌徒<br/>题目描述<br/>HNSDFZ有一大批赌徒。他们分布在化学组、生物组、机房……这些赌场有道路相连，形成一棵树的结构。<br/>赌场里的人越来越多。如果记某个赌场第$n$天的人数为$F_n$，则有$F_n=2F_{n-2}+3F_{n-1}$。每个赌场的$F_1$和$F_2$是预先知道的。当然，赌徒的数量不能太多。每个赌场都会不停地清理人员，做法是把每天的人数模$2333$。<br/>现在是第$m$天，3班的某个英语老师要打击赌徒。她准备打击一条链上的所有赌徒。但是她并不知道自己最多能打到多少个赌徒，所以把你捆过来算一算。<br/>输入格式<br/>第一行一个正整数，$n$表示赌场个数，$m$表示在第几天动手。<br/>接下来$n$行，每行两个整数$F_1,F_2$。<br/>接下来$n-1$行，每行两个整数$u,v$表示$u$和$v$有边相连。<br/>输出格式<br/>一行，一个正整数，表示能打击到的赌徒个数。<br/>样例输入<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>115 1<br/>1 1<br/>1 1<br/>1 1<br/>1 1<br/>1 1<br/><br/>1 2<br/>1 3<br/>2 4<br/>2 5<br/><br/><br/>样例输出<br/>14<br/><br/><br/><br/>数据范围及提示<br/>输入数据中：<br/>在第一天，所有的赌场都只有1个人。<br/>在这时打击，最多能打击到4个人。这条链是$4-2-1-3$。<br/>$n \\le 5 \\times 10^5$, $m \\le 2\\times 10^9$<br/><br/>D. 星际争霸<br/>题目描述<br/>虽然二十世纪的科技和文化进步神速，但是和後世科技和文明的跳跃式进步相比起来， 也只能甘拜下风。在二十一世纪的末，人类的文明经历了巨大而且难以想像的进步。崭新的科技以难以想像的速度窜起，即使是地球上最为落後的国家也开始拥有越来越先进的电脑和资料库。在东欧共产主义解体的同时，核子武器开始变得随手可得。原来国际势力的兴衰是以资产和军事强权来作为依据，第三世界的国家却利用这个机会猛然窜起，挑战这些强权，打破国际间局势的均衡。 <br/>当系统控工学、复制和基因工程变成人人皆可掌握的科技之後，激进人道主义者和狂热的宗教团体开始质疑私人公司以基因工程图利的正当性。大众开始纷纷装置由精密工学所研制出来的人工器官，其他人则开始显现出各种各样的基因突变性状，包括了较为隐性的器官变得敏锐，到明显的心灵感应。人类基因库中所产生的这些变化，让全球各地的人本主义者感到非常的恐慌。 <br/>科技继续进步及扩张，人口增加的速度也开始飙升。在二十世纪结束的时候，地球上有 六十亿的人口。仅仅经过短短的三百年，人口暴增为两百三十亿。污染和自然资源、燃料的耗竭更是火上加油。各个国家莫不竭力寻找降低人口成长率的方法。在人口爆炸、基因突变横扫整个地球的同时，一般人都认为地球将因此而走向天灾地变的结局。<br/>于是人类造出一艘星际巨舰，在擎天神的领导下，飞往无边的太空......<br/>最後，其中一艘的航舰引擎融毁了。在经过二十八年的曲速旅行之後，这些巨大的船只重新出现在三度空间中，靠近一个可居住星系的外缘。这里距离地球六万光年之远，他们的曲速引擎全毁，生命维持的系统几乎已经耗竭。所有的船只只有进入紧急状况，准备迫降在最接近的可居住行星上。<br/>每个行星的居民努力的试图在被称为『新世界』的星球上生存。他们并不知道还有其它的同类挣扎著在别的地方求生存，只能够努力的利用手边的资源活下去。<br/>然而，Zerg和Protoss的兵力正进攻过来，能否活下还是个问题......<br/>作为采矿的工具，空间建筑工程车 (Space Constrution Vehicle)，简称SCV，它们的多样性和无以比拟的可靠性使得它们成为一种极有价值的建筑工具。<br/>采矿的流程如下，然而图不能动。<br/><br/>SCV从指挥中心 (Command Center) 出发，移动至水晶矿处开采矿物，为了简化问题，设定为采矿不需要时间。采完矿后需要返回指挥中心将矿物送回，否则不能算采到了矿物。图片里既有正在采矿的也有才完了矿带着矿回指挥中心的。<br/>因为地面环境复杂，所以SCV所走的路线不一定是笔直的，而是曲折的，再次你可以将其理解为以指挥中心为根的一颗有根树，而水晶矿处于该有根树的叶子节点处。有根树的每一条边都有距离，长度单位为宇宙单位。定义SCV速度为 1 宇宙单位/s。为简化问题，SCV一次采矿可以将该水晶矿采完。<br/>有时会有一些宇宙生物（比如卡拉兽）会爬行至采矿路径上的一些点导致该路径不通。增加采矿难度。出于某种原因，地图会不断更新，矿物就会恢复原状，卡拉兽也会被更新至一个新的节点。<br/>Zerg和Protoss的进攻已经很近了，你需要尽快采更多的资源......<br/>输入格式<br/>第一行有$2$个正整数$n$，$m$，表示图上有$n$个点，地图更新$m$次。<br/>接下来$n-1$行，每行$3$个正整数$p$，$f$，$l$，代表描述第$p$个点，其父节点为$f$，与父节点的连边长为$l$。<br/>接下来$x$行，有$2$个正整数$p$，$w$，表示第$p$号节点有$w$水晶矿。$x$为叶节点个数。<br/>接下来$m$行，每行一个正整数$p$，$t$，表示地图更新后，有一只卡拉兽在$p$号节点位置上，Zerg和Protoss的进攻将在$t$秒后来临。如果$p$为$0$，表示没有卡拉兽在地图上。<br/>输出格式<br/>地图每次更新会将采完的矿回复原状。<br/>输出共$m$行，每行对于一次地图更新，输出在进攻来临前采集到的最多矿物数量。<br/>样例输入1<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>83 3<br/>2 1 35<br/>3 1 24<br/>2 100<br/>3 65<br/>0 60<br/>1 23<br/>3 33<br/><br/><br/>样例输出1<br/>1<br/>2<br/>365<br/>0<br/>0<br/><br/><br/><br/>样例输入2<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>189 4<br/>2 1 8<br/>3 1 10<br/>5 2 25<br/>6 2 13<br/>7 3 22<br/>4 1 26<br/>8 4 12<br/>9 4 23<br/>5 78<br/>6 66<br/>7 48<br/>8 50<br/>9 80<br/>0 257<br/>3 200<br/>2 230<br/>1 500<br/><br/><br/>样例输出2<br/>1<br/>2<br/>3<br/>4242<br/>194<br/>130<br/>0<br/><br/><br/>数据范围及提示<br/>对于$10\\% $的数据: $n \\le 20, m \\le 5$<br/>对于$20\\% $的数据: $n \\le 20, m \\le 500$<br/>对于另外$20\\% $的数据，地图没有卡拉兽<br/>对于另外$20\\% $的数据，$n \\le 1000, m \\le 50$<br/>对于$100\\% $的数据，$n \\le 1000, m \\le 500, t \\le 50000$<br/>指挥中心的编号始终为$1$，地图至多有一只卡拉兽","tags": "Contests","url": "blog/2016-7-1/hnsdfz-3.html"},
{"title": "HNSDFZ2016 #1","text": "HNSDFZ2016 #1<br/>A. ZY的钻石树 (Link)<br/>时间限制: 1s / 内存限制: 250MB<br/>题目描述<br/>ZY是一个很神的孩子，对于他来说一切都是O(1)的。 <br/>ZY也是一个很喜欢玩MC的孩子。 <br/>这天，ZY登陆了他的MC，他发现他家不知道被哪个熊孩子糟蹋了。 <br/>他的家变成了一颗有N个节点的树，每个树都有一种钻石块(种类是1-1000000的整数表示)。 <br/>奇怪的是，同种的钻石块ZY只能拿一个。 <br/>更加奇怪的是，不同时刻某些钻石块还会改变自己的种类。 <br/>ZY因此想知道，以某个节点为根的子树中有多少个不同的钻石块 <br/>1号节点为树的根 <br/>两种操作： <br/>1 x 询问x节点为根的子树有多少个不同的钻石块 <br/>0 x val 修改x节点的钻石块种类为val<br/>输入格式<br/>第一行N，代表树的节点数 第二行N个数，代表每个节点的钻石块种类 然后N-1行代表哪两个点连接 一行M代表操作数 之后M行代表操作<br/>输出格式<br/>对于每个询问输出其答案<br/>样例输入<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>197<br/>1 2 3 4 5 6 7<br/>1 2 <br/>1 7 <br/>2 3 <br/>2 6 <br/>3 4 <br/>3 5 <br/>10<br/>1 5 <br/>0 7 22<br/>1 2 <br/>0 6 10 <br/>0 4 2 <br/>0 4 45 <br/>1 5 <br/>1 2 <br/>0 2 12 <br/>1 1 <br/><br/><br/>样例输出<br/>1<br/>2<br/>3<br/>4<br/>51<br/>5<br/>1<br/>5<br/>7<br/><br/><br/>数据范围及提示<br/>m,n<=100000<br/>B. ZY的核电站 (riteme)<br/>时间限制: 5 s / 内存限制: 256 MB / 打开O2优化<br/>题目描述<br/><br/>“ZY喜欢玩核电站。”<br/><br/>ZY的核电站非常特殊。早在2038年，ZY就发现了高分子有机物的完全裂解可以释放大量的核能的原理（这句话纯属FP）。因此ZY的核电站反应堆里面全是高分子有机物，可惜只有一个。<br/>为了使发电量尽可能大，ZY找到了一种能使有机物完全裂解的方式，使释放出来的能量最大。由于这是ZY的有机物，因此裂解方式也非常奇葩。下面是ZY在2039年的论文《论ZY对MC1核电站的巨大贡献》中的节选片段：<br/><br/>......<br/>我们的有机物是由$n$个各种原子构成的，原子之间通过不同的共价键相连。<br/><br/>($\\text{H}$太多了，到时候这些没用的氢原子都会被ZY丢掉)<br/>......<br/>为了方便进行裂解，这个有机物是没有环的，这样就可以节约成本来买**V*P***......<br/>......<br/>每次裂解都会断开一个共价键，此时这个有机物会分为两部分。并且释放大量的能量......<br/>设放出的能量为$E$，有机物裂解后的两部分的共价键的集合分别为$A$和$B$，则：、<br/>$$ E = \\sum_{a\\in A} a.\\text{energy} \\cdot \\sum_{b\\in B} b.\\text{energy} \\tag{ZY's energy theorem}$$<br/>其中$\\text{energy}$表示共价键的能量。<br/>......<br/>为了充分利用有机物中的能量，每裂解一个共价键后，我们有办法无损耗无成本的将其还原，即有机物会变得和裂解前一样。但是出于种种原因，这个共价键就不能再次进行裂解了。除非ZY发出SB之神力来使所有的共价键复活......<br/>......<br/>那么，一个有机物完全裂解所能放出的能量为所有共价键裂解一次后所放出的能量之和。<br/>......<br/><br/>(实际上，ZY的这篇论文长达$2147483647$字)<br/>当然，ZY的智商理论上为$-\\infty$。因此它的核电站其实非常辣鸡。反应堆中的有机物不一定是稳定的，但是ZY利用LCT算法以$O(\\infty!)$的时间复杂度内成功地保证了有机物的结构，这样就方便ZY发出SB之神力。但是令ZY想跳楼的是，总有一个共价键的能量在维护有机物结构时会变动。然而”机智”的ZY可以发现这些变化。<br/>ZY只希望能够快速算出当前的有机物通过完全裂解究竟能放出多少能量。由于ZY的数学只有学前班水平，所以每当她算到一半时，这个有机物又开始乱搞了，ZY就只能用LCT来重新维护它。<br/>一年之内，ZY的核电站什么电都没有发。为了快速计算，ZY找到了你这个**。<br/>ZY希望你能给出一个好方法来帮助她计算当前有机物完全裂解能放出的能量。<br/>输入格式<br/>第$1$行输入两个正整数$n$，$m$。$n$表示有机物中原子的数量，$m$表示ZY维护有机物结构的次数。<br/>接下来$n - 1$行描述一个有机物。对于每一行输入三个整数$u$，$v$和$e$，表示第$u$号原子和第$v$号原子之间以能量为$e$的共价键相连。<br/>接下来$m$行，每一行描述一个共价键的键能变化。每行输入三个整数$u$，$v$和$e$，表示第$u$号原子和第$v$号原子之间的共价键的能量变为$e$。保证第$u$号原子和第$v$号原子之间存在共价键。<br/>输出格式<br/>对于每次共价键能量的变动，输出一行一个整数，表示键能改变后的有机物完全裂解能放出的能量。<br/>输入样例<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>127 4<br/>1 2 2<br/>1 7 1<br/>2 3 2<br/>2 6 1<br/>3 4 1<br/>3 5 1<br/><br/>1 2 2<br/>1 2 3<br/>2 3 3<br/>1 2 0<br/><br/><br/>输出样例<br/>1<br/>2<br/>3<br/>413<br/>15<br/>16<br/>10<br/><br/><br/>数据范围及提示<br/>对于第一个询问:<br/>裂解$1$和$2$之间的共价键: $1 \\times (2 + 1 + 1 + 1) = 5$<br/>裂解$2$和$3$之间的共价键: $(2 + 1 + 1) \\times (1 + 1) = 8$<br/>其余的共价键裂解得到的能量均为$0$。<br/>因此答案为$13$。<br/>对于$10\\% $的数据: $n \\le 1,000, \\; m \\le 5,000$<br/>对于$10\\% $的数据: $n \\le 10,000, \\; m \\le 500,000$<br/>对于$10\\% $的数据: $n \\le 100,000, \\; m \\le 100$<br/>对于$10\\% $的数据: $n \\le 10,000, \\; m \\le 1,000,000$<br/>对于另外$20\\% $的数据: 有机物没有支链。<br/>对于$100\\% $的数据: $n \\le 200,000, \\; m \\le 1,000,000, \\; e \\le 10 $<br/>C. ZY的仙人掌 (blue)<br/>时间限制: 2 s / 内存限制: 512 MB<br/>题目描述<br/>ZY是个很喜欢打MC的孩子，动态仙人掌对他来说是$O(1)$的。 <br/>ZY登录MC，发现自己在一个仙人掌包围的巨大盒子里。这是$n\\times n$的巨大网格，可以走到上下左右相邻的格子，但是不能斜走。 <br/>ZY认为，既然来了，就要潇洒走一回。他tp到一个网格，准备步行前往另一个网格。 <br/>但是blue显然不愿意看到ZY如此悠闲。所以，每次ZY作出计划，blue都会让某个格子长出仙人掌。（ZY怎敢踏过仙人掌）<br/>那么问题来了：给出ZY的计划和blue的操作，询问ZY能否完成计划。<br/>输入格式<br/>第一行，两个整数$n$、$m$，表示盒子是$n\\times n$的，ZY有$m$个计划。 接下来$m$行，每行三个点对：$(x_1,y_1)$表示ZY的出发点，$(x_2,y_2)$表示ZY的目标点，$(x_3,y_3)$表示blue让这个点长出仙人掌。<br/>输出格式<br/>输出共$m$行，描述ZY的计划能否完成。 如果能完成，输出Yes，否则输出No<br/>样例输入<br/>1<br/>2<br/>3<br/>45 3<br/>1 1 4 4 2 2<br/>1 1 3 3 1 2<br/>1 1 3 3 3 1<br/><br/><br/>样例输出<br/>1<br/>2<br/>3Yes<br/>Yes<br/>No<br/><br/><br/>数据范围及提示<br/>数据有梯度，暴力可拿分。<br/>可能在同一个地点长仙人掌；也可能ZY从仙人掌出发或者到达仙人掌。如果遇到这种情况，请直接输出<br/>No<br/>n <= 1000 ?<br/>D. ZY的三元组 (blue)<br/>时间限制: 1 s / 内存限制: 233 MB<br/>题目描述<br/>ZY是个很神的孩子，计算勾股数对他来说是$O(1)$的。<br/>对于 $a,b,c \\in Z^+$，且$a<=b<=c$ 有 $a^k+b^k=c^k$，而且$a:b:c$为最简整数比，并且$c-b$不超过3，则称三元组$(a,b,c)$为贼达k拉斯三元组。<br/>给定$n$和$m$，字典序输出所有$c<=n$，$2<=k<=m$的贼达k拉斯三元组。<br/>输入格式<br/>一行，$n,m$<br/>输出格式<br/>每行一个贼达k拉斯三元组。 如果没有就不输出.<br/>样例输入<br/>1100 3<br/><br/><br/>样例输出<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>93 4 5<br/>5 12 13<br/>7 24 25<br/>8 15 17<br/>9 40 41<br/>11 60 61<br/>12 35 37<br/>13 84 85<br/>16 63 65<br/><br/><br/>数据范围及提示<br/>数据范围<br/>$n<=100000$，$2<=k<=1000$。<br/>题解<br/>A (Missing)<br/>B<br/>题目描述不用看，看样例就好了…<br/>给你一棵无根树，每条边有边权。将一条边断开会出现两棵树，这两棵树的各自的边权之和相乘就是裂解一次的能量。完全裂解就是每一条都这样计算一下。<br/>如果只要计算一次，考虑将无根树转为有根树，然后DFS一遍计算以每个节点的子树中的边权之和。根节点的这个值就是总边权之和。用对于每条边，用深度较大的节点来记录这条边上的信息$a$和$b$。$a$表示子树中的边权之和，$b$表示子树外的边权之和(当然要除去这条边)。然后在$\\Theta(n)$的时间内可以计算出答案。<br/>接下来考虑维护答案。对于每条边的修改，自己的$a$和$b$不会有影响，对于从这条边到根节点的链上的每一条边的$a$值都会增加，而对于其它的边的$b$值都会增加。因此我们用$\\Delta a$和$\\Delta b$来记录每一条边的增量，这个值可以利用树链剖分+线段树来维护，链上的边直接增加，其它边先全局打上标记，然后对不需要的边打上反标记即可。<br/>最后在线段树的根节点统计答案，利用求和的性质即可：<br/>$$<br/>\\begin{aligned}<br/>\\sum^n_{i=1} a^,_i b^,_i & = \\sum^n_{i=1} (a_i + \\Delta a)(b_i + \\Delta b) \\\\<br/>& = \\sum^n_{i=1} a_ib_i + \\Delta a\\sum^n_{i=1}b_i + \\Delta b\\sum^n_{i=1} a_i + n\\Delta a\\Delta b<br/>\\end{aligned}<br/>$$<br/>从这也能看出维护三个和式和两个标记就可完成维护。总复杂度为$O(n\\log^2n)$。<br/>C (Missing)<br/>D (Missing)<br/><br/><br/><br/><br/>ZY从不打摆。 ↩<br/><br/><br/>","tags": "HNSDFZ 互测 2016","url": "blog/2016-5-31/hnsdfz2016-1.html"},
{"title": "HNSDFZ2016 #2","text": "HNSDFZ2016 #2<br/>这是一场痞题大战。<br/>A. 二十四点 (blue)<br/>时间限制: 0.4s / 内存限制: 128MB<br/>题目描述<br/>给定四个数，判断能否构成二十四点。仅允许：+ - * / () [] {}这几种符号。<br/>输入格式<br/>第一行，一个正整数$n$，表示有$n$组数据。 接下来$n$行，每行四个正整数，表示给你的牌。 保证：这些正整数$\\in[1,13]$。<br/>输出格式<br/>$n$行，每行一个整数，描述是否能构成二十四点。 能则输出$Yes$，不能则输出$No$。<br/>样例输入<br/>1<br/>2<br/>32<br/>5 5 5 1<br/>9 9 9 9<br/><br/><br/>样例输出<br/>1<br/>2Yes<br/>No<br/><br/><br/>数据范围及提示<br/>最多5000组。<br/>B. BST厂长 (riteme)<br/>时间限制: 1 s / 内存限制: 128 MB<br/>题目描述<br/><br/>二叉树真是迷人......<br/><br/>随着时代的进步，二叉搜索树(Binary Search Tree)发挥着越来越大的作用。作为HNSDFZ上机部长XL，担负着为学校制造各种BST的任务。它们会用于各种用途：成绩排名、薪水发放、PY**......<br/>本来学校对BST的需求并不是很大，但是自从ZY加入了上机组后，BST的需求越来越大......<br/>作为XL，早已按捺不住。于是XL利用通用技术教学楼建立了一个厂房，专门制造各种BST。<br/>这个厂子会收到各种各样的订单。每个订单都会是一个很长的数列，其中没有两个数是相同的。而XL要做的就是将这些数字依次插入到一棵空的BST中，然后将BST发送出去。<br/>然而人工干这件事实在是太麻烦了，因此XL将ZY抓过来造BST。然而ZY更懒，把Link抓过来要它帮<br/>ZY写个程序来构建BST。然而Link并不屑于写这个程序，于是这个任务莫名其妙地传到了你手上......<br/>当然XL不会就这样放手不管，XL会随时来检查这棵BST是否是正确的，以防你在乱造BST。<br/>输入格式<br/>第一行输入一个正整数$n$，表示订单中数列的长度。<br/>接下来$n$行，每行输入两个正整数$x$和$k$。表示将$x$插入到当前的BST中。初始时是空树。$k$则表示XL的检查。他会问你根节点到新插入的节点$x$的链上第$k$个节点是谁。默认从$1$开始数。<br/>输出格式<br/>对于每一次XL的检查，输出对应的答案。<br/>样例输入<br/>1<br/>2<br/>3<br/>43<br/>2 1<br/>1 1<br/>3 2<br/><br/><br/>样例输出<br/>1<br/>2<br/>32<br/>2<br/>3<br/><br/><br/>数据范围及提示<br/>对于第一次插入$2$，树的根节点为$2$，故答案为$2$。<br/>对于第二次插入$1$，因为$1 \\lt 2$，所以$1$是$2$的左儿子。$2$到$1$的链上的第一个节点为$2$<br/>对于最后一次插入$3$，因为$3 \\gt 2$，所以$3$是$2$的右儿子。$2$到$3$的链上的第二个节点是$3$。<br/>对于$10\\% $的数据，$n \\le 20,000$。<br/>对于$10\\% $的数据，$n \\le 90,000$。<br/>对于$20\\% $的数据，$n \\le 100,000$。<br/>对于另外$10\\% $的数据，数列完全随机。<br/>对于$100\\% $的数据，$n \\le 200,000$，$1 \\le x \\le n$，保证每次检查的节点存在。<br/>C. 鱼的记忆 (Link)<br/>时间限制: 3s / 内存限制: 100MB<br/>题目描述<br/>对于只有7秒记忆的鱼来说，他能够记住的东西太少了。 <br/>但是鱼对于美的追求却不会因为他的记忆而放弃。 <br/>他想知道在他的记忆中，对于每个事物有多少个事物没有这个事物美丽。 <br/>每一件事物都有三个维度的评价，鱼能够很快的知道评价是多少。 <br/>但是他并没有办法知道每个事物有多少个事物没有这个事物美丽。 <br/>如果一个事物的三个维度都>=另外一个事物的三个维度并且这个事物被鱼看到的时间不能比其先。<br/>输入格式<br/>第一行一个n，表示鱼见到的事物个数 第2到n+1行分别为4个整数。 分别是前3维和时间<br/>输出格式<br/>输出n行，分别是有多少个事物没这个事物美丽<br/>样例输入<br/>1<br/>2<br/>3<br/>43  <br/>1 2 3 5  <br/>2 1 1 6  <br/>1 1 1 5  <br/><br/><br/>样例输出<br/>1<br/>2<br/>31  <br/>1  <br/>0  <br/><br/><br/>数据范围及提示<br/>10%  N<=1000 <br/>10%  N<=30000 <br/>80%  N<=100000 <br/>没错，就是4维的。 <br/>前面3维小于100000 <br/>第4维<=7 鱼的记忆只有7秒 <br/>D. ZY的铁套装 (Haogram)<br/>时间限制: 1s / 内存限制: 250MB<br/>题目描述<br/>在附中内网MC伊始之时，RLB(排名不分先后)三侠努力地挖矿造家打脏比，每天幸福充实的生活着，MC着。<br/>然而ZY突然出现，夺走了RLB所有的铁块，打造了一身时尚时尚最时尚的铁套装。<br/>RLB决心攻击ZY，收回铁套装。毕竟挖矿很难。<br/>于是RLB三侠拿起了武器背包，向ZY发起进攻，并决心事后封ZY的id。<br/>由于ZY的铁套装十分时(qiang)尚(da)，所以必须要连击$L$次才能打败ZY。<br/>RLB三侠有$N$个武器，每个武器本可以在两个时刻发动攻击，然而ZY的铁套装太强，每个武器使用一次就报废了。<br/>每次攻击要从1时刻开始向ZY攻击，显然，如果RLB没有可以在1时刻攻击的武器，那就一次也不能打到ZY了。<br/>输入格式<br/>第一行有两个数，$N$和$L$。 接下来的$N$行，每一行有两个数$a$,$b$，表示该武器可以在$a$或$b$时刻攻击ZY。<br/>输出格式<br/>输出一行，如果 RLB 能攻击 ZY 至少$L$次，输出”Yes”,否则”No”。(区分大小写)。<br/>样例输入<br/>1<br/>2<br/>3<br/>43 2<br/>1 2<br/>2 3<br/>4 5<br/><br/><br/>样例输出<br/>1Yes<br/><br/><br/>数据范围及提示<br/>输出样例1 解释：<br/>1时刻，RLB用1号武器攻击, 1号武器报废<br/>2时刻，RLB用2号武器攻击, 2号武器报废<br/>3时刻，RLB没有可以在3时刻攻击ZY的武器，攻击结束。<br/>一共攻击2次，正好打败ZY！<br/>数据范围：<br/>对于30% 的数据，保证N <= 1000<br/>对于100% 的数据，保证N <= 1000000<br/>攻击ZY的时刻 0 < a,b <= 10000<br/>题解<br/>A<br/>暴力暴力暴力......<br/>B<br/>用平衡树维护当前二叉树中能够被插入的节点，每次插入节点时在平衡树上二分找出新节点的范围，然后利用倍增法计算LCA来确定父亲，最后更新倍增数组的值。<br/>查询时利用倍增上跳即可。<br/>C<br/>对于同一时间内，利用CDQ分治就可以解决(像Mokia或陌上花开一样)<br/>由于有个时间轴，当时却只有7，因此进行7次CDQ分治......<br/>因该要注意下细节，我并没有写......<br/>Link真是脑洞大开......<br/>D<br/>将原问题转换为一个二分图匹配的问题，然后匈牙利算法直接跑。<br/>即第$i$件武器与对应的天相连来构建二分图。<br/>一群贪心100分......","tags": "HNSDFZ 互测 2016","url": "blog/2016-5-31/hnsdfz2016-2.html"},
{"title": "HNSDFZ2016 #3","text": "HNSDFZ2016 #3<br/>大家都在出水题。<br/>A. 密码锁 (riteme)<br/>题目描述<br/>dyx在家里玩耍时发现了一个神奇的密码锁。然而他早已忘记了这个锁的密码，于是他随便尝试了一下，结果锁就打开了......<br/>锁的内部有一个很长的字符串，机智的dyx马上就发现这就是密码锁的核心。于是他研究了一下午，探寻这把锁的奥秘。<br/>他发现这个字符串是一个表达式的形式，像下面这个样子：<br/>1a|b&(!c^d)<br/><br/><br/>其中，每一个由小写字母组成的单词是一个变量，对应着密码锁上的一个按钮。由于按钮只能按下或不按下，于是你可以认为每个变量是一个布尔类型的（即只有$\\text{true}$和$\\text{false}$之分）<br/>其余的字符就只有&、|、^、!和左右小括号。dyx发现括号是用来优先运算的，意思是这是一个会将所有变量进行计算的表达式，并且优先计算括号中的子表达式。同时，&、|、^、!都是运算符，它们分别对应的是逻辑与、逻辑或、逻辑异或和逻辑非。其中前三者运算优先级一致，当它们在同一级出现时会从左至右运算，逻辑非的优先级比它们高。当每一个变量都有相应的值时，整个表达式就会就会进行计算，并给出一个布尔值。dyx还发现，当整个表达式的值为$\\text{true}$时，密码锁就会打开。<br/>很明显，整个密码锁的输入方案共有$2^n$种，其中$n$是表达式中变量的数量。于是dyx瞬间明白为什么他一次就可以将这个密码锁解开了。然而dyx是一个勇于探究的人，他想知道到底有多少中方法可以解开一个密码锁。<br/>不知为何，dyx又发现了一火车的密码锁。坚持不懈的dyx不停的计算着每一个密码锁能解开的方案数......由于密码锁的表达式越来越长并且人脑计算量是$\\Theta(1)$的，dyx不得不需要一个程序来帮助他计算这个方案数。<br/>输入格式<br/>每个测试数据点有多个表达式。文件以EOF结束。<br/>每一个表达式占一行，且中间只有小写字母和&、|、^、!、(、)。<br/>对于&、|和^运算，它们左右会各有一个变量或子表达式。其运算规则如下：<br/><br/><br/><br/>$a$<br/>$b$<br/>$a$ & $b$ ($a \\land b$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/>$\\text{false}$<br/><br/><br/>$\\text{false}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/><br/><br/><br/><br/>$a$<br/>$b$<br/>$a$ | $b$ ($a \\lor b$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/><br/><br/><br/><br/>$a$<br/>$b$<br/>$a$ ^ $b$ ($a \\oplus b$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{true}$<br/>$\\text{false}$<br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/><br/>对于!运算，它后面会有一个变量或子表达式。其运算规则如下：<br/><br/><br/><br/>$a$<br/>!$a$ ($\\lnot a$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/><br/><br/><br/>输入保证表达式是有效的，且表达式中不存在缺少参数的运算符和空的括号。<br/>为了防止此题变成不可做的NP-hard问题，输入保证表达式中每一个变量名只出现一次。<br/>输出格式<br/>对于每一个表达式，输出能够解开它的方案总数。由于答案可能过大，因此将答案对$10^9 + 7$取模后输出。<br/>一种方案即指对每一个变量给定一个值。<br/>两种方案不同当且仅当至少一个变量所给定的值不同。<br/>样例输入<br/>1<br/>2<br/>3a&b<br/>a|b|c<br/>a|!(b|c)<br/><br/><br/>样例输出<br/>1<br/>2<br/>31<br/>7<br/>5<br/><br/><br/>数据范围及提示<br/>对于第一个表达式，只有$a = \\text{true}, b = \\text{true}$才为$\\text{true}$。<br/>对于第二个表达式，只要三者有一个变量为$\\text{true}$就是$\\text{true}$。<br/>对于第三个表达式，先运算b|c，然后对其取反，最后与$a$做逻辑与。<br/>以下$n$表示变量数量，$T$表示测试数据组数，$L$表示表达式的总长度。<br/>对于$10\\% $的数据，$n \\le 10,\\; T = 15$。<br/>对于另外$10\\% $的数据，只有逻辑或运算，没有括号。<br/>对于另外$10\\% $的数据，不存在逻辑非和括号。<br/>对于另外$20\\% $的数据，不存在括号。<br/>对于另外$20\\% $的数据，$n \\le 500$。<br/>对于$100\\% $的数据，变量名长度$\\le 4$，$L \\le 10^6$，$n \\le 3\\times10^5$。<br/>其中$90\\% $的数据，$T \\le 5$。<br/>B. UnString (Link)<br/>题目描述<br/>ZY很累。<br/>因为最近内网的服务器地址总是改来改去。<br/>然而ZY又非常想去捣乱。他必须知道内网的服务器的地址是啥。<br/>但是阴险的Blue却是给地址加了个密，还TM竟然隐藏了一些字符。<br/>但是ZY也是蛮机智的，他得到了一段被加密的地址<br/>还有Blue傻逼丢博客的字符对照表，如果地址和博客的字符对照表相似<br/>那么ZY就知道他得到的地址是对的，虽然他仍然不能知道地址是啥。<br/>输入格式<br/>第一行一个字符串$S$，字符串$S$是由a-b组成的字符串<br/>第二行一个字符串$C$，字符串$C$是由a-b和?组成的字符串<br/>多组数据输入 (Link这货坑爹)<br/>输出格式<br/>我们将?认为是任何字符，询问$C$是否是$S$的子串<br/>输出YES或者NO<br/>样例输入<br/>1<br/>2abc<br/>a?c<br/><br/><br/>样例输出<br/>1YES<br/><br/><br/>数据范围及提示<br/>$30\\% $ $S$长度小于$2000$，$C$长度小于$20$<br/>$60\\% $ $S$长度小于$100000$，$C$长度小于$500$<br/>$100\\% $ $S$长度不超过$200000$,$C$长度不超过$2000$<br/>C. 赌徒 (ruanxingzhi)<br/>题目描述<br/>HNSDFZ有一大批赌徒。他们分布在化学组、生物组、机房……这些赌场有道路相连，形成一棵树的结构。<br/>赌场里的人越来越多。如果记某个赌场第$n$天的人数为$F_n$，则有$F_n=2F_{n-2}+3F_{n-1}$。每个赌场的$F_1$和$F_2$是预先知道的。当然，赌徒的数量不能太多。每个赌场都会不停地清理人员，做法是把每天的人数模$2333$。<br/>现在是第$m$天，3班的某个英语老师要打击赌徒。她准备打击一条链上的所有赌徒。但是她并不知道自己最多能打到多少个赌徒，所以把你捆过来算一算。<br/>输入格式<br/>第一行一个正整数，$n$表示赌场个数，$m$表示在第几天动手。<br/>接下来$n$行，每行两个整数$F_1,F_2$。<br/>接下来$n-1$行，每行两个整数$u,v$表示$u$和$v$有边相连。<br/>输出格式<br/>一行，一个正整数，表示能打击到的赌徒个数。<br/>样例输入<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>115 1<br/>1 1<br/>1 1<br/>1 1<br/>1 1<br/>1 1<br/><br/>1 2<br/>1 3<br/>2 4<br/>2 5<br/><br/><br/>样例输出<br/>14<br/><br/><br/>数据范围及提示<br/>输入数据中：<br/>在第一天，所有的赌场都只有1个人。<br/>在这时打击，最多能打击到4个人。这条链是$4-2-1-3$。<br/>$n \\le 5 \\times 10^5$, $m \\le 2\\times 10^9$<br/>D. 星际争霸 (Haogram)<br/>题目描述<br/>虽然二十世纪的科技和文化进步神速，但是和後世科技和文明的跳跃式进步相比起来， 也只能甘拜下风。在二十一世纪的末，人类的文明经历了巨大而且难以想像的进步。崭新的科技以难以想像的速度窜起，即使是地球上最为落後的国家也开始拥有越来越先进的电脑和资料库。在东欧共产主义解体的同时，核子武器开始变得随手可得。原来国际势力的兴衰是以资产和军事强权来作为依据，第三世界的国家却利用这个机会猛然窜起，挑战这些强权，打破国际间局势的均衡。 <br/>当系统控工学、复制和基因工程变成人人皆可掌握的科技之後，激进人道主义者和狂热的宗教团体开始质疑私人公司以基因工程图利的正当性。大众开始纷纷装置由精密工学所研制出来的人工器官，其他人则开始显现出各种各样的基因突变性状，包括了较为隐性的器官变得敏锐，到明显的心灵感应。人类基因库中所产生的这些变化，让全球各地的人本主义者感到非常的恐慌。 <br/>科技继续进步及扩张，人口增加的速度也开始飙升。在二十世纪结束的时候，地球上有 六十亿的人口。仅仅经过短短的三百年，人口暴增为两百三十亿。污染和自然资源、燃料的耗竭更是火上加油。各个国家莫不竭力寻找降低人口成长率的方法。在人口爆炸、基因突变横扫整个地球的同时，一般人都认为地球将因此而走向天灾地变的结局。<br/>于是人类造出一艘星际巨舰，在擎天神的领导下，飞往无边的太空......<br/>最後，其中一艘的航舰引擎融毁了。在经过二十八年的曲速旅行之後，这些巨大的船只重新出现在三度空间中，靠近一个可居住星系的外缘。这里距离地球六万光年之远，他们的曲速引擎全毁，生命维持的系统几乎已经耗竭。所有的船只只有进入紧急状况，准备迫降在最接近的可居住行星上。<br/>每个行星的居民努力的试图在被称为『新世界』的星球上生存。他们并不知道还有其它的同类挣扎著在别的地方求生存，只能够努力的利用手边的资源活下去。<br/>然而，Zerg和Protoss的兵力正进攻过来，能否活下还是个问题......<br/>作为采矿的工具，空间建筑工程车 (Space Constrution Vehicle)，简称SCV，它们的多样性和无以比拟的可靠性使得它们成为一种极有价值的建筑工具。<br/>采矿的流程如下，然而图不能动。<br/><br/>SCV从指挥中心 (Command Center) 出发，移动至水晶矿处开采矿物，为了简化问题，设定为采矿不需要时间。采完矿后需要返回指挥中心将矿物送回，否则不能算采到了矿物。图片里既有正在采矿的也有才完了矿带着矿回指挥中心的。<br/>因为地面环境复杂，所以SCV所走的路线不一定是笔直的，而是曲折的，再次你可以将其理解为以指挥中心为根的一颗有根树，而水晶矿处于该有根树的叶子节点处。有根树的每一条边都有距离，长度单位为宇宙单位。定义SCV速度为 1 宇宙单位/s。为简化问题，SCV一次采矿可以将该水晶矿采完。<br/>有时会有一些宇宙生物（比如卡拉兽）会爬行至采矿路径上的一些点导致该路径不通。增加采矿难度。出于某种原因，地图会不断更新，矿物就会恢复原状，卡拉兽也会被更新至一个新的节点。<br/>Zerg和Protoss的进攻已经很近了，你需要尽快采更多的资源......<br/>输入格式<br/>第一行有$2$个正整数$n$，$m$，表示图上有$n$个点，地图更新$m$次。<br/>接下来$n-1$行，每行$3$个正整数$p$，$f$，$l$，代表描述第$p$个点，其父节点为$f$，与父节点的连边长为$l$。<br/>接下来$x$行，有$2$个正整数$p$，$w$，表示第$p$号节点有$w$水晶矿。$x$为叶节点个数。<br/>接下来$m$行，每行一个正整数$p$，$t$，表示地图更新后，有一只卡拉兽在$p$号节点位置上，Zerg和Protoss的进攻将在$t$秒后来临。如果$p$为$0$，表示没有卡拉兽在地图上。<br/>输出格式<br/>地图每次更新会将采完的矿回复原状。<br/>输出共$m$行，每行对于一次地图更新，输出在进攻来临前采集到的最多矿物数量。<br/>样例输入1<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>83 3<br/>2 1 35<br/>3 1 24<br/>2 100<br/>3 65<br/>0 60<br/>1 23<br/>3 33<br/><br/><br/>样例输出1<br/>1<br/>2<br/>365<br/>0<br/>0<br/><br/><br/>样例输入2<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>189 4<br/>2 1 8<br/>3 1 10<br/>5 2 25<br/>6 2 13<br/>7 3 22<br/>4 1 26<br/>8 4 12<br/>9 4 23<br/>5 78<br/>6 66<br/>7 48<br/>8 50<br/>9 80<br/>0 257<br/>3 200<br/>2 230<br/>1 500<br/><br/><br/>样例输出2<br/>1<br/>2<br/>3<br/>4242<br/>194<br/>130<br/>0<br/><br/><br/>数据范围及提示<br/>对于$10\\% $的数据: $n \\le 20, m \\le 5$<br/>对于$20\\% $的数据: $n \\le 20, m \\le 500$<br/>对于另外$20\\% $的数据，地图没有卡拉兽<br/>对于另外$20\\% $的数据，$n \\le 1000, m \\le 50$<br/>对于$100\\% $的数据，$n \\le 1000, m \\le 500, t \\le 50000$<br/>指挥中心的编号始终为$1$，地图至多有一只卡拉兽<br/>题解<br/>A<br/>任选一种方法建立AST，标程使用的是递归下降式解析器。<br/>然后在AST上DP即可得到答案。<br/>B<br/>模糊字符串匹配，使用AC自动机，好像有论文什么的......<br/>原来的B题被出题人弃了，于是出题人十分不负责地放裸题，数据还一大堆问题......<br/>AC自动机搞法纯属暴力！<br/>此题正解是FFT，不知道HJWJBSR究竟是怎么搞的。<br/>正则表达式的时间复杂度未知......<br/>此外还可以用bitset水过去，时间复杂度是$O({nm \\over T})$，$T$是机器的整型长度。具体做法是用所有字符到原串中匹配，匹配上就填$1$否则填$0$，得到不同的布尔数组。对于问号，就全部填$1$。目标就是按照模式串的每个字符顺序排放，找到一个斜列全是$1$即可。因此可以使用bitset，每次先左移一定的位置然后按位与。如果最后得到的bitset中有$1$则表示匹配成功。<br/>最后，bitset跑得比标解FFT快很多......<br/>C<br/>每个点用矩阵快速计算点权，然后DFS找加权直径。<br/>D<br/>可以将每一个叶节点视为一个有代价有价值的物品，然后做01背包。<br/>对于能够删除一些物品后再计算好像没有什么好办法，标程就是每次询问暴力......<br/>坐等HJWJBSR给出牛逼搞法。<br/>HJWJBSR说可以用前缀和就可以做到$O(nt)$。","tags": "HNSDFZ 互测 2016","url": "blog/2016-7-9/hnsdfz-3.html"},
{"title": "HNSDFZ2016 #4","text": "HNSDFZ2016 #4<br/>A. 24点加强版 (ruanxingzhi)<br/>题目描述<br/>这是一道提交答案的防AK水题。<br/>给定$n$个正整数,以四则运算、小括号拼出$k$。<br/>自然,每个数都要用且仅用一次。<br/>输入格式<br/>第一行,两个正整数,表示$n$和$k$。<br/>第二行,$n$个正整数,意义如题目所述。<br/>输出格式<br/>一行,一个四则运算的表达式。注意所有括号都是小括号,可以括号嵌套。<br/>样例输入1<br/>1<br/>24 24<br/>6 6 6 6<br/><br/><br/>样例输出1<br/>1()6+(6+(6)+6)<br/><br/><br/>样例输入2<br/>1<br/>24 24<br/>2 7 1 7<br/><br/><br/>样例输出2<br/>1(7*7-1)/2<br/><br/><br/>数据范围及提示<br/>对于每个输入文件k_.in,你需要提交一个输出文件k_.out.<br/>共有$7$个测试点。前$4$个测试点每个$10$分,后$3$个测试点每个$20$分。<br/>$k$-SBK变换 (riteme)<br/>题目描述<br/>数学家Lunk最近发现了一种逗逼的SBK变换。在Lunk眼里，SBK变换是这样的：<br/><br/>给你一个$1$至$n$的排列$A$和一个$1$至$n$的排列$P$，$P$对$A$做一次SBK变换后将得到一个新的排列$B$，其中：<br/>$$ B_{P_i} = A_i \\tag{SBK Transformation}$$<br/><br/>然而做一次SBK变换太过无聊，于是Lunk决定连续做多次SBK变换。即将每次变换后的结果$B$变为$A$，然后继续用$P$对$A$做SBK变换。Lunk想知道连续对$A$做$k$次SBK变换后的结果。<br/>输入格式<br/>第一行输入两个整数$n$和$k$，表示排列的长度和连续做SBK变换的次数。<br/>第二行输入$n$个整数表示排列$A$。<br/>第三行输入$n$个整数表示排列$P$。<br/>输出格式<br/>一行输出$n$个整数，表示$k$次SBK变换后的结果。<br/>样例输入<br/>1<br/>2<br/>35 2<br/>1 2 3 4 5<br/>2 3 4 5 1<br/><br/><br/>样例输出<br/>14 5 1 2 3<br/><br/><br/>样例解释<br/>做完第一次SBK变换后： 5 1 2 3 4<br/>做完第二次SBK变换后： 4 5 1 2 3<br/>数据范围及约定<br/>共$10$个测试点，每个测试点的数据范围如下表所示：<br/><br/><br/><br/>数据点<br/>$n$的规模<br/>$k$的规模<br/><br/><br/><br/><br/>1<br/>$\\le10^3$<br/>$\\le10^3$<br/><br/><br/>2<br/>$\\le10^3$<br/>$\\le10^3$<br/><br/><br/>3<br/>$\\le10^4$<br/>$\\le10^5$<br/><br/><br/>4<br/>$\\le10^4$<br/>$\\le2\\times10^5$<br/><br/><br/>5<br/>$\\le4\\times10^5$<br/>$\\le2^{30}$<br/><br/><br/>6<br/>$\\le4\\times10^5$<br/>$\\le2^{33}$<br/><br/><br/>7<br/>$\\le6\\times10^5$<br/>$\\le2^{63}$<br/><br/><br/>8<br/>$\\le6\\times10^5$<br/>$\\le2^{63}$<br/><br/><br/>9<br/>$\\le10^6$<br/>$\\le2^{63}$<br/><br/><br/>10<br/>$\\le2.3\\times10^6$<br/>$\\le2^{63}$<br/><br/><br/><br/>C. 稀奇古怪的根 (Link)<br/>题目描述<br/>DYX是一个很ZY的ZY,但是他不想ZY一样ZY。<br/>他特别喜欢捣鼓一些无与伦比的树。<br/>他也特别喜欢逆序对这种东西,因此他想把逆序对拓展到树上来。<br/>DYX对于树上的逆序对的定义是这样的:<br/>树上的某个点到根节点的路径上权值比他大的节点和他构成逆序对<br/>换句话来说,就是指,树上某个节点能和他构成逆序对的节点是他的子树中<br/>权值比他小的或者是他到根节点的路径上权值比他大的<br/>聪明的DYX很快就把他推广到树上了。<br/>最近DYX学会了LCT,里面的换根操作打动了他。<br/>因此他在想能不能把LCT的换根拓展到他的树上<br/>定义树上两个节点$X$和$Y$,且$X$是$Y$到根节点的路径上面的一个节点<br/>定义$X$和$Y$构成逆序对当且仅当$X$的权值比$Y$的大<br/>给你一棵树,询问以某个节点为根的时候这棵树总共有多少组逆序对<br/>输入格式<br/>第一行$n$和$m$表示树的节点个数和询问个数<br/>第二行$n$个数表示每个节点的权值<br/>然后$n-1$行两个数$X$,$Y$.表示点$X$和$Y$有一条边连接<br/>然后$m$行每行$1$个数$X$,表示以$X$为根的时候树中有多少组逆序对<br/>输出格式<br/>输出$m$行,每行一个整数,表示以$X$为根的树中有多少组逆序对<br/>样例输入<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>1610 5<br/>1 2 3 4 5 6 7 8 9 10<br/>1 2<br/>1 3<br/>3 4<br/>3 5<br/>3 7<br/>2 9<br/>2 10<br/>2 6<br/>2 8<br/>3<br/>2<br/>1<br/>7<br/>10<br/><br/><br/>样例输出<br/>1<br/>2<br/>3<br/>4<br/>52<br/>1<br/>0<br/>8<br/>10<br/><br/><br/>数据范围及提示<br/>$30\\% $ $n,\\;m \\le 1000$<br/>$50\\% $ $n,\\;m \\le20000$, 且权值不大于$20000$<br/>$100\\% $ $n,\\;m \\le 100000$, 保证所有数据在int范围内<br/>提供两个类:<br/>LCT和主席树,要的请找出题人。<br/>要了的话就­1分<br/>D. 最长公共子序列 (Haogram)<br/>题目描述<br/>给定两个正整数序列,每个序列中元素两两不同,且范围都在$[1,\\;n^2]$。求其最长公共子序列。<br/>输入格式<br/>第一行一个正整数$t$, 表示数据组数。对于每组数据:<br/>第一行三个数$n$, $p$, $q$, $n$, 含义如题, $p$, $q$分别为两个序列的长度。<br/>接下来两行描述两个序列。<br/>输出格式<br/>共$t$行$t$个整数,表示答案。<br/>样例输入<br/>1<br/>2<br/>3<br/>41<br/>3 7 8<br/>1 7 5 4 8 3 9<br/>1 4 3 5 6 2 8 9<br/><br/><br/>样例输出<br/>14<br/><br/><br/>数据范围及提示<br/>对于$30\\% $的数据，$n \\le 30$<br/>对于$100\\% $的数据，$2 \\le n \\le 250,\\;1 \\lt p,\\;q \\le n^2,\\;t\\le10$<br/>E. ZY的金坷垃 (HJWJBSR)<br/>题目描述<br/><br/>Zy:金坷垃好处都有啥,谁说对了就给他<br/>zy:肥料掺了金坷垃,不流失,不蒸发,零浪费<br/>zY:肥料掺了金坷垃,能吸收两米下的氮磷钾<br/>zy:世界肥料都涨价,肥料掺了金坷垃,一袋能顶两袋撒<br/>zY:用了金坷垃,小麦亩产一千八。日本的粮食再也不向美国进口了!hhhhhhhh<br/>Zy:小鬼子,真不傻!金坷垃给了他对美国农业危害大,决不能给了他!<br/>Zy:非洲农业不发达,我们都要支援他。金坷垃,你们日本别想了!<br/>zY:狡猾,狡猾。没有金坷垃,怎么种庄稼!金坷垃!金坷垃!(残念脸<br/><br/>zy最近从小鬼子手中抢到了金坷垃。开始考虑怎么撒。他家的地可以看做一个$n\\times m$的方阵。<br/>由于非洲农业不发达,zy家的地有些地方并不能够播撒。<br/>并且金坷垃是全球瞩目的焦点是农业科技的前沿,所以播撒的方式也比较不一样:每次需要选择一个没被选择过的矩形<br/>并均匀撒上金坷垃,且必须将所有矩形都播撒一次。<br/>每次播撒的花费的金坷垃袋数是矩形包含的格子个数的平方。<br/>zy想知道他要买多少金坷垃才够用。<br/>输入格式<br/>第一行给出两个正整数$n$和$m$代表zy家的地的长和宽。<br/>下面$n$行每行一个长度$m$的01串描述了zy家地的状态。$0$代表这个地不能撒,$1$代表能撒。<br/>输出格式<br/>一个非负整数代表金坷垃至少要多少袋。<br/>样例输入<br/>1<br/>2<br/>3<br/>4<br/>5<br/>65 5<br/>01001<br/>11000<br/>00010<br/>00000<br/>10001<br/><br/><br/>样例输出<br/>115<br/><br/><br/>数据范围及提示<br/>对于$30\\% $的数据, 保证$n,\\;m \\le 10$。<br/>对于$50\\% $的数据,保证$n,\\;m \\le 100$。<br/>对于所有数据,保证$n,\\;m \\le 1000$。<br/>题解<br/>A<br/>这道题首先需要你有1个小时。<br/>然后就可以A掉了。<br/>防AK什么鬼......<br/>B<br/><br/>20分: 模拟 ($\\Theta(nk)$)<br/>80分:<br/>排列矩阵快速幂 ($\\Theta(n \\log k)$，排列矩阵的乘法可以在$\\Theta(n)$的时间内计算)<br/>寻找循环节，倍增找到每个值 ($O(n\\log k)$)<br/><br/><br/>100分: 寻找循环节，取模找到每个值 ($\\Theta(n)$)<br/><br/>C<br/>首先需要计算DFS序。<br/>然后用可持久化平衡树来维护它上面的值。<br/>首先以$1$为根，计算每棵子树中比树根小的值有多少个，加起来就是$1$的答案。<br/>然后从$1$开始DFS一遍，考虑在知道当前节点的答案的情况下，换根到自己的一个儿子处，答案的变化，可以在$\\Theta(\\log n)$的时间内计算出来。<br/>然后就可以愉快的$\\Theta(1)$回答啦~~~<br/>D<br/>将其中一个序列的值依次重新编号，然后将另外一个序列也同步修改一下。<br/>然后就转成了求另外一个序列的最长上升子序列问题。<br/>这个可以在$\\Theta(n\\log n)$的时间内计算。<br/>E<br/>引用一段话：<br/><br/>题解：<br/>本来打算出了另外一道题，后来才发现正确性不太好。又不想变成只能出数据结构题的选手，就临时换了这个比较裸的题。<br/>（出题好难<br/>很明显如果矩形代价都是1那么肯定就是直接悬线法。<br/>否则他要算这个的代价就在悬线法里面加特技：每次相当于要从一个长宽分别为n*m的矩形里面算满足特定条件的子矩形的答案。这样就不会重复。<br/>相当于$\\sum_{i=y_0}^{y_1} i^2 \\times \\text{横着的答案}$。<br/>横着的答案：$\\sum_{i=1}^m i^2 \\cdot (n-i+1)$。<br/>然后就没了。<br/>","tags": "HNSDFZ 互测 2016","url": "blog/2016-8-15/hnsdfz-4.html"},
{"title": "HNSDFZ2016 #5","text": "HNSDFZ2016 #5<br/>A. 微小的数学 (ruanxingzhi)<br/>题目描述<br/><br/>到了附中我这三年也没有什么别的,大概三件事:一个,算出了$\\varphi(n)$了; 第二个,算出了$\\mu(n)$; 第三个,就是算出$\\varphi \\times \\mu$了。<br/>如果还说有一点成绩就是科普了杜教筛......还有上周的狄利克雷卷积也是很大的。但这些都是次要的。<br/>我主要干的就是三件事,很惭愧,就做了一点微小的数学。<br/>—— Gromah<br/>现在请你追随Gromah的脚步,来虐掉这个题,做一点微小的数学吧。<br/>—— ruanxingzhi<br/><br/>一句话题意:求：<br/>$$<br/>\\sum_{i=1}^n\\sum_{d \\mid i} \\varphi(d) \\mu(\\frac{i}d)<br/>$$<br/>输入格式<br/>仅一行,一个正整数$n$。<br/>输出格式<br/>仅一行,一个正整数,表示答案。<br/>样例输入1<br/>113<br/><br/><br/>样例输出1<br/>138<br/><br/><br/>样例输入2<br/>1233<br/><br/><br/>样例输出2<br/>110138<br/><br/><br/>数据范围及提示<br/>对于$10\\% $的数据,有$n \\le 32$。<br/>对于$30\\% $的数据,有$n \\le 1000$。<br/>对于$50\\% $的数据,有$n \\le 100000$。<br/>对于$100\\% $的数据,有$n \\le 50000000$<br/>B. 一圈一圈 (Haogram)<br/>题目描述<br/><br/>“有些事,我都已忘记,但我现在还记得,啦啦啦啦啦......”<br/>“一圈一圈似爪牙,似魔鬼的步伐,啦啦啦啦......”<br/>传闻《我的滑板鞋》作者约瑟翰·庞麦郎即将推出新歌《一圈一圈》,并且mv中要配上鬼畜的舞蹈,于是他贴出了应聘广告,Hagram们自然不想放弃这个赚钱的好机会,毅然决然地前往应聘......<br/><br/>约瑟翰·庞麦郎一共应聘了$k$个Hagram，$k$个Hagram都要参与舞蹈。Hagram们被要求在一个$n$行$m$列的矩阵上跳舞，当然一个格子只能站一个Hagram。为了保证舞蹈的鬼畜性，矩阵的第$c$个圈上必须四边都要有Hagram存在，圈数是从最外层往内数的。<br/>两个舞蹈队形不同当且仅当其中一个方案的一个格子上有Hagram而另一个方案没有。<br/>如果有一个Hagram在某一圈的顶点上，可以认为其既在行上，又在列上。<br/>现在约瑟翰·庞麦郎想知道一共有多少种不同的方案，答案对$10^9+7$取模。<br/>输入格式<br/>对于每组数据，四个数：$n,\\;m,\\;k,\\;c$<br/>当$n=m=k=c=0$时结束。<br/>输出格式<br/>对于每组数据，输出一行一个正整数表示答案。<br/>样例输入<br/>1<br/>2<br/>3<br/>4<br/>52 2 1 1<br/>2 2 2 1<br/>3 3 1 2<br/>3 3 2 2<br/>0 0 0 0<br/><br/><br/>样例输出<br/>1<br/>2<br/>3<br/>40<br/>2<br/>1<br/>8<br/><br/><br/>数据范围及提示<br/>对于$30\\% $的数据，$n,\\;m \\le 3$，$k \\le 10$。<br/>对于$100\\% $的数据，$n,\\;m \\le 50$，$k \\le 3 \\times 10^3$。<br/>保证$c$合法。<br/>C. KFight (Link)<br/>题目描述<br/>Zy他是一位在异界闻名的勇士。<br/>Zy在知道公主ZY被恶龙BigGayY抓走后，内心及其不平静。<br/>Zy知道他走向人生巅峰，迎娶公主的时候到了。他要去找到BigGayY，然后打摆他。<br/>但是，BigGayY早就知道闻名的勇士Zy会来。<br/>因此倾心于他的公主SAMA找到了他的骑士们阻止Zy的到来。<br/>骑士有$N$个，他们挡在了Zy去打摆恶龙的路上。Zy要想办法打败他们，但是他不能出全力。<br/>不然的话，到时候没力气打摆BigGayY。因此他只能出$K$拳。<br/>骑士们很逗逼，他们有些人会组成团来和Zy战斗，有些人分开和Zy战斗。<br/>作为勇士的Zy很强，他每次一拳都可以打死一个人或者一团人。<br/>但是骑士团里面还有其他的ZY，作为Zy，他不能够去打败这些ZY，这些ZY也不会去阻止他。  <br/>作为异界王者的国王，很想知道Zy不能够救出公主的概率是多少，他并不想让Zy找到公主。<br/>因此他找到了你，想知道Zy不能救出公主的概率是多少。<br/>输入格式<br/>第一行一个T表示有T波骑士来阻挡了Zy。<br/>第二行三个数$N,\\;K,\\;Q$，分别表示每一波有$N$个骑士来袭，Zy只能打$K$拳，然后这一波骑士里面有$Q$个ZY。<br/>输出格式<br/>对于每一波骑士，输出Zy打不过的概率，保留$10$位小数。<br/>样例输入<br/>1<br/>21<br/>3 1 0<br/><br/><br/>样例输出<br/>10.8000000000<br/><br/><br/>数据范围及提示<br/>注意精度,由于取的小数位很多，注意精度问题。<br/>对于$30\\% $的数据有$K \\le N \\le 4,\\;Q = 0,\\;T \\le 10$。<br/>对于$60\\% $的数据有$K \\le N \\le 20,\\;Q \\le 10,\\;T \\le 2000$。<br/>对于$100\\% $的数据有$K \\le N \\le 30,\\;Q \\le 20,\\;T \\le 2000$。<br/>D. 空袭 (riteme)<br/>题目描述<br/>这是一道交互题。<br/>注意本交互库不提供Pascal支持。只支持C\\C++。<br/>统计学家Lunk所居住的城市遭到的软斯兰国的空袭，弄得Lunk心神不定。<br/>然而伟大的统计学家怎么会就因为空袭而四处避难呢？Lunk决定弄出个大新闻。<br/>由于各种原因，Lunk所居住的城市的市区的形状十分奇怪。Lunk将其大致的轮廓画在地图上，形成了一个多边形的形状。软斯兰国的飞机每丢下一枚炸弹，Lunk就会马上观测到炸弹的位置，并将其画在地图上。但是，他所想要统计的只是智障的软斯兰国有多少枚炸弹攻击到了市区。<br/>于是Lunk放弃了在地图上画下每一个炸弹的位置，而是转而在地下室里直接统计。<br/>现在它所需要的就是一个能帮他统计的程序。他希望能在你们写的程序中选出一个精确度高并且跑得比香港记者还快的程序来帮助它完成这个任务。<br/>我该如何编写这个程序<br/>选手目录下将会下发interface.h这个文件。<br/>你需要实现interface.h中的接口。<br/>你需要在同一目录下新建一个文件airstrike.cpp，其中包含以下内容：<br/>1<br/>2<br/>3#include \ interface.h\ <br/><br/>// 实现部分<br/><br/><br/>你需要实现的接口在头文件中有简要说明。这里做详细说明。<br/>1void initialize(const double *x, const double *y, const size_t n, const int id);<br/><br/><br/>是载入程序的入口。在进行查询之前，会调用这个函数。<br/>载入所用的时间不会计入你的程序用时。但是载入时间不能超过$3\\text{s}$。<br/>x和y是两个数组，给出的是市区的轮廓，即Lunk绘制的多边形的顶点，按照逆时针顺序给出。<br/>n是多边形的顶点数量。<br/>id是当前数据点的标号，在下文会有解释。<br/>1bool query(const double dx, const double dy);<br/><br/><br/>是Lunk的操作，每次调用即查询炸弹是否炸在市区内。如果炸在市区内则返回true，否则返回false。<br/>dx和dy是炸弹炸到的坐标。<br/>该函数的用时会被计入程序用时。<br/>1void finalize();<br/><br/><br/>是结束程序。这个函数将在所有查询任务完成后调用。<br/>用于释放你的程序所用的资源。<br/>该函数的用时不会计入程序用时，但是其运行时间不能超过$3\\text{s}$。<br/>注意，请不要使用delete[]删除掉之前initialize参数中给你的顶点数组，否则后果自负。<br/>我该如何测试这个程序<br/>选手目录下将会下发main.cpp这个文件。<br/>首先你需要有输入的数据，其格式将在下文给出。<br/>假设你的程序文件是airstrike.cpp，那么使用以下命令来编译：<br/>1g++ main.cpp airstrike.cpp -std=c++11 -o main<br/><br/><br/>或者你需要调试：<br/>1g++ main.cpp airstrike.cpp -std=c++11 -o main -g<br/><br/><br/>打开-O2优化：<br/>1g++ main.cpp airstrike.cpp -std=c++11 -o main -O2<br/><br/><br/>对于C语言，将main.cpp改名为main.c，使用gcc，并且将-std=c++11改为-std=c11即可。<br/>然后使用：<br/>1./main<br/><br/><br/>来运行程序。<br/>如果需要使用文件输入输出，你可以使用管道，也可以修改main.cpp，将其中的两行带有注释的freopen取消注释，然后重新编译即可。<br/>注意，该程序不会测试你的用时并给你评分。并且与最终评测时的运行程序不同。<br/>输入格式<br/>此处的输入格式是根据上面的测试程序所说的。<br/>第一行输入两个整数$n$和$d$，表示顶点数量和数据编号。<br/>下面$n$行描述市区，每一行给出一个整点$(x,\\;y)$，表示一个顶点。<br/>之后给出若干行，一直到文件尾，每行给出一个整点$(x_q,\\;y_q)$，表示炸弹的位置。<br/>输出格式<br/>对于每一个Lunk的询问，输出对应的信息 (YES或NO)。<br/>样例输入1<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>93 1<br/>0 0<br/>6 1<br/>8 7<br/><br/>6 5<br/>2 7<br/>8 1<br/>3 1<br/><br/><br/>样例输出1<br/>1<br/>2<br/>3<br/>4YES<br/>NO<br/>NO<br/>YES<br/><br/><br/>样例解释1<br/>样例输入1如下图所示：<br/><br/>样例输入2<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>157 1<br/>1 1<br/>7 1<br/>4 2<br/>3 4<br/>7 5<br/>5 6<br/>1 6<br/><br/>0 4<br/>2 4<br/>4 4<br/>5 3<br/>5 5<br/>3 1<br/><br/><br/>样例输出2<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6NO<br/>YES<br/>NO<br/>NO<br/>YES<br/>YES<br/><br/><br/>样例解释2<br/>样例输入2如下图所示：<br/><br/>数据限制<br/>共$7$个数据测试点，限制如下：<br/><br/><br/><br/>数据编号<br/>$n$的规模<br/>特殊限制<br/><br/><br/><br/><br/>$1$<br/>$\\le 10$<br/>无<br/><br/><br/>$2$<br/>$\\le 10^3$<br/>无<br/><br/><br/>$3$<br/>$\\le 10^5$<br/>无<br/><br/><br/>$4$<br/>$\\le 2 \\times 10^5$<br/>无<br/><br/><br/>$5$<br/>$\\le 10^6$<br/>左右的边与$y$轴平行，下边与$x$轴平行，上边顶点$x$递增，均高于下边，输入数据从左下角开始。<br/><br/><br/>$6$<br/>$\\le 10^6$<br/>凸多边形<br/><br/><br/>$7$<br/>$\\le 10^3$<br/>$0 \\le x,\\;y \\le 10^3$<br/><br/><br/><br/>对于$100\\% $的数据，满足$3 \\le n \\le 10^6,\\;|x|,\\;|y|,\\;|x_q|,\\;|y_q| \\le 10^9$。<br/>顶点按照逆时针顺序输入，没有两个顶点一样，并且为简单多边形。<br/>评分标准<br/>对于不同的数据点，分值和时间限制如下表所示：<br/><br/><br/><br/>数据编号<br/>分值<br/>时间限制<br/><br/><br/><br/><br/>$1$<br/>$5$<br/>$0.1\\text{s}$<br/><br/><br/>$2$<br/>$10$<br/>$1\\text{s}$<br/><br/><br/>$3$<br/>$15$<br/>$1\\text{s}$<br/><br/><br/>$4$<br/>$30$<br/>$1\\text{s}$<br/><br/><br/>$5$<br/>$10$<br/>$1\\text{s}$<br/><br/><br/>$6$<br/>$15$<br/>$1\\text{s}$<br/><br/><br/>$7$<br/>$15$<br/>$1\\text{s}$<br/><br/><br/><br/>在时间限制内，如果程序不出意外 (如运行时错误)，将会不断的给出询问。设你的程序完成的询问个数为$x$。对于每一个点的评分标准如下：<br/><br/><br/><br/>数据编号<br/>$20\\% $<br/>$40\\% $<br/>$60\\% $<br/>$80\\% $<br/>$100\\% $<br/><br/><br/><br/><br/>$1$<br/>$\\ge 10^5$<br/>$\\ge 2\\times 10^5$<br/>$\\ge 3 \\times 10^5$<br/>$\\ge 4 \\times 10^5$<br/>$\\ge 5 \\times 10^5$<br/><br/><br/>$2$<br/>$\\ge 5 \\times 10^4$<br/>$\\ge 10^5$<br/>$\\ge 2 \\times 10^6$<br/>$\\ge 3 \\times 10^6$<br/>$\\ge 4 \\times 10^6$<br/><br/><br/>$3$<br/>$\\ge 5 \\times 10^2$<br/>$\\ge 10^3$<br/>$\\ge 2 \\times 10^5$<br/>$\\ge 4 \\times 10^5$<br/>$\\ge  5 \\times 10^5$<br/><br/><br/>$4$<br/>$\\ge 10^3$<br/>$\\ge 1 \\times 10^5$<br/>$\\ge 2 \\times 10^5$<br/>$\\ge 3 \\times 10^5$<br/>$\\ge 4 \\times 10^5$<br/><br/><br/>$5$<br/>$\\ge 10^3$<br/>$\\ge 8 \\times 10^5$<br/>$\\ge 10^6$<br/>$\\ge 1.2 \\times 10^6$<br/>$\\ge 1.4 \\times 10^6$<br/><br/><br/>$6$<br/>$\\ge 5 \\times 10^2$<br/>$\\ge 8 \\times 10^5$<br/>$\\ge 10^6$<br/>$\\ge 1.2 \\times 10^6$<br/>$\\ge 1.4 \\times 10^6$<br/><br/><br/>$7$<br/>$\\ge 10^6$<br/>$\\ge 2 \\times 10^6$<br/>$\\ge 3 \\times 10^6$<br/>$\\ge 4 \\times 10^6$<br/>$\\ge 10^7$<br/><br/><br/><br/>你的$x$需要达到对应的要求才能得到对应的百分比。评测程序将选取你能达到的最高的百分比。<br/>其中百分比是将该点总分乘上该百分比并向下取整，作为你该点的分数。<br/>如果询问回答错误，将每回答错误一次扣除$1$分，扣分到$0$分为止，分数不会变为负数。<br/>如果发生运行时错误，或者运行严重超时，将导致该点得$0$分。<br/>如果你的initialize或finalize超时，该点得$0$分。<br/>关于评测机<br/>出于一些原因，GCC编译出来的评测器并不是很稳定，可能出现成绩波动的情况，所以评测时最好采用Clang进行编译，得到的结果会稳定一些。<br/>如果你对你的算法十分自信，然而在评测时却没有得到满分，可以进行重测。<br/>温馨提示<br/>评测时限很长，请不要恶意卡评测，谢谢合作！<br/>部分题解<br/>A<br/>raunxingzhi总是喜欢出这种题目，莫名其妙。<br/>首先是$O(n \\ln n)$的做法，令：<br/>$$<br/>f(n) = \\sum_{d \\mid n} \\varphi(d) \\mu(\\frac{n}d)<br/>$$<br/>对其进行逆反演，可以得到：<br/>$$<br/>\\varphi(n) = \\sum_{d \\mid n} f(d)<br/>$$<br/>所以：<br/>$$<br/>f(n) = \\varphi(n) - \\sum_{d \\mid n,\\;d \\lt n} f(d)<br/>$$<br/>所以欧拉函数可以$\\Theta(n)$预处理，而后面的部分可以按照贡献计算，做到$O(n \\ln n)$。<br/>mdzz，$O(n \\ln n)$怎敢过......<br/>其次是两种更快算法。<br/>第一种是乱搞算法，是一个分块打表。<br/>由于我们计算一个$\\sum_{d \\mid n} \\varphi(d) \\mu(\\frac{n}d)$就需要$\\Theta(\\sqrt{n})$的时间，考虑提前将一些答案计算出来。<br/>设每隔$T$个打一个表，那么总共会打$n / T$个表，每次询问的时间为$O(T\\sqrt{n})$。因此，只要你的文件存得下，$T$越小这个速度越快。<br/>第二种是$\\Theta(n)$的算法。首先考虑将式子变形，改变枚举顺序：<br/>$$<br/>\\sum_{i=1}^n \\sum_{d \\mid i} \\varphi(d) \\mu(\\frac{i}d) \\Longrightarrow \\sum_{d = 1}^n \\varphi(d) \\sum_{k = 1}^{\\left\\lfloor \\frac{n}d \\right\\rfloor} \\mu(k)<br/>$$<br/>变成了先枚举因子，然后枚举因子的倍数。于是就变成了欧拉函数和莫比乌斯函数的前缀和之积。<br/>注意不要写出以下代码：<br/>1typedef int int64;<br/><br/><br/>否则会挂得很惨。<br/>B<br/>Haogram的题似乎有很多做法，我都不太记得了，这里瞎BB一下：<br/>我的做法是生成函数。一个最原始的想法是枚举环上四条边有多少个人，这样将四条边上的答案相乘并且乘上站在环外的方案数就是当前答案。<br/>这样纯枚举是$\\Theta(n^4)$的。这个过程非常类似于多项式乘法，换成生成函数的观点，就是将答案组合起来。<br/>于是设四个生成函数，分别表示一条边上站$0,\\;1,\\;2,\\;\\dots$个人的方案数，实际上就是一个组合数，然后暴力将多项式乘起来 (因为$n$很小)，可以做到$\\Theta(n^2)$的复杂度。<br/>如果$n$很大可以换成FFT或NTT。注意使用NTT时，因为题目中已经有了一个模数，所以这两个模数或多或少会有一些冲突，需要注意一下。<br/>然后就是留下四个角的特殊情况。之前我们需要在边上的人不能站在角上。现在来钦定这四个角上有没有人。最后你一共要手动枚举$7$中情况orzorz......<br/>注意其中一条边退化为$1$的情况。<br/>标解是使用容斥原理。因为不考虑那个莫名其妙的要求，直接计数是很简单的。然后就需要考虑去掉不合法的情况。基础情况自然是一条边上没有人。<br/>运用容斥原理乱搞就好了~~只有$4$个条件所以速度很快。<br/>C<br/>你们自己问Link吧，我也不会......<br/>D<br/>原来只要出交互题就可以做到全场爆$\\color{red}{0}$，曾经有人出过提答题，结果全场AC......<br/>60分不写就算了，40分智障分也不写你们好劲啊！一颗赛艇啊！<br/>首先百度一下和谷歌一下的第一版的算法基本上就$10$到$20$左右吧。射线法和角度判别法都是$\\Theta(n)$的算法。<br/>然后后面$40$分是些智障数据点。第$5$个点是上边会上下起伏，我们可以二分找出对应的边，然后叉积判断即可。<br/>第$6$个点凸多边形可以直接进行三角剖分，然后利用角度二分找到对应的三角形，就可以愉快地判定了。这些过程均可用叉积。<br/>第$7$个点直接在initialize里面全部预处理就OK了。注意查询的点可能不在那个范围内，需要特判一下。<br/>接下来是标准解法。<br/>首先考虑一个离线算法，这个算法我是从梯形化三角剖分里借鉴到的。首先将所有边建立两个事件，左端点插入和右端点删除，然后排序。查询也要排序。<br/>然后做一条从左至右的竖直扫描线，用一棵平衡树来维护当前穿过扫描线的边。<br/>很明显的一点就是平衡树中的边不会相交，这样我们可以方便地确定两条边之间的比较关系。<br/>首先如果一条边的两个端点都在另一条边所在的直线下面，那么这条边肯定在在另一条边下面。<br/>利用这一点就可确定大小关系。但是需要注意一种特殊情况：<br/><br/>此时$A$显然在$B$下面，然而如果用$A$去判定$B$就会得到错误的结果 (因为$B$有一个点在$A$所在直线下方)。<br/>我们所要做的就是，当发现这种情况时，交换$A$和$B$，就可以避免处理这种情况。<br/>这样我们每扫描完一个$x$，就可以逐个回答当前的询问了。在平衡树上二分找到上下边，然后判定这个点是否在这两条边所表示的半平面交的范围内。<br/>由于是交互题，被强制在线了。为了能够在线，我们需要每一个$x$处的平衡树来在线回答。这个东西可以利用可持久化平衡树高效地存下来。","tags": "HNSDFZ 互测 2016","url": "blog/2016-8-28/hnsdfz-5.html"},
{"title": "Hall 定理","text": "Hall 定理<br/>基本形式<br/>Hall 定理是一个用于判定二分图是否具有完美匹配的定理。<br/>首先对于二分图 $G = (X \\cup Y, E)$，点集被分为了 $X$ 和 $Y$ 两部分。<br/>是否具有完美匹配，首先一个最基本的条件就是 $|X| = |Y|$。<br/>Hall 定理则在此基础上给出了一个更强的条件。<br/>首先对于一个点集 $T \\subseteq X$，定义 $\\Gamma(T)$ 如下：<br/>$$<br/>\\Gamma(T) = \\{v \\mid u \\rightarrow v \\in E,\\; u \\in T,\\; v \\in Y\\}<br/>$$<br/>即表示 $T$ 中所有点能够直接到达的 $Y$ 中的点的集合。<br/><br/>上图中，$\\Gamma(\\{1,\\;3\\}) = \\{4,\\;5,\\;6\\}$。<br/>Hall 条件用于判断一个二分图是否存在完美匹配。如果对于任意的点集 $T \\subseteq X$，均存在：<br/>$$<br/>|T| \\le |\\Gamma(T)|<br/>$$<br/>称此二分图满足 Hall 条件。Hall 定理的表述如下：<br/><br/>二分图 $G(X \\cup Y,E)$ 存在完美匹配当且仅当 $|X| = |Y|$ 并且满足 Hall 条件。<br/><br/>本文会使用 $C = A - B$ 表示集合之差，即 $C = A \\cap \\overline B$。<br/>证明<br/>首先，当 $|X| \\neq |Y|$ 时，二分图不存在完美匹配。如果二分图存在完美匹配，则意味着 $|X| = |Y|$。此外，上述定理的充分性非常显然，因为如果 $|\\Gamma(T)| < |T|$，那么对于子集 $T$ 是无法找出完美匹配的。<br/>现在来证明必要性。记 $n = |X|$，不难发现当 $n = 0$ 或 $n = 1$ 时，Hall 定理是成立的。<br/>尝试使用数学归纳法来证明 $n > 1$ 的情形。假设对于任意 $n < k$ 的情况都是成立的，则需要证明当 $n = k$ 时也是成立的。先来考虑条件最为苛刻的一类非空真子集 $T \\subset X$，它满足 $|\\Gamma(T)| = |T|$。对于子集 $S \\subseteq X - T$，由于满足 Hall 条件，所以 $|\\Gamma(S  \\cap T)| \\geq |S \\cap T|$，又因为 $|\\Gamma(T)| = |T|$，所以 $|\\Gamma(S) - \\Gamma(T)| \\geq |S|$，也就是说，如果图 $G$ 中删去 $T$ 和 $\\Gamma(T)$ 中的所有点得到新图 $G'(X' \\cup Y',E')$，则 $|X'| < k$ 且依然满足 Hall 条件，故 $G'$ 存在完美匹配。由于 $T$ 是真子集，所以 $|T| < k$，所以 $G$ 关于点集 $T \\cup \\Gamma(T)$ 的导出子图一定存在完美匹配。即 $G$ 存在完美匹配。<br/>注意到满足上述条件的非空真子集 $T$ 并不总是存在。当不存在的时候，我们有：<br/>$$<br/>|\\Gamma(T)| \\geq |T| + 1 \\;\\;\\;\\; (\\forall \\; T \\subset X)<br/>$$<br/>这个时候任意删去图 $G$ 的任意一条匹配边，不会使 $G$ 不符合 Hall 条件。由于 $n$ 减少了 $1$，所以删去该匹配边后的图存在完美匹配。<br/>计算所有满足 Hall 条件的子集<br/>对于一张二分图而言，如何确定 $X$ 或 $Y$ 的一个子集是否满足 Hall 条件？<br/>令 $n$ 为 $|X|$。首先我们可以根据定义，对于每个子集枚举自己的子集。采用 DP，可以推算出所有子集的答案。时间复杂度为 $O(3^n)$。<br/>考虑到直接枚举子集过于暴力，因此先选择集合中的一个点 $u$，将其删去，将会得到一个更小的子集，这个值已经被提前计算过了，因此一大部分的子集的答案就都被算入其中了。剩下的还未考虑到的子集均包含 $u$，但是除了集合本身外，剩余的子集均会相差至少一个点。因此我们枚举所有集合中的点并去掉，用得到的新的更小的集合的 DP 值来更新当前集合，最后再计算自己是否满足不等式。这样计算的时间是 $O(2^n \\cdot n)$ 的。<br/>大致的代码如下：<br/>1<br/>2<br/>3<br/>4<br/>5f = [True] * 2^n  // DP数组<br/>for s in [0, 2^n):<br/>    for u in [0, n):<br/>        f[s] &= f[s ^ (1 << u)]<br/>    # 检查s本身是否可行，更新f[s]<br/><br/><br/>简单运用<br/>Hall 定理一般没有什么优化算法复杂度上的用途，但是可以作为一个比较好的思维工具。<br/>例如下面这个问题：<br/>[Russian Code Cup 2016 - Finals] A. Closing ceremony<br/>大意是有一个 $n\\times m$ 的网格和 $n \\times m$ 个人，每个人都要走到一个网格上的一点，每个点只能装下一个人。<br/>同时定义两个点之间的距离为曼哈顿距离，每个人有自己行走的路程上限。<br/>现在这 $n \\times m$ 个人分成两批，从 $(0,\\;0)$ 和 $(0,\\;m+1)$ 出发，问你是否存在一种安排每个人的最终位置的方案，来满足每个人走到对应位置时的路程不超过自己的上限。<br/>令点 $A$ 为 $(0,\\;0)$，点 $B$ 为 $(0,\\;m+1)$。并且设 $f(i,\\;j)$ 表示离 $A$ 距离至少为 $i$，离 $B$ 距离至少为 $j$ 的格子的个数。<br/>设 $S_A(i)$ 表示在 $A$ 最远距离至少为 $i$ 的人数，同理，$S_B(i)$ 表示在 $B$ 处最远距离至少为 $i$ 的人数。由于每个人和一个位置形成了一个一一对应的关系，由此我们可以构建一个二分图，并且我们所要做的就是判定这个二分图是否具有完美匹配。<br/>事实上由于存在单调性，利用 Hall 定理可以知道，我们只用判定是否对于所有的 $f(i,\\;j)$ 均不大于 $S_A(i) + S_B(j)$，如果满足这个条件，那么这个二分图就有最大匹配。<br/>那么现在的问题就是求得 $f$。由于曼哈顿距离为 $i$ 的等距线实际上是一条斜率为 $1$ 或 $-1$ 的直线，所以 $f(i,\\;j)$ 就是两条直线在网格中围成的面积。<br/>并且注意到它可以递归计算：<br/>$$<br/>f(i,\\;j) = f(i+1,\\;j) + f(i,\\;j+1) - f(i+1,\\;j+1)<br/>$$<br/>并且需要考虑这两条直线的交点是否会占用一个格子。所以我们的做法就是枚举交点，确定是那两条直线相交，并且赋给对应的 $f$ 去，然后对 $f$ 计算后缀和就是我们想要的东西啦～","tags": "图论 二分图 Hall 定理","url": "blog/2016-9-19/hall-theorem.html"},
{"title": "Home Page","text": "欢迎来到 riteme’s site！<br/>这是 riteme 的个人主页。<br/>全部换成 Material Design 啦，虽然还是不清真…<br/>博客更新比较缓慢，可能会长期不更......<br/>博客里大多关于编程与 OI，大家随意翻阅~~<br/>最近更新<br/>数学问题杂记一些比较有意思的数学问题Read More…<br/>杜教筛的时空复杂度分析Read More…<br/>附中 2018 夏令营课件Read More…<br/>最小树形图最小树形图朱刘算法以及 Tarjan 的改进版本Read More…<br/>砍木棍问题将一根长为 $a$ 的木棍每次随机砍掉一段，期望多少次后木棍长度小于 $b$ ？Read More…<br/>位运算卷积与 FWT介绍了位运算卷积以及快速计算的 FWT 算法Read More…<br/>区间加多项式问题的研究Read More…<br/>计算纯电阻网络的等效电阻Read More…<br/>OI Coding Guidelines个人对 OI 编程的一些经验Read More…<br/>计算分拆数的一种方法使用多项式乘法加速计算分拆数Read More…<br/>查看全部","tags": "Home","url": "index.html"},
{"title": "Int 2048","text": "Int 2048<br/>时间限制：$1 \\mathrm{s}$<br/>空间限制：$1024 \\mathrm{MB}$<br/>题目描述<br/>这是一道交互题。<br/>注意本交互库不提供Pascal\\C支持，只支持C++。<br/>L语言之父Lunk最近声称用该语言编写计数问题不要取模，因为Lunk发明了$256 \\mathrm{\\ Byte}$的int2048_t，并且已经内置到L语言中。<br/>然而屁民们并不相信，因为Lunk的int2048_t还不支持Xntel公司的CSB指令 (Count Set Bits，计数被设置的位的数量)，于是众人D之。Lunk为了挽回自己的脸面，决定实现一个CSB命令来教训一下这群智障。<br/>CSB指令是一个这样的指令：它用于计数一个整型的二进制表示中的$1$的个数。例如下面的整型中：<br/>$$01001101$$<br/>其执行CSB的结果是$4$。<br/>Lunk不想再搞个新东西来支持这个垃圾玩意，他只准备利用现有的功能来实现它。目前int2048_t所支持的功能如下表所示：<br/><br/><br/><br/>符号<br/>说明<br/>示例<br/>代价<br/>实际复杂度<br/><br/><br/><br/><br/>(constructor)<br/>构造一个int2048_t<br/>int2048_t<br/>$0$<br/>$\\Theta(n)$<br/><br/><br/>(constructor)<br/>从一个字符串构造一个int2048_t<br/>int2048_t(\ 110\ )<br/>$0$<br/>$\\Theta(n)$<br/><br/><br/>+<br/>加法<br/>0011 = 0010 + 0001<br/>$1$<br/>$\\Theta(n)$<br/><br/><br/>-<br/>取负数 (计算其补码)<br/>1111 = -0001<br/>$1$<br/>$\\Theta(n)$<br/><br/><br/>-<br/>减法 (需要执行一个取负数和加法)<br/>1101 = 1111 - 0010<br/>$2$<br/>$\\Theta(n)$<br/><br/><br/>~<br/>将各位取反<br/>1010 = ~0101<br/>$1$<br/>$\\Theta(n)$<br/><br/><br/>&<br/>按位与<br/>0010 = 1011 & 0110<br/>$1$<br/>$\\Theta(n)$<br/><br/><br/>|<br/>按位或<br/>1111 = 1011 | 0110<br/>$1$<br/>$\\Theta(n)$<br/><br/><br/>^<br/>按位异或<br/>1101 = 1011 ^ 0110<br/>$1$<br/>$\\Theta(n)$<br/><br/><br/><<<br/>左移<br/>1100 = 1011 << 2<br/>$1$<br/>$O(n)$<br/><br/><br/>>><br/>右移<br/>0010 = 1011 >> 2<br/>$1$<br/>$O(n)$<br/><br/><br/>==<br/>判断是否相等<br/>0010 == 0010<br/>$1$<br/>$\\Theta(n)$<br/><br/><br/>!=<br/>判断是否不等<br/>0010 != 1010<br/>$1$<br/>$\\Theta(n)$<br/><br/><br/><<br/>小于<br/>0010 < 0100<br/>$1$<br/>$O(n)$<br/><br/><br/>><br/>大于<br/>0110 > 0100<br/>$1$<br/>$O(n)$<br/><br/><br/><=<br/>小于等于<br/>0100 <= 0100<br/>$1$<br/>$O(n)$<br/><br/><br/>>=<br/>大于等于<br/>0010 >= 0010<br/>$1$<br/>$O(n)$<br/><br/><br/>(bool)<br/>转为bool类型 (如果为$0$则为$\\mathrm{false}$，否则为$\\mathrm{true}$)<br/>if (a)<br/>$1$<br/>$O(n)$<br/><br/><br/><br/>在上表中，代价是智障们评定运行快慢的标准，实际复杂度是在实际运行 (即你的程序) 中的时间复杂度，其中$n$表示int2048_t的二进制位数，即$2048$。<br/>智障屁民们将会给出一堆的测试，如果Lunk的CSB指令写挂了，那么它们将会打$0$分。如果Lunk的CSB指令太慢，它们就又不高兴。于是Lunk请你帮他编写一个快速的CSB指令的实现。<br/>实现<br/>选手目录下将会下发int2048_t.hpp和int.h两个文件。<br/>int2048_t.hpp是Lunk的int2048_t的实现，已经被int.h包含，选手不用自行包含。<br/>选手需要实现一个evaluate函数，表示CSB指令。其函数原型如下：<br/>1int evaluate(const int2048_t &num);<br/><br/><br/>当交互库运行时，会将测试数据通过num传入，而该函数的目的就是返回CSB指令在num上的结果。<br/>样例交互库<br/>选手目录下将会下发implementer.cpp这个文件。<br/>假设你的实现的源文件是int.cpp，那么使用下面的编译命令来编译：<br/>1g++ int.cpp implementer.cpp -std=c++11 -o exec<br/><br/><br/>然后将会得到可执行文件exec。<br/>输入格式<br/>此处的输入格式值针对样例交互库而言的。<br/>输入只有一行，表示测试的整形，以二进制形式给出。请确保输入不超过2048位，否则将导致不正常结果。<br/>由于int2048_t是有符号整型，出于一些原因，最终测试数据的输入的最高位都是$0$。<br/>输出格式<br/>此处的输出格式是针对样例交互库而言的。<br/>样例交互库将会从输入得知答案，并将输入转为int2048_t，然后执行evaluate得到你的答案。如果两者答案一致，将会输出你所使用的代价总和。否则将输出Wrong answer，并给出正确答案和你的答案。<br/>样例输入<br/>101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111<br/><br/><br/>样例答案<br/>12047<br/><br/><br/>评分标准<br/>此题共$10$个数据点，每个数据点$10$分。<br/>对于每一个数据点而言，如果你的答案不正确，那么将记$0$分。<br/>否则，记$a$为你的evaluate执行的代价总和，$v_{\\min}$和$v_{\\max}$是每个数据点的特定的参数，那么你的得分将是：<br/>$$<br/>\\left\\lfloor \\max\\left\\{ 10 \\cdot\\min\\left\\{ 1, \\; { v_{\\max} - a \\over v_{\\max} - v_{\\min} } \\right\\}, \\; 0 \\right\\} \\right\\rfloor<br/>$$<br/>数据限制<br/>对于每一个数据点，其限制如下表所示 (其中$x$表示答案)：<br/><br/><br/><br/>数据点编号<br/>$x$<br/>$v_{\\min}$<br/>$v_{\\max}$<br/><br/><br/><br/><br/>$1$，$2$，$3$<br/>$ \\leqslant 400 $<br/>$6140$<br/>$6144$<br/><br/><br/>$4$，$5$，$6$<br/>$ \\leqslant 200 $<br/>$801$<br/>$1201$<br/><br/><br/>$7$，$8$，$9$，$10$<br/>$ \\leqslant 2047 $<br/>$76$<br/>$120$<br/><br/><br/><br/>提示<br/>一个整型的原码就是其二进制表示：<br/>$$<br/>13 \\rightarrow 00001101<br/>$$<br/>其反码就是将除了符号位 (即最高位) 的所有取反：<br/>$$<br/>00001101 \\rightarrow 01110010<br/>$$<br/>对于负数，其符号位为$1$：<br/>$$<br/>01110010 \\rightarrow 11110010<br/>$$<br/>二进制数的补码就是将其反码加上$1$，同时对于溢出的位直接丢弃，符号位也参与计算：<br/>$$<br/>-13 \\rightarrow 11110011 \\\\<br/>-0 \\rightarrow 11111111 + 1 \\rightarrow 100000000 \\rightarrow 00000000<br/>$$<br/>因此采用补码存储负数，原码存储自然数，这样减法可以变为加法：<br/>$$<br/>1 - 13 = 1 + (-13) \\rightarrow 00000001 + 11110011 = 11110100 \\rightarrow -12<br/>$$<br/>所以减法需要花费$2$的代价。","tags": "Problems","url": "blog/2016-11-24/int.html"},
{"title": "Lesson 16","text": "Lesson 16: Mary had a little lamb (玛丽有一头小羔羊)<br/>Mary and her husband Dimitri lived in the tiny village of Perachora in southern Greece. One of Mary’s prize possessions was a little white lamb which her husband had given her. She kept it tied to a tree in a field during the day and went to fetch it every evening. One evening, however, the lamb was missing. The rope had been cut, so it was obvious that the lamb had been stolen.  When Dimitri came in from the fields,His wife told him what had happened.Dimitri at once set out to find the thief. He knew it would not prove difficult in such a small village. After telling several of his friends about the theft, Dimitri found out that his neighbour, Aleko, had suddenly acquired a new lamb. Dimitri immediately went to Aleko’s house and angrily accused him of stealing the lamb. He told him he had better return it or he would call the police. Aleko denied taking it and led Dimitri into his back-yard. It was true that he had just bought a lamb, he explained, but his lamb was black. Ashamed of having acted so rashly, Dimitri apologized to Aleko for having accused him. While they were talking it began to rain and Dimitri stayed in Aleko’s house until the rain stopped. When he went outside half an hour later, he was astonished to find that the little black lamb was almost white. Its wool, which had been dyed black, had been washed clean by the rain!","tags": "English","url": "blog/english/16.html"},
{"title": "NOIP2014 寻找道路题解","text": "[NOIP2014] 寻找道路<br/>原题题意<br/>给你一张$ n(n \\le 1000) $个点和$ m(m\\le200000) $条边权为1的无向边的图，找出一条符合下列要求的路径：<br/>1. 路径上的所有点的出边所指向的点都直接或间接与终点连通。<br/>2. 在满足条件 1 的情况下使路径最短。<br/>做法<br/>既然路径上的所有点都要满足要求1,于是我们先求出这张有向图中哪些点满足要求。<br/>我们使用一个valid数组来存储某个点是否直接或间接地到终点的布尔值，故最暴力的方法就是每个点DFS。其实只需要一次DFS即可，因为只要任意一个与某个点的出边相连接的点能够到达终点，那么这个点也可以到达终点，否则不行。这样在写的过程中，比较麻烦，因此我们在读入图的时候同时构造一张反向图，即每条边与原图方向相反，然后从终点BFS，将每个可以便利到的点打上标记。<br/>做完这个处理后，只需要从起点BFS就能求出答案。","tags": "NOIP BFS 图论 题解","url": "blog/2016-2-1/find-path.html"},
{"title": "NOIP2015 信息传递题解","text": "[NOIP2015] 信息传递<br/>原题题意<br/>给你一张$ n \\; (n \\le 200000) $个点的有向图，请你找出其中最短的有向环，输出此环的长度。<br/>做法<br/>使用DFS将图遍历，找出有向环统计最小。<br/>遍历是对节点进行标记，如果遍历中发现已经被标记的节点，则表示找到了一个环。<br/>需要注意几点：<br/><br/>一次DFS不一定能将整张图遍历，因此需要检查每个点，多次DFS。  <br/>注意DFS的起点而导致的冲突。<br/>   为了说明这个问题，我放一张图解释一下。<br/>   下面是一张有向图：<br/><br/>   假如我们第一次从2出发，DFS完后将2之后的点都打上了标记。<br/>   然后从1出发继续寻找，发现2被打上了标记，会误认为是一个环，导致错误的结果。<br/>   解决方法很简单，我们给每次DFS一个不同的编号，通常从1开始。<br/>   我们默认如果点的标记为0表示还没有访问过。<br/>   如果还没有访问，做的标记就是本次DFS的编号。因此，只要发现被标记的点是自己打上的，才说明发现了环。<br/>   如果发现了别的DFS打上的标记，就不必继续搜索了。<br/>有向环的长度计算。<br/>   这个很好办，DFS中我们维护一个$dist$数组，表示到本次搜索起点的距离。<br/>   当发现有向环时，可以利用此数组算出来。<br/>递归优化。<br/>   这个DFS由于不需要回溯之类的操作，并且题目中给出每个人只会将信息传给一个人，<br/>   那么说明每个点的出度为1，因此我们可以将DFS改成递推的形式：<br/><br/>1<br/>2<br/>3<br/>4def dfs(s):<br/>    while next(s) is not marked:<br/>        # 处理s<br/>        s = next(s)<br/><br/>","tags": "NOIP DFS 图论 题解","url": "blog/2016-2-1/message.html"},
{"title": "OI Coding Guidelines","text": "OI Coding Guidelines<br/>前段时间被 XL 拖过去瞎讲了一堂课，这里把课件放出来，以供大家参考。<br/>前言<br/>这份简单的指南主要是关于以下两个方面：<br/><br/>OI 赛场上 C++ 语言的一些常用技巧和注意事项。<br/>NOI Linux (Ubuntu) 中常用的工具。<br/><br/>由于大多是我个人的感受，而本人又是一个菜鸡被线踩选手，所以后面的内容大家简单看看就好。<br/>下面有些段落前面会标上 “*” 号，表示这一部分的内容在正式赛场上不能使用，因为至少需要 C++11 的支持。<br/>第一部分：C++ 语言<br/>CCF 已经发了公告，不久后将会逐步取消 Pascal 和 C 语言。对于使用 Pascal 的同学，需要尽快转到 C++ 上面来。而对于使用 C 语言的同学，我觉得这是不存在的，因为 OI 中鲜有使用一些 C++ 高级特性的场景，那么 C 语言选手和 C++ 选手的主要区别就只剩是否使用 STL。<br/>这里我将会写一点一般 OIer 容易忽视的一些 C++ 语法和技巧，希望对你们有用。<br/>代码结构<br/>我看过的大部分代码都是下面这个结构：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29<br/>30<br/>31<br/>32<br/>33<br/>34// 开头注释，或是一些奇怪的东西<br/><br/>#include <...><br/>#include <...><br/>#include <...><br/>// #include <bits/stdc++.h>: someone may love it. This is OK in NOI.<br/><br/>// 花式宏定义<br/>// 一些简单的函数<br/><br/>struct XXPoint {<br/>    // 某某 struct<br/>};<br/><br/>struct XXTree {<br/>    // 某某数据结构<br/>};<br/><br/>void aaa() {<br/>    // ...<br/>}<br/><br/>inline int bbb() {<br/>    // ...<br/>}<br/><br/>// ...<br/><br/>int main() {<br/>    // 开文件<br/>    init();<br/>    work();<br/>    return 0;<br/>}<br/><br/><br/>至于到底该怎么写，这都是个人的习惯和爱好。这里只是建议每个函数不宜过长，最好不要有超过 $20$ 行的函数，因为这种很长的函数不利于代码调试。<br/>空格与空行<br/>通常，很多表达式的中间我们都会打上一个空格，用来凸显运算符的位置。一个很长的表达式没有空间，都是比较难以阅读的。如下面这个表达式：<br/>1x1=-b+sqrt(b*b-4*a*c)/2/a;x2=-b-sqrt(b*b-4*a*c)/(2*a);// 解方程<br/><br/><br/>普遍会写成这样：<br/>1<br/>2x1 = -b + sqrt(b * b - 4 * a * c) / 2 / a;<br/>x2 = -b - sqrt(b * b - 4 * a * c) / (2 * a);  // 注释与代码之间通常也有 1-2 个的空格<br/><br/><br/>相比之下，下面这个在代码中就清晰很多。当然，如果你觉得像 4 * a * c 这种可以写的和数学公式 $4ac$ 一样紧凑，4*a*c 也是可以接受的。打这种空格并不需要花费什么时间，只要多试几次，自然就熟悉了。我们的目的在于希望通过这种习惯性的空格来减少自己检查错误的时间。<br/>空行通常用于分隔两段作用有明显差异的代码块，如两个函数之间、同一个函数的不同步骤之间。这个时候写点注释也是可以的，但是上了考场，由于时间原因，大家普遍不会写注释......<br/>下面这段代码我是随便从 UOJ 上截的一段改的，体会一下就好。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24sieve();<br/><br/>for (int i = 1; i <= h; i++)<br/>    if (!(a[1] %  pri[i])) p[++tot] = pri[i];<br/><br/>for (int i = 1; i <= n; i++) {<br/>    i64 t = gcd(a[1], a[i]);<br/><br/>    if (t == 1) {<br/>        printf(\ -1 \ );<br/>        continue;<br/>    }<br/><br/>    bool flag = 1;<br/>    for (int j = 1; j <= tot && 1LL * p[j] * p[j] <= t; j++) {<br/>        if (!(t %  p[j])){<br/>            printf(\ % lld \ , t / p[j]);<br/>            flag = 0;<br/>            break;<br/>        }<br/>    }<br/><br/>    if (flag) printf(\ 1 \ );  // t为质数<br/>}<br/><br/><br/>如果您是一个热衷于缩行的青少年，上面的话您可以无视......<br/>命名习惯<br/>通常普遍为大家所接受的就是使用英文（或简写），而不是拼音乃至拼音简写。我见过一个比较极端的例子就是 ksm。乍一看不知道是个什么东西，直到看了代码才知道是 “快速幂” 的意思......一般这种函数通常都会写做 quick_pow 或者是 qpow。当然，上面的结论是基于方便他人理解你的代码而得出的。在 OI 中，基本没人会在意你是怎么写的。所以如果你更熟悉我们的国语，使用拼音命名法也无妨。<br/>兼顾阅读效率和编码效率，我的推荐是名称最好 $2$-$4$ 个字符，超过 $6$ 个字符是不太适合的。之所以不推荐 $1$ 个字符，是因为容易产生命名冲突，也就意味着容易写错代码。<br/>下面列举了一些在 OI 中常见的写法及其含义：<br/><br/><br/><br/>写法<br/>原始单词 / 符号<br/>注释<br/><br/><br/><br/><br/>aha<br/>Aha!<br/>dalao HJWJBSR 最爱<br/><br/><br/>ans<br/>answer<br/><br/><br/><br/>arr<br/>array<br/><br/><br/><br/>buc<br/>bucket<br/>桶排序相关<br/><br/><br/>buf<br/>buffer<br/>缓存、缓冲<br/><br/><br/>ch<br/>child / children<br/>通常指树上的儿子<br/><br/><br/>chk<br/>check<br/><br/><br/><br/>cls<br/>clear screen<br/>清空屏幕<br/><br/><br/>cmp, comp<br/>compare<br/>想必你在 sort 中用过<br/><br/><br/>cnt<br/>count<br/><br/><br/><br/>cur<br/>current<br/><br/><br/><br/>del<br/>delete<br/><br/><br/><br/>dist, dis<br/>distance<br/><br/><br/><br/>div<br/>divisor<br/>因子<br/><br/><br/>div<br/>divide<br/>除法<br/><br/><br/>e, E<br/>$\\mathrm{e} = 2.71828...$<br/>自然对数函数的底数<br/><br/><br/>eps, EPS<br/>$\\varepsilon$ (epsilon)<br/>通常表示精度设定（浮点数中）<br/><br/><br/>equ<br/>equal<br/><br/><br/><br/>err<br/>error<br/><br/><br/><br/>eval<br/>evaluate<br/>计算<br/><br/><br/>expr<br/>expression<br/>表达式<br/><br/><br/>f, g, h, dp<br/>-<br/>一般的 DP 数组<br/><br/><br/>fa<br/>father<br/><br/><br/><br/>func<br/>function<br/>函数<br/><br/><br/>g, G<br/>graph / primive root<br/>图 / 数论中的原根<br/><br/><br/>i, j, k<br/>-<br/>各种下标<br/><br/><br/>inf, INF<br/>infinity<br/>#define INF 0x3f3f3f3f?<br/><br/><br/>init<br/>initialize<br/><br/><br/><br/>ins<br/>insert<br/><br/><br/><br/>interp<br/>interpolate<br/>线性插值，$\\vec c = (1-t)\\vec a + t \\vec b$<br/><br/><br/>inv<br/>inverse<br/>逆元<br/><br/><br/>iX (X = 16, 32, 64, 128)<br/>signed integer<br/>有符号整型<br/><br/><br/>jmp<br/>jump<br/><br/><br/><br/>l, r, m<br/>left, right, middle<br/>常用于二分中<br/><br/><br/>lch<br/>left child<br/><br/><br/><br/>len<br/>length<br/><br/><br/><br/>ll, LL<br/>long long (in C++)<br/><br/><br/><br/>mi, mx<br/>min, max<br/>（我个人不喜欢 mi）<br/><br/><br/>mid<br/>middle<br/><br/><br/><br/>mod, MOD<br/>modulo<br/>$10^9 + 7,\\;998244353$, your best friends<br/><br/><br/>mul<br/>multiply<br/><br/><br/><br/>num<br/>number<br/><br/><br/><br/>nxt<br/>next<br/><br/><br/><br/>pi, PI<br/>$\\pi = 3.14159...$<br/><br/><br/><br/>pos<br/>position<br/><br/><br/><br/>pre<br/>prefix<br/>前缀<br/><br/><br/>pre, prev<br/>previous<br/>上一个<br/><br/><br/>pri<br/>prime<br/><br/><br/><br/>ptr<br/>pointer<br/>指针<br/><br/><br/>rand, rnd<br/>random<br/><br/><br/><br/>rch<br/>right child<br/><br/><br/><br/>ref<br/>reference<br/>引用<br/><br/><br/>res<br/>result<br/><br/><br/><br/>ret<br/>return<br/><br/><br/><br/>rev<br/>reverse<br/><br/><br/><br/>S<br/>set<br/>通常表示集合<br/><br/><br/>s, t<br/>source, sink (target)<br/>源点和汇点，在网络流和最短路中常见<br/><br/><br/>seg<br/>segment<br/>You must know segment trees.<br/><br/><br/>seq<br/>sequence<br/><br/><br/><br/>sqr<br/>square<br/>$x^2$<br/><br/><br/>sqrt<br/>square root<br/>$\\sqrt x$<br/><br/><br/>stk<br/>stack<br/><br/><br/><br/>str<br/>string<br/><br/><br/><br/>suf<br/>suffix<br/>后缀<br/><br/><br/>tmp<br/>temporary<br/>临时的<br/><br/><br/>tot<br/>total<br/>似乎 Pascal 选手喜欢用？<br/><br/><br/>u, v, w<br/>vertexes and weight<br/>图论题中天天有<br/><br/><br/>upd<br/>update<br/><br/><br/><br/>uX (X = 16, 32, 64, 128)<br/>unsigned integer<br/>无符号整型<br/><br/><br/>val<br/>value<br/><br/><br/><br/><br/>当然，每个人都会有自己的喜好，你可以参照上面来简化你的命名规范。<br/>全局中的变量和函数<br/>这一部分主要是提一下 inline 和 static 关键字。inline 关键字用于函数，表示提醒编译器可以对这个函数展开内联优化，简单的说就是将函数的代码直接写出来，而不是一个函数调用。这里给一个具体的例子：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8int func(int n) {<br/>    return n + 5;<br/>}<br/><br/>int main() {<br/>    printf(\ % d\\n\ , func(10));  // 输出 15<br/>    return 0;<br/>}<br/><br/><br/>那么内联展开后的结果应该等价于：<br/>1<br/>2<br/>3<br/>4int main() {<br/>    printf(\ % d\\n\ , 10 + 5);  // 输出 15<br/>    return 0;<br/>}<br/><br/><br/>从实际的汇编代码来看，如果不写 inline，得到的代码是这样的：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13.LC0:  // 字符串 \ % d\\n\  的声明<br/>    .string \ % d\\n\ <br/>    .text<br/>    .globl main<br/>    .type main, @function<br/><br/>// main 函数中<br/>movl $10, % edi    // 填入参数 10<br/>call func         // 执行 func<br/>movl % eax, % esi   // 将 func 的返回结果填入 printf 的参数<br/>movl $.LC0, % edi  // 将 \ % d\\n\  填入参数<br/>movl $0, % eax     // 由于 printf 使用了变长参数列表，所以这里应该是填了一个终止标记？<br/>call printf       // 调用 printf<br/><br/><br/>而进行了内联优化之后，就会变成这样子：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7movl $10, -4(% rbp)<br/>movl -4(% rbp), % eax<br/>addl $5, % eax  // 直接执行 10 + 5 (eax 处原是 10)<br/>movl % eax, % esi<br/>movl $.LC0, % edi<br/>movl $0, % eax<br/>call printf<br/><br/><br/>上面的过程在不开优化的情况下是不会进行的，这里我是通过强制 GCC 执行内联才得到的结果。此外，对于递归函数，编译器是不会进行内联优化的，也就是说递归函数前面加上 inline 没有任何用处。如果一个函数很长或者很复杂，编译器也通常不会进行优化。我的推荐是如果行数不超过 $7$ 行，就写一个 inline，否则就没有必要浪费时间。<br/>static 可以用于函数和变量前。在函数前写个 static 纯属画蛇填足，因为 OI 中没有任何用处，但在变量前写个 static，可以使你少写一个清零。被声明为 static 的原始类型变量初始默认都是 $0$，而不是一个随机的值。<br/>在函数中的静态变量相当于是一个全局变量，只是函数外部不可以访问到它。这个特性通常被拿来做计数器：<br/>1<br/>2<br/>3<br/>4<br/>5// 调用 5 次 cnt 将分别返回 1 2 3 4 5<br/>int cnt() {<br/>    static int tot;  // 初始为 0<br/>    return ++tot;<br/>}<br/><br/><br/>模块化<br/>虽然大部分题目只会涉及到一两个算法，但是 OI 中不缺乏代码量大、涉及算法和方法比较多的题目，例如需要打各种公式的 “【清华集训2016】定向越野 ”、为了给部分分而造出的三合一 “【NOI2015】小园丁与老司机 ”，以及 NOIP 三合一的 “【WC2013】平面图 ”。如果代码没有良好的规划，那么在考场上写这种题目出错的概率将大大增加。<br/>模块化通常是将没有什么关联的代码块做出适当的隔离。最需要这种方法的情况是需要使用不同的算法解决不同要求的问题的时候，通常代码会有下面的结构：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29<br/>30<br/>31<br/>32<br/>33<br/>34<br/>35<br/>36struct NAIVE {<br/>    // 暴力算法<br/><br/>    void main() {<br/>        // ...<br/>    }<br/>};<br/><br/>struct Solver1 {<br/>    // 骗分算法 1<br/><br/>    void main() {<br/>        // ...<br/>    }<br/>};<br/><br/>struct Solver2 {<br/>    // 骗分算法 2<br/><br/>    void main() {<br/>        // ...<br/>    }<br/>};<br/><br/>int main() {<br/>    if (n <= 1000)<br/>        (new NAIVE)->main();    // 使用暴力算法<br/>    else if (something met)<br/>        (new Solver1)->main();  // 采用算法一<br/>    else if (something else met)<br/>        (new Solver2)->main();  // 采用算法二<br/>    else  // ***k the problem<br/>        puts(\ orz\ );            // 表示对出题人崇高的敬意<br/><br/>    return 0;<br/>}<br/><br/><br/>这样做相比于所有算法都写在全局的好处在于它首先避免了算法之间的命名冲突。其次，如果一个算法将不会被使用，那么它所需要的内存也不会被申请，避免了全部开在全局而导致超出内存限制的隐患。请注意，在 NOI 的评测机中，你开了多大的数组就会计入多少的内存，而不是某些评测机，即使开了 $512\\mathrm{MB}$ 的数组，但是如果只用了 $32\\mathrm{MB}$，就只会记你 $32\\mathrm{MB}$。<br/>除了使用 class/struct 这种方法之外，一些人还会使用 namespace。虽然我个人觉得 namespace 在 OI 中没什么用，因为它的作用可以说只是把命名空间中的所有名字全部加了个前缀。比如 STL 中的所有东西全部被放在了一个叫做 std 的命名空间，所以，如果程序前面不用 using namespace std，那么使用 STL 中的函数就都需要加上一个 std::，如 std::sort。<br/>class 与 struct<br/>在 C++ 中，class 与 struct 的唯一区别在于：class 的成员默认使用 private 修饰，而 struct 中默认使用 public。换句话说，下面的这个定义：<br/>1<br/>2<br/>3<br/>4class A {<br/> public:<br/>    // ...<br/>};<br/><br/><br/>与 struct A {}; 是等价的。在 OI 中，没有必要关心成员应该被声明为 public 还是 private，所以大家普遍使用 struct。出于这个原因，下文中将不会再提及 class。<br/>构造函数是 struct 一个很方便的特性，一般被用于给算法或数据结构提供参数，或者用于初始化。但是请注意，构造函数不是普通的函数。构造函数的调用意味着一个新的实例的创建，因此一般不会递归的调用构造函数。例如，下面这份代码：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10struct Aha {<br/>    int arr[1000000];<br/><br/>    Aha(int n) {<br/>        if (!n)<br/>            return;<br/>        printf(\ % d\\n\ , arr[0]);  // 防止编译器优化<br/>        Aha(n - 1);<br/>    }<br/>};<br/><br/><br/>如果执行 new Aha(1000)，将意味着会有 $1000$ 个 Aha 会被创建，意味着 $10^6 \\times 10^3 = 10^9$ 个 int 被创建，意味着你会获得 Memory Limit Exceeded 或者 Runtime Error。意思是，每一次 Aha 构造函数的递归，都是在一个新的 Aha 上进行的，而不是在同一个上。所以，像线段树这种普遍使用递归来构造的数据结构，一般会新定义一个函数来构建。<br/>此外，构造函数在 OI 中更普遍的应用是简单数据的声明，如 Point、Vector 和 Line 之类的东西。例如在需要计算几何的代码中，通常会有：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7struct Point {<br/>    Point() : x(0), y(0) {}  // 默认构造函数<br/>    Point(double _x, double _y) : x(_x), y(_y) {}<br/>    Point(const Point &p) : x(p.x), y(p.y) {}  // 复制构造函数<br/><br/>    double x, y;<br/>};<br/><br/><br/>那么，使用 Point() 将会得到一个位于原点的点，而使用 Point(2, 3) 将会得到一个坐标在 $(2,\\;3)$ 的点。<br/>OIer 普遍不会关心内存回收的问题，除非是确实不回收会导致超内存。所以大家的代码中都鲜有析构函数的出现。一般析构函数的作用就是删除一些用 new 或者 malloc 申请出的空间，一个典型的例子就是线段树和平衡树的删除：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16struct Node {<br/>    Node(int l, int r)  // 构造函数<br/>        : left(l), right(r), lch(NULL), rch(NULL) {<br/>        dat = new int;<br/>    }<br/><br/>    ~Node() {<br/>        delete dat;<br/>        delete lch;<br/>        delete rch;<br/>    }<br/><br/>    int left, right;<br/>    int *dat;<br/>    Node *lch, *rch;<br/>};<br/><br/><br/>假设 root 是树根，那么 delete root 将会回收整个线段树，因为 delete lch 和 delete rch 意味着左儿子和右儿子的析构函数也会被递归的调用。也许你会问当 lch 或 rch 为 NULL 的时候会怎么样，其实什么事都不会发生，因为如果 delete 一个空指针（0、NULL 或者 C++11 中的 nullptr），这个操作将会被无视。<br/>另外一个常用的特性就是运算符重载。基本上你能想到的运算符都是可以重载的，这些都可以在 cppreference (http://en.cppreference.com/w/cpp/language/operators) 上看到。接下来只介绍几个常用的重载。<br/>重载比较关系符，大于小于等于之类的，如果重载了小于就可以直接用 std::sort 排序而不用写 cmp：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29#include <cmath>  // For hypot<br/><br/>#define EPS 1e-8<br/><br/>inline bool equ(double a, double b) {<br/>    return a - EPS < b && b < a + EPS;<br/>}<br/><br/>struct Point {<br/>    double x, y;<br/><br/>    // 计算模长<br/>    double len() const {<br/>        return hypot(x, y);<br/>    }<br/><br/>    bool operator<(const Point &b) const {<br/>        return len() < b.len();  // 按模长长短排序。<br/>    }<br/><br/>    // 相等和不等<br/>    bool operator==(const Point &b) const {<br/>        return equ(x, b.x) && equ(y, b.y);<br/>    }<br/><br/>    bool operator!=(const Point &b) const {<br/>        return !(*this == b);<br/>    }<br/>};<br/><br/><br/>通常，运算符重载还可以用友元函数来写。上面的例子用友元函数来写就是这样的：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13struct Point {<br/>    double x, y;<br/><br/>    double len() const {<br/>        return hypot(x, y);<br/>    }<br/><br/>    friend bool operator<(const Point &a, const Point &b);<br/>};<br/><br/>bool operator<(const Point &a, const Point &b) {<br/>    return a.len() < b.len();<br/>}<br/><br/><br/>这就类似于写 cmp 这种东西了。<br/>像向量这种东西，我们经常会需要重载加减、数乘、叉积和点积运算，这时候就可以使用运算符重载。具体的写法你们可以自己脑补。我一般把数乘和点积重载为 * 号，把叉积重载为 %  号。<br/>此外，函数调用也可以重载（就是函数调用后的那一对括号......）。这通常用于提供给 std::map 和 std::priority_queue 之类的 cmp：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8struct cmp {<br/>    bool operator()(int a, int b) const {<br/>        return a > b;<br/>    }<br/>};<br/><br/>static priority_queue<int, vector<int>, cmp> q;  // 转变为小根堆<br/>static cmp func;  // 可以直接把 func 当函数用。<br/><br/><br/>运算符优先级<br/>C++ 中书写表达式的时候不可避免的就是运算符优先级的考虑，尤其是含有位运算的表达式中。了解 C++ 中的运算符优先级有利于我们在考场上节约时间和精力。一般情况下只要知道以下几个相对顺序就可以了：<br/><br/>乘法、除法、取模 (*, /, % )<br/>加法、减法 (+, -)<br/>按位左移、右移 (<<, >>)<br/>大于、小于、不大于、不小于 (>, <, <=, >=)<br/>相等、不相等 (==, !=)<br/>按位与 (&)<br/>按位异或 (^)<br/>按位或 (|)<br/>逻辑与 (&&)<br/>逻辑或 (||)<br/><br/>比较容易写错的是有按位左移、右移的，要注意加法减法的优先级比按位左移右移高，因此 1 << 3 + 7 的结果不是 $2^3 + 7$，而是 $2^{10}$。此外由于比较运算符的优先级没有按位左移、右移高，所以如果比较符两边的按位平移要用括号包起来。另外，与的优先级高于或的优先级。如果考试时忘记了，那你最好还是多写几个括号以免出错。<br/>详细的运算符优先级也可以在 cppreference  (http://en.cppreference.com/w/cpp/language/operator_precedence) 上看到。<br/>模板<br/>这里将介绍一些简单的模板（template）的使用。一般是用于一些简单的函数，如 max：<br/>1<br/>2<br/>3<br/>4template <typename T><br/>inline T max(const T &a, const T &b) {<br/>    return b < a ? a : b;<br/>}<br/><br/><br/>我们可以直接使用 max(1, 2)，它将返回 2。实际上是编译器发现你填入的参数 a 和 b 都是 int，所以编译器可以推断出 template 中的声明 T 应该是 int。于是编译器将上面的 max 函数补全，然后产生了下面的代码：<br/>1<br/>2<br/>3inline int max(const int &a, const int &b) {<br/>    return b < a ? a : b;<br/>}<br/><br/><br/>这是模板的本质。实际上，编译器可能有时候无法推断类型是什么，就比如下面这段快读的代码：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17template <typename T><br/>inline T read() {<br/>    T x = 0, f = 1;<br/>    char c;<br/>    do {<br/>        c = getchar();<br/>        if (c == '-')<br/>            f = -1;<br/>    } while (!isdigit(c));<br/><br/>    do {<br/>        x = x * 10 + c - '0';<br/>        c = getchar();<br/>    } while (isdigit(c));<br/><br/>    return f * x;<br/>}<br/><br/><br/>此时，如果你想读入一个 int，就需要调用 read<int>()，通过尖括号内的内容告诉编译器 T 应该是什么东西。当然，一般的快读不会这么写，因为在性能要求很高的情况下返回值可能会增大常数，所以一般都是引用参数：<br/>1<br/>2<br/>3<br/>4<br/>5template <typename T><br/>inline void read(T &x) {<br/>    x = 0;<br/>    // 下面基本一致<br/>}<br/><br/><br/>这样就不用填模板参数了，直接像 read(n) 一样使用就好。<br/>模板当然可以多放几个待定的类型，例如，我一般写的判断两个浮点数是否相同的代码是这样的：<br/>1<br/>2<br/>3<br/>4template <typename T1, typename T2><br/>inline bool equ(const T1 a, const T2 b) {<br/>    return fabs(a - b) < EPS;<br/>}<br/><br/><br/>如果 a 和 b 只声明一个 T，那么当调用 equ(1.0f, 1.0) 会出现编译错误，因为 a 是 float 而 b 是 double，T 不能同时是两个类型。<br/>你可以为特定的类型写特化的函数。还是拿之前快读做例子，读入整型应该是那么读，但读入字符串就要换一种方式，因此我们需要这么写：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18template <><br/>// read<char> 可以简写为 read，因为 T = char 可以从参数中推出<br/>inline void read<char>(char &ch) {<br/>    do {<br/>        ch = getchar();<br/>    } while (!isalpha(ch));<br/><br/>    char *str = &ch;<br/>    size_t pos = 1;<br/>    do {<br/>        str[pos++] = getchar();<br/>    } while (isalpha(str[pos - 1]));<br/>    str[pos - 1] = 0;<br/>}<br/><br/>// 输入 \ owengetmad\ <br/>char buf[233];<br/>read(buf[0]);  // buf = \ owengetmad\ <br/><br/><br/>上面是将 T 指定为 char 时的特化，说白了就是将 T 替换掉再写一遍。之所以不特化为 char []，是因为之前读取整数的模板使用的是引用参数，而数组类型不能为引用，所以只能折中一下使用 char，对 ch 取个地址就可得到字符数组的地址。<br/>class 和 struct 也可以使用模板，虽然这在 OI 中不常用。我所在 OI 见到的也就类似于下面这种情况：<br/>1<br/>2<br/>3<br/>4template <typename T><br/>struct Point {<br/>    T x, y;<br/>};<br/><br/><br/>如果需要特化，会写成这样：<br/>1<br/>2<br/>3<br/>4template <><br/>struct Point<int> {<br/>    int x, y;<br/>};<br/><br/><br/>* 剩下一个常用的就是变长模板参数，OI 中一般用于输出调试信息：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6template <typename ... Args><br/>void DEBUG(const char *str, const Args & ... args) {<br/>    printf(\ (debug) \ );<br/>    printf(str, args...);<br/>    putchar('\\n');<br/>}<br/><br/><br/>使用 DEBUG(\ BOY♂% s♂DOOR % d\ , \ NEXT\ , 123) 会输出 “(debug) BOY♂NEXT♂DOOR 123”。<br/>宏定义<br/>宏定义的本质是文本替换，通常用于节约代码量。当需要重复打很多形式差不多的代码的时候，宏是一个非常有用的工具。例如 “【NOIP2015】斗地主 “加强” 版 ” 的 “爆搜 + DP” 做法，其 DP 转移几乎长得一模一样，但是数量很多，因此这里使用宏定义可以大大节约时间。<br/>for 通常会被众多 OIer 弄成宏函数：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6#define rep(i, l, r) for (int i = l; i <= (r); i++)<br/>#define rrep(i, r, l) for (int i = r; i >= (l); i--)<br/><br/>rep(i, 1, n) rep(j, 1, m) {<br/>    // ...<br/>}<br/><br/><br/>这样就不用写 for 中那重复而又枯燥无味的部分了。在维数比较多的 DP 中，写出来的代码会简洁许多。一些人也喜欢用 per 来表示倒序遍历。<br/>* 对于 STL 容器的遍历 (vector, map 之类)，可以使用这样的语法：<br/>1<br/>2<br/>3<br/>4vector<int> vec;<br/>for (auto &v : vec) {<br/>    // Do something with v<br/>}<br/><br/><br/>宏开关经常用来打开 / 关闭调试信息，如定义 NDBEUG 宏：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7// #define NDEBUG<br/><br/>#ifdef NDEBUG  // 如果 NDEBUG 打开 (取消第一行的注释)<br/>#define DEBUG(...)  // 空的调试信息输出函数<br/>#else<br/>#define DEBUG(msg, ...) printf(\ (% s #% d) \  msg, __FUNCTION__, __LINE__, __VA_ARGS__);  // 否则启用调试<br/>#endif<br/><br/><br/>上面的 “...” 跟之前模板中的变长参数类似，使用 __VA_ARGS__ 这个特殊的宏可以将 “...” 所指代的参数放入。__FUNCTION__ 和 __LINE__ 是另外两个特殊的宏，它们可以记录下 DEBUG 宏函数被调用的地方所处的函数名称和行号。也可以使用 __PRETTY_FUNCTION__，它会记录下所处的函数的详细声明，可以用于区分重载的函数 。另外，assert 的打开和关闭也是受 NDEBUG 影响。assert 意思是断言，即做一个假设，如果假设不成立则终止程序 （调用 abort），它包含在 cassert 头文件中。一般的用法如下：<br/>1<br/>2<br/>3<br/>4<br/>5#include <cassert><br/><br/>int a = 1 + 1;<br/>assert(a == 2);  // 想必 a = 2<br/>assert(a == 3);  // a 显然不等于 3，所以这里会导致程序终止<br/><br/><br/>善用 assert 是一个良好的习惯。在比较复杂的数据结构中，一些地方可以添加几个断言，比如在访问一个指针前 assert 一下看指针是否为空。从而在调试的时候，如果出现异常，可以很快的发现错误的位置。最后提交文件的时候在开头声明一下 NDEBUG，就可以关掉所有的调试信息和断言。<br/>作为一个简单的文本替换，宏的弊端在于容易使人犯错。首先就是运算符优先级的问题。一个典型的例子就是开一个大小为 $2n$ 的数组。OI 中由于不是很关心浪费的一点点空间，所以有人可能会写出这样的代码：<br/>1<br/>2#define NMAX 100000 + 5<br/>int arr[NMAX * 2];  // arr 的大小为 100010 而不是所期望的 200010<br/><br/><br/>这种错误是会让人非常苦恼的，因为你的程序小数据不会有事，而大数据会不停的 Runtime Error，可你却一直看不出有什么问题。还有就是之前的 rep 的定义中，我写的是 i <= (r) 而不是 i <= r，原因非常简单，如果你要使用 rep(i, 1, a ^ b) 后者可能会导致你无尽的循环（因为是 i <= a ^ b，小于等于的优先级高于异或，所以它的值是 (i <= a) ^ b ）。这种例子相当之多，这里就不再列举。因此，但凡使用宏，就一定要注意多打几个括号。<br/>另外一个经典的错误，来自于一个简单的 max 宏函数：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14#define max(a, b) ((a) > (b) ? a : b)<br/><br/>int query(Node *x, int l, int r) {<br/>    if (l <= x->left && x->right <= r)<br/>        return x->value;<br/><br/>    int mid = (x->left + x->right) >> 1, ans = INT_MIN;<br/>    if (l <= mid)<br/>        ans = max(ans, query(x->lch, l, r));<br/>    if (r > mid)<br/>        ans = max(ans, query(x->rch, l, r));<br/><br/>    return ans;<br/>}<br/><br/><br/>乍一看好像没什么问题，但实际上你的线段树早已背叛了你，它将给予你无尽的 Time Limit Exceeded。原因在于，上述代码中两个取 max 的地方，如果儿子给出的答案更大，那么那个 query 将会被调用第二次，导致线段树时间复杂度的退化。因此在这里我还是推荐使用内联函数而不是宏来实现这些简单的函数。<br/>常用函数和 STL<br/>虽然像 max、min 之类的函数在 algorithm 头文件已有定义，但是一些特别的情况下可以使用更简单的函数来减小常数。例如用于更新最值：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9template <typename T><br/>inline void chkmax(T &a, const T &b) {<br/>    if (b > a) a = b;<br/>}<br/><br/>template <typename T><br/>inline void chkmin(T &a, const T &b) {<br/>    if (b < a) a = b;<br/>}<br/><br/><br/>相比于 a = max(a, b) 而言，可以减少不必要的赋值，从而减小了常数。另外一个同类型的就是取模加法：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7template <typename T><br/>inline void add(T &a, const T &b) {<br/>    a += b;<br/><br/>    if (a >= MOD) a -= MOD;<br/>    if (a < 0) a += MOD;<br/>}<br/><br/><br/>因为只是加减法，所以使用 (a + b) %  MOD 实际上会浪费一次取模操作。顺带一提，一般的计算机上加减乘的速度差不多，取模和除法速度与它们相比慢很多，所以经常会尝试减少除法和取模的次数来减小常数。在浮点数中，减法和除法造成的精度误差比较大。<br/>algorithm 头文件中有很多 OI 常用的函数，下面将列举我经常用的几个。<br/>使用 reverse 可以将数组翻转：<br/>1<br/>2int a[] = {1, 2, 3, 4, 5};<br/>reverse(a, a + 5);  // a = {5 4, 3, 2, 1}<br/><br/><br/>众所周知 sort 主要使用的是快速排序算法，同时也有一个 stable_sort，使用的是归并排序。绝大部分情况下大家都会使用 sort，少数交互题可能会卡快速排序的比较次数，这时才会使用 stable_sort 来避免。<br/>unique 的作用是将多个连续相同的元素变为一个，通常和 sort 一起使用来去重：<br/>1<br/>2<br/>3<br/>4int a[] = {1, 3, 2, 1, 2, 1, 4};<br/>sort(a, a + 7);<br/>int cnt = unique(a, a + 7) - a;<br/>// a = {1, 2, 3, 4, ...}, cnt = 4<br/><br/><br/>lower_bound 和 upper_bound 则是常用的二分函数。它们只能用于有序的序列上。lower_bound 会帮你找出某个元素第一次出现的位置，而 upper_bound 会帮你找出某个元素最后一次出现的位置的下一个位置，如：<br/>1<br/>2<br/>3<br/>4<br/>5int a[] = {1, 2, 2, 2, 2, 3, 7};<br/>//            ^           ^<br/>//            lower       upper<br/>lower = lower_bound(a, a + 7, 2);<br/>upper = upper_bound(a, a + 7, 2);<br/><br/><br/>inplace_merge 是用于合并两个有序序列的，用于实现归并排序。在一些情况下可能会用到。<br/>1<br/>2int a[] = {1, 3, 5, 2, 4, 6};<br/>inplace_merge(a, a + 3, a + 6);  // a = {1, 2, 3, 4, 5, 6}<br/><br/><br/>STL 中的容器也常常被使用，用于减少代码量。一般常用的有这么一些：<br/><br/>vector 动态数组，这个其实看个人喜好，它可以支持下标访问，并且可以快速在末尾增加、删除元素。<br/>deque 双端队列，可以下标访问，但常数比数组略高，可以在两头快速插入、删除。<br/>queue 队列，接口比较简单，用 front 查看队首，pop 弹出队首，push 加入队尾。<br/>stack 栈，类似于 queue，只不过是用 top 查看栈顶。<br/>set 和 map，这是 STL 良心为大家提供的红黑树，可以快速查找和使用与 algorithm 中类似的 lower_bound 以及 upper_bound。<br/>priority_queue 优先队列，也就是大根堆，接口和 stack 差不多。<br/>bitset 卡常神器，用于存储二进制序列，可以进行位运算，时空复杂度基本都是 $O(n / w)$。<br/>string 字符串，其实就是 vector<char>，一般不怎么用。<br/>* unordered_set 和 unordered_map，功能与 set 和 map 对应，但是是哈希表实现的，复杂度更优秀，但不支持二分查找。可以在头文件 tr1/unordered_set 和 tr1/unordered_map 中找到。<br/><br/>这些东西主要还是推荐大家自己去 cppreference 上去查然后试着用一下，相信你们的英文水平足够了。<br/>第二部分：Linux 下编程环境<br/>编辑器<br/>写程序第一步是什么？当然是写代码。在写代码之前，你需要确定你在将来在考场上要使用什么编辑器。NOI Linux 目前提供的编辑器有这些：<br/><br/>gedit<br/>VIM<br/>Emacs<br/>GUIDE、Anjuta、Lazarus 之流<br/><br/>在这里我也不做什么推荐，大家找自己喜欢的就好。我只知道正式考场上普通玩家都是使用与 “UOJ 自定义测试” 差不多的 gedit，中高端玩家普遍选择 Emacs 或 VIM。<br/>编译器<br/>NOI Linux 下只提供了 g++ 来给我们编译程序。如果你的源代码叫做 a.cpp，那么使用：<br/>1g++ a.cpp<br/><br/><br/>将会在当前目录下产生一个 a.out 的可执行文件，使用 ./a.out 就可以运行它。如果你觉得 a.out 这个名字太 naïve，可以使用：<br/>1g++ a.cpp -o exec<br/><br/><br/>将会得到 exec 这个可执行文件。对于交互式的题目，一般会提供一个叫做 grader.cpp 的文件，此时你按照要求写好程序后，应该这样编译：<br/>1g++ grader.cpp a.cpp<br/><br/><br/>如果需要打开优化，可以使用：<br/>1g++ a.cpp -O2  // 或者 -O3<br/><br/><br/>一套题目的第一页通常会有注明表示某些题目是否开优化。这是比较重要的信息，通常会决定你是否需要花时间来卡常数。<br/>一般为了充分发挥编译器的作用，我会打开编译器的绝大部分警告：<br/>1g++ a.cpp -Wall -Wextra<br/><br/><br/>打开之后，一些常见的却不是语法错误的小问题都会被编译器报告。如 if (a = b) 这种相等符号少写一个等号的错误，编译器都会提示你。<br/>调试器<br/>gdb 是最常用于调试程序的工具。尽管多数情况下输出调试可以解决问题，但是 gdb 可以帮你在某些情况下节约时间。gdb 的主要优势在于可以灵活的跟踪程序运行的状况，方便我们找出 BUG 的根源。<br/>如果一个程序想要使用 gdb 调试，那么在编译的时候需要加上 -g 选项：<br/>1g++ a.cpp -g<br/><br/><br/>然后执行 gdb a.out 即可进入调试。一般你会看到下面这些东西：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1<br/>Copyright (C) 2016 Free Software Foundation, Inc.<br/>License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html><br/>This is free software: you are free to change and redistribute it.<br/>There is NO WARRANTY, to the extent permitted by law.  Type \ show copying\ <br/>and \ show warranty\  for details.<br/>This GDB was configured as \ x86_64-linux-gnu\ .<br/>Type \ show configuration\  for configuration details.<br/>For bug reporting instructions, please see:<br/><http://www.gnu.org/software/gdb/bugs/>.<br/>Find the GDB manual and other documentation resources online at:<br/><http://www.gnu.org/software/gdb/documentation/>.<br/>For help, type \ help\ .<br/>Type \ apropos word\  to search for commands related to \ word\ ...<br/>Reading symbols from a.out...done.<br/>(gdb)<br/><br/><br/>其实只有最后一句 “Reading symbols from a.out...done.” 有用，它告诉我们 a.out 被成功读取。如果你不想看到上面一大堆话，那么在命令末尾加个 -q 即可。<br/>现在来举个例子。就以下面的程序开刀，来体会一下使用 gdb 的基本流程：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17#include <cstdio><br/><br/>int fac(int n) {<br/>    return fac(n - 1) * n;<br/>}<br/><br/>int main() {<br/>    int n;<br/>    scanf(\ % d\ , &n);<br/>    n = fac(n);<br/><br/>    for (unsigned i = n; i >= 0; i--) {<br/>        puts(\ Aha!\ );<br/>    }<br/><br/>    return 0;<br/>}<br/><br/><br/>编译后进入 gdb，输入 l 并回车，可以看到程序的前面几行：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11(gdb) l<br/>1   #include <cstdio><br/>2<br/>3   int fac(int n) {<br/>4       return fac(n - 1) * n;<br/>5   }<br/>6<br/>7   int main() {<br/>8       int n;<br/>9       scanf(\ % d\ , &n);<br/>10      n = fac(n);<br/><br/><br/>这时按下回车，可以看到紧接着的后面几行：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8(gdb)<br/>11<br/>12      for (unsigned i = n; i >= 0; i--) {<br/>13          puts(\ Aha!\ );<br/>14      }<br/>15<br/>16      return 0;<br/>17  }<br/><br/><br/>这不是因为回车就是看代码的功能，而是在 gdb 中什么也不输入就直接回车表示执行上一个你使用的命令。所以这里实际上是又执行了一遍 l 命令。你也可以使用上下方向键来翻阅你之前使用的命令。使用 l [行号] 将会把你所指定的行号附近的代码展示给你。而 l [函数名] 则会把对应函数展示。<br/>当然我们不是拿 gdb 来看代码的......如果你现在使用 r 命令，gdb 将会正常启动这个程序。你会发现这在和 gdb 外面运行程序没什么区别，输入了一个数字之后程序就会段错误。这是因为我们还没有设置断点，gdb 不会无缘无故使程序暂停。<br/>使用 b [函数名 / 行号] 可以在特定的函数入口或者某一行设置断点，当程序运行到这里的时候，就会暂停下来：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7(gdb) b main<br/>Breakpoint 1 at 0x40058c: file a.cpp, line 7.<br/>(gdb) r<br/>Starting program: /home/owen/aknoi/a.out<br/><br/>Breakpoint 1, main () at a.cpp:7<br/>7   int main() {<br/><br/><br/>使用 n 可以执行当前这一行代码：<br/>1<br/>2(gdb) n<br/>9       scanf(\ % d\ , &n);<br/><br/><br/>这里再回车一下就会执行 scanf 了，也就会要你输入一个数字了：<br/>1<br/>2<br/>3(gdb) n<br/>1<br/>10      n = fac(n);<br/><br/><br/>注意，到了第 $10$ 如果继续使用 n，将不会进入 fac 函数。如果想进入 fac 函数一探究竟，就需要使用 s：<br/>1<br/>2<br/>3(gdb) s<br/>fac (n=1) at a.cpp:4<br/>4       return fac(n - 1) * n;<br/><br/><br/>使用 p 可以计算一些表达式，如：<br/>1<br/>2(gdb) p n * 123<br/>$1 = 123<br/><br/><br/>p 是 gdb 的方便所在，它可以查看程序中的变量从而知道程序当前的状况。当然，总是手动使用 p 非常麻烦，我们可以使用 disp 来将某个表达式挂在旁边随时查看：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6(gdb) disp n<br/>1: n = 1<br/>(gdb) s<br/>fac (n=0) at a.cpp:4<br/>4       return fac(n - 1) * n;<br/>1: n = 0<br/><br/><br/>没错，你会发现 n 的值会在每一步指令结束后展示给你。注意到左边的那个标号 1，你可以使用 undisp 1 来取消这个显示。<br/>当然你不会一直使用 n 和 s 让程序跑下去，有时候是希望让程序先自由的跑一跑。这里我们先给第 $4$ 行加个断点，并使用 c 命令继续运行程序：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7(gdb) b 4<br/>Breakpoint 2 at 0x400571: file a.cpp, line 4.<br/>(gdb) c<br/>Continuing.<br/><br/>Breakpoint 2, fac (n=-1) at a.cpp:4<br/>4       return fac(n - 1) * n;<br/><br/><br/>由于在继续执行的过程中遇上了断点 $2$，所以程序又一次暂停。现在可以来看看函数的调用栈了：<br/>1<br/>2<br/>3<br/>4<br/>5(gdb) bt<br/>#0  fac (n=-1) at a.cpp:4<br/>#1  0x000000000040057e in fac (n=0) at a.cpp:4<br/>#2  0x000000000040057e in fac (n=1) at a.cpp:4<br/>#3  0x00000000004005bb in main () at a.cpp:10<br/><br/><br/>可以看到 fac 调用了三层。我们可以使用 d 命令来删除一个断点，并且尝试继续执行：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7(gdb) d 2<br/>(gdb) c<br/>Continuing.<br/><br/>Program received signal SIGSEGV, Segmentation fault.<br/>0x000000000040056e in fac (n=<error reading variable: Cannot access memory at address 0x7fffff7feffc>) at a.cpp:3<br/>3   int fac(int n) {<br/><br/><br/>没有了断点的阻挠，我们的程序直接段错误。输入 bt 就可以看到 fac 递归了相当多层，导致超出栈空间。找到了错误原因，就可使用 q 命令退出 gdb 了：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6(gdb) q<br/>A debugging session is active.<br/><br/>    Inferior 1 [process 23333] will be killed.<br/><br/>Quit anyway? (y or n) y<br/><br/><br/>由于 fac 函数缺少边界条件导致爆栈，所以修改之后的程序是这样的：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19#include <cstdio><br/><br/>int fac(int n) {<br/>    if (n == 0)<br/>        return 1;<br/>    return fac(n - 1) * n;<br/>}<br/><br/>int main() {<br/>    int n;<br/>    scanf(\ % d\ , &n);<br/>    n = fac(n);<br/><br/>    for (unsigned i = n; i >= 0; i--) {<br/>        puts(\ Aha!\ );<br/>    }<br/><br/>    return 0;<br/>}<br/><br/><br/>现在编译并运行程序将会无限输出 “Aha!”。再次使用 gdb 来调试，这次直接开始运行程序，并且在一堆 “Aha!” 面前沉着地按下 “Ctrl + C”：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10Aha!<br/>Aha!<br/>Aha!<br/>Aha!<br/>Aha!<br/>^C<br/>Program received signal SIGINT, Interrupt.<br/>0x00007ffff7856290 in __write_nocancel () at ../sysdeps/unix/syscall-template.S:84<br/>84  ../sysdeps/unix/syscall-template.S: No such file or directory.<br/>(gdb)<br/><br/><br/>然后这个程序就暂停了。gdb 告诉你现在在一个奇怪的文件里面，其实是因为在执行 puts 时暂停了。现在我们想回到 a.cpp 函数的第 $15$ 行，因此可以设一个断点：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10(gdb) b a.cpp:15<br/>Breakpoint 2 at 0x4005d1: file a.cpp, line 15.<br/>(gdb) c<br/>Continuing.<br/><br/><br/>Breakpoint 2, main () at a.cpp:15<br/>15          puts(\ Aha!\ );<br/>(gdb) p i<br/>$1 = 4294925190<br/><br/><br/>打印出 i 的值，发现变得非常大。这是因为 i 是无符号整型，当 i = 0 时再减一，就会变成 UINT_MAX，因而导致死循环。至此，这个程序的异常就全部查清了。以上也差不多就是 OI 中常用的命令，如果想要 gdb 为你发挥更大的作用，就需要平常多练习使用，然后才能在正式考场上熟练运用这些工具。<br/>性能剖析工具<br/>NOI Linux 上唯一提供的性能剖析工具就是 gprof 了。它的主要目的就是生成一份程序的运行报告，主要包括程序中每个函数的相关数据。使用方法并不复杂，大致流程如下：<br/>首先，编译程序的时候带上 -pg 选项：<br/>1g++ a.cpp -pg<br/><br/><br/>然后运行一下这个程序，OI 中通常会拿个大数据来跑一下。注意，带上这个选项后程序运行速度可能变慢了很多，这是因为此时程序运行中会收集一些信息，变慢是正常的。程序运行完毕后，使用 gprof 生成报告：<br/>1gprof a.out > result.out<br/><br/><br/>result.out 就是报告了，使用任意编辑器可以打开。下面放一个我最近写的程序生成的报告的前几行：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17Flat profile:<br/><br/>Each sample counts as 0.01 seconds.<br/>  %    cumulative   self              self     total<br/> time   seconds   seconds    calls  ms/call  ms/call  name<br/> 17.29      0.52     0.52 99401724     0.00     0.00  pushdown(int)<br/> 10.97      0.85     0.33 25936095     0.00     0.00  rotate(int, int)<br/>  6.32      1.36     0.19  6808190     0.00     0.00  upans(int, int)<br/>  6.15      1.54     0.19 38677554     0.00     0.00  update(int)<br/>  5.32      1.70     0.16 36189660     0.00     0.00  clear(int)<br/>  5.15      1.86     0.16 40849140     0.00     0.00  splay(int)<br/>  4.99      2.16     0.15       43     3.49    60.87  dfs(int, int)<br/>  4.82      2.30     0.15 13616380     0.00     0.00  query(int, long long)<br/>  4.82      2.45     0.15 83375581     0.00     0.00  rminb(int)<br/>  3.66      2.56     0.11                             main<br/>  2.66      2.64     0.08 83375581     0.00     0.00  rmina(int)<br/>  2.33      2.71     0.07        1    70.06   130.11  initialize()<br/><br/><br/>上面可以看到每个被调查到的函数所占用的时间百分比，秒数和调用次数。排名越靠前的表明占用时间越多。从上面可以看出，pushdown 和 rotate 占用了绝大部分时间，因此如果想卡常数，首先应考虑它们，这样效果才最明显。有时候这份报告里面可能会出现一些名字很长很奇怪的函数，不要觉得是出了问题，因为它们可能是 STL 里面的函数，所以名字才会很奇怪。<br/>gprof 一般是用在你考试时间比较充裕的情况下，给大数据结构和一些数论筛题来分析程序性能瓶颈用的。如果你想卡常数了，可以利用这份报告做一个参考。<br/>后记<br/>至此，这篇废话连篇的简单的指南就结束了~~~<br/>（我自己也没想到写了这么长......）<br/>最后祝大家 OI 顺利，最后都实现自己心中的理想！<br/>23-24 Sept 2017, by riteme","tags": "胡言乱语","url": "blog/2017-10-28/oi-coding-guidelines.html"},
{"title": "POJ2135 Farm Tour","text": "[POJ2135] Farm Tour<br/>原题题意<br/>FJ老爷爷带着他的朋友到他的开心农场装B。FJ的农场是一张有$n(n\\le1000)$个点，$m(m\\le10000)$条边的无向图，每个点从$1$开始编号，每条边有一个边权。现在他想从$1$走到$n$，然后又从$n$走到$1$，他希望走的路最短且每条路不走两遍。<br/>做法<br/>看到要使走的路最短，就肯定要动用最短路了。然而他还需要两条，且这两条路径的每一条边都不同，用单纯的最短路难以办到。<br/>不妨运用最大流的思想，将每条边拆成两个有向管道，且容量为1。那么，在增广时，只要是走过的边就会没有流量了，保证只有一条路径经过。<br/>将最短路和最大流结合起来，就是最小费用最大流，这里我们将流网络的每条弧增加一个属性cost表示费用（注意不是单位费用），对应的就是原图中的边权。每次增广时选取费用最小的来进行增广，就能确保找到的增广路是原图中的最短路。<br/>最后一个问题就是要找两条，这个其实很好办。我们利用源点和汇点来控制。首先建立一个源点，与$1$相连，容量为2,当然费用为0，这样不会最短路的结果。同样的方法，将汇点与$n$连接。这样，每次只能增广1的流，就能确保最多只有2条增广路。<br/>需注意的是，在残留网络中，方向边的边权要为-cost，这样才能让增广正常进行。因此，Dijkstra算法并不适合。","tags": "POJ 网络流 最小费用流 图论 题解","url": "blog/2016-2-1/farm-tour.html"},
{"title": "RSRL开发记录（一）","text": "RSRL开发记录（一）<br/>深觉自己姿势水平还是太低，许多东西并没有学到家就准备搞东西，ne2d就是一个典型的例子吧。虽然以后可能还会继续，但是现在先写个软渲染器来熟悉一些基础知识。<br/>项目开在了GitHub和Git@OSC上，欢迎围观：<br/>GitHub: https://github.com/riteme/RSRL<br/>Git@OSC: https://git.oschina.net/riteme/RSRL<br/>所谓乎开发记录，就是记录一点有点价值的东西，各位随意看看。<br/>颜色运算<br/>Color.h & Color.cpp<br/>常见的屏幕颜色有四个分量：红($\\mathrm{R}$)、绿($\\mathrm{G}$)、蓝($\\mathrm{B}$)和透明度($\\mathrm{A}$)。通常这四个分量用uint8_t来记录，范围就是$0$至$255$。在计算机图形学中为了方便插值，通常都是用浮点数来存储的，范围为$0.0$至$1.0$。<br/>计算一个颜色的反色可以用以下公式：<br/>$$<br/>\\mathrm{R}^\\prime = 1 - \\mathrm{R} \\\\<br/>\\mathrm{G}^\\prime = 1 - \\mathrm{G} \\\\<br/>\\mathrm{B}^\\prime = 1 - \\mathrm{B}<br/>$$<br/>这里我们不考虑透明度。<br/>另一个比较重要的就是Alpha混合，就是将两个颜色按照透明度混合，通常是这样计算的：<br/>$$<br/>\\mathrm{R}^\\prime = \\mathrm{R}_1 \\cdot \\mathrm{A}_1 + \\mathrm{R}_2 \\cdot \\mathrm{A}_2 \\cdot (1 - \\mathrm{A}_1) \\\\<br/>\\mathrm{G}^\\prime = \\mathrm{G}_1 \\cdot \\mathrm{A}_1 + \\mathrm{G}_2 \\cdot \\mathrm{A}_2 \\cdot (1 - \\mathrm{A}_1) \\\\<br/>\\mathrm{B}^\\prime = \\mathrm{B}_1 \\cdot \\mathrm{A}_1 + \\mathrm{B}_2 \\cdot \\mathrm{A}_2 \\cdot (1 - \\mathrm{A}_1) \\\\<br/>\\mathrm{A}^\\prime = 1 - (1 - \\mathrm{A}_1) \\cdot (1 - \\mathrm{A}_2)<br/>$$<br/>其中$\\{\\mathrm{R}_1,\\;\\mathrm{G}_1,\\;\\mathrm{B}_1,\\;\\mathrm{A}_1\\}$是前景色，$\\{\\mathrm{R}_1,\\;\\mathrm{G}_1,\\;\\mathrm{B}_1,\\;\\mathrm{A}_1\\}$是后景色。<br/>同时，这个公式可以实现颜色的叠加顺序不同，最终的结果也会有所不同。<br/>向量与矩阵<br/>Math.h & Math.cpp<br/>这里不在介绍什么是向量和矩阵了，这里至介绍一下为什么要使用矩阵。<br/>首先我们的可能需要缩放一个向量，这可以使用矩阵来表示：<br/>$$<br/>\\left[<br/>\\begin{matrix}<br/>S_X & 0 & 0 \\\\<br/>0 & S_Y & 0 \\\\<br/>0 & 0 & S_Z<br/>\\end{matrix}<br/>\\right]<br/>\\cdot<br/>\\left(<br/>\\begin{matrix}<br/>X \\\\<br/>Y \\\\<br/>Z<br/>\\end{matrix}<br/>\\right)<br/>$$<br/>如果是旋转，那么这样也可以（下面示例的是绕Z轴旋转）：<br/>$$<br/>\\left[<br/>\\begin{matrix}<br/>\\cos\\alpha & -\\sin\\alpha & 0 \\\\<br/>\\sin\\alpha & \\cos\\alpha & 0 \\\\<br/>0 & 0 & 1<br/>\\end{matrix}<br/>\\right]<br/>\\cdot<br/>\\left(<br/>\\begin{matrix}<br/>X \\\\<br/>Y \\\\<br/>Z<br/>\\end{matrix}<br/>\\right)<br/>$$<br/>对于绕X轴和绕Y轴的旋转可以类似的构造。<br/>很多其它的线性变换都可以用矩阵来表示。当我们想进行多个变换的时候，我们可以使用矩阵乘法来变为一个矩阵，这样就加速了复杂的变换。<br/>但是平移向量出了一点意外，因为3维的矩阵无法表示平移变化。<br/>为了统一它们，平移变化被加上了一维，使用四维矩阵来表示之：<br/>$$<br/>\\left[<br/>\\begin{matrix}<br/>1 & 0 & 0 & D_X \\\\<br/>0 & 1 & 0 & D_Y \\\\<br/>0 & 0 & 1 & D_Z \\\\<br/>0 & 0 & 0 & 1<br/>\\end{matrix}<br/>\\right] \\cdot<br/>\\left(<br/>\\begin{matrix}<br/>X \\\\<br/>Y \\\\<br/>Z \\\\<br/>1<br/>\\end{matrix}<br/>\\right)<br/>$$<br/>是不是非常巧妙？虽然向量和矩阵都变成了四维，但是这样我们就可以将所有的线性变换都用矩阵表示，并且可以利用矩阵乘法来加速变换。这也就是为什么矩阵在计算机图形学中十分重要的原因之一了。","tags": "RSRL","url": "blog/2016-11-6/rsrl-1.html"},
{"title": "ZY的核电站","text": "ZY的核电站 (nuclear.in/out/cpp)<br/>时间限制: 5 s / 内存限制: 256 MB / 打开O2优化<br/>题目描述<br/><br/>“ZY喜欢玩核电站。”<br/><br/>ZY的核电站非常特殊。早在2038年，ZY就发现了高分子有机物的完全裂解可以释放大量的核能的原理（这句话纯属FP）。因此ZY的核电站反应堆里面全是高分子有机物，可惜只有一个。<br/>为了使发电量尽可能大，ZY找到了一种能使有机物完全裂解的方式，使释放出来的能量最大。由于这是ZY的有机物，因此裂解方式也非常奇葩。下面是ZY在2039年的论文《论ZY对MC1核电站的巨大贡献》中的节选片段：<br/><br/>......<br/>我们的有机物是由$n$个各种原子构成的，原子之间通过不同的共价键相连。<br/><br/>($\\text{H}$太多了，到时候这些没用的氢原子都会被ZY丢掉)<br/>......<br/>为了方便进行裂解，这个有机物是没有环的，这样就可以节约成本来买**V*P***......<br/>......<br/>每次裂解都会断开一个共价键，此时这个有机物会分为两部分。并且释放大量的能量......<br/>设放出的能量为$E$，有机物裂解后的两部分的共价键的集合分别为$A$和$B$，则：、<br/>$$ E = \\sum_{a\\in A} a.\\text{energy} \\cdot \\sum_{b\\in B} b.\\text{energy} \\tag{ZY's energy theorem}$$<br/>其中$\\text{energy}$表示共价键的能量。<br/>......<br/>为了充分利用有机物中的能量，每裂解一个共价键后，我们有办法无损耗无成本的将其还原，即有机物会变得和裂解前一样。但是出于种种原因，这个共价键就不能再次进行裂解了。除非ZY发出SB之神力来使所有的共价键复活......<br/>......<br/>那么，一个有机物完全裂解所能放出的能量为所有共价键裂解一次后所放出的能量之和。<br/>......<br/><br/>(实际上，ZY的这篇论文长达$2147483647$字)<br/>当然，ZY的智商理论上为$-\\infty$。因此它的核电站其实非常辣鸡。反应堆中的有机物不一定是稳定的，但是ZY利用LCT算法以$O(\\infty!)$的时间复杂度内成功地保证了有机物的结构，这样就方便ZY发出SB之神力。但是令ZY想跳楼的是，总有一个共价键的能量在维护有机物结构时会变动。然而”机智”的ZY可以发现这些变化。<br/>ZY只希望能够快速算出当前的有机物通过完全裂解究竟能放出多少能量。由于ZY的数学只有学前班水平，所以每当她算到一半时，这个有机物又开始乱搞了，ZY就只能用LCT来重新维护它。<br/>一年之内，ZY的核电站什么电都没有发。为了快速计算，ZY找到了你这个**。<br/>ZY希望你能给出一个好方法来帮助她计算当前有机物完全裂解能放出的能量。<br/>输入格式<br/>第$1$行输入两个正整数$n$，$m$。$n$表示有机物中原子的数量，$m$表示ZY维护有机物结构的次数。<br/>接下来$n - 1$行描述一个有机物。对于每一行输入三个整数$u$，$v$和$e$，表示第$u$号原子和第$v$号原子之间以能量为$e$的共价键相连。<br/>接下来$m$行，每一行描述一个共价键的键能变化。每行输入三个整数$u$，$v$和$e$，表示第$u$号原子和第$v$号原子之间的共价键的能量变为$e$。保证第$u$号原子和第$v$号原子之间存在共价键。<br/>输出格式<br/>对于每次共价键能量的变动，输出一行一个整数，表示键能改变后的有机物完全裂解能放出的能量。<br/>输入样例<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>127 4<br/>1 2 2<br/>1 7 1<br/>2 3 2<br/>2 6 1<br/>3 4 1<br/>3 5 1<br/><br/>1 2 2<br/>1 2 3<br/>2 3 3<br/>1 2 0<br/><br/><br/>输出样例<br/>1<br/>2<br/>3<br/>413<br/>15<br/>16<br/>10<br/><br/><br/>数据范围及提示<br/>对于第一个询问:<br/>裂解$1$和$2$之间的共价键: $1 \\times (2 + 1 + 1 + 1) = 5$<br/>裂解$2$和$3$之间的共价键: $(2 + 1 + 1) \\times (1 + 1) = 8$<br/>其余的共价键裂解得到的能量均为$0$。<br/>因此答案为$13$。<br/>对于$10\\% $的数据: $n \\le 1,000, \\; m \\le 5,000$<br/>对于$10\\% $的数据: $n \\le 10,000, \\; m \\le 500,000$<br/>对于$10\\% $的数据: $n \\le 100,000, \\; m \\le 100$<br/>对于$10\\% $的数据: $n \\le 10,000, \\; m \\le 1,000,000$<br/>对于另外$20\\% $的数据: 有机物没有支链。<br/>对于$100\\% $的数据: $n \\le 200,000, \\; m \\le 1,000,000, \\; e \\le 10 $<br/><br/><br/><br/><br/>ZY从不打摆。 ↩<br/><br/><br/>","tags": "Problems ZY","url": "blog/2016-5-26/riteme.html"},
{"title": "x^n-1问题","text": "$x^n-1$问题<br/>问题描述<br/>请对下面的多项式$ A_n(x) $进行因式分解：<br/>$$ A_n(x) = x^n - 1 \\tag{1}$$<br/>其中，$ n \\in \\text{N}^* $。<br/>分析<br/>对于$ n = 1$的情况，我们无需分解。对于$n = 2 $的情况，我们可以分解为$ (x - 1)(x + 1) $。<br/>如果次数更高，这个问题就比较棘手。<br/>对于这个问题，我们有如下的定理：<br/>$$ m \\mid n \\Longrightarrow (x^m - 1) \\mid (x^n - 1) \\tag{2}$$<br/>这个定理可以用多项式除法来验证。<br/>因此，我们为了分解$(1)$式，首先用$\\Theta(\\sqrt{n})$的时间对$n$进行分解质因数，从而能找到$(1)$的几个因式，然后原始就可以表示成几个形如$(x^a - 1)(x^b - 1) \\cdots (x^z - 1)$的形式，从而能够递归的继续分解。<br/>然而我们需要注意一点：以$n=6$为例，$6$的因子有$1$、$2$、$3$和$6$。我们发现选择了$(x^6 - 1)$作为因式跟没选一样。然而选择其它的因子时发现更严重的问题：<br/>$$ (x - 1) \\mid (x^3 - 1) \\Longrightarrow (x - 1) \\nmid {x^6 - 1 \\over x^3 - 1} $$<br/>这样导致几个因子间会有冲突，因此我们无法直接选择因式。<br/>为了解决这个问题，我们定义一系列的多项式$ p_n(x) $：<br/>$$ p_n(x) = { x^n - 1 \\over \\prod_{i \\mid n}p_i(x)} \\; (i \\neq n) \\tag{3}$$<br/>实际上，这些多项式只是将原本$ x^n - 1 $中的非本身因式去掉了，这样使得：<br/>$$ (x - 1) \\mid {x^6 - 1 \\over p_3(x) } $$<br/>因为<br/>$$<br/>{x^6 - 1 \\over p_3(x) } = {x^6 - 1 \\over {(x^3 - 1) / (x - 1)}} = (x - 1) \\cdot {x^6 - 1 \\over x^3 - 1}<br/>$$<br/>这样，我们可以将任意的$ A_n(x) $表示为如下形式：<br/>$$ A_n(x) = \\prod_{i \\mid n} p_i(x) \\tag{4}$$<br/>根据$(3)$式和$(4)$式，递推完$ p_n(x) $后，我们就可以将$ A_n(x) $中的每一项都求解出来。如果多项式除法的时间复杂度为$ \\Theta(g(n)) $，那么我们可以在$ \\Theta(n\\sqrt{n} \\cdot g(n)) + \\Theta(\\sqrt{n}) = \\Theta(n\\sqrt{n} \\cdot g(n))$的时间内对$ A_n(x) $进行因式分解。","tags": "数学 多项式","url": "blog/2016-3-21/x-2-1.html"},
{"title": "【NOI2016】“循环之美” 无脑解法","text": "【NOI2016】“循环之美” 无脑解法<br/>题意<br/>给定$n, m, k$，求出所有满足$1 \\leqslant x \\leqslant n,\\; 1 \\leqslant y \\leqslant m$的正整数中，$x / y$是纯循环小数的个数。数值相同的只算一次。<br/>$n,\\;m$均不超过$10^9$，$k$不超过$2000$。<br/>题解<br/>网上一般的解法都是推一大堆式子，然后经过一些讨论最后得出使用杜教筛的做法。<br/>接下来要给的是一个xjb算法，各位听听就好。<br/>初步转化<br/>首先，如果$x / y$是纯循环小数，那么$1 / y$也是纯循环小数。<br/>考虑小数循环节的计算方式，实际上和$k^x \\pmod{y}$的循环节是一样的。由于我们知道$k^0 \\equiv 1 \\pmod{y}$，所以一定存在一个$L > 0$满足$k^L \\equiv 1 \\pmod{y}$。这样就可得知$k \\cdot k^{L - 1} = 1 + cy$。利用扩展欧几里得算法我们可以知道当$k$和$y$不互质时，是不会有解的。<br/>综上，我们要求的就是：<br/>$$<br/>\\sum_{i = 1}^n \\sum_{j = 1}^m [\\gcd(i, j) = 1][\\gcd(j, k) = 1]<br/>$$<br/>具体分析<br/>看到之后，我发现如果没有后面那个$j$和$k$的互质条件，则是一个简单的莫比乌斯函数前缀和的计算，可以使用杜教筛，这里就不多讲。现在考虑$j$要和$k$互质，看到计数想容斥，我们自然去找不与$k$互质的$j$，那么设$\\gcd(j, k) = d$。首先$d > 2$，其次$d$是$j$和$k$的一个公因子，所以我们枚举$d$的倍数即可。同时注意一个$j$可能被多个因子所减去，所以需要使用莫比乌斯函数作为容斥系数。因此需要减去的部分为：<br/>$$<br/>\\sum_{d \\mid k} \\mu(d) \\sum_{j = 1}^{\\lfloor m / d \\rfloor} \\sum_{i = 1}^n [\\gcd(dj, i) = 1]<br/>$$<br/>由于$\\gcd(dj, i) = 1$等价于$\\gcd(j, i) = 1$并且$\\gcd(d, i) = 1$，所以上式变为：<br/>$$<br/>\\sum_{d \\mid k, d > 1} \\mu(d) \\sum_{j = 1}^{\\lfloor m / d \\rfloor} \\sum_{i = 1}^n [\\gcd(j, i) = 1][\\gcd(i, d) = 1]<br/>$$<br/>我们机智的发现后面那两个求和就是原问题的“数据规模减小版”......<br/>所以设$f(n, m, k)$表示我们的答案，那么可以得到DP转移式：<br/>$$<br/>f(n, m, k) = \\sum_{i = 1}^n\\sum_{j = 1}^m [\\gcd(i, j) = 1] - \\sum_{d \\mid k, d > 1} \\mu(d) f\\left(\\left\\lfloor \\frac{m}d \\right\\rfloor, n, d\\right)<br/>$$<br/>很像杜教筛？我直接拿去用个哈希表来记忆化搜一下，好像最坏的数据也只访问了$30000$左右个状态......这么优美的一道题就这样过了......<br/>复杂度不会算......<br/>具体实现<br/>UOJ Submission #159233<br/>  1<br/>  2<br/>  3<br/>  4<br/>  5<br/>  6<br/>  7<br/>  8<br/>  9<br/> 10<br/> 11<br/> 12<br/> 13<br/> 14<br/> 15<br/> 16<br/> 17<br/> 18<br/> 19<br/> 20<br/> 21<br/> 22<br/> 23<br/> 24<br/> 25<br/> 26<br/> 27<br/> 28<br/> 29<br/> 30<br/> 31<br/> 32<br/> 33<br/> 34<br/> 35<br/> 36<br/> 37<br/> 38<br/> 39<br/> 40<br/> 41<br/> 42<br/> 43<br/> 44<br/> 45<br/> 46<br/> 47<br/> 48<br/> 49<br/> 50<br/> 51<br/> 52<br/> 53<br/> 54<br/> 55<br/> 56<br/> 57<br/> 58<br/> 59<br/> 60<br/> 61<br/> 62<br/> 63<br/> 64<br/> 65<br/> 66<br/> 67<br/> 68<br/> 69<br/> 70<br/> 71<br/> 72<br/> 73<br/> 74<br/> 75<br/> 76<br/> 77<br/> 78<br/> 79<br/> 80<br/> 81<br/> 82<br/> 83<br/> 84<br/> 85<br/> 86<br/> 87<br/> 88<br/> 89<br/> 90<br/> 91<br/> 92<br/> 93<br/> 94<br/> 95<br/> 96<br/> 97<br/> 98<br/> 99<br/>100<br/>101<br/>102<br/>103<br/>104<br/>105<br/>106<br/>107<br/>108<br/>109<br/>110<br/>111<br/>112<br/>113<br/>114<br/>115<br/>116<br/>117<br/>118<br/>119<br/>120<br/>121<br/>122<br/>123<br/>124<br/>125<br/>126<br/>127<br/>128<br/>129<br/>130<br/>131<br/>132<br/>133<br/>134<br/>135<br/>136<br/>137<br/>138<br/>139<br/>140<br/>141<br/>142<br/>143<br/>144<br/>145<br/>146<br/>147<br/>148<br/>149<br/>150<br/>151<br/>152<br/>153<br/>154<br/>155<br/>156<br/>157<br/>158<br/>159<br/>160<br/>161<br/>162<br/>163<br/>164// #define NDEBUG<br/><br/>#include <cassert><br/>#include <cstdio><br/>#include <cstring><br/>#include <climits><br/><br/>#include <vector><br/>#include <algorithm><br/><br/>using namespace std;<br/><br/>#define KMAX 2000<br/>#define S 5000000<br/>#define MOD 116099<br/><br/>typedef long long i64;<br/><br/>template <typename TPolicy><br/>struct HashTable {<br/>    typedef typename TPolicy::TKey TKey;<br/>    typedef typename TPolicy::TVal TVal;<br/>    typedef pair<TKey, TVal> Data;<br/><br/>    vector<Data> bucket[MOD];<br/><br/>    int get_pos(int key) {<br/>        int pos = key %  MOD;<br/>        return pos < 0 ? pos + MOD : pos;<br/>    }<br/><br/>    void insert(TKey key, TVal val) {<br/>        bucket[get_pos(TPolicy::hash(key))].push_back(Data(key, val));<br/>    }<br/><br/>    bool query(TKey key, TVal &val) {<br/>        int pos = get_pos(TPolicy::hash(key));<br/><br/>        for (auto e : bucket[pos]) {<br/>            if (e.first == key) {<br/>                val = e.second;<br/>                return true;<br/>            }<br/>        }<br/><br/>        return false;<br/>    }<br/>};<br/><br/>struct PrePolicy {<br/>    typedef int TKey;<br/>    typedef int TVal;<br/><br/>    static int hash(int x) {<br/>        return x;<br/>    }<br/>};<br/><br/>static int c[S + 10];<br/>static int p[S + 10];<br/>static HashTable<PrePolicy> mu;<br/><br/>int pre(int n) {<br/>    if (n <= S)<br/>        return p[n];<br/><br/>    int ret = 1;<br/>    if (mu.query(n, ret))<br/>        return ret;<br/><br/>    for (int i = 2, last = 2; i <= n; i = last + 1) {<br/>        last = n / (n / i);<br/>        ret -= (last - i + 1) * pre(n / i);<br/>    }<br/><br/>    mu.insert(n, ret);<br/>    return ret;<br/>}<br/><br/>struct Key {<br/>    int n, m, k;<br/><br/>    bool operator==(const Key &b) const {<br/>        return n == b.n && m == b.m && k == b.k;<br/>    }<br/>};<br/><br/>struct DpPolicy {<br/>    typedef Key TKey;<br/>    typedef i64 TVal;<br/><br/>    static int hash(const TKey &x) {<br/>        return (x.n ^ x.m) * x.k;<br/>    }<br/>};<br/><br/>static vector<int> d[KMAX + 10];<br/>static HashTable<DpPolicy> mem;<br/><br/>i64 dp(int n, int m, int k) {<br/>    if (n == 0 || m == 0)<br/>        return 0;<br/><br/>    Key key = {n, m, k};<br/>    i64 ret = 0;<br/>    if (mem.query(key, ret))<br/>        return ret;<br/><br/>    for (int i = 1, last = 1; i <= n && i <= m; i = last + 1) {<br/>        last = min(n / (n / i), m / (m / i));<br/>        i64 sum = pre(last) - pre(i - 1); <br/>        ret += sum * (n / i) * (m / i);<br/>    }<br/><br/>    for (int i : d[k]) {<br/>        ret += c[i] * dp(m / i, n, i);<br/>    }<br/><br/>    mem.insert(key, ret);<br/>    return ret;<br/>}<br/><br/>static int n, m, k;<br/>static bool marked[S + 10];<br/>static int prime[S + 10], cnt;<br/><br/>void initialize() {<br/>    scanf(\ % d% d% d\ , &n, &m, &k);<br/><br/>    c[1] = p[1] = 1;<br/>    for (int i = 2; i <= S; i++) {<br/>        if (!marked[i]) {<br/>            c[i] = -1;<br/>            prime[++cnt] = i;<br/>        }<br/><br/>        p[i] = p[i - 1] + c[i];<br/>        for (int j = 1; i * prime[j] <= S; j++) {<br/>            int p = prime[j];<br/>            marked[i * p] = true;<br/><br/>            if (i %  p == 0) {<br/>                c[i * p] = 0;<br/>                break;<br/>            } else<br/>                c[i * p] = -c[i];<br/>        }<br/>    }<br/><br/>    for (int i = 2; i <= k; i++) {<br/>        for (int j = 2; j <= i; j++) {<br/>            if (c[j] && i %  j == 0)<br/>                d[i].push_back(j);<br/>        }<br/>    }<br/>}<br/><br/>int main() {<br/>    // freopen(\ cyclic.in\ , \ r\ , stdin);<br/>    initialize();<br/>    printf(\ % lld\\n\ , dp(n, m, k));<br/><br/>    return 0;<br/>}<br/><br/>","tags": "NOI 数论 题解","url": "blog/2017-5-18/cyclic.html"},
{"title": "中国剩余定理 (CRT)","text": "中国剩余定理 (CRT)<br/>玩一玩<br/>找出所有$a$，使得满足下列关系式：<br/>$$<br/>\\begin{aligned}<br/>a & \\equiv 3\\;(\\text{mod}\\;5) \\\\<br/>a & \\equiv 2\\;(\\text{mod}\\;7)<br/>\\end{aligned}<br/>$$<br/>通过暴力枚举，我们可以得知答案：<br/>$$<br/>a = 23 + 35k\\;(k \\in Z)<br/>$$<br/>简单形式<br/>现在来考虑一个问题：<br/><br/>证明：一定存在一个$a$，满足<br/>$$a \\equiv a_1\\;(\\text{mod}\\;m) \\\\a \\equiv a_2\\;(\\text{mod}\\;n)$$<br/>其中$m \\bot n$<br/><br/>我们使用鸽巢原理来证明。<br/>设有$n$个数模$m$等于$a_1$，这$n$个数是：<br/>$$<br/>a_1,\\;m + a_1,\\;2m + a_1,\\;\\dots,\\;(n - 1)m + a_1<br/>$$<br/>即设其中有两个数模$n$意义下同余，设它们为$im + a_1$和$jm + a_1$ ($i < j$)。<br/>那么意味着：<br/>$$<br/>jm + a_1 = pn + r \\\\<br/>im + a_1 = qn + r<br/>$$<br/>两式相减可得：<br/>$$<br/>(j - i)m = (p - q)n<br/>$$<br/>因为$p - q \\in Z$，所以$n \\mid (j - i)m$。<br/>但是$m \\bot n$，且$0 \\lt j - i \\le n - 1$，所以$n \\not\\mid (j - i)m$，与之前的假设相矛盾。<br/>故之前选出的$n$个数里面没有两个数在模$n$意义下同余。<br/>那么这里面必定存在一个数模$n$余$a_2$。<br/>中国剩余定理<br/><br/>证明：存在一个数$x$，满足<br/>$$x \\equiv a_1 \\; (\\text{mod}\\;m_1) \\\\x \\equiv a_2 \\; (\\text{mod}\\;m_2) \\\\\\dots \\\\x \\equiv a_k \\; (\\text{mod}\\;m_k)$$<br/>其中$m_1,\\;m_2,\\;\\dots,\\;m_k$两两互质<br/><br/>当然可以考虑两两合并的方式，并使用之前鸽巢原理的证法来证明。<br/>当然我们考虑一种更具有价值的证法。<br/>既然要证明其存在，不如直接构造一个答案：<br/>首先设：<br/>$$<br/>M = \\prod_{j=1}^k m_j \\tag{2.1}<br/>$$<br/>是所有模数之积。<br/>$$<br/>M_i = {M \\over m_i} \\tag{2.2}<br/>$$<br/>是剔除掉某一个模数的积。<br/>$$<br/>C_i = M_i(M_i^{-1}\\;\\text{mod}\\;m_i) \\tag{2.3}<br/>$$<br/>则是一个神奇的数字。<br/>由于$M_i$肯定与$m_i$互质，所以这个逆元是肯定能求出来的。<br/>那么：<br/>$$<br/>x \\equiv \\sum_{i=1}^k a_iC_i \\; (\\text{mod}\\;M)<br/>$$<br/>接下来就是要证明这个数同时满足上面的方程。<br/>首先注意到：<br/>$$<br/>m_i \\mid C_j \\Longrightarrow C_i \\equiv 0 \\; (\\text{mod}\\;m_i) \\;\\;\\; (i \\neq j)<br/>$$<br/>同时：<br/>$$<br/>C_i \\equiv M_i\\cdot M_i^{-1} \\equiv 1 \\; (\\text{mod}\\;m_i)<br/>$$<br/>于是：<br/>$$<br/>x \\equiv a_i \\; (\\text{mod} \\; m_i)<br/>$$<br/>因此这个数是满足要求的。<br/>同时我们获得了中国剩余定理 (CRT) 的公式：<br/>$$<br/>x = \\sum_{i=1}^k a_i M_i(M_i^{-1}\\;\\text{mod}\\;m_i) \\tag{2.4}<br/>$$<br/>借助欧几里德算法，可以在$O(n\\log n)$的时间内计算答案。<br/>应用<br/>中国剩余定理一个最大的应用就是计算一些数在模一个合数下的取值。<br/>例如，求大组合数取模：<br/>$$<br/>{n \\choose m} \\;\\text{mod}\\; p<br/>$$<br/>对于这个问题，如果$p$是质数且比较小，我们可以采用Lucas定理求解。<br/>然而现在是合数。<br/>我们考虑一种方案，将合数$p$进行质因数分解，这样就可以分解成多个质数，对于每一个质数，我们都有方法求解答案。这样对于每一个质数计算答案之后，我们得到了一个模线性方程组。<br/>这样就变成了我们之前所讨论的问题。对于此，使用中国剩余定理，就可以合并答案。","tags": "数学 数论 中国剩余定理","url": "blog/2016-8-17/crt.html"},
{"title": "二进制GCD","text": "二进制GCD<br/>在算导上发现了一个有趣的算法，有氧环境下可以拿来卡卡常.....<br/>算法原理<br/>下面将考虑计算$\\gcd(a,\\;b)$，假定$a \\ge b$：<br/><br/>如果$a$、$b$都是偶数，那么易知：<br/>$$<br/>\\gcd(a,\\;b) = 2\\gcd(a / 2,\\;b / 2)<br/>$$<br/>如果$a$是偶数，$b$是奇数，那么有：<br/>$$<br/>\\gcd(a,\\;b) = \\gcd(a / 2, b)<br/>$$<br/>如果$a$是奇数，$b$是偶数，那么有：<br/>$$<br/>\\gcd(a,\\;b) = \\gcd(a,\\;b / 2)<br/>$$<br/>如果$a$、$b$都是奇数，那么有：<br/>$$<br/>\\gcd(a,\\;b) = \\gcd((a - b) / 2, b)<br/>$$<br/><br/>这些结论都是比较容易证明的，这里就略去了。<br/>由于减法的速度比取模快 (减法速度基本与加法一致)，同时除以$2$和乘以$2$可以使用位运算来代替，并且每次折半可以保证复杂度，所以理论上这个算法是非常快的。<br/>但是需要注意，欧几里德算法是上界$O(\\log(\\min\\{a,\\;b\\}))$，而此算法类似于快速幂，是上下界$\\Theta(\\log(\\min\\{a,\\;b\\}))$。<br/>但这并不影响它的效率。在我的机子上 (使用Clang 3.6.0) 实测，在编译器打开-O2优化下比欧几里德算法快。<br/>但是在没有开-O2优化时，因为常数问题速度变慢许多。<br/>算法实现<br/>下面展示一个基本实现：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15function BINARY-GCD(a, b):<br/>    if a < b:  # 要保证 a >= b<br/>        SWAP(a, b)<br/>    if b == 0:<br/>        return a<br/>    if a & 1:<br/>        if b & 1:<br/>            return BINARY-GCD((a - b) >> 1, b)<br/>        else:<br/>            return BINARY-GCD(a, b >> 1)<br/>    else:<br/>        if b & 1:<br/>            return BINARY-GCD(a >> 1, b)<br/>        else:<br/>            return BINARY-GCD(a >> 1, b >> 1) << 1<br/><br/><br/>注意到欧几里德算法里面是尾递归，编译器可以依此做优化。<br/>而上面给出的代码里面并不是这种形式。<br/>但是我们可以稍微修改一下，就可以将其改为尾递归形式：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15function TAIL-BINARY-GCD(a, b, shift = 0):  # 记录一个shift表示答案乘了几个2<br/>    if a < b:<br/>        SWAP(a, b)<br/>    if b == 0:<br/>        return a << shift  # 将shift的记录的2算入答案<br/>    if a & 1:<br/>        if b & 1:<br/>            return TAIL-BINARY-GCD((a - b) >> 1, b, shift)<br/>        else:<br/>            return TAIL-BINARY-GCD(a, b >> 1, shift)<br/>    else:<br/>        if b & 1:<br/>            return TAIL-BINARY-GCD(a >> 1, b, shift)<br/>        else:<br/>            return TAIL-BINARY-GCD(a >> 1, b >> 1, shift + 1)  # 计数器加1<br/><br/><br/>在编译器优化的帮助下，这份代码跑得更快。<br/>此外，二进制GCD另一个巨大的优势就是在需要高精度的场合下，不但降低时间复杂度也减低了编程难度 (毕竟不需要高精度取模)，所以在这种情况下是一个非常好的算法。","tags": "数学 GCD","url": "blog/2016-8-19/binary-gcd.html"},
{"title": "二项式定理及其它","text": "二项式定理及其它<br/>二项式定理<br/>基本定理<br/>二项式定理是用于展开两数相加的幂次的公式：<br/>$$<br/>(x + y)^n = \\sum_{k=0}^n {n \\choose k} x^k y^{n-k} \\tag{1.1}<br/>$$<br/>我们可以考虑使用组合证明。由于我们可以从$n$个括号中任意选取$k$个来组成$x^k$的项，这个方案数恰好是${n \\choose k}$，剩下的$y$也是同理。因此对应的项的系数就是${n \\choose k}$或${n \\choose n - k}$。<br/>下面使用归纳法证明：<br/>当$n = 1$的时候：<br/>$$<br/>(x + y)^1 = x + y = \\sum_{k=0}^1 {1 \\choose k} x^ky^{1-k}<br/>$$<br/>结论显然成立。<br/>假设对$n$成立，求证对$n + 1$成立：<br/>$$<br/>\\begin{aligned}<br/>(x + y)^{n+1} & = (x + y)(x + y)^n \\\\<br/>& = (x + y)\\sum_{k=0}^n {n \\choose k} x^ky^{n-k} \\\\<br/>& = \\sum_{k=0}^n {n \\choose k} x^{k+1}y^{n-k} + \\sum_{k=0}^n {n \\choose k} x^ky^{n-k+1} \\\\<br/>& = x^{n+1} + y^{n+1} + \\sum_{k=0}^{n-1} {n \\choose k} x^{k+1}y^{n-k} + \\sum_{k=1}^n {n \\choose k} x^ky^{n-k+1} \\\\<br/>& = x^{n+1} + y^{n+1} + \\sum_{k=1}^{n} {n \\choose k - 1} x^{k}y^{n-k+1} + \\sum_{k=1}^n {n \\choose k} x^ky^{n-k+1} \\\\<br/>& = x^{n+1} + y^{n+1} + \\sum_{k=1}^n \\left[{n \\choose k - 1}+{n \\choose k}\\right] x^ky^{n-k+1} \\\\<br/>& = x^{n+1} + y^{n+1} + \\sum_{k=1}^n {n+1 \\choose k} x^ky^{n-k+1} \\\\<br/>& = \\sum_{k=0}^{n+1} {n+1 \\choose k} x^ky^{n-k+1} \\\\<br/>\\end{aligned}<br/>$$<br/>这样就完成了我们的证明。<br/>简单运用<br/>组合恒等式<br/>将$y = 1$，我们将得到一个很常用的式子：<br/>$$<br/>(1 + x)^n = \\sum_{k=0}^n {n \\choose k} x^k \\tag{1.2}<br/>$$<br/>令$x = 1$:<br/>$$<br/>\\sum_{k=0}^n {n \\choose k} = (1 + 1)^n = 2^n \\tag{1.3}<br/>$$<br/>得到了组合数之和，<br/>令$x = -1$:<br/>$$<br/>\\sum_{k=0}^n (-1)^k {n \\choose k} = 0 \\tag{1.4}<br/>$$<br/>得到了组合数的交错和。<br/>通过移项可以得到更进一步的结论：:<br/>$$<br/>{n \\choose 0} + {n \\choose 2} + \\dots = {n \\choose 1} + {n \\choose 3} + \\dots \\tag{1.5}<br/>$$<br/>结合$(1.3)$可知：<br/>$$<br/>{n \\choose 0} + {n \\choose 2} + \\dots = {n \\choose 1} + {n \\choose 3} + \\dots = 2^{n-1} \\tag{1.6}<br/>$$<br/>导数<br/>现在我们重新考虑这个式子：<br/>$$<br/>(1 + x)^n = \\sum_{k=0}^n {n \\choose k} x^k \\tag{1.2}<br/>$$<br/>两边同时关于$x$求导：<br/>$$<br/>n(1 + x)^{n-1} = \\sum_{k=0}^n {n \\choose k} \\cdot kx^{k-1} \\tag{1.7}<br/>$$<br/>令$x = 1$：<br/>$$<br/>n2^{n-1} = \\sum_{k=0}^n k{n \\choose k} \\tag{1.8}<br/>$$<br/>这样我们得到了一个非常有意思的式子。<br/>运用这个式子，我们可以算出：<br/>$$<br/>\\sum_{k=0}^n (2k+1){n \\choose k} = (n+1)2^n<br/>$$<br/>事实上，你还可以对$(1.8)$进一步求导，从而得到$k^2$的公式。<br/>组合数的平方和<br/>$$<br/>\\sum_{k=0}^n {n \\choose k}^2 = {2n \\choose n} \\tag{1.9}<br/>$$<br/>对于这个结论，我们考虑下面的式子：<br/>$$<br/>(1 + x)^n(1+x)^n = (1+x)^{2n}<br/>$$<br/>运用二项式定理展开可得：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{i=0}^n {n\\choose i} x^i \\cdot \\sum_{j=0}^n {n\\choose j} x^j & = \\sum_{i=0}^n\\sum_{j=0}^n {n \\choose i}{n \\choose j} x^ix^j \\\\<br/>& = \\sum_{k=0}^{2n} {2n \\choose k} x^k<br/>\\end{aligned}<br/>$$<br/>考虑等号两边系数同为$k$的项，一定满足下面的等式：<br/>$$<br/>\\sum_{i=0}^n {n \\choose i}{n \\choose k - i} = {2n \\choose k} \\tag{1.10}<br/>$$<br/>当$k = n$时：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{i=0}^n {n \\choose i}{n \\choose n - i} & = \\sum_{i=0}^n {n \\choose i}{n \\choose i} \\\\<br/>& = \\sum_{i=0}^n {n \\choose i}^2 \\\\<br/>& = {2n \\choose n}<br/>\\end{aligned}<br/>$$<br/>这样就证明了组合数的平方和的结论。<br/>二项式定理与$\\text{e}$<br/>根据泰勒展开，我们可以知道：<br/>$$<br/>\\text{e}^x = \\sum_{n=0}^\\infty \\frac{x^n}{n!} \\tag{1.11}<br/>$$<br/>令$x = 1$就可以得到$\\text{e}$的无穷展开形式：<br/>$$<br/>\\text{e} = \\sum_{k=0}^\\infty \\frac1{k!} \\tag{1.12}<br/>$$<br/>而我们平常所熟知的$\\text{e}$的定义是这样的：<br/>$$<br/>\\text{e} = \\lim_{n \\rightarrow \\infty} \\left(1 + \\frac1n\\right)^n \\tag{1.13}<br/>$$<br/>运用二项式定理可以证明泰勒展开的结果与上面的定义等价：<br/>$$<br/>\\begin{aligned}<br/>\\text{e} & = \\lim_{n\\rightarrow\\infty} \\left(1 + \\frac1n\\right)^n \\\\<br/>& = \\lim_{n\\rightarrow\\infty} \\sum_{k=0}^n {n \\choose k} \\frac1{n^k} \\\\<br/>& = \\lim_{n\\rightarrow\\infty} \\sum_{k=0}^n \\frac1{k!} \\frac{\\prod_{i=n-k+1}^n i}{n^k}<br/>\\end{aligned}<br/>$$<br/>由于：<br/>$$<br/>\\lim_{n \\rightarrow \\infty} \\frac{\\prod_{i=n-k+1}^n i}{n^k} = 1<br/>$$<br/>所以这一项可以去掉。于是就得到了泰勒展开的结果。<br/>多项式定理<br/>与二项式定理，这个定理并不怎么常用。<br/>可能是形式比较复杂，不便于理论分析。<br/>多项式定理是二项式定理的扩展：<br/>$$<br/>(x_1 + x_2 + \\dots + x_m)^n = \\sum_{k_1 + k_2 + \\dots + k_m = n} {n \\choose k_1\\;k_2\\;\\dots\\;k_m} x_1^{k_1}x_2^{k_2}\\cdots x_m^{k_m} \\tag{2.1}<br/>$$<br/>其中：<br/>$$<br/>{n \\choose k_1\\;k_2\\;\\dots\\;k_m} = {n! \\over k_1!k_2!\\cdots k_m!}<br/>$$<br/>是多项式系数，同时也是多重集合的全排列数量。<br/>组合证明方法与二项式定理类似。同时也可以从二项式定理归纳法而来。<br/>牛顿二项式定理<br/>牛顿二项式定理又称为广义二项式定理：<br/>$$<br/>(x + y)^\\alpha = \\sum_{k=0}^\\infty {\\alpha \\choose k} x^ky^{\\alpha - k} \\;\\;\\; (\\alpha \\in R,\\;\\color{red}{0 \\le \\;\\mid x\\mid\\; \\lt \\;\\mid y\\mid}) \\tag{3.1}<br/>$$<br/>注意红色的字，这是非常重要的限制。<br/>其中：<br/>$$<br/>{\\alpha \\choose k} = {\\prod_{i=\\alpha - k +1}^\\alpha i \\over k!}<br/>$$<br/>是在实数域的二项式系数。<br/>不会那么高深的高数知识，不会证......<br/>基本用途<br/>这种形式并不常用，而另外一种形式很常用：<br/>令$z = x/y$，那么$\\color{red}{\\mid z\\mid \\;\\lt 1}$：<br/>$$<br/>(x + y)^\\alpha = y^\\alpha(z + 1)^\\alpha<br/>$$<br/>所以：<br/>$$<br/>\\begin{aligned}<br/>(z + 1)^\\alpha & = \\sum_{k=0}^\\alpha {\\alpha \\choose k} {x^ky^{\\alpha-k} \\over y^\\alpha} \\\\<br/>& = \\sum_{k=0}^\\alpha {\\alpha \\choose k} {x^k \\over y^k}\\cdot{y^{\\alpha-k} \\over y^{\\alpha-k}} \\\\<br/>& = \\sum_{k=0}^\\alpha {\\alpha \\choose k} z^k \\\\<br/>& = (1 + z)^\\alpha<br/>\\end{aligned}<br/>\\tag{3.2}<br/>$$<br/>几何级数<br/>令$\\alpha = -n \\; (n \\in Z)$：<br/>$$<br/>{\\alpha \\choose k} = {-n \\choose k} = (-1)^k{n + k - 1 \\choose k}<br/>$$<br/>所以：<br/>$$<br/>\\frac1{(1+z)^n} = \\sum_{k=0}^\\infty (-1)^k{n + k - 1 \\choose k} z^k<br/>$$<br/>令$z = -z$：<br/>$$<br/>\\frac1{(1-z)^n} = \\sum_{k=0}^\\infty {n+k-1 \\choose k}z^k<br/>$$<br/>妙啊！讨厌的$-1$不见了！<br/>令$n=1$：<br/>$$<br/>\\frac1{1-z} = \\sum_{k=0}^\\infty z^k<br/>$$<br/>正是收敛几何级数。<br/>这东西在生成函数里面很常见。<br/>看生成函数之前一定要学好牛顿二项式定理和泰勒展开QAQ。<br/>现在我们来求一下有限几何级数的公式。<br/>注意$\\mid z \\mid \\;\\lt 1$：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{k=0}^n z^k & = \\sum_{k=0}^\\infty z^k - \\sum_{k=n+1}^\\infty z^k \\\\<br/>& = \\sum_{k=0}^\\infty z^k - z^{n+1}\\sum_{k=0}^\\infty z^k \\\\<br/>& = (1 - z^{n+1}) \\sum_{k=0}^\\infty z^k \\\\<br/>& = {1 - z^{n+1} \\over 1-z}<br/>\\end{aligned}<br/>\\tag{3.3}<br/>$$<br/>开根运算<br/>之前取$\\alpha = -n$，从而解决了几何级数的问题。<br/>现在取$\\alpha = 1/2$，就可以将求平方根变成一个迭代的形式。<br/>并且可以求任意幂次、任意精度的结果。<br/>由于$z$有限制，因此需要提项，如：<br/>$$<br/>\\sqrt{20} = \\sqrt{16+4} = 4\\sqrt{1 + 0.25}<br/>$$<br/>这样我们就获得了一个求根号的好方法。","tags": "数学 组合数学 二项式定理 多项式定理 牛顿二项式定理","url": "blog/2016-8-18/binomial.html"},
{"title": "伪代码规定","text": "伪代码规定<br/>最近博客上的伪代码越写越乱了，是时候好好定一下了。<br/>参考了《算法导论》的伪代码风格，杂揉一些Python的写法。<br/>注释<br/>//后的所有内容都是注释。<br/>1// 这是注释<br/><br/><br/>变量<br/>以单个字符为主，小写字母可以有多个，大写字母最好只有1个。<br/>变量的属性用.操作符来访问。<br/>这里的变量实际上都是对实体的一个引用，类似于C++中的指针。<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7a = 1  // 第一次声明a<br/>b = 2  // 第一次声明b<br/>a = b  // a绑定到b上，即a和b指向同一实体<br/>a = COPY(b)  // 将b的值复制到a<br/>a = DEEPCOPY(b)  // 深度复制，将b中所有的引用全部复制。<br/>a.name = \ 233\   // 属性的设定<br/>b.name = a.name  // 属性的访问与设定<br/><br/><br/>函数<br/>函数的声明以function开始。<br/>函数名称最好全部大写，如果有多个词语用-分开。<br/>函数名后面带一个元组，表示参数。<br/>return语句用来返回函数值。如果没有return，那么实际返回nil。<br/>1<br/>2<br/>3<br/>4function ADD-TWO-NUMBERS(a, b):<br/>    return a + b<br/><br/>c = ADD-TWO-NUMBERS(1, 2)  // c = 3<br/><br/><br/>操作符<br/>=: 赋值，在if中表示判断是否相等<br/><: 小于<br/>>: 大于<br/><=: 不大于<br/>>=: 不小于<br/>+: 加号<br/>-: 减号<br/>*: 乘号<br/>**: 幂运算<br/>/: 除号<br/>mod: 取模<br/>~: 按位取反<br/>&: 按位与<br/>|: 按位或<br/>^: 按位异或<br/><<: 按位左移<br/>>>: 按位右移<br/>not: 逻辑反<br/>and: 逻辑且<br/>or: 逻辑或<br/>xor: 逻辑异或<br/>条件控制语句<br/>if<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8if statement:<br/>    // 如果为真<br/>else if statement2:<br/>    // ...<br/>else if statement3:<br/>    // ...<br/>else:<br/>    // ...<br/><br/><br/>while<br/>1<br/>2while condition:<br/>    // ...<br/><br/><br/>for<br/>for的形式可以多样。条件可以用陈述句。<br/>1<br/>2for i = 0 to 100 step 2:  // i从0到100，每次加2。<br/>    // ...<br/><br/><br/>foreach可以以不定的顺序遍历集合内的所有元素。<br/>1<br/>2foreach a in A:<br/>    // ...<br/><br/><br/>对于诸如1到100的遍历，可以使用定义域。<br/>1<br/>2foreach i in [1, 100]:<br/>    // ...<br/><br/><br/>内置类型<br/>nil: 表示不存在的值<br/>Number: 表示实数<br/>String: 表示字符串，用\ \ 表示<br/>Boolean: 表示布尔值，只有true和false<br/>Byte: 表示一个字节(通常为8bit)，允许使用16进制和2进制，16进制以#开始。<br/>Set: 表示集合，用{}表示。<br/>所有的类型后加上[]表示该类型的数组类型。<br/>对于元组，使用()来表示。<br/>内置函数或语句<br/>ASSERT statement: 断言，如果不为真则报错。<br/>SWAP(a, b): 交换两者的引用。<br/>delete a: 删除a这一引用<br/>以及各种数学函数<br/>元组<br/>使用小括号来声明元组。<br/>1<br/>2(a, )  // 如果只有一个元素，则需要带上一个额外的逗号。<br/>(a, b, c)  // 三元组<br/><br/><br/>元组可以裂解。<br/>1a, b = (1, 2)  // a = 1, b = 2<br/><br/><br/>构成元组的方式也可以随意。<br/>1a, b = b, a  // 此乃SWAP的实现<br/><br/><br/>如果遇到极端情况…<br/>如果上面的规定不能满足表达算法的需要，那么有两种解决方法：<br/><br/>从其它的语言借点语法过来，别人看得懂就行。<br/>使用陈述句。<br/><br/>记住，如果解决不了时，就用陈述句。","tags": "伪代码","url": "blog/2016-4-23/fake-code.html"},
{"title": "位运算卷积与FWT","text": "位运算卷积与 FWT<br/>几行代码里隐藏数学真是高深莫测，只有勇者才能够发现这绝妙的规律。<br/>位运算卷积<br/>普通的卷积 (即多项式乘法) 是这个样子：<br/>$$<br/>C_i = \\sum_{j + k = i} A_j \\cdot B_k \\;\\;\\;\\;\\forall \\; j, k \\in [0, n)<br/>\\tag{1.1}<br/>$$<br/>而位运算卷积就是将加号变为了二元位运算，就是这样：<br/>$$<br/>C_i = \\sum_{j \\oplus k = i} A_j \\cdot B_k \\;\\;\\;\\;\\forall \\; j, k \\in [0, n)<br/>\\tag{1.2}<br/>$$<br/>其中 $\\oplus$ 指代任意二元位运算符号，如异或 (就是记做 $\\oplus$)、与运算 ($\\land$) 和或运算 ($\\lor$) 等等。<br/>注意到，在多项式乘法中，如果两个多项式的界为 $A$ 和 $B$，那么答案的界就是 $A + B - 1$。而在位运算卷积中，却是 $2^{\\left\\lceil\\log_2\\max\\{A,B\\}\\right\\rceil}$。而且对于两个输入向量而言，末尾添加几个 $0$ 是不会对答案产生影响的1。因此，像在快速傅里叶变换中一样，假定输入的向量大小一致且均为 $2$ 的幂，设这个大小为 $n$。<br/>在下文中，向量 $A = (a_0, a_1, ..., a_k)$ 的倒置 $A^T$ 为：<br/>$$<br/>A^T = \\left[\\begin{matrix}<br/>a_0 \\\\<br/>a_1 \\\\<br/>\\vdots \\\\<br/>a_k<br/>\\end{matrix}\\right] \\tag{1.3}<br/>$$<br/>为了方便，矩阵 $M$ 与向量 $A = (a_0, a_1, ..., a_k)$ 相乘表示线性变换时，简写为 $MA$，代表 $(MA^T)^T$。<br/>特殊情况<br/>为了探寻规律，我们以异或为例，手动计算一下 $n$ 很小时的情况。<br/>$n = 2^0$<br/>当输入两个数时，结果会是一个数。由于 $0 \\oplus 0 = 0$，所以：<br/>$$<br/>C_0 = A_0 \\cdot B_0<br/>\\tag{2.1}<br/>$$<br/>So easy, 也没什么意思。<br/>$n = 2^1$<br/>输入两个向量 $A = (a_0, a_1)$ 和 $B = (b_0, b_1)$。得到的结果 $C$ 是：<br/>$$<br/>C = (a_0 b_0 + a_1 b_1, a_0 b_1 + a_1 b_0)<br/>\\tag{2.2}<br/>$$<br/>不如大胆的尝试一下，能否通过某种变换，从而能够使用更简单的点积来计算呢，就像下面这个样子：<br/>$$<br/>TA \\cdot TB = TC<br/>\\tag{2.3}<br/>$$<br/>这里 $T$ 表示变换，同时他还需要一个逆变换从而使得我们能够得到 $C$。我们可以从线性代数的角度来考虑这个问题，那么我们希望 $T$ 能够是一个线性变换，这样我们就可以用矩阵来表示之。<br/>那么意味着我们要找到一个矩阵 $T$，满足：<br/>$$<br/>T<br/>\\left[<br/>\\begin{matrix}<br/>a_0 \\\\<br/>a_1<br/>\\end{matrix}<br/>\\right]<br/>\\cdot<br/>T<br/>\\left[<br/>\\begin{matrix}<br/>b_0 \\\\<br/>b_1<br/>\\end{matrix}<br/>\\right]<br/>=<br/>T<br/>\\left[<br/>\\begin{matrix}<br/>a_0 b_0 + a_1 b_1 \\\\<br/>a_0 b_1 + a_1 b_0<br/>\\end{matrix}<br/>\\right]<br/>\\tag{2.4}<br/>$$<br/>首先这个线性变换只在二维向量空间上进行的，所以 $T$ 应该是一个 $2 \\times 2$ 的矩阵，于是设：<br/>$$<br/>T =<br/>\\left[<br/>\\begin{matrix}<br/>m & n \\\\<br/>p & q<br/>\\end{matrix}<br/>\\right]<br/>\\tag{2.5}<br/>$$<br/>那么之前是一个两个向量的点积式，于是我们可以列出两个方程来表示：<br/>$$<br/>\\begin{cases}<br/>\\begin{aligned}<br/>(ma_0 + na_1)(mb_0 + nb_1) & = m(a_0 b_0 + a_1 b_1) + n(a_0 b_1 + a_1 b_0) \\\\<br/>(pa_0 + qa_1)(pb_0 + qb_1) & = p(a_0 b_0 + a_1 b_1) + q(a_0 b_1 + a_1 b_0)<br/>\\end{aligned}<br/>\\end{cases}<br/>\\tag{2.6}<br/>$$<br/>于是你发现第一个方程和第二方程没有区别......好吧，那就只研究第一个方程，将其暴力拆开是这样的：<br/>$$<br/>m^2a_0 b_0 + mna_0 b_1 + mna_1 b_0 + n^2a_1 b_1 = ma_0 b_0 + na_0 b_1 + na_1 b_0 + ma_1 b_1<br/>\\tag{2.7}<br/>$$<br/>一个二元二次方程，有很多解了啦，但是我们只需要一个。最简单的解法2就是对应的项的系数相同。<br/>也就是说：<br/>$$<br/>m^2 = m \\Longrightarrow m = 1<br/>\\tag{2.8}<br/>$$<br/>然后就是：<br/>$$<br/>n^2 = 1 \\Longrightarrow n = \\pm 1<br/>\\tag{2.9}<br/>$$<br/>然后发现 $n$ 的这两个取值都可以满足 $mn = n$。那么对于 $p$ 和 $q$ 是同理的，因此 $T$ 的一种形式是这样的：<br/>$$<br/>\\left[<br/>\\begin{matrix}<br/>1 & \\pm 1 \\\\<br/>1 & \\pm 1 \\\\<br/>\\end{matrix}<br/>\\right]<br/>\\tag{2.10}<br/>$$<br/>不过我们不能够全部填 $1$，因为我们在一开始的要求是 $T$ 要有逆变换，但是全是 $n = q$ 的矩阵不满秩，所以没有逆矩阵。因此，我们只有两种选择。<br/>对于其逆矩阵，我在这里帮你们算出来了：<br/>$$<br/>\\left[<br/>\\begin{matrix}<br/>1 & -1 \\\\<br/>1 & 1 \\\\<br/>\\end{matrix}<br/>\\right]^{-1}<br/>=<br/>\\left[<br/>\\begin{matrix}<br/>0.5 & 0.5 \\\\<br/>-0.5 & 0.5 \\\\<br/>\\end{matrix}<br/>\\right] \\\\<br/>\\left[<br/>\\begin{matrix}<br/>1 & 1 \\\\<br/>1 & -1 \\\\<br/>\\end{matrix}<br/>\\right]^{-1}<br/>=<br/>\\left[<br/>\\begin{matrix}<br/>0.5 & 0.5 \\\\<br/>0.5 & -0.5 \\\\<br/>\\end{matrix}<br/>\\right]<br/>\\tag{2.11}<br/>$$<br/>实在记不住就爆枚一下矩阵吧，这样的 $\\pm 1$ 矩阵没几个，试一试就好......<br/>$n = 2^m \\;\\; (m \\geqslant 2)$<br/>现在来考虑更复杂的情况。<br/>跟前面一样的思想，我们企图找到 $T_m$，满足：<br/>$$<br/>T_mA \\cdot T_mB = T_mC<br/>\\tag{2.12}<br/>$$<br/>我们已经知道 $T_0 = 1$ 并且求出了 $T_1$。<br/>基于这样一个事实：<br/>$$<br/>a \\oplus b = c \\Longrightarrow<br/>a[i] \\oplus b[i] = c[i]<br/>\\tag{2.13}<br/>$$<br/>这里 $a[i]$ 表示 $a$ 的二进制表示中的第 $i$ 位。这说明二进制运算有一个重要的性质就是其每一位可以分开运算。<br/>这有什么好处呢？我们先考虑最高位，这样将输入向量分为两部分：<br/>$$<br/>A = (A_0, A_1) \\\\<br/>B = (B_0, B_1)<br/>\\tag{2.14}<br/>$$<br/>下标为 $0$ 的表示最高位为 $0$，下标为 $1$ 的表示最高位为 $1$。实际上，就是将向量切成了两半。<br/>对于结果 $C = (C_0, C_1)$ 而言，在不考虑最高位的情况下，$A_0$、$A_1$、$B_0$ 和 $B_1$ 任意求卷积都是可以对 $C_0$ 和 $C_1$ 有贡献的 (卷积后一个向量加法累计贡献)。但是此处我们需要考虑最高位，那么就会有一定的限制，也就是下标的运算结果的限制。<br/>不难发现，这实际上退化为了 $n = 2$ 的情况，这里用之前的方法来表示：<br/>$$<br/>T_1<br/>\\left[<br/>\\begin{matrix}<br/>T_{m-1} A_0 \\\\<br/>T_{m-1} A_1<br/>\\end{matrix}<br/>\\right]<br/>\\cdot<br/>T_1<br/>\\left[<br/>\\begin{matrix}<br/>T_{m-1}B_0 \\\\<br/>T_{m-1}B_1<br/>\\end{matrix}<br/>\\right]<br/>=<br/>T_1<br/>\\left[<br/>\\begin{matrix}<br/>T_{m-1}C_0 \\\\<br/>T_{m-1}C_1<br/>\\end{matrix}<br/>\\right]<br/>\\tag{2.15}<br/>$$<br/>对于逆变换也是一样。<br/>于是可以得知：<br/>$$<br/>T_m = T_1<br/>\\left[<br/>\\begin{matrix}<br/>T_{m-1} \\\\<br/>T_{m-1}<br/>\\end{matrix}<br/>\\right]<br/>\\tag{2.16}<br/>$$<br/>但实际上已经没有意义啦！因为 $(2.15)$ 就是一个分治计算的过程，并且它的复杂度是：<br/>$$<br/>T(n) = 2T(n / 2) + \\Theta(n) = \\Theta(n\\log n)<br/>\\tag{2.17}<br/>$$<br/>于是我们获得了 FWT 算法3！<br/>FWT 算法<br/>前面 BB 了一大段，现在来梳理一下：<br/><br/>我们计算 $TA$ 和 $TB$。<br/>然后答案就是 $T^{-1}(TA \\cdot TB)$。<br/><br/>如何计算 $TA$ 和 $T^{-1}A$？根据 $(2.15)$ 式，我们先要按最高位分成两个向量，对于每一个子向量，递归计算其经过变换后的结果。然后根据 $T_1$ 来合并结果。<br/>以异或运算为例，假设我们钦定了使用这个矩阵作为我们的变换：<br/>$$<br/>T =<br/>\\left[<br/>\\begin{matrix}<br/>1 & 1 \\\\<br/>1 & -1 \\\\<br/>\\end{matrix}<br/>\\right]<br/>\\tag{3.1}<br/>$$<br/>那么合并的过程就是这样4：<br/>$$<br/>TA = (TA_0 + TA_1, TA_0 - TA_1)<br/>\\tag{3.2}<br/>$$<br/>你只用按照矩阵的形式来计算就可以了。<br/>对于逆变换，就是这样合并：<br/>$$<br/>T^{-1} A = \\left({T^{-1}A_0 + T^{-1}A_1 \\over 2}, {T^{-1}A_0 - T^{-1}A_1 \\over 2}\\right)<br/>\\tag{3.3}<br/>$$<br/>具体实现<br/>为了方便理解，在这里给出用 Python 编写的 FWT 算法，依然是异或的例子。<br/>递归形式<br/>递归形式简单粗暴，容易编写。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29<br/>30<br/>31<br/>32<br/>33<br/>34<br/>35<br/>36<br/>37<br/>38<br/>39<br/>40<br/>41<br/>42<br/>43import numpy<br/><br/>def fwt(X):<br/>    \ \ \ 正变换，返回TX<br/>    X: 输入向量<br/>    \ \ \ <br/><br/>    if len(X) == 1:<br/>        return X<br/><br/>    m = len(X) // 2<br/>    A0 = fwt(X[:m])<br/>    A1 = fwt(X[m:])<br/>    return numpy.array(*(A0 + A1), *(A0 - A1))<br/><br/>def rfwt(X):<br/>    \ \ \ 逆变换，返回T^{-1}X<br/>    X: 输入向量<br/>    \ \ \ <br/><br/>    if len(X) == 1:<br/>        return X<br/><br/>    m = len(X) // 2<br/>    A0 = rfwt(X[:m])<br/>    A1 = rfwt(X[m:])<br/>    return numpy.array(*((A0 + A1) / 2), *((A0 - A1) / 2))<br/><br/>def product(A, B):<br/>    \ \ \ 计算卷积<br/>    A, B: 输入向量<br/>    \ \ \ <br/><br/>    TA = fwt(A)<br/>    TB = fwt(B)<br/>    TC = TA * TB<br/>    return rfwt(TC)<br/><br/># 调用<br/>print(product(<br/>    numpy.array([1, 2, 3, 4]),<br/>    numpy.array([2, 3, 3, 3])<br/>))  # [29, 28, 27, 26]<br/><br/><br/>迭代形式<br/>与快速傅里叶变换类似，FWT 也可以改写为迭代的版本，具体的原理可以参见快速傅里叶变换的实现：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28import copy<br/>import numpy<br/><br/>def iterative_fwt(X):<br/>    A = copy.deepcopy(X)<br/>    s = 2<br/>    while s <= len(X):<br/>        for i in range(0, len(X), s):<br/>            for j in range(0, s // 2):<br/>                tmp = A[i + j]<br/>                A[i + j] += A[i + j + s // 2]<br/>                A[i + j + s // 2] = tmp - A[i + j + s // 2]<br/>        s *= 2<br/><br/>    return A<br/><br/>def iterative_rfwt(X):<br/>    A = copy.deepcopy(X)<br/>    s = 2<br/>    while s <= len(X):<br/>        for i in range(0, len(X), s):<br/>            for j in range(0, s // 2):<br/>                tmp = A[i + j]<br/>                A[i + j] = (A[i + j] + A[i + j + s // 2]) / 2<br/>                A[i + j + s // 2] = (tmp - A[i + j + s // 2]) / 2<br/>        s *= 2<br/><br/>    return A<br/><br/><br/>当然这里给出版本不是常数上效率最高的，大家可以根据实际情况改写代码。<br/>其他的位运算<br/>之前一直在讨论异或，没有关注与运算和或运算。因为它们的推导过程是一样的。这里就不重复其过程了。<br/>对于与运算而言：<br/>$$<br/>T =<br/>\\left[<br/>\\begin{matrix}<br/>1 & 1 \\\\<br/>0 & 1 \\\\<br/>\\end{matrix}<br/>\\right] \\\\<br/>T^{-1} =<br/>\\left[<br/>\\begin{matrix}<br/>1 & -1 \\\\<br/>0 & 1 \\\\<br/>\\end{matrix}<br/>\\right]<br/>\\tag{5.1}<br/>$$<br/>对于或运算而言：<br/>$$<br/>T =<br/>\\left[<br/>\\begin{matrix}<br/>1 & 0 \\\\<br/>1 & 1 \\\\<br/>\\end{matrix}<br/>\\right] \\\\<br/>T^{-1} =<br/>\\left[<br/>\\begin{matrix}<br/>1 & 0 \\\\<br/>-1 & 1 \\\\<br/>\\end{matrix}<br/>\\right]<br/>\\tag{5.2}<br/>$$<br/>实现它们的位运算卷积就只用修改合并的过程即可。<br/>其他运用<br/>子集和<br/>现在是时候来看一下或卷积了，按照之前方法，求出或卷积变换的一种形式。这里我们关注的是 $(5.2)$ 中的变换。FWT 算法运行过程中，是从低位到高位的顺序进行合并的。我们还是按照某一位来划分序列 $A = (A_0, A_1)$，那么 $TA$ 就是 $(A_0, A_0 + A_1)$，不难发现，原来的 $A_1$ 部分加上了 $A_0$，也就是相当于一个集合里面少了一个元素的集合的值被加了过来，这些集合都是自己的子集。因此，这样的 FWT 算法实际上计算的是下面这个东西：<br/>$$<br/>H(S) = \\sum_{T \\subseteq S} A(T) \\tag{6.1}<br/>$$<br/>这就是子集和变换。同时利用 $T^{-1}$，我们可以根据 $H$ 来算出 $A$。关系运算符 “$\\subseteq$” 是偏序，根据莫比乌斯反演5，我们得知逆 FWT 算的是：<br/>$$<br/>\\begin{aligned}<br/>A(S) & = \\sum_{T \\subseteq S} \\mu(T)H(S - T) \\\\<br/>& = \\sum_{T \\subseteq S} (-1)^{|T|}H(S - T)<br/>\\end{aligned} \\tag{6.2}<br/>$$<br/>即逆子集和变换。计算它们的时间复杂度都是 $\\Theta(n \\log n)$。<br/>子集卷积<br/>利用或卷积，我们可以干些更有趣的事情，那就是子集卷积：对于两个向量 $F= (f_0, f_1, ..., f_{n-1})$ 和 $G = (g_0, g_1, ..., g_{n-1})$，它们的子集卷积 $H = F \\times G$ 为：<br/>$$<br/>H(S) = \\sum_{T \\subseteq S} F(T)G(S - T) \\tag{7.1}<br/>$$<br/>记 $k = \\Theta(\\log n)$，如果直接两边同时枚举计算，其复杂度为 $\\Theta(n^2)$。如果先枚举 $S$，再枚举 $S$ 的子集 $T$，那么实际上我们只枚举了 $\\sum_{j = 0}^k \\binom{k}j 2^j = (1 + 2)^k = 3^k$ 次。为了能够降低复杂度，我们可以尝试使用 FWT 算法。容易看出，或卷积与子集卷积最为相似。我们可以把子集卷积等价地写成下面的形式：<br/>$$<br/>H(S) = \\sum_{X \\subseteq S} \\sum_{Y \\subseteq S} [X \\cup Y = S][X \\cap Y = \\varnothing] F(X)G(Y) \\tag{7.2}<br/>$$<br/>而或卷积可以等价地写成这样的形式：<br/>$$<br/>H(S) = \\sum_{X \\subseteq S} \\sum_{Y \\subseteq S} [X \\cup Y = S] F(X)G(Y) \\tag{7.3}<br/>$$<br/>与子集卷积相比，只是少了一个交集为空的条件。为了能够解决这个条件，我们可以从集合的大小下手。主要原因是大小只有 $\\Theta(\\log n)$ 种，并且 $|A \\cup B| \\leqslant |A| + |B|$（当且仅当 $A$ 与 $B$ 无交集时取等），这样一来就可以按照大小分类进行 FWT。<br/>具体的做法如下，首先令：<br/>$$<br/>F_k(S) = \\begin{cases}<br/>F(S) & (|S| = k) \\\\<br/>0 & (\\text{otherwise})<br/>\\end{cases} \\tag{7.4}<br/>$$<br/>类似的方法定义 $G_k$、$H_k$。令元素个数为 $k = \\Theta(\\log n)$，枚举 $i$ 和 $j$ 满足 $i + j = l$，将 $F_i$ 和 $G_j$ 进行或卷积后贡献给 $H_l$，最后将 $H_0$ 到 $H_k$ 全部加起来就是子集卷积后的 $H$。这里需要注意的是，$F_i$ 和 $G_j$ 的卷积不必每次都做 FWT 和逆 FWT 变换，就像多项式乘法一样，经过 FWT 之后的序列之间的点积就是原序列的卷积，序列之间的加法还是原序列的加法。因此最终的复杂度是 $\\Theta(2^k k^2) = \\Theta(n \\log^2 n)$。<br/>下面是我的 Python 2 实现：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29<br/>30<br/>31<br/>32<br/>33<br/>34<br/>35<br/>36<br/>37<br/>38<br/>39<br/>40<br/>41<br/>42<br/>43<br/>44<br/>45<br/>46<br/>47<br/>48<br/>49<br/>50<br/>51<br/>52<br/>53<br/>54<br/>55<br/>56<br/>57<br/>58<br/>59<br/>60<br/>61<br/>62<br/>63<br/>64<br/>65<br/>66<br/>67<br/>68<br/>69<br/>70<br/>71<br/>72<br/>73<br/>74n = int(raw_input())<br/>assert n & (n - 1) == 0, 'Argument \ n\  must be a power of 2.'<br/><br/>f = map(int, raw_input().split())<br/>g = map(int, raw_input().split())<br/><br/>def fwt(X):<br/>    if len(X) == 1:<br/>        return X<br/><br/>    m = len(X) >> 1<br/>    A, B = fwt(X[:m]), fwt(X[m:])<br/>    for i in xrange(m):<br/>        A.append(A[i] + B[i])<br/>    return A<br/><br/>def rfwt(X):<br/>    if len(X) == 1:<br/>        return X<br/><br/>    m = len(X) >> 1<br/>    A, B = rfwt(X[:m]), rfwt(X[m:])<br/>    for i in xrange(m):<br/>        A.append(B[i] - A[i])<br/>    return A<br/><br/>def cnt(x):<br/>    r = 0<br/>    while x:<br/>        x ^= x & (-x)<br/>        r += 1<br/>    return r<br/><br/>def add(A, B):<br/>    return [A[x] + B[x] for x in xrange(len(A))]<br/><br/>def mul(A, B):<br/>    return [A[x] * B[x] for x in xrange(len(A))]<br/><br/>def show(X):<br/>    print ' '.join(map(str, X))<br/><br/>k = cnt(n - 1) + 1<br/>F = [[0] * n for i in xrange(k)]<br/>G = [[0] * n for i in xrange(k)]<br/>H = [[0] * n for i in xrange(k)]<br/><br/># 按照大小分组<br/>for i in xrange(n):<br/>    c = cnt(i)<br/>    F[c][i] = f[i]<br/>    G[c][i] = g[i]<br/><br/># 提前进行 FWT<br/>for i in xrange(k):<br/>    F[i] = fwt(F[i])<br/>    G[i] = fwt(G[i])<br/><br/># 卷积部分<br/>for i in xrange(k):<br/>    for j in xrange(k - i):<br/>        print i, j<br/>        H[i + j] = add(H[i + j], mul(F[i], G[j]))<br/><br/>for i in xrange(k):<br/>    H[i] = rfwt(H[i])<br/><br/># 计算结果<br/>R = [0] * n<br/>for i in xrange(n):<br/>    c = cnt(i)<br/>    R[i] = H[c][i]<br/><br/>show(R)<br/><br/><br/><br/><br/><br/><br/>当然需要保证添加完 $0$ 后结果的界不变。数值上不会有影响。 ↩<br/><br/><br/>为什么不直接将$m$和$n$设为$0$？因为那样太naïve了，你得到的$T$是零矩阵。 ↩<br/><br/><br/>有时也称 FWHT。 ↩<br/><br/><br/>由于我们已经得到了矩阵，所以这个变换是线性变换，你可以有其它的写法。 ↩<br/><br/><br/>可以参见我的博客。 ↩<br/><br/><br/>","tags": "位运算卷积 FWT","url": "blog/2016-11-25/fwt.html"},
{"title": "公平组合游戏","text": "公平组合游戏<br/>应该是2016年的最后一篇博客了，Goodbye 2016！<br/>定义<br/>公平组合游戏与平常的游戏类似，但是需要满足以下要求：<br/><br/>有两个玩家轮流行动。<br/>双方的游戏方式一致。<br/>双方均知道游戏的完整信息。<br/>以玩家无法行动为游戏结束。<br/>游戏在有限步数内结束，并且一定能分出胜负。<br/><br/>经典的Nim游戏就是公平组合游戏的代表，但是围棋、象棋以及井字棋这些不属于，因为这三种双方的行动不同。而且像井字棋，可能存在平局。<br/>简单Nim游戏<br/>现在通过一个简单的Nim游戏来介绍一些概念。这个Nim游戏规定如下：<br/><br/>一开始有$n$个石子。<br/>双方轮流取石子，必须取一颗或两颗。<br/>无法取石子者失败。<br/><br/>对于这个游戏，我们想知道，在双方都十分聪明的情况下，先手/后手是否必胜。或者给出一个必胜的策略。<br/>我们可以简单分析一下。以先手为例，如果没有石子，那么一开场就算输。如果只有一颗或两颗石子，那么先手可以马上取走并获得胜利。然而，当有$3$颗石子时，你会发现无论怎么取，先手都会输掉比赛，因为无法一次取走所有的石子，而后手在你取完一次之后，相当于变成了石子数为$1$或$2$的先手，那么后手必赢。<br/>实际上，当$n \\;\\mathrm{mod}\\; 3 = 0$的时候，先手会必输，否则后手必输，此时先手只用保证每次自己取完之后石子的数量都是$3$的倍数即可。<br/>必胜与必败<br/>我们规定一个位置 (例如上面的Nim游戏中石子的个数) 是$\\mathrm{N}$点是当此时先手的人必胜的位置，而$\\mathrm{P}$点则是此时先手的人必输的位置1。例如，当$n = 0$时 (下面简写为$0$)，先手是必输的。因此$0$是$\\mathrm{P}$点。而在$1$和$2$时，先手会必胜，所以它们是$\\mathrm{N}$点。<br/>简单分析可知：<br/><br/>终止位置是$\\mathrm{P}$点。<br/>所能到达的位置都是$\\mathrm{N}$点的位置是$\\mathrm{P}$点。<br/>能够到达$\\mathrm{P}$点的位置是$\\mathrm{N}$点。<br/><br/>例如，在$3$这个位置，取走一个石子会到达$2$这个位置，取走两个石子会到达$1$这个位置，而这两个位置都是$\\mathrm{N}$点，所以$3$是$\\mathrm{P}$点。因此$3$个石子时先手必败。<br/>图的表示<br/>如果将每个位置用点表示，而位置之间的转移用有向边表示，那么$0$到$3$之间的关系可以由下图表示：<br/><br/>由于游戏是有限步数的，所以这张图必须是拓扑图。在这图上，我们可以将所有没有出边的点标记为$\\mathrm{P}$点，然后根据上面的规则就可以辨识所有的位置是$\\mathrm{N}$点还是$\\mathrm{P}$点。由此也可以看出，一个公平组合游戏必定能分出胜负。<br/>Sprague-Grundy定理<br/>现在我们将位置用图$G(V, E)$上的点表示，对于一个点$u$，那么定义它的SG函数$g$为：<br/>$$<br/>g(u) = \\mathrm{mex}(\\{g(v) : \\forall (u, v) \\in E\\})<br/>$$<br/>$\\mathrm{mex}$是定义域在集合上的函数，返回这个集合中最小的没出现过的非负整数。<br/>例如：<br/>$$<br/>\\begin{aligned}<br/>& \\mathrm{mex}(\\varnothing) & = 0 \\\\<br/>& \\mathrm{mex}(\\{0\\}) & = 1 \\\\<br/>& \\mathrm{mex}(\\{0, 1, 2, 4, 5\\}) & = 3<br/>\\end{aligned}<br/>$$<br/>因此，对于没有出边的点，其$g$值为$0$。另一方面，这些点都是$\\mathrm{P}$点。如果我们计算之前出现的图中的$g$值：<br/><br/>上图中$0$和$3$都是$0$，$1$和$2$都不是$0$。十分巧合的是，$0$和$3$是$\\mathrm{P}$点，$1$和$2$是$\\mathrm{N}$点。<br/>对此，我们可以证明下面一点：<br/><br/>位置$p$是$\\mathrm{P}$点当且仅当$g(p) = 0$。<br/><br/>证明：首先对于没有出边的点，它们是$\\mathrm{P}$点，并且其$g$值为$0$。同时，所有能到达的这些点的点，其$g$值$\\gt 0$，并且为$\\mathrm{N}$点。<br/>对于其他的点，如果是$\\mathrm{N}$点，那么它一定能到达一个$\\mathrm{P}$点，所以其$g$值不能为$0$。如果是$\\mathrm{P}$点，那么它所能到达的点都是$\\mathrm{N}$点，这些点中没有谁的$g$值是$0$，所以其$g$值为$0$。<br/>这样我们拥有了一个量化胜负的函数。但是对于上面这个简单Nim游戏并没有什么好处，因为上面的计算完全可以利用逻辑运算而不需要计算什么$\\mathrm{mex}$。<br/>多数情况下，你所见到的所谓Nim游戏并没有这么简单：它通常有许多堆石子，允许任意取走 (或是取走指定数量的石子)，此时再去问你先手是必胜还是必败。<br/>这并没有什么难的，我们依然可以将许多堆石子放入多元组来构成一个位置，然后依然可以计算这个位置是$\\mathrm{N}$点还是$\\mathrm{P}$点。但是，当石子数量比较多时，这个位置的增长几乎是不可接受的。<br/>事实上，即使是多堆石子，它依然可以分解为多个一堆的Nim游戏，每次行动时，玩家可以任意选择其中一个游戏来行动。不妨用$G_1(V_1, E_1)$和$G_2(V_2, E_2)$两张图来表示两个公平组合游戏，那么定义$G(V, E) = G_1 + G_2$为游戏的组合，即新游戏$G$可以每一步在$G_1$中行动，或是在$G_2$中行动。我们需要将两张图加合为一张图，所以对于$u \\in V_1$和$v \\in V_2$的两个点，在$G$中将变为一个点$(u, v)$。同时和$u$、$v$相关的边都连向这个点。<br/>可是，多数情况下，我们不会关心这个图是什么样的，因为它实在是太复杂了。但是却有一个很好的性质：<br/><br/>(Sprague-Grundy定理)<br/>令$G = G_1 + G_2 + \\cdots + G_n$，设$G_i$的SG函数为$g_i$，$G$的SG函数为$g$，那么有：<br/>$$ g(X) = g((x_1, x_2, \\dots, x_n)) = g_1(x_1) \\oplus g_2(x_2) \\oplus \\cdots \\oplus g_n(x_n) $$<br/>其中$X \\in V, x_i \\in V_i$，$\\oplus$是异或运算。<br/><br/>证明：在这里不再介绍异或了，如果不了解的可以先去看一下。<br/>根据SG函数的定义，我们只用证明以下两点就可以完成整个定理的证明：<br/>设$b = g_1(x_1) \\oplus g_2(x_2) \\oplus \\cdots \\oplus g_n(x_n)$。<br/><br/>对于所有的$0 \\leqslant a \\lt b$，$X$一定存在一个可以到达的位置，满足其$g$值为$a$。<br/>对于所有$X$所可以到达的位置，没有$g$值为$b$。<br/><br/>证明$(1)$：设$d = a \\oplus b$。设$d$的二进制表示的最高位的位置为$k$。由于$a \\lt b$，所以一定有$a$的第$k$位为$0$，并且$b$的第$k$位为$1$。由于$b = g_1(x_1) \\oplus g_2(x_2) \\oplus \\cdots \\oplus g_n(x_n)$，那么一定存在一个$g_i(x_i)$的第$k$位为$1$。不失一般性，设$i = 1$，那么可以知道$d \\oplus g_1(x_1) \\lt g_1(x_1)$，所以存在一个位置$x^\\prime_1$能够从$x_1$转移过来，并且满足$g_1(x^\\prime_1) = d \\oplus g_1(x_1)$。这相当于在$G_1$中行动一步，所以$(x_1, x_2, \\dots, x_n)$也存在一个转移到$(x^\\prime_1, x_2, \\dots, x_n)$的行动，而此时有：<br/>$$<br/>\\begin{aligned}<br/>a & = g_1(x^\\prime_1) \\oplus g_2(x_2) \\oplus \\cdots \\oplus g_n(x_n) \\\\<br/>& = d \\oplus g_1(x_1) \\oplus g_2(x_2) \\oplus \\cdots \\oplus g_n(x_n) \\\\<br/>& = d \\oplus b<br/>\\end{aligned}<br/>$$<br/>所以$(1)$成立。<br/>证明$(2)$：不失一般性，假设我们在$G_1$中从$x_1$行动到$x^\\prime_1$，那么根据SG函数的定义，有$g_1(x_1) \\neq g_1(x^\\prime_1)$，所以$b \\oplus g_1(x_1) \\oplus g_1(x^\\prime_1) \\neq b$，所以$(2)$成立。<br/>至此，我们已经成功证明了Sprague-Grundy定理。现在我们尝试将其运用到Nim游戏上：<br/>首先对于一堆石子的情况，由于取走任意数量不为$0$的石子，所以只要不是没有石子，先手可以一次取完。简单推理可以知道$g(n) = n$。即只要有石子就先手必胜。<br/>现在我们有许多堆石子，每一堆石子都可以视为一个Nim游戏，那么这个游戏就是许多Nim游戏加合。根据Sprague-Grundy定理，如果每一堆石子的个数为$x_i$，那么SG函数就是：<br/>$$<br/>\\begin{aligned}<br/>g((x_1, x_2, \\dots, x_n)) & = g(x_1) \\oplus g(x_2) \\oplus \\cdots \\oplus g(x_n)  \\\\<br/>& = x_1 \\oplus x_2 \\oplus \\cdots \\oplus x_n<br/>\\end{aligned}<br/>$$<br/>换言之，如果每堆石子数异或起来如果不为$0$，那么先手就必胜，否则将会必败。这确实是一个非常神奇的结论。同时，结合之前关于$\\mathrm{N}$点和$\\mathrm{P}$的一些讨论，我们知道只要能使异或和变为$0$的操作就是我们的先手必胜策略。<br/><br/><br/><br/><br/>N意为”Next”，即执行这一步的人会赢。P意为”Previous”，即执行上一步的人会赢。 ↩<br/><br/><br/>","tags": "公平组合游戏 Sprague-Grundy定理 SG函数 博弈论","url": "blog/2016-12-30/sg.html"},
{"title": "关于","text": "关于<br/>riteme 来自 HNSDFZ / FDU。<br/>sitegen.py<br/>使用 Python 3 编写的不清真站点生成器。<br/>参见左侧栏 “GitHub 项目”。<br/>需要的依赖：<br/><br/>Python 3 (>= 3.4)<br/>Python Markdown<br/>Pygments (用于提供代码高亮)<br/>Beautiful Soup 4<br/><br/>独立模块功能：<br/><br/>info: 提取文档基本信息 (右上角)。<br/>navigater: 辅助文件夹导航。<br/>parser: Markdown 阶段预处理特殊语法。<br/>tag: 标签生成。<br/>tipuesearch: 生成 Tipuesearch 的搜索数据。<br/>tocer: 提取并生成目录。<br/><br/>可执行工具：<br/><br/>pagegen.py: 用于生成单个页面。<br/>sitegen.py: 用于生成整个网站。<br/>setup.py: 简单网站架设工具。<br/><br/>Material Design<br/>使用的是功能比较简单的 Material Design Lite，而且版本已经比较老了QAQ。<br/>主题风格都是我自己 xjb 调的。<br/>目前页面上还是有一些已知的小问题，有些是老版本 MDL 的锅，实在是没精力换框架了 TAT。<br/>数学公式<br/>使用 MathJax 和 KaTeX。<br/>以后计划抛弃笨重的 MathJax，换用清真的 KaTeX。<br/>正在尝试 KaTeX......但现实很残酷，KaTeX 容错性实在不行，因此变成了浏览者可在 MathJax 和 KaTeX 之间二选一。<br/>实际上 KaTeX 能够无错渲染的文章真的不多...... KaTeX 0.10.0 版本大赞！<br/>站内搜索<br/>使用 Tipuesearch。<br/>Tipuesearch 有个缺点就是需要浏览器将搜索数据下载下来。而这个文件通常很大。以后可能会考虑换成其它的东西。<br/>评论<br/>使用 Gitment。<br/>自行魔改了下 JS 文件给汉化了。不知道现在 Gitment 自己有没有提供多语言支持。<br/>友链<br/>欢迎互换友链 ~ ~ ~<br/>想换友链的可以直接在评论里留言 ~ ~ ~<br/>联系我<br/>我的邮箱：riteme@qq.com<br/>我的 GitHub：https://github.com/riteme<br/>我的知乎：https://www.zhihu.com/people/riteme","tags": "About","url": "about.html"},
{"title": "凸包相关","text": "凸包相关<br/>定义<br/>通常说的凸包是指一个点集的凸包，并且是指在二维平面上1。这种凸包本身是一个凸多边形，由点集中的点构成，并且要求凸包上的点尽可能少。下面是一个凸包的示例：<br/><br/>对于其它的图形，也可以有凸包，如线段的凸包：<br/><br/>实际上线段的凸包就是所有线段的端点的凸包。更一般的，多边形的凸包就是所有多边形的顶点的凸包。<br/>而曲线图形的凸包则没有这么简单，从圆的凸包就可见一窥：<br/><br/>下面的文章将不讨论与曲线相关的凸包。<br/>特别的，当点集里只有两个点时，凸包退化为一条线段。只有一个点时，退化为一个点。<br/>同时需要注意多点共线和多点重合而导致的凸包退化现象。<br/>构造算法<br/>在计算几何里面，计算凸包就跟排序一样十分经典，至今已经研究出了许多算法。它们中的绝大部分可以在维基百科上看到，这里只介绍Javis步进法、水平扫描线法和Graham扫描法。<br/>Jarvis步进法 (Gift Wrapping)<br/>Jarvis步进法可以看作是给点集包上包装纸，最后算出凸包的。算法过程非常简单：<br/><br/>找出最左下和最右上的两个点，记为$p_1$、$p_2$，它们一定是凸包上的点。<br/>设$p_1$为当前点，每次从剩下的点中找出以当前点为原点极角最小的点，将其加入凸包，并设为当前点。重复这一步骤，直到遇到$p_2$。这样完成了凸包右边的构造。<br/>与第二步相似，构造凸包的左边（每一步寻找极角最大的点）。<br/><br/>以下面的点集为例：<br/><br/>首先找到左下和右上两个点：<br/><br/>构建右凸包：<br/><br/><br/>构建左凸包：<br/><br/><br/><br/>至此，凸包构建完毕。<br/>由于Jarvis步进法中凸包每一个点都需要对剩下的点进行处理，所以该算法的时间复杂度为$\\Theta(nh)$，其中$h$是凸包的规模。最坏情况下为$\\Theta(n^2)$。由于当点在一个有限矩形内随机分布时凸包的期望规模为$O(\\log n)$，所以在这种情况下，该算法的时间复杂度为$O(n\\log n)$。<br/>下面是其伪代码：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29<br/>30<br/>31<br/>32<br/>33<br/>34<br/>35<br/>36<br/>37<br/>38<br/>39<br/>40<br/>41<br/>42<br/>43<br/>44<br/>45<br/>46<br/>47<br/>48function JARVIS(Q):  # Q是点集<br/>    if |Q| <= 3:  # 点数不大于3<br/>        return Q<br/><br/>    p1, p2 = nil<br/>    for p in Q:<br/>        if p1 == nil or ( p.y < p1.y or p.y == p1.y and p.x < p1.x ):<br/>            p1 = p<br/>        if p2 == nil or ( p.y > p2.y or p.y == p2.y and p.x < p2.x ):<br/>            p2 = p<br/><br/>    # 使用叉积来比较极角大小<br/>    CH = [p1, p2]  # 凸包<br/>    Q.pop(p1, p2)  # 删除p1, p2<br/><br/>    # 右凸包<br/>    x = p1<br/>    while true:<br/>        y = Q[0]<br/>        for p in Q[1:]:<br/>            if cross(y - x, p - x) < 0 or<br/>               cross(y - x, p - x) == 0 and |y - x| < |p - x|:  # 共线<br/>                y = p<br/><br/>        if y == p2:<br/>            break<br/><br/>        CH.append(y)<br/>        Q.pop(y)<br/>        x = y<br/><br/>    # 左凸包<br/>    x = p1<br/>    while true:<br/>        y = Q[0]<br/>        for p in Q[1:]:<br/>            if cross(y - x, p - x) > 0 or<br/>               cross(y - x, p - x) == 0 and |y - x| < |p - x|:  # 共线<br/>                y = p<br/><br/>        if y == p2:<br/>            break<br/><br/>        CH.append(y)<br/>        Q.pop(y)<br/>        x = y<br/><br/>    return CH<br/><br/><br/>水平扫描线法<br/>计算几何中，扫描线是一种常用的方法。我们也可以使用扫描线来计算凸包。<br/>我们可以从左至右扫描每一个点来更新凸包。可以确定，最左边和最右边的点都是凸包上的点。因此利用扫描线来分别计算上下凸包。<br/>算法步骤如下：<br/><br/>将所有点按照$x$排序。<br/>对于每一组$x$相同的点，仅保留$y$值最大和最小的点。<br/>取出最左和最右作为基点，用于判断其它的点是在上凸包还是下凸包。<br/>从左至右扫描每一个点，根据基点利用叉积计算该点是应插入上凸包还下凸包，将其插入对应的凸包中。然后从这个点开始向前访问，如果和之前的点形成内凹的形状（可以利用叉积判断），就将之前的点删除。直到不存在这样的形状为止。<br/><br/>下面展示了一个水平扫描线的示例：<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>开始从上凸包中删除点：<br/><br/><br/><br/><br/><br/>由于每个点只会被访问1次，点在栈中只会被弹出一次，所以扫描线的部分是$\\Theta(n)$的。但排序需要$O(n\\log n)$的时间，所以总复杂度是$O(n\\log n)$的。是一个非常不错的算法。<br/>伪代码如下：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28function SCANLINE(Q):<br/>    if |Q| <= 3:<br/>        return Q<br/><br/>    sort Q by order of x<br/>    foreach x keeps the highest and lowest points<br/><br/>    p1, p2 = Q[0], Q[-1]<br/>    CH1 = []<br/>    CH2 = []<br/>    for p in Q:<br/>        if p == p1:  # 起点<br/>            CH1.append(p)<br/>            CH2.append(p)<br/>            continue<br/>        if p == p2 or  # 终点<br/>           cross(p2 - p1, p - p1) >= 0:  # 在上凸包<br/>            while |CH1| > 1 and cross(CH1[-1] - CH1[-2], p - CH1[-2]) >= 0:<br/>                CH1.pop()<br/>            CH1.append(p)<br/>        if p == p2 or<br/>           cross(p2 - p1, p - p1) < 0:  # 在下凸包<br/>            while |CH2| > 1 and cross(CH2[-1] - CH2[-1], p - CH2[-2]) <= 0:<br/>                CH2.pop()<br/>            CH2.append(p)<br/><br/>    merge CH1, CH2 into CH<br/>    return CH<br/><br/><br/>Graham扫描法<br/>计算凸包的另外一种算法就是Graham扫描法，也可以视为是旋转扫描线的运用。类似于Jarvis步进法这种不断包裹形成凸包的方法，Graham扫描法首先选出一个肯定在凸包上的点作为基点，然后将其它点进行极角排序，按照极角序的顺序来扫描。并且按照水平扫描线算法中删除先前的点的方法来不断更新凸包。<br/>Graham算法有一个好处，就是最终得到的凸包还是按照极角序排列的，不需要再次排序，方便后续的处理。<br/>算法步骤如下：<br/><br/>选出最左下的点作为基点<br/>以基点为原点，其它点按照极角逆时针排序。对于极角相同的点，保留与基点距离最远的点。<br/>维护一个栈，依次访问每一个点，检查之前的点是否与其形成了凹陷的形状（利用叉积判断），如果有就从栈中退掉一个点。否则将该点压入栈中。<br/>最后栈中元素就是凸包<br/><br/>下面给出了一个示例：<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>图上依次连接的线表示栈中的元素。<br/>对于Graham扫描法的时间复杂度，与水平扫描线的分析一致，关键在于排序的时间复杂度。<br/>该算法总体复杂度为$O(n\\log n)$。<br/>下面是该算法的伪代码：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17function GRAHAM-SCAN(Q):<br/>    if |Q| <= 3:<br/>        return Q<br/><br/>    select the base point p1<br/><br/>    sort Q by polar angle order, when meets the same polar angle,<br/>    keep the furthest one.<br/><br/>    CH = []<br/>    for p in Q[1:]:<br/>        while |Q| > 1 and<br/>              cross(Q[-1] - Q[-2], p - Q[-2]) <= 0:<br/>            CH.pop()<br/>        CH.append(p)<br/><br/>    return CH<br/><br/><br/>小结<br/>上面介绍了三种凸包构造算法，其中水平扫描线法和Graham扫描法是最为常用和高效的算法。<br/>这两种算法中的扫描线方法可以被单独拿出来使用，因而可以做进一步扩展（如下面将提到的动态凸包问题）<br/>扩展与应用<br/>动态凸包<br/>动态凸包是指要求实现动态插入点并维护点集凸包的问题，目前好像还没有支持在线2删除点的高效算法。<br/>目前流行的两种动态凸包算法来源于之前的两种凸包算法：水平扫描线法和Graham扫描法。<br/>水平序<br/>第一种是来源于水平扫描线的算法。我们用两棵平衡树来维护上下两个凸包，均按照$x$排序。<br/>每次插入点之前，先要判断点是否在凸包内部。首先二分出该点所在的上凸包或下凸包的左右两个点，然后利用叉积来判断是否在凸包外。注意这里有几个边界情况：<br/><br/>点超出了凸包的最左边和最右边时要单独处理。<br/>点的$x$与最左边或最右边相同时需要考虑一下。<br/><br/>如果点在凸包内，那么凸包将不会被更新。否则就要考虑更新凸包。<br/>按照同样的方法，在平衡树上查找出该点在凸包上左边和右边的点，然后向左向右检查是否有违反凸包性质的凹陷形状，如果有，则删除对应的点。直到凸包性质得到维护。然后将该点插入即可。<br/>类似的，对于之前判断点是否在凸包内的边界情况，在这里就需要更加注意。<br/>由于有上下两个凸包，所以相似的代码需要写两遍......<br/>极角序<br/>第二种是来源于Graham扫描法的算法，这个算法与水平序相比边界更简单，代码也更短。<br/>该算法要求得到一个初始的凸包（至少两个点），并以这些点的中心作为原点，按照极角序3插入到平衡树中。<br/>与水平序类似，首先要查询点是否在凸包内部。同样，我们在平衡树中查找极角左右的点，并利用叉积判断是否在凸包内。注意我们期望这些点会按照一个环的方式存入，然而平衡树是链状数据结构。因此在边界处需要到另外一边寻找答案。<br/>如果查询的点与原点一样，就没有极角可言了，因此我们需要判断该点是否与原点一样。由于我们的原点必定在凸包内，所以可以直接判定。<br/>之后的插入与水平序一致，二分出左右点，并维护凸包性质即可。<br/>注意这里没有超出左右边界的情况，这就是极角序的一大优势。同时，极角序也只用维护一棵平衡树。<br/>具体实现<br/>[Codeforces 70D] Professor’s task<br/>这道题是非常良心的模板题，如果想实现动态凸包，可以到这里来测试。<br/>本人的代码由于是手写的向量和平衡树，所以代码相当长，就不在此以代码框的形式放出。有兴趣的可以点开下面的链接来看：<br/>水平序<br/>极角序<br/>旋转卡壳<br/>旋转卡壳是一类应用于凸多边形上的算法。由于凸包也是凸多边形，所以也可以用在凸包上。<br/>为了解释什么是旋转卡壳，首先来看一个经典的问题：<br/><br/>给你一个点集$Q$，求这个点集中最远4的两个点的距离。<br/><br/>该问题最为直接的方法是枚举这两个点对，然后计算距离。这样做的时间复杂度为$\\Theta(n^2)$。<br/>有没有一种更快的算法呢？首先可以注意到，最远的两个点一定在凸包上，因为如果它们不在凸包上，那么凸包实际上可以被扩大。<br/>这样我们就只用考虑凸包上的点了。对于凸包上的一个点，很直观的想法就是找到凸包另一边最远的点。<br/>这是就要用到旋转卡壳，我们用一对平行线”夹紧”这个凸包，这样被两条直线所压住的点之间就可能有最远点对。<br/><br/>由于当前所卡中的不一定就是最远点对，所以还需要继续寻找。<br/>而对每一条凸包上的边而言，都只有最远的点对其有效。<br/>所以可以想象其中一条直线不断的沿着凸包上的边进行旋转，而另一条直线则不断更新与之最远的点。<br/><br/>第一条直线的事情好办，关键在于第二条。由于凸包上的点到第一条直线的距离具有单调性，所以第二条直线可以沿着一个方向移动，从而到达合适的位置。<br/>当然需要注意一种边界情况：如果有两条平行的边，那么第二条直线可能卡中两个点5，这样就需要多枚举一些情况。<br/>按照这样的方法旋转一周，就可以对所有可能的点对完成枚举，极大地减少了枚举量。<br/>对于凸多边形的每一条边我们都要计算一次答案。如果计算答案的复杂度为$O(g(n))$，那么旋转卡壳的复杂度就是$O(ng(n))$。对于最远点对问题，我们可以在$\\Theta(n)$的时间内解决。<br/>旋转卡壳还有许多有趣的应用，很多情况下是用于解决点集和凸多边形上的问题。<br/>斜率优化<br/>斜率优化是一类应用在递推优化上的算法，它巧妙在于将看似没有规律的递推关系转为了二维平面上的线性规划问题。下面举一个简单的例子：<br/><br/>给你一个数组$A[1\\dots n]$和$B[1\\dots n]$　$(A[i],\\;B[i] > 0,\\;i\\in[1.\\;n])$，并给出$f(1)$和$f(2)$，已知$f$具有以下递推关系：<br/>$$ f(x) = \\max\\{A[x]f(i) + B[x]f(i - 1) \\mid i \\in [2,\\;x)\\} $$<br/>求$\\sum_{i=1}^nf(i)$。<br/><br/>首先，直接枚举的时间复杂度为$\\Theta(n^2)$，并不是很优。<br/>如果单纯是取最大值，这个问题就可以用线段树来解决。然而$\\max$中的东西简直莫名其妙，令人摸不着头脑。<br/>不妨从另外一个角度来考虑问题。对于当前的$x$而言，考虑之前的两个位置$j,\\;k \\in [2,\\;x)$ (假定$j \\lt k$)，什么时候$j$会比$k$更优（即可能取到最大值）。<br/>我们发现。只有下面的不等式成立时，$j$会比$k$更优：<br/>$$ A[x]f(j) + B[x]f(j - 1) \\gt A[x]f(k) + B[x]f(k - 1) $$<br/>由于$f(x)$是递增的，所以我们可以尝试对上式进行一些等价变形：<br/>$$ A[x](f(j) - f(k)) \\gt B[x](f(k - 1) - f(j - 1)) $$<br/>$$ {f(j) - f(k) \\over f(k-1) - f(j-1)} \\gt {B[x] \\over A[x]} \\tag{1} $$<br/>$$ {f(j) - f(k) \\over f(j-1) - f(k-1)} \\lt -{B[x] \\over A[x]} \\tag{2} $$<br/>回想一下直线斜率的计算公式，不难发现$(2)$式左边是一个计算斜率的形式，而右边是一个常量（对特定的$x$而言）。<br/>因此$(2)$式左边可以视为是两个点$(f(j-1),\\;f(j))$和$(f(k-1),\\;f(k))$的直线的斜率与$-B[x] / A[x]$的关系。<br/><br/>如上图所示，这个时候：<br/>$$ {f(j) - f(k) \\over f(j-1) - f(k-1)} \\gt -{B[x] \\over A[x]} $$<br/>故此时$j$不比$k$更优。<br/>可以注意到，对于这个问题，查询的斜率都是负数，所以只要两点间的斜率大于$0$，就可以有更优的调整。<br/>因此所有非上凸包的点都不比上凸包的点更优。<br/>于是我们就只用考虑上凸包的点了。<br/>由于上凸包的相邻两点间斜率是递减的，而我们的目标是查找到第一个小于$-B[x] / A[x]$的边，所以我们可以采用二分的方法！<br/>到此整个算法已经很妙了，只剩下一个问题，就是这些点并不是一开始就知道的。<br/>所以我们需要动态插入点并维护凸包，这就需要之前所提及的动态凸包。<br/>由于只需要上凸包，所以这里最好选用水平序，并且只需要维护一棵平衡树。<br/>这样这个问题我们就做到的$O(n\\log n)$的时间复杂度。<br/>事实上，机智的人可能发现这个问题并不需要这种高级的方法，然而这里只是为了解释什么是斜率优化。在真正复杂的地方，斜率优化还是有很大用处，并且形式也多变。<br/><br/><br/><br/><br/>凸包的定义可以扩展至高维。 ↩<br/><br/><br/>如果只需要删除且允许离线，则可以进行”时光倒流”，从后往前处理，这样就变成了插入。 ↩<br/><br/><br/>最好采用先象限后极角的方法，避免一些边界情况。 ↩<br/><br/><br/>最近点对问题的解决方法与之完全不同，通常是采用分治法。 ↩<br/><br/><br/>由于凸包上不允许出现同一条直线上出现多于两个点（因为要使凸包上的点尽可能少），所以不会同时卡中三个以上的点。 ↩<br/><br/><br/>","tags": "凸包 计算几何 数据结构 斜率优化 旋转卡壳","url": "blog/2016-8-11/convex-hull.html"},
{"title": "区间加多项式问题的研究","text": "区间加多项式问题的研究<br/>问题描述<br/>给定一个长度为 $n$，初始值全为 $0$ 的序列 $A[1..n]$，要求支持以下两种操作：<br/><br/>修改操作：每次给定一个区间 $[l, r]$ 以及一个 $K$ 次多项式 $P(x)$，要求将 $[l, r]$ 的第 $k$ 项加上 $P(k)$。也就是 $A[l + k - 1]$ 加上 $P(k)$，对于所有的 $1 \\leqslant k \\leqslant r - l + 1$。<br/>查询操作：查询操作分为两种 (i) 给定位置 $k$，要求输出 $A[k]$ 的值 （单点查询）; (ii) 给定区间 $[l, r]$，要求输出区间 $[l, r]$ 内所有数之和，即 $\\sum_{k = l}^r A[k]$（区间查询）。<br/><br/>记操作总数为 $q$，修改操作中多项式的最高次数为 $K$，并且 $K$ 与 $n$ 和 $q$ 相比较小。本文的目的是针对修改操作和区间查询给出一个 $O((n + q)K \\log n)$ 的在线算法以及一个 $O(qK \\log q)$ 的离线算法。<br/>解决方案<br/>在线算法<br/>我们可以首先考虑一个简化的修改操作：每次指定区间为 $[1..n]$，也就是整个序列。实际上我们只用保存一个多项式 $Q(x)$，每次修改操作就将 $P(x)$ 加到 $Q(x)$ 上，修改后的序列中 $A[k]$ 实际上就是 $Q(k)$。如果我们花费 $\\Theta(nK)$ 的时间来计算一个表 $F(n, k) = \\sum_{x = 1}^n x^k$，即 $x^k$ 的前缀和，就可以在单次 $\\Theta(K)$ 的时间内计算出 $A$ 的区间和。<br/>回到原先的问题，发现 $P(x)$ 不仅在序列中的起始位置变了，而且管辖范围也缩减到 $[l, r]$。为了尽可能简化问题，我们尝试对多项式进行处理。我们希望 $P(k)  = A[k]$ 而不是 $P(k) = A[l + k - 1]$，不难发现我们所需要做的，就是函数的平移：$P'(x) = P(x - l + 1)$。这样做的好处在于，修改操作变为了对整个序列的修改，但是只在指定的区间有作用。经过平移之后，不同的多项式可以按照之前的方式累加并且正确地计算结果，因此，只要配合平衡树或线段树之类的数据结构即可快速解决区间问题。具体而言，就是对序列的每一个位置维护一个多项式，修改时，将平移后的多项式 $P'(x)$ 加到区间 $[l, r]$ 上的每一个位置，并利用线段树上的节点来存储必要的信息用于计算区间和。这一部分的时间复杂度是 $O(qK \\log n)$，至于使用数据结构处理区间加的过程这里就不详细讨论了。<br/>现在的问题是我们需要得到 $P'(x)$ 的系数表达形式才能方便地加减。设 $P(x) = \\sum_{k = 0}^K a_k x^k$，以及平移量 $c$，那么 $P'(x) = P(x + c) = \\sum_{k = 0}^K a_k (x + c)^k$。这显然可以直接用二项式定理在 $\\Theta(K^2)$ 的时间复杂度内展开。但是这种形式的式子普遍可以转化为卷积1，从而能够利用 FFT 算法来加速。为了达到这一点，考虑利用二项式定理展开并进行整理：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{k = 0}^K a_k(x + c) ^k & = \\sum_{k = 0}^K a_k \\sum_{j = 0}^k \\binom{k}{j} x^j c^{k - j} = \\sum_{j = 0}^K x^j \\sum_{k = j}^K \\binom{k}{j}a_k c^{k - j} \\\\<br/>& = \\sum_{j = 0}^K {x^j \\over j!} \\sum_{k = j}^K k!\\  a_k \\cdot {c^{k - j} \\over (k - j)!} \\\\<br/>& = \\sum_{j = 0}^K {x^j \\over j!} \\sum_{t = 0}^{K - j} (j + t)!\\  a_{j + t} \\cdot {c^t \\over t!} ~~~~ (t = k - j)\\\\<br/>\\end{aligned}<br/>$$<br/>此时右边的式子已经变成了一个卷积的形式。令 $B_k = (K - k)! \\ a_{K - k}$、$C_k = c^k / k!$，那么：<br/>$$<br/>P'(x) = \\sum_{j = 0}^K {x^j \\over j!} \\sum_{t = 0}^{K - j}B_{K - j - t} \\cdot C_t<br/>$$<br/>令 $F(n) = \\sum_{k = 0}^n B_k \\cdot C_{n - k}$，$F(n)$ 可以用 FFT 算法在 $\\Theta(K \\log K)$ 的时间内计算出来，此时：<br/>$$<br/>P'(x) = \\sum_{j = 0}^K {F(K - j) \\over j!} x^j<br/>$$<br/>因此，我们可以在 $\\Theta(K \\log K)$ 的时间复杂度内完成多项式平移。结合数据结构，我们可以在 $O(nK + qK(\\log n + \\log K)) = O((n + q)K \\log n)$ 的时间复杂度解决区间加多项式问题。<br/>离线算法<br/>接下来的目标是让时间复杂度变得与序列长度 $n$ 无关。考虑求区间和的一种离线算法：扫描线算法。<br/><br/>(Fig.1. 扫描线算法的一个示例。$6$ 个方格代表序列 $X[1..6]$。上面的操作是将区间 $[2, 4]$ 都加上 $3$；下面的是扫描线的过程，首先将原序列视为差分序列，在位置 $2$ 加上 $3$，位置 $4$ 减去 $3$，模拟一根扫描线从 $1$ 一直扫描到 $6$，其中遇到正数就给 $A$ 加上，遇到负数则相应地减去，这样扫描线扫到哪里，$A$ 的值就是那个位置的值)<br/>为了方便，我们先只考虑单点查询。由于需要支持修改过程中的查询，所以对每个操作记录一个时间戳 $t$，特别的，第一个操作的时间戳是 $1$。如果是修改操作，则当前时间加 $1$，而查询操作不必增加时间。这样对于每一个单点查询以及它的时间戳 $t$，只需要将所有时间戳不大于 $t$ 的区间覆盖了当前位置的修改操作的多项式加起来，就可得到当前位置的多项式，从而可以计算这个位置的值。因此我们在扫描线的过程中维护一个数据结构（平衡树/线段树），按照时间戳的顺序来维护所有的修改操作的多项式。对于每个修改操作，在区间开始的位置加一个“添加”事件，区间末尾加一个“删除”事件，执行相应的事件时就将数据结构中的对应多项式插入或删除；而对于查询操作，就只需查询前缀和即可。实际上，如果某个位置没有任何事件，那么这个位置就可以直接跳过，因为它不会对我们的数据结构产生任何影响，从而可以在 $O(qK \\log q)$ 的时间复杂度下完成区间修改/单点查询问题。<br/>现在来考虑区间查询。我们知道，利用前缀和，可以将区间和变为两个单点值之差。利用这一点，不难想到我们可以直接将多项式 $P(x)$ 变成自己的前缀和多项式，即 $P'(x) = \\sum_{k = 1}^x P(k)$，这样我们维护的实际上就是原序列的前缀和序列，成功地将区间查询问题转化为了单点查询问题。我们知道，$K$ 次多项式的前缀和是 $K + 1$ 次多项式，而计算多项式前缀和有很多公式或方法：伯努利公式（又称 Faulhaber’s formula）、离散微积分、子集反演或者多项式插值。但它们都是针对 $k$ 次单项式（即 $x^k$）的公式，并且计算复杂度都是 $\\Theta(k)$，如果运用到任意 $K$ 次多项式，就又需要 $\\Theta(K^2)$ 的时间。<br/>到了这种时候，我们可能又会想要 FFT 出场了。在此之前，我们需要选择一个便于变形的公式。我经过一番挑选，发现还是伯努利公式形式最优秀：<br/>$$<br/>\\sum_{k = 1}^x k^n = 1^n + 2^n + \\cdots + x^n = \\frac1{n+1}\\sum_{k = 0}^n \\binom{n + 1}{k} B_k x^{n + 1 - k}<br/>\\tag{Bernoulli's Formula}<br/>$$<br/>其中 $B_k$ 表示伯努利数，并且 $B_1 = +1/2$2。伯努利数可以通过多项式逆元快速计算，具体可以查看这里。或者当 $K$ 足够小时，我们可以直接将需要的伯努利数存入程序。<br/>接下来又要经过一番套路变形：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{k = 1}^x P(k) & = \\sum_{k = 1}^x \\sum_{j = 0}^K a_j k^j = \\sum_{j = 0}^K a_j \\sum_{k = 1}^x k^j \\\\<br/>& = \\sum_{j = 0}^K {a_j \\over j + 1} \\sum_{k = 0}^j \\binom{j + 1}{k} B_k x^{j + 1 - k} \\\\<br/>&  = \\sum_{j = 0}^K {a_j \\over j + 1} \\sum_{t = 0}^j \\binom{j + 1}{j - t} B_{j - t} x^{t + 1} ~~~~ (t = j - k) \\\\<br/>&  = \\sum_{t = 0}^K x^{t  + 1} \\sum_{j  = t}^K {a_j \\over j + 1} \\binom{j + 1}{j - t} B_{j - t} \\\\<br/>& = \\sum_{t = 0}^K {x^{t + 1} \\over (t + 1)!} \\sum_{j = t}^K j!\\ a_j \\cdot {B_{j - t} \\over (j - t)!} \\\\<br/>& = \\sum_{t = 0}^K {x^{t + 1} \\over (t + 1)!} \\sum_{j = 0}^{K - t} (j + t)!\\ a_{j + t} \\cdot {B_j \\over j!}<br/>\\end{aligned}<br/>$$<br/>Alright！3又是熟悉的面孔。故技重施，令 $C_k = (K - k)!\\ a_{K - k}$、$D_k = B_k / k!$，右边就变成了卷积的形式。因此我们可以在 $\\Theta(K \\log K)$ 的时间复杂度内计算多项式前缀和的表达式。结合之前单点查询的算法，如果允许离线操作，区间加多项式问题可以在 $O(qK \\log q)$ 的时间复杂度内解决。另外，将区间和转化为单点差之后，实际上还可以使用动态开点的数据结构来实现在线算法，时间复杂度是 $O(qK \\log n)$ 的。<br/>最后，我自己使用 C++ 实现了离线算法，如果想要查看可以前往 我的 GitHub。<br/><br/><br/><br/><br/>卷积是针对两个序列 $A[0..n]$ 和 $B[0..n]$ 而言的。定义卷积 $C = A \\times B$，则 $C(n) = \\sum_{k = 0}^n A(k) \\cdot B(n - k)$，这一过程可以视为多项式乘法，故可以使用 FFT（快速傅里叶变换）来实现，时间复杂度为 $\\Theta(n \\log n)$。 ↩<br/><br/><br/>有一些地方的会使用 $B_1 = -1/2$ 的伯努利数。 ↩<br/><br/><br/>“But your spelling is alwrong.” —— Concrete Mathematics ↩<br/><br/><br/>","tags": "数据结构 多项式 FFT 伯努利数","url": "blog/2018-1-28/interval-polynomial.html"},
{"title": "友链","text": "友情链接<br/>欢迎各位大神来互换友链~~~<br/><br/><br/><br/>Nickname<br/>Address<br/><br/><br/><br/><br/>ruanxingzhi<br/>ruanx.pw<br/><br/><br/>Haogram<br/>haogram.hol.es<br/><br/><br/>HJWJBSR<br/>hjwjbsr.is-programmer.com<br/><br/><br/>Mr.Rabbit<br/>www.ianime.co<br/><br/><br/>Linyxus<br/>blog.linyxus.xyz<br/><br/><br/>memset0<br/>memset0.cf<br/><br/><br/>MicDZ<br/>www.micdz.cn<br/><br/><br/>xehoth<br/>blog.xehoth.cc<br/><br/><br/><br/>另外这里是几个本校神犇：<br/><br/><br/><br/>Nickname<br/>Address<br/><br/><br/><br/><br/>remoon<br/>CSDN/remoon<br/><br/><br/>Creeper_LKF<br/>CSDN/Creeper_LKF<br/><br/><br/>Twilight_<br/>CSDN/Twilight_Sx<br/><br/><br/>","tags": "Friend Links","url": "links.html"},
{"title": "双重计数的简单应用","text": "双重计数的简单应用<br/>什么是双重计数<br/>双重计数就是就是计数同一个事物考虑两种计算方式，得到两个看上去没有联系的表达式相等，从而得到优美的公式的一种方法。通常也被称作“多重计数”或者“双计数”。<br/>应用<br/>组合恒等式<br/>大小为 $n$ 的集合的所有子集数是 $2^n$ 的，因为集合中的每个元素可以选择选或者不选。另一方面，它的子集数目同时也是 $\\sum_{k=0}^n {n \\choose k}$，于是我们可以得到经典的组合恒等式：<br/>$$<br/>\\sum_{k=0}^n {n \\choose k} = 2^n \\tag{2.1}<br/>$$<br/>这应该是双计数最基础的运用了吧。<br/>我们递推组合数时经常会用到这样的公式：<br/>$$<br/>k{n \\choose k} = n{n - 1 \\choose k - 1} \\tag{2.2}<br/>$$<br/>证明它十分简单，只需要将组合数公式展开约分即可。但是形象的组合证明也许更好，因此我们来考虑二元组 $(A,\\;x)$ 的数量，其中要求满足 $x \\in A$。我们从两个方面来考虑：<br/><br/>如果先计数集合 $A$，再计数 $x$：集合 $A$ 的数量为 ${n \\choose k}$，从中选出一个元素的方案数为 $k$，所以总方案数为 $k{n \\choose k}$。<br/>如果先计数 $x$，再计数 $A$：首先 $x$ 有 $n$ 种选法，然后考虑从剩下的 $n - 1$ 个元素里面来选出 $k - 1$ 个元素，即可得到一个大小为 $k$ 的子集 $A$。因此总方案数为 $n{n - 1 \\choose k - 1}$。<br/><br/>由于我们计数的是同一个东西，所以 $(2.2)$ 式成立。<br/>Burnside 定理<br/>Burnside 定理的证明本身就是一个巧妙的双计数，具体的证明过程就不在这里展出，各位可以参考网上的相关资料或者这篇博客。<br/>无标号的有根树计数<br/>无标号的有根树表示我们所计数的树是有一个固定的根节点，但是同构的树只能算一个。为了方便，我们令 $n$ 个无标号节点的有根树的数量为 $t(n)$。例如，下面的三棵树中：<br/><br/>蓝色的节点是根节点，第一棵树和第二棵树虽然本质上一模一样，但是由于树根的不同，所以算作不同的树。而第三棵树和第一棵数仅仅只是子树顺序的调动，由于节点没有编号，所以认为与第一棵树是同构的。<br/>如何计数这样的东西？首先有一个明显的特征就是树根是固定的，而每一棵子树又是一棵有根树，所以我们来考虑递推：设 $f(n, \\;m)$ 表示 $n$ 个节点，其中最大的子树大小为 $m$ 的方案数，通过枚举大小为 $m$ 的子树的个数 $k$ 可以做如下递推：<br/>$$<br/>f(n,\\;m) = \\sum_{1 \\leqslant mk < n} {k + t(m) - 1 \\choose k} \\sum_{i = 1}^{m - 1} f(n - mk, \\;i)　\\tag{2.3}<br/>$$<br/>而 $t(n) = \\sum_{k = 1}^{n - 1} f(n,\\;k)$，所以利用一些递推技巧，不考虑算术的复杂度，我们可以在 $O(n^2\\ln n)$ 的时间内计算出 $t(n)$。<br/>现在我们来考虑使用双计数的技巧，尝试计数二元组 $(T, \\;x)$ 的方案数，其中 $T$ 是一棵有根树，而 $x$ 是将 $T$ 按照最小表示法1标号之后一个非树根的节点编号，现在来考虑两个方面：<br/><br/>考虑先计数 $T$，后计数 $x$：总共的 $T$ 共有 $t(n)$ 个，其中非根节点数量为 $n - 1$ 个，故总方案数为 $(n - 1)t(n)$。<br/>考虑先计数 $x$，后计数 $T$：首先假定 $x$ 在一个大小为 $m$ 的某个子树中，这样的子树一共有 $t(m)$ 种，而子树上的 $x$ 有 $m$ 种，所以一共有 $mt(m)$ 种。然后注意到跟它相同的子树可能不止一个，而我们的 $x$ 都要枚举到。当 $x$ 在第一棵上这样的子树时，方案数为 $t(n - m)$，在第二棵时，方案数为 $t(n - 2m)$......所以我们可以得知方案数为 $\\sum_{1 \\leqslant km < n} t(n - km)$。由于 $x$ 在不同的大小的子树中，所以总方案数为 $\\sum_{m = 1}^{n - 1}mt(m)\\sum_{1\\leqslant km<n}t(n-km)$<br/><br/>联立两式相等，我们可以得知：<br/>$$<br/>t(n) = \\frac1{n-1}\\sum_{m = 1}^{n - 1}mt(m)\\sum_{1\\leqslant km<n}t(n-km) \\tag{2.4}<br/>$$<br/>通过枚举 $T = mk$，递推式可以变为：<br/>$$<br/>t(n) = \\frac1{n-1}\\sum_{T = 1}^{n - 1} t(n - T) \\sum_{m \\mid T} mt(m) \\tag{2.5}<br/>$$<br/>这样就可以方便的在 $O(n^2)$ 时间递推计算 $t(n)$ 了，也可以通过进一步的变形从而利用FFT算法来加速计算。当然有关利用生成函数来计算类似问题的可以参考这里。<br/>无标号的无向连通简单图计数<br/>上述方法可以继续套用到无向图上来，首先我们设 $n$ 个没有标号的无向简单图数量为 $h(n)$，连通图数量为 $f(n)$，以及非连通图数量为 $g(n)$。$n = 0..5$ 的几个数值如下2：<br/>$$<br/>\\begin{aligned}<br/>f: &1, 1, 1, 2, 6, 21, ... \\\\<br/>g: &0, 0, 1, 2, 5, 13, ... \\\\<br/>h: &1, 1, 2, 4, 11, 34, ...<br/>\\end{aligned}<br/>$$<br/>关于 $h$ 的计算，可以使用 Polya 计数法来得出（只可惜这种方法并不高效），具体的方法可以参见这里。由于非连通图是由一些连通块构成的，很像我们在无标号有根树中的子树，所以我们接下来考虑计算关于 $g$ 的递推关系。<br/>首先，我们考虑计数二元组 $(G, \\;x)$ 的数量，类似的，$G$ 是一张非连通图，而 $x$ 是将 $G$ 编号后的一个节点 $x$。同样，我们考虑两个方面：<br/><br/>先计数 $G$ 后计数 $x$：显然方案数为 $ng(n)$。<br/>先计数 $x$ 后计数 $G$：考虑 $x$ 在一个大小为 $t$ 的连通块中，按照类似的方法，我们可以得知这样的 $x$ 有 $tf(t)$ 种。另外，我们还需要枚举它是 $G$ 中第几个这样的连通块，这样的方案数是 $\\sum_{1 \\leqslant kt \\leqslant n} h(n - kt)$ 种。<br/><br/>所以，我们得到：<br/>$$<br/>g(n) = \\frac1n\\sum_{t = 1}^{n - 1} tf(t) \\sum_{1\\leqslant kt \\leqslant n} h(n - kt) \\tag{2.6}<br/>$$<br/>因此知道了 $h(n)$ 的值，同时就可以将 $f(n)$ 和 $g(n)$ 都计算出来。<br/>然而，我并没有找到更好的计算 $h(n)$ 的办法，希望如果有大神知道能够告诉我一声！<br/><br/><br/><br/><br/>显然我们可以对比较小的（例如大小为 $1$）大小相同的不同的有根树都给个编号，然后更大的有根树可以按照先子树大小后子树编号来对它树根的子树排序，因此就可以继续给更大的子树编号。 ↩<br/><br/><br/>我们认为大小为 $0$ 的图是存在的，并且它是连通的。 ↩<br/><br/><br/>","tags": "图计数 组合数学","url": "blog/2017-6-19/double-count.html"},
{"title": "密码锁","text": "密码锁 (expression.cpp/in/out)<br/>时间限制: 1 s / 内存限制: 512 MB / 打开O2优化<br/>题目描述<br/>dyx在家里玩耍时发现了一个神奇的密码锁。然而他早已忘记了这个锁的密码，于是他随便尝试了一下，结果锁就打开了......<br/>锁的内部有一个很长的字符串，机智的dyx马上就发现这就是密码锁的核心。于是他研究了一下午，探寻这把锁的奥秘。<br/>他发现这个字符串是一个表达式的形式，像下面这个样子：<br/>1a|b&(!c^d)<br/><br/><br/>其中，每一个由小写字母组成的单词是一个变量，对应着密码锁上的一个按钮。由于按钮只能按下或不按下，于是你可以认为每个变量是一个布尔类型的（即只有$\\text{true}$和$\\text{false}$之分）<br/>其余的字符就只有&、|、^、!和左右小括号。dyx发现括号是用来优先运算的，意思是这是一个会将所有变量进行计算的表达式，并且优先计算括号中的子表达式。同时，&、|、^、!都是运算符，它们分别对应的是逻辑与、逻辑或、逻辑异或和逻辑非。其中前三者运算优先级一致，当它们在同一级出现时会从左至右运算，逻辑非的优先级比它们高。当每一个变量都有相应的值时，整个表达式就会就会进行计算，并给出一个布尔值。dyx还发现，当整个表达式的值为$\\text{true}$时，密码锁就会打开。<br/>很明显，整个密码锁的输入方案共有$2^n$种，其中$n$是表达式中变量的数量。于是dyx瞬间明白为什么他一次就可以将这个密码锁解开了。然而dyx是一个勇于探究的人，他想知道到底有多少中方法可以解开一个密码锁。<br/>不知为何，dyx又发现了一火车的密码锁。坚持不懈的dyx不停的计算着每一个密码锁能解开的方案数......由于密码锁的表达式越来越长并且人脑计算量是$\\Theta(1)$的，dyx不得不需要一个程序来帮助他计算这个方案数。<br/>输入格式<br/>每个测试数据点有多个表达式。文件以EOF结束。<br/>每一个表达式占一行，且中间只有小写字母和&、|、^、!、(、)。<br/>对于&、|和^运算，它们左右会各有一个变量或子表达式。其运算规则如下：<br/><br/><br/><br/>$a$<br/>$b$<br/>$a$ & $b$ ($a \\land b$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/>$\\text{false}$<br/><br/><br/>$\\text{false}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/><br/><br/><br/><br/>$a$<br/>$b$<br/>$a$ | $b$ ($a \\lor b$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/><br/><br/><br/><br/>$a$<br/>$b$<br/>$a$ ^ $b$ ($a \\oplus b$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{true}$<br/>$\\text{fasle}$<br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/>$\\text{true}$<br/><br/><br/>$\\text{false}$<br/>$\\text{false}$<br/>$\\text{false}$<br/><br/><br/><br/>对于!运算，它后面会有一个变量或子表达式。其运算规则如下：<br/><br/><br/><br/>$a$<br/>!$a$ ($\\lnot a$)<br/><br/><br/><br/><br/>$\\text{true}$<br/>$\\text{false}$<br/><br/><br/>$\\text{false}$<br/>$\\text{true}$<br/><br/><br/><br/>输入保证表达式是有效的，且表达式中不存在缺少参数的运算符和空的括号。<br/>为了防止此题变成不可做的NP-hard问题，输入保证表达式中每一个变量名只出现一次。<br/>输出格式<br/>对于每一个表达式，输出能够解开它的方案总数。由于答案可能过大，因此将答案对$10^9 + 7$取模后输出。<br/>一种方案即指对每一个变量给定一个值。<br/>两种方案不同当且仅当至少一个变量所给定的值不同。<br/>输入样例<br/>1<br/>2<br/>3a&b<br/>a|b|c<br/>a|!(b|c)<br/><br/><br/>输出样例<br/>1<br/>2<br/>31<br/>7<br/>5<br/><br/><br/>数据范围及提示<br/>对于第一个表达式，只有$a = \\text{true}, b = \\text{true}$才为$\\text{true}$。<br/>对于第二个表达式，只要三者有一个变量为$\\text{true}$就是$\\text{true}$。<br/>对于第三个表达式，先运算b|c，然后对其取反，最后与$a$做逻辑与。<br/>以下$n$表示变量数量，$T$表示测试数据组数，$L$表示表达式的总长度。<br/>对于$10\\% $的数据，$n \\le 10,\\; T = 15$。<br/>对于另外$10\\% $的数据，只有逻辑或运算，没有括号。<br/>对于另外$10\\% $的数据，不存在逻辑非和括号。<br/>对于另外$20\\% $的数据，不存在括号。<br/>对于另外$20\\% $的数据，$n \\le 500$。<br/>对于$100\\% $的数据，变量名长度$\\le 4$，$L \\le 10^6$，$n \\le 3\\times10^5$。<br/>其中$90\\% $的数据，$T \\le 5$。","tags": "Problems","url": "blog/2016-6-30/expression.html"},
{"title": "差分序列与Stirling数","text": "差分序列与Stirling数<br/>刚看完《组合数学》的这一节，写一点笔记。<br/>差分序列<br/>定义<br/>设一个序列：<br/>$$<br/>h(0), h(1), h(2), h(3), h(4), \\dots<br/>$$<br/>的一阶差分序列为：<br/>$$<br/>\\Delta h(0), \\Delta h(1), \\Delta h(2), \\Delta h(3), \\dots<br/>$$<br/>其中：<br/>$$<br/>\\Delta h(n) = h(n + 1) - h(n)<br/>$$<br/>同样，将差分出来的序列再次进行差分，可以得到二阶差分序列。因此，我们定义零阶差分序列就是原序列，$p$阶差分序列为：<br/>$$<br/>\\Delta^{(p)} h(n) = \\Delta^{(p - 1)} h(n + 1) - \\Delta^{(p - 1)} h(n) \\;\\;\\;\\; (p \\gt 0)<br/>$$<br/>差分序列有一种求导的意味。<br/>多项式的差分序列<br/>多项式$h(n) = 2n^3 + 2n^2 - 4n + 233$的差分序列如下：<br/>$$<br/>233, 233, 249, 293, 377, 513, \\dots \\\\<br/>0, \\;16, \\;44, \\;84, \\;136, \\dots \\\\<br/>16, \\;28, \\;40, \\;96, \\dots \\\\<br/>12, \\;12, \\;12, \\dots \\\\<br/>0, \\;\\;0, \\dots \\\\<br/>\\dots<br/>$$<br/>我们发现$h(n)$是个$3$次多项式，而它的序列经过$4$次差分就变成了全是$0$的序列。<br/>可以证明，一个$p$次多项式的序列最多经过$p + 1$次差分就会变为全$0$序列。<br/>首先考虑$0$次多项式，它的序列值是一个常数，所以至多经过一次差分就可以变为$0$。<br/>现在进行归纳假设：假设对于$p$次多项式的序列最多经过$p + 1$次差分就会得到全$0$序列，那么现在证明对于$p + 1$次多项式最多差分$p + 2$次就可以得到全$0$序列。<br/>观察最高次数的项，在每一次差分中的变化：<br/>$$<br/>\\begin{aligned}<br/>\\Delta^{(c)} h(n) & = \\Delta^{(c-1)} h(n + 1) - \\Delta^{(c-1)}h(n) \\\\<br/>& = (n + 1)^{p} + \\cdots - n^p - \\cdots \\\\<br/>& = \\sum_{k = 0}^p {p \\choose k} n^k + \\cdots - n^p - \\cdots<br/>\\end{aligned}<br/>$$<br/>由于${p \\choose p} = 1$，所以最高次数的项在一次差分中被减去了，所以差分后的序列是一个至多$p$次的多项式的序列。因此，根据归纳假设，$p + 1$次的多项式最多进行$p + 2$次差分就可以对到全$0$序列。<br/>差分的线性性<br/>如果：<br/>$$<br/>h(n) = af(n) + bg(n)<br/>$$<br/>那么：<br/>$$<br/>\\begin{aligned}<br/>\\Delta h(n) & = \\Delta (af(n) + bg(n)) \\\\<br/>& = a(f(n + 1) - f(n)) + b(g(n + 1) - g(n)) \\\\<br/>& = a\\Delta f(n) + b\\Delta g(n)<br/>\\end{aligned}<br/>$$<br/>由此我们证明了差分是一个线性变换。这称为差分的线性性。<br/>特殊差分表<br/>在差分表中：<br/>$$<br/>233, 233, 249, 293, 377, 513, \\dots \\\\<br/>0, \\;16, \\;44, \\;84, \\;136, \\dots \\\\<br/>16, \\;28, \\;40, \\;96, \\dots \\\\<br/>12, \\;12, \\;12, \\dots \\\\<br/>0, \\;\\;0, \\dots \\\\<br/>\\dots<br/>$$<br/>称第一横行为第$0$行，表示原数列，如上面的$233, 233, 249, 293, 377, 513, \\dots$。而左边的第一斜列为第$0$条对角线，如上面的$233,0,16,12,0,\\dots$。显然知道了这两个中的任意一个就可以确定整个差分表。<br/>考虑一下由下面的对角线构成的差分表会是怎样的数列构成的：<br/>$$<br/>0, 0, 0, 0, 1, 0, 0\\dots<br/>$$<br/>首先，这个差分表后面全部变成了$0$，所以这肯定是一个$4$次多项式的差分表。同时我们可以确定这个多项式有$4$个零点，所以我们可以写出：<br/>$$<br/>f(n) = cn(n-1)(n-2)(n-3)<br/>$$<br/>其中$c$还是待确定的。<br/>同时，我们注意到$f(4) =  1$，所以：<br/>$$<br/>c \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1 = 1 \\Longrightarrow c = \\frac1{4!}<br/>$$<br/>换言之：<br/>$$<br/>f(n) = {n! \\over 4!(n - 4)!} = {n \\choose 4}<br/>$$<br/>是不是感觉很神奇？这一结论可以推广到任意位置的$1$的差分表。同时，利用差分表的线性性，我们可以得到更加神奇的东西：<br/><br/>如果$\\Delta f(n)$的第$0$条对角线为$c_0, c_1, c_2, c_3, \\dots, c_p, 0, 0, \\dots$，那么：<br/>$$ f(n) = \\sum_{k=0}^p c_k{n \\choose k}$$<br/><br/>此时你也许会想问这东西有什么用？由于它是对于一个多项式的差分分析得到的结论，因此，我们对于一个多项式，如果知道了第$0$条对角线，那么我们可以直接计算这个多项式。<br/>并且，根据Pascal公式，我们可以知道：<br/>$$<br/>\\sum_{k=0}^p {n \\choose k} = {n + 1 \\choose p}<br/>$$<br/>所以：<br/>$$<br/>\\sum_{k = 0}^n f(k) = \\sum_{k = 0}^p c_k {n + 1 \\choose k}<br/>$$<br/>所以，当我们拥有了这个结论之后，我们就可以以同样的代价来计算它的前缀和。<br/>现在来考虑一个具体一点并且不是很复杂的问题，但是可能当场并不能解决它：<br/><br/>给你$T$次询问，每次给出$n$和$p$，要求你计算：<br/>$$ \\sum_{a = 1}^n a^p \\pmod{10^9 + 7}$$<br/>$1 \\leqslant T \\leqslant 5000$，$1 \\leqslant p \\leqslant 5000$，$1 \\leqslant n \\leqslant 10^{18}$。<br/><br/>如果采用直接计算$c_0, c_1, c_2, \\dots$的话，总的复杂度为$\\Theta(q^3 + Tq)$。这里出现的问题就是系数的预处理代价太高，因此我们需要寻找一种更快速的计算方法。<br/>对此，我们设$f_p(n) = n^p$，同时设它的系数为：<br/>$$<br/>c(p, 0), c(p, 1), c(p, 2), \\dots, c(p, p)<br/>$$<br/>那么答案就是：<br/>$$<br/>\\sum_{k = 0}^p c(p, k){n + 1 \\choose k}<br/>$$<br/>第二类Stirling数<br/>定义<br/>有第二类Stirling数就有第一类Stirling数，但是由于第二类Stirling数可以帮助我们解决之前的问题，所以先介绍它。<br/>第二类Stirling数的用途是使用下降幂来表示数的幂。下降幂是这样的一种东西：<br/>$$<br/>x^{\\underline{n}} = {x! \\over (x - n)!}<br/>$$<br/>回到前面的问题，可以发现：<br/>$$<br/>\\begin{aligned}<br/>n^p & = \\sum_{k = 0}^p c(p, k){n \\choose k} \\\\<br/>& = \\sum_{k = 0}^p \\frac{c(p, k)}{k!} n^{\\underline{k}}<br/>\\end{aligned}<br/>$$<br/>所以设：<br/>$$<br/>S(p, k) = {c(p, k) \\over k!}<br/>$$<br/>为第二类Stirling数。并且满足：<br/>$$<br/>n^p = \\sum_{k = 0}^p S(p, k)n^{\\underline{k}}<br/>$$<br/>同时注意一下它的边界值：<br/>$$<br/>S(n, n) = 1 \\;\\;\\;\\; \\forall n \\in N \\\\<br/>S(n, 0) = 0 \\;\\;\\;\\; \\forall n \\in N_+<br/>$$<br/>不妨来考虑一下：<br/>$$<br/>\\begin{aligned}<br/>n^{p-1} & = \\sum_{k = 0}^{p-1} S(p-1, k)n^{\\underline{k}} \\\\<br/>n^p = n \\cdot n^{p-1} & = n\\sum_{k = 0}^{p-1} S(p-1, k)n^{\\underline{k}} \\\\<br/>& = \\sum_{k = 0}^{p-1} S(p-1, k) \\cdot n \\cdot n^{\\underline{k}} \\\\<br/>& = \\sum_{k = 0}^{p-1} S(p-1, k) \\cdot (n - k + k) \\cdot n^{\\underline{k}} \\\\<br/>& = \\sum_{k = 0}^{p-1} S(p-1, k) n^{\\underline{k + 1}} + \\sum_{k = 0}^{p-1} kS(p-1, k) n^{\\underline{k}} \\\\<br/>& = \\sum_{k = 1}^{p} S(p-1, k - 1) n^{\\underline{k}} + \\sum_{k = 0}^{p-1} kS(p-1, k) n^{\\underline{k}}<br/>\\end{aligned}<br/>$$<br/>通过比较同一项的系数，我们可以得知下面的递推式：<br/>$$<br/>S(p, k) = kS(p - 1, k) + S(p - 1, k - 1)<br/>$$<br/>解决之前的问题<br/>在之前的问题中，我们知道：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{a = 1}^n a^p & = \\sum_{k = 0}^p c(p, k){n + 1 \\choose k} \\\\<br/>& = \\sum_{k = 0}^p S(p, k)(n + 1)^{\\underline{k}}<br/>\\end{aligned}<br/>$$<br/>对于后面的式子，我们发现可以通过递推算出$(n + 1)^{\\underline{0}}$至$(n + 1)^{\\underline{p}}$的值，同时，我们有了之前的递推式，我们可以在$\\Theta(p^2)$的时间内预处理出第二类Stirling数。所以这个问题我们可以以$\\Theta(p^2 + Tp)$的时间复杂度解决这个问题。<br/>其实，根据第二类Stirling数的递推公式，我们也可以类似的推出$c(p, k)$的递推公式：<br/>$$<br/>c(p, k) = k(c(p - 1, k - 1) + c(p - 1, k))<br/>$$<br/>读者可以自己试一试。<br/>但是这还不是这个问题的最优解法。使用伯努利数和快速傅里叶变换，我们可以得到更好的复杂度。这里就没有介绍了。<br/>另外，使用拉格朗日插值法也可以快速求解这个问题，具体的可以参见这篇博客。<br/>组合意义<br/>现在来考虑一下这个简单问题：<br/><br/>求$p$个人，放入$k$个相同的房子 (房子不可以为空) 的方案数。<br/><br/>不难我们可以想出一个递推：设$f(p, k)$为$p$个人放入$k$个相同的房子的方案数，那么它满足：<br/>$$<br/>f(p, k) = kf(p - 1, k) + f(p - 1, k - 1)<br/>$$<br/>对于其正确性，考虑两点：<br/><br/>如果第$p$个人单独进入一个房间，那么方案数为$f(p - 1, k - 1)$。<br/>如果第$p$个人进入之前的房间，那么它可以挑选之前的$k$个房间的任意一间，即方案数为$kf(p - 1, k)$。<br/><br/>同时我们注意到：<br/>$$<br/>f(n, n) = 1<br/>$$<br/>并且：<br/>$$<br/>f(n, 0) = 0 \\;\\;\\;\\; \\forall n \\in N_+<br/>$$<br/>也就是$f$和第二类Stirling数满足一样的初始条件和递推公式，那么意味着$f(p, k)$和$S(p, k)$是一样的。所以这个问题的答案就是$S(p, k)$。这也正是第二类Stirling数的组合意义。<br/>对于这个问题，我们可以从容斥原理的角度来获得另外一个不同的公式。设$A_1,\\; A_2, \\;A_3,\\dots,A_k$为第$1$到第$k$个房间为空的方案集合，那么我们的答案就是：<br/>$$<br/>S(p, k) = \\frac1{k!}\\left|\\overline{A}_1 \\cup \\overline{A}_2 \\cup \\cdots \\cup \\overline{A}_k\\right|<br/>$$<br/>注意在之前的推导里面我们区分了这$k$个房间，而第二类Stirling数是没有区分的，所以要乘以$1/k!$。<br/>考虑到如果有$t$个房间为空，那么对于每一个人而言，就只有$k - t$个选择，所以对于此的方案数的就是$(k - t)^p$。所以我们可以知道：<br/>$$<br/>S(p, k) = \\frac1{k!}\\sum_{t = 0}^k (-1)^t{k \\choose t}(k - t)^p<br/>$$<br/>这也就是计算单个第二类Stirling数的公式。<br/>第一类Stirling数<br/>定义<br/>现在来介绍第一类Stirling数。与第二类Stirling数类似，第一类Stirling数是使用数的幂来表示下降幂。<br/>现在来观察一下规律：<br/>$$<br/>\\begin{aligned}<br/>& n^{\\underline{0}} = 1 \\\\<br/>& n^{\\underline{1}} = n \\\\<br/>& n^{\\underline{2}} = n(n - 1) = n^2 - n \\\\<br/>& n^{\\underline{3}} = n(n - 1)(n - 2) = n^3 - 3n^2 + 2n \\\\<br/>& n^{\\underline{4}} = n(n - 1)(n - 2)(n - 3) = n^4 - 6n^3 + 11n^2 - 6n \\\\<br/>& \\dots<br/>\\end{aligned}<br/>$$<br/>可以发现，下降幂展开以后是一个系数正负号交替的多项式。与在第二类Stirling数中类似的，我们设$s(p, k)$为第一类Stirling数，并且满足：<br/>$$<br/>n^{\\underline{p}} = \\sum_{k = 0}^p (-1)^{p - k}s(p, k)n^k<br/>$$<br/>以及边界值：<br/>$$<br/>s(n, n) = 1 \\;\\;\\;\\; \\forall n \\in N \\\\<br/>s(n, 0) = 0 \\;\\;\\;\\; \\forall n \\in N_+<br/>$$<br/>类似的，我们可以据此推出第二类Stirling数的递推公式：<br/>$$<br/>\\begin{aligned}<br/>n^{\\underline{p - 1}} & = \\sum_{k = 0}^{p-1} (-1)^{p - k - 1}s(p - 1, k)n^k \\\\<br/>n^{\\underline{p}} & = (n - p + 1)\\sum_{k = 0}^{p-1} (-1)^{p - k - 1}s(p - 1, k)n^k \\\\<br/>& = \\sum_{k = 0}^{p-1} (-1)^{p - k - 1}s(p - 1, k)n^{k+1} + \\sum_{k = 0}^{p-1} (-1)^{p - k}(p - 1)s(p - 1, k)n^k \\\\<br/>& = \\sum_{k = 1}^{p} (-1)^{p - k}s(p - 1, k - 1)n^{k} + \\sum_{k = 0}^{p-1} (-1)^{p - k}(p - 1)s(p - 1, k)n^k<br/>\\end{aligned}<br/>$$<br/>通过比较同次项的系数可以得知：<br/>$$<br/>s(p, k) = (p - 1)s(p - 1, k) + s(p - 1, k - 1)<br/>$$<br/>组合意义<br/>同样的，第一类Stirling数也具有其组合意义。通过考虑下面的问题就可以证明：<br/><br/>求$p$个人围成$k$个圈 (圈不能为空) 的方案数。<br/>注意这里的圈中的人的顺序不同也会视为圈不同。<br/><br/>对于这个问题，我们证明其答案$f(p, k)$满足下面的递推关系：<br/>$$<br/>f(p, k) = (p - 1)f(p - 1, k) + f(p - 1, k - 1)<br/>$$<br/>证明：<br/><br/>如果第$p$个人独自站成一个圈，那么共有$f(p - 1, k - 1)$种方案。<br/>如果第$p$个人与之前的人站在一起，那么他有$p - 1$种方案站在一个人的右边，所以共有$(p - 1)f(p - 1, k)$中方案。<br/><br/>不难验证这个问题的初始条件与第一类Stirling数一致，所以$f(p, k)$和$s(p, k)$就是一样的啦～","tags": "差分 Stirling数 多项式插值","url": "blog/2016-11-29/delta-and-stirling.html"},
{"title": "平衡树套链表","text": "平衡树套链表<br/>前言<br/><br/>这是一个闲得卵疼的产物<br/><br/>有时候我们希望能够在一个序列上快速遍历，然而这个序列却又是动态的，因此会考虑到平衡树来维护序列。<br/>然而普通平衡树查找前趋后继是比较麻烦的，除了Splay有一个很简单直观的方法1，其它平衡树都要与父亲节点纠缠一番。<br/>然而最关键的是，它们查询前趋后继还不是$\\Theta(1)$的时间，最坏情况下是$O(\\log n)$的。<br/>因此考虑将链表”挂载”在平衡树上，可以将查找前趋后继的时间复杂度降为$\\Theta(1)$，并且只需要在插入和删除时每个节点付出$\\Theta(1)$的代价。同时顺序遍历节点的代码将与普通链表一样。这样在动态维护凸包等一些复杂的平衡树应用中做到一些优化。<br/>想必强者2看完前言已经脑补出这玩意了。<br/>插入<br/>实际上我们就是需要在插入节点时同时记录一个节点的前趋和后继。<br/>由于新插入的节点一定是在树的底部，因此我们需要考虑的情况很少。<br/>这时有两种情况，一种是插入到左儿子：<br/><br/>那么新插入的节点必定是其父亲的前趋。这个过程可以看作是往链表中插入一个元素。<br/>同样，对于插入到右儿子，情况也是类似的：<br/><br/>因此，对于每个新插入的节点，只需要花费$\\Theta(1)$的时间来记录前趋后继。<br/>旋转<br/>许多平衡树 (Treap、Splay等) 都是以旋转操作来进行平衡的。然而平衡的时候是否要维护链表信息呢？<br/>实际上根本不需要，因为旋转操作不会影响平衡树的有序性，所以对于每个节点而言，它的前趋后继是不会变化的，所以没有必要改动信息。<br/>删除<br/>有了前面的基础，删除操作其实很自然了。实际上就是最后要真正删除节点时，将链表上的指针重设。如果你写过链表的删除 (这东西很简单)，在平衡树上也就是一样的了。<br/>应用<br/>这个东西实际上只是一个小技巧，它可以用来简便一些代码，尤其是维护动态凸包这种要不停地向左向右访问节点的东西。如果我们使用的是循环链表，就可从任意一个节点开始循环遍历每一个节点。<br/><br/><br/><br/><br/>将当前节点Splay至根，然后就不用讨论父亲节点了。 ↩<br/><br/><br/>LinkSBK ↩<br/><br/><br/>","tags": "数据结构 平衡树 链表","url": "blog/2016-7-28/bst-with-list.html"},
{"title": "平面计算几何","text": "平面计算几何<br/>1 线段<br/>下图中展示了一条无向线段$AB$。<br/><br/>一般来说，我们所见的线段都是不定方向的。但在计算几何中，我们会借助向量这一强大的工具，因此我们需要将线段表示成有向线段(Directed Segment)的形式。如下图所示：<br/><br/>事实上，有向线段就是一个向量。在上面，线段$AB$被向量$\\vec{AB}$所替代。<br/>同样，我们也可以用相反的向量$\\vec{BA}$来表示$AB$。<br/>2 叉积<br/>2.1 定义<br/>对于两个向量$p_1$和$p_2$，它们的叉积(Cross Product)$p_1 \\times p_2$的定义如下：<br/>$$<br/>p_1 \\times p_2 = <br/>\\begin{vmatrix}<br/>x_1 & x_2 \\\\<br/>y_1 & y_2<br/>\\end{vmatrix} = <br/>x_1y_2 - x_2y_1<br/>\\tag{2.1}<br/>$$<br/>上面的定义使用了行列式，初学者可能感到迷糊。好在叉积有着很好的几何解释。<br/>2.2 几何解释<br/>下图中，向量$p_1$和向量$p_2$的叉积$p_1 \\times p_2$就是它们和与$p_1$平行的向量$p_3$和与$p_2$平行的向量$p_4$所围成的平行四边形$ABCD$的有向面积。<br/><br/>为什么会是有向面积呢？你可以自己造个数据来算一下，你会发现$p_1 \\times p_2 = -p_2 \\times p_1$。<br/>我们发现，叉积结果的符号与$p_1$和$p_2$的相对位置关系有很大联系：<br/><br/>当$p_2$在$p_1$的顺时针方向时，$ p_1 \\times p_2 \\lt 0$。  <br/>当$p_2$在$p_1$的逆时针方向时，$ p_1 \\times p_2 \\gt 0$。  <br/>当$p_2$与$p_1$共线（方向相同或相反）时，$ p_1 \\times p_2 = 0$。<br/><br/>利用这些性质，我们可以完成许多有趣的事情。<br/>同时，利用上面的图像，我们可以探究出叉积公式的另外一种形式：<br/><br/>在前面的基础上，我们作$ BE \\bot p_2 $，那么平行四边形$ABCD$的面积又可以表示为：<br/>$$ S_{ABCD} = |p_2| \\cdot |BE| $$<br/>又因为：<br/>$$ |BE| = |p_1| \\sin \\alpha $$<br/>因此：<br/>$$ p_1 \\times p_2 = |p_1|\\cdot|p_2|\\sin \\alpha \\tag{2.2} $$<br/>但是显然这样的公式对于计算机而言需要大量的浮点数运算，所以用这个公式计算叉积精度可能不高。<br/>但是这个公式可以改为下面的形式：<br/>$$ \\alpha = \\sin^{-1}\\left({p_1 \\times p_2 \\over |p_1| \\cdot |p_2|}\\right) \\tag{2.3}$$<br/>这样我们可以利用这个公式来计算两个向量间的夹角。<br/>如果两个向量的起点都不在原点时，该怎么计算这个有向面积呢？<br/>这其实相当简单，我们将两个向量的公共起点作为原点，然后运用向量减法来计算相对向量，然后就可以计算了。<br/>2.3 计算面积<br/>下面我们将利用叉积来计算简单多边形的面积。<br/>首先，简单多边形时多边形中没有边相交的多边形。注意包括凸多边形以及令人讨厌的凹多边形。<br/>首先从平行四边形入手。<br/><br/>这是之前的图。虽然向量的叉积算出来时有向面积，但是我们只用取绝对值，就是平行四边形的面积了。<br/>对于三角形，通过对称的方法可以构造出平行四边形。因此三角形就是叉积的绝对值的一半。<br/>先来看一下正方形：<br/><br/>显然，它的面积是$1$。<br/>但现在要你用向量的方法来计算，该怎么办?<br/>我们的正方形是用一组向量来表示的($\\vec{AB}$、$\\vec{BC}$、$\\vec{CD}$和$\\vec{DA}$)，并且按照逆时针排列，这样就指定了顶点的顺序。<br/>然后我们按照下面的流程来计算面积：<br/><br/>在平面内任选一点作为原点。  <br/>按照有向边的顺序依次计算叉积并累积求和，最后的结果除以$2$就是多边形的面积。<br/><br/>现在我们来演示一次：<br/><br/>选定原点，平面内任意一个点都可以。这里选择的是$O$点。<br/><br/>计算叉积，首先是$\\vec{AB}$，我们计算的是$\\vec{OA} \\times \\vec{OB} = -1 $。<br/><br/>然后是$\\vec{BC}$，$\\vec{OB} \\times \\vec{OC} = 2$。<br/><br/>之后是$\\vec{CD}$，$\\vec{OC} \\times \\vec{OD} = 2$。<br/><br/>最后是$\\vec{DA}$，$\\vec{OD} \\times \\vec{OA} = -1$。<br/>将叉积结果累加起来并除以$2$，得到$ S_{ABCD} = 1$。<br/>算法得到了正确结果。<br/>事实上，这个算法就是简单多边形的面积算法。那么，为什么这样计算是正确的呢？<br/>我们首先来考虑$\\vec{AB}$和$\\vec{BC}$。<br/><br/>这两个向量从$O$的角度来看，它们是相反的方向，并且它们叉积出来的结果是异号的。<br/>我们可以发现，${\\vec{OA} \\times \\vec{OB} \\over 2}$就是$-S_{\\triangle OBA}$，${\\vec{OB} \\times \\vec{OC} \\over 2}$就是$S_{\\triangle OBC}$，$S_{\\triangle OBC}-S_{\\triangle OBA} = S_{\\triangle ABC}$。因此这一对边就可以计算出这个正方形一半的面积。对于另一半，也是如此。<br/>因此，我们发现，这个算法时先计算这个多边形与选定的原点构成的更大的多边形的面积：<br/><br/>上图就是线计算了$S_{OCDEFG}$。这几条边的叉积之和为正数。<br/>然后计算不属于多边形的部分：<br/><br/>上图中就是计算$S_{OCBAG}$，而这几条边的叉积之和是负数。因此相加后就只剩下多边形的面积了。<br/>又因为叉积计算的是平行四边形的面积，所以最后要除以$2$。","tags": "数学 计算几何","url": "blog/2016-4-12/geometry.html"},
{"title": "快速数论变换 (NTT)","text": "快速数论变换 (NTT)<br/>之前写了一篇关于多项式算法的博客，提到了快速傅立叶变换 (FFT)。<br/>快速傅立叶变换中使用了单位复数根来进行采样与插值，快速数论变换和这是类似的，只不过使用的是原根。<br/>原根的性质<br/>为了方便，假设下面所有的 $n$ 都是大于 $1$ 的 $2$ 的幂，我们设：<br/>$$<br/>g_n = g^{(p-1) / n}<br/>$$<br/>其中 $p$ 是素数并且 $n \\mid (p-1)$，另外 $g$ 是模 $p$ 意义下的原根。<br/>考虑下单位复数根为什能做到 $\\Theta(n \\log n)$ 的时间复杂度，是因为它具有下面的性质：<br/><br/>$$ \\omega_n^n = 1 \\\\ \\omega_n^{n/2} = -1$$<br/><br/>对原根而言：<br/>$$<br/>g_n^n = g^{n(p-1) / n} = g^{p-1} = g^{\\varphi(p)} = 1 \\\\<br/>g_n^{n/2} = g^{(p - 1)/2}<br/>$$<br/>而：<br/>$$<br/>g^{(p - 1)/2} \\equiv \\sqrt{1} \\pmod{p}<br/>$$<br/>因此应该有 $\\pm 1$ 这两种取值。但是由于 $g^{(p-1) / 2} \\neq g^{p-1} = 1$，所以不能为 $1$。<br/><br/>$$ \\omega_{dn}^{dk} = \\omega_n^k $$<br/><br/>原根也可以：<br/>$$<br/>g_{dn}^{dk} = g^{dk(p-1) / dn} = g^{k(p-1) / n} = g_n^k<br/>$$<br/><br/>(折半引理)<br/>$$ \\{(\\omega_n^k)^2\\} = \\{\\omega_{n/2}^k\\} $$<br/><br/>原根依然可以。<br/>根据上面的结论，我们有：<br/>$$<br/>(g_n^{k})^2 = g_{n}^{2k} = g_{n/2}^k \\\\<br/>(g_n^{k+n/2})^2 = g_n^{2k+n} = g_n^{2k} = g_{n/2}^k<br/>$$<br/>因此，单位复数根该有的性质原根居然都有！<br/>NTT算法<br/>从上面的讨论中我们知道，将你的 FFT 代码中的单位复数根换成 $g_n^k$，就是 NTT。注意到处取模。<br/>逆 FFT 变换时需要除以 $n$，在模 $p$ 意义下记住是使用逆元。<br/>NTT 的总复杂度与 FFT 一致，是 $\\Theta(n \\log n)$。<br/>最后还剩下一个问题：$p$ 和 $g$ 该怎么办。<br/>在 FFT 中，为了方便处理，$n$ 一般都是选定了一个 $2$ 的幂。因此，对于 $p$，我们只需要选出一个 $p-1$ 中含有 $2$ 的幂的因子的素数，并且这个 $2$ 的幂要大于 $n$。通常选择形如 $a\\cdot 2^k + 1$ 的素数。<br/>为了方便，通常选定：<br/>$$<br/>p = 1004535809 = 479 \\times 2^{21} + 1<br/>$$<br/>它的最小正原根是 $3$。<br/>另外一个是著名的 UOJ 模数 $998244353 = 2^{23} \\times 7 \\times 17 + 1$，最小正原根也是 $3$。<br/>使用快速数论变换的好处就是避免了浮点数精度误差。当输入系数都是整型的时候最好优先考虑 NTT。","tags": "FFT NTT","url": "blog/2016-8-22/ntt.html"},
{"title": "所有文章","text": "所有文章<br/>2018<br/>2018-9<br/><br/>杜教筛的时空复杂度分析<br/><br/>2018-7<br/><br/>附中 2018 夏令营课件<br/><br/>2018-6<br/><br/>最小树形图: 最小树形图朱刘算法以及 Tarjan 的改进版本<br/><br/>2018-3<br/><br/>砍木棍问题: 将一根长为 $a$ 的木棍每次随机砍掉一段，期望多少次后木棍长度小于 $b$ ？<br/><br/>2018-1<br/><br/>区间加多项式问题的研究<br/><br/>2017<br/>2017-12<br/><br/>数学问题杂记: 一些比较有意思的数学问题<br/><br/>2017-10<br/><br/>计算纯电阻网络的等效电阻<br/>OI Coding Guidelines: 个人对 OI 编程的一些经验<br/>计算分拆数的一种方法: 使用多项式乘法加速计算分拆数<br/><br/>2017-9<br/><br/>静态树上的最近公共祖先问题: 介绍了求解最近公共祖先的主要的算法<br/><br/>2017-6<br/><br/>双重计数的简单应用: 介绍了几个双重计数在图计数上的例子<br/><br/>2017-5<br/><br/>【NOI2016】“循环之美” 无脑解法: NOI2016 Day1 T3 直接 DP 做法<br/>$n = p \\mathrm{\\;mod\\;} n$递推次数的上界？: 一个简单的求模质数意义下的逆元的算法的时间复杂度分析，未完工。<br/><br/>2017-3<br/><br/>拉格朗日插值法: 拉格朗日插值公式和其应用，用于求自然数的$k$次幂的前缀和<br/>指数与原根笔记: 数论中有关指数和原根的一些定理和相关算法<br/><br/>2017-2<br/><br/>无向图最小割: 关于无向图上的最小割问题以及该问题的解决方法<br/>长链剖分: 长链剖分算法，与树链剖分类似，但可以以 $O(n \\log n) - \\Theta(1)$ 的复杂度查询树上祖先<br/><br/>2017-1<br/><br/>曼哈顿距离最小生成树: 记录一下求 $n$ 个点的最小曼哈顿距离生成树的算法<br/><br/>2016<br/>2016-12<br/><br/>公平组合游戏: 公平组合游戏中十分重要的概念和 Sprague-Grundy 定理<br/>染色计数: 介绍了用于解决本质不同的染色问题的有力工具 Burnside 定理<br/>欧拉回路: 欧拉回路的判定与构造算法<br/><br/>2016-11<br/><br/>差分序列与 Stirling 数: 介绍了差分序列和两类 Stirling 数<br/>位运算卷积与 FWT: 介绍了位运算卷积以及快速计算的 FWT 算法<br/>辛普森积分法: 简单介绍了辛普森积分法和自适应辛普森积分法<br/>RSRL开发记录（一）<br/><br/>2016-10<br/><br/>收到一封奇怪的邮件<br/><br/>2016-9<br/><br/>Hall 定理: 一个用于判定二分图是否具有最大匹配的定理<br/><br/>2016-8<br/><br/>HNSDFZ2016 #5: HNSDFZ2016 第五次欢乐互测<br/>快速数论变换 (NTT): 快速傅立叶变换的双胞胎，用原根代替单位复数根<br/>二进制 GCD: 在算导上发现了一个有趣的算法，有氧环境下可以拿来卡卡常.....<br/>莫比乌斯反演: 介绍了莫比乌斯函数和莫比乌斯反演公式<br/>二项式定理及其它: 记录一下二项式定理、多项式定理和牛顿二项式定理的一些东西<br/>中国剩余定理 (CRT): 介绍了基本的中国剩余定理<br/>HNSDFZ2016 #4: HNSDFZ2016 第四次欢乐互测<br/>凸包相关: 凸包的构造算法与动态凸包、旋转卡壳和斜率优化<br/><br/>2016-7<br/><br/>平衡树套链表: 用链表加速平衡树上前趋后继的查询<br/>有关多项式的算法:记录一些与多项相关式算法<br/>HNSDFZ2016 #3: HNSDFZ2016 第三次欢乐互测<br/><br/>2016-6<br/><br/>极限与导数: 最近学了一些基础微积分，这里稍微记录一下<br/>诱导排序与 SA-IS 算法: 介绍一种在 2009 年出现的基于诱导排序思想的线性时间构建后缀数组的算法 SA-IS。此算法号称是目前速度最快的后缀数组构建算法<br/>树状数组: 总结一下树状数组的用法<br/><br/>2016-5<br/><br/>HNSDFZ2016 #2: HNSDFZ2016 第二次欢乐互测<br/>HNSDFZ2016 #1: HNSDFZ2016 第一次欢乐互测<br/>排列与组合: 介绍了排列与组合的基础知识<br/><br/>2016-4<br/><br/>伪代码规定: 规定下本博客的伪代码规范，不要想太多<br/>树链剖分: 介绍了树链剖分算法及其小扩展<br/>Graphviz: 可视化调试利器: 介绍可视化工具 Graphviz 的基本使用<br/>平面计算几何: 计算几何的基础知识和算法<br/>秩平衡树 (Rank Balanced Tree): 利用秩进行平衡的二叉搜索树<br/>替罪羊树 (Scapegoat Tree): 二叉平衡树替罪羊树<br/><br/>2016-3<br/><br/>$x^n-1$ 问题: 对 $x^n-1$ 进行因式分解<br/>2-3 树与红黑树: 2-3 树与红黑树<br/><br/>2016-2<br/><br/>DevIL 快速入门: 了解图片库 DevIL<br/>正式开始编写 ne2d: 启动 ne2d<br/>测试多说: 测试多说评论系统<br/>编译并使用 bgfx: bgfx 在 Ubuntu 上编译<br/>最小费用最大流: 增广路算法<br/>[POJ2135] Farm Tour: POJ2135 题解<br/>[NOIP2014] 寻找道路: NOIP2014 Day2 T2 题解<br/>[NOIP2015] 信息传递: NOIP2015 Day1 T2 题解<br/>最近公共祖先 (LCA): 朴素 LCA 算法，Tarjan LCA 算法，倍增法<br/><br/>2016-1<br/><br/>pagegen.py 的试炼: 测试 pagegen.py<br/><br/>临时链接<br/><br/>无尽的黄金 (HNSDFZ OIER FORBIDDEN before self contest #6)<br/>空袭 (HNSDFZ OIER FORBIDDEN before self contest #5)<br/>$k$-SBK 变换 (HNSDFZ OIER FORBIDDEN before self contest #4)<br/>HNSDFZ #3<br/>Lesson 16<br/>","tags": "Posts","url": "posts.html"},
{"title": "拉格朗日插值法","text": "拉格朗日插值法<br/>简介<br/>众所周知，给定$n + 1$个横坐标不相同的点，可以唯一确定一个$n$次的多项式。那么如何求出这个多项式？最直观的做法就是列方程求解。但是这样需要$\\Theta(n^3)$的时间来计算。而拉格朗日插值法则通过构造的方法，得到了一个经过$n + 1$个点的$n$次多项式。<br/>具体的过程是这样的，假设现在我们得到了$n + 1$个点：<br/>$$<br/>(x_0, y_0), \\;(x_1, y_1),\\; \\dots,\\;(x_n, y_n)<br/>$$<br/>设拉格朗日基本多项式为：<br/>$$<br/>\\ell_j(x) = \\prod_{i = 0, i \\neq j}^n {x - x_i \\over x_j - x_i}<br/>\\tag{1.1}<br/>$$<br/>这个基本多项式构造十分巧妙，因为注意到$\\ell_j(x_j) = 1$，并且$\\ell_j(x_i) = 0, \\;\\forall i \\neq j$。那么，接着构造出这个$n$次多项式：<br/>$$<br/>P(x) = \\sum_{i = 0}^n y_i\\ell_i(x)<br/>\\tag{1.2}<br/>$$<br/>根据基本多项式的性质，我们可以知道$P(x_i) = y_i$，也就是经过了这$n + 1$个点。<br/>通过简单的多项式乘法和多项式除法就可以在$\\Theta(n^2)$的时间求出这个多项式的系数表达。<br/>拉格朗日插值公式形式比较优美，接下来将介绍拉格朗日插值法另外一个应用。<br/>自然数的幂的前缀和<br/>这是一个十分经典的问题：<br/><br/>对于给定的$n$和$k$，要求求出：<br/>$$ \\sum_{a = 1}^n a^k $$<br/>通常$n$会比较大，而$k$只有几千或者几万。<br/><br/>当$k = 1$时，我们知道公式为$n(n + 1) / 2$，是一个二次多项式。<br/>更一般的，答案一定是$k + 1$次多项式。通过差分可以处理这种多项式，具体的可以参考我之前的博客或者有关第二类斯特林数的资料。<br/>现在我们来考虑使用拉格朗日插值法来获得答案多项式。<br/>首先如果我们得知了$n = 0, 1, \\dots, k + 1$处的答案$f(n)$，那么给定的$n$处的答案可以写成：<br/>$$<br/>\\begin{aligned}<br/>f(n) & = \\sum_{i = 0}^{k + 1} f(i) {(n - 0)(n - 1)\\cdots[n - (i - 1)][(n - (i + 1)]\\cdots[n - (k + 1)] \\over (i - 0)(i - 1)\\cdots[i - (i - 1)][(i - (i + 1)]\\cdots[i - (k + 1)]} \\\\<br/>& = \\sum_{i = 0}^{k + 1} f(i) {\\prod_{j = 0}^{i - 1} (n - j) \\prod_{j = i + 1}^{k + 1} (n - j) \\over i!(-1)^{k - i + 1}(k + 1 - i)!} \\\\<br/>& = \\sum_{i = 0}^{k + 1} (-1)^{k - i + 1}f(i) {\\prod_{j = 0}^{i - 1} (n - j) \\prod_{j = i + 1}^{k + 1} (n - j) \\over i!(k + 1 - i)!}<br/>\\end{aligned}<br/>$$<br/>注意到后面的分式中，分子是一个前缀积乘以一个后缀积，而分母是两个阶乘。这些都可以在$\\Theta(k)$的时间内求出。<br/>现在剩下的问题就是如何求出$f(0), f(1), \\dots, f(k + 1)$了。由于$g(x) = x^k$是个完全积性函数，所以我们可以通过欧拉筛法求出$g$函数前面的一些值。具体的就是对于质数采取直接快速幂，合数则拆出任意一个因子来算，通常是欧拉筛法中可以顺便求得的最小质因子。根据素数定理，素数大约有$O(k/\\ln k)$个。每次快速幂需要花费$\\Theta(\\log k)$的时间，因此总的时间复杂度可以估计为$\\Theta(k)$，是一个非常优秀的算法。<br/>上面的方法具有通用性，只要我们可以快速的求出某个$k$次多项式的前$k + 1$个值，那么剩下的部分可以使用拉格朗日插值法在$\\Theta(k)$的时间内完成计算。","tags": "多项式插值","url": "blog/2017-3-18/lagrange-interpolation.html"},
{"title": "指数与原根笔记","text": "指数与原根笔记<br/>这里大部分定理的证明方法摘自《初等数论》第三版。<br/>指数<br/>令$\\delta_m(a)$为满足下面等式的最小正整数$d$，称为模$m$下$a$的指数：<br/>$$<br/>a^d \\equiv 1 \\pmod{m}<br/>$$<br/>容易知道，如果$a$与$m$不互质，那么这样的正整数$d$不存在。因此下面均认为$a \\bot m$。<br/><br/>定理1 设$d_0 = \\delta_m(a)$，对于任意满足<br/>$$ a^d \\equiv 1 \\pmod{m} $$<br/>的$d$，均满足$d_0 \\mid d$。<br/><br/>证明 如果存在$d$满足该等式但$d_o \\nmid d$，我们可以知道：<br/>$$<br/>a^{d - d_0} \\equiv 1 \\pmod{m}<br/>$$<br/>对于$d - d_0$，如果$d - d_0 < d_0$，那么违背了$d_0$的定义，假设不成立。如果$d - d_0 \\geqslant d_0$，那么可以将$d$换为$d - d_0$继续以上过程，同样得到假设不成立。<br/>另一方面，如果$d_0 \\mid d$，那么最后得到$a^0 \\equiv 1 \\pmod{m}$，此时依然满足$d_0$的定义，所以$d_0 \\mid d$。<br/>根据欧拉定理我们知道：<br/>$$<br/>a^{\\varphi(m)} \\equiv 1 \\pmod{m} \\;\\;\\;\\; \\forall\\; a\\bot m<br/>$$<br/>因此可以推出：<br/>$$<br/>\\delta_m(a) \\mid \\varphi(m) \\tag{1.1}<br/>$$<br/>考虑一个数$a$和它的逆元$a^{-1}$，由于：<br/>$$<br/>a^d \\equiv 1 \\Longleftrightarrow (a^{-1})^d \\equiv 1 \\pmod{m}<br/>$$<br/>所以我们可以得到：<br/>$$<br/>\\delta_m(a) = \\delta_m(a^{-1}) \\tag{1.2}<br/>$$<br/>下面的定理可以帮助我们快速计算一个数的幂的指数：<br/><br/>定理2 设$k$是非负整数，则有：<br/>$$ \\delta_m(a^k) = {\\delta_m(a) \\over \\gcd(\\delta_m(a), k)} \\tag{1.3} $$<br/><br/>证明 令$\\delta = \\delta_m(a)$，$\\delta_1 = \\delta_m(a^k)$，$\\delta_2 = \\delta / \\gcd(\\delta, k)$，那么根据指数的定义，可以得到：<br/>$$<br/>a^{k\\delta_1} \\equiv 1 \\pmod{m}<br/>$$<br/>以及<br/>$$<br/>a^{k\\delta_2} \\equiv 1 \\pmod{m}<br/>$$<br/>根据定理1，我们可以得到：<br/>$$<br/>\\delta \\mid k\\delta_1, \\; \\delta_1 \\mid \\delta_2<br/>$$<br/>所以可以推出：<br/>$$<br/>\\delta_2 = { \\delta \\over \\gcd(\\delta, k) } \\;\\left|\\; { k\\delta_1 \\over \\gcd(\\delta, k) } \\right.<br/>$$<br/>又因为$\\delta_2 \\bot k / \\gcd(\\delta, k)$，所以$\\delta_2 \\mid \\delta_1$。综上可以得到定理。<br/><br/>定理3<br/>$$ \\delta_m(ab) = \\delta_m(a)\\delta_m(b) \\Longleftrightarrow \\delta_m(a) \\bot \\delta_m(b) \\tag{1.4} $$<br/><br/>证明 设$\\delta = \\delta_m(ab)$，$\\delta_1 = \\delta_m(a)$以及$\\delta_2 = \\delta_m(b)$。<br/>(充分性) $\\delta_m(a) \\bot \\delta_m(b) \\Longrightarrow \\delta_m(ab) = \\delta_m(a)\\delta_m(b)$<br/>因为：<br/>$$<br/>\\begin{aligned}<br/>(ab)^\\delta & \\equiv 1 \\equiv (ab)^{\\delta_1\\delta} \\\\<br/>& \\equiv b^{\\delta_1\\delta} \\pmod{m}<br/>\\end{aligned}<br/>$$<br/>所以可以知道$\\delta_2 \\mid \\delta_1\\delta$。又因为$\\delta_1 \\bot \\delta_2$，所以$\\delta_2 \\mid \\delta$。同理可得$\\delta_1 \\mid \\delta$。<br/>因为$\\delta_1 \\bot \\delta_2$，所以得到$\\delta_1\\delta_2 \\mid \\delta$。<br/>另一方面，由于：<br/>$$<br/>(ab)^{\\delta_1\\delta_2} \\equiv 1 \\pmod{m}<br/>$$<br/>所以$\\delta \\mid \\delta_1\\delta_2$。综上可以得到$\\delta = \\delta_1\\delta_2$。<br/>(必要性) $\\delta_m(ab) = \\delta_m(a)\\delta_m(b) \\Longrightarrow \\delta_m(a) \\bot \\delta_m(b)$<br/>利用$\\mathrm{lcm}(\\delta_1, \\delta_2)$作为中介。因为：<br/>$$<br/>(ab)^{\\mathrm{lcm}(\\delta_1, \\delta_2)} \\equiv 1 \\pmod{m}<br/>$$<br/>所以可以得到$\\delta = \\delta_1\\delta_2 \\mid \\mathrm{lcm}(\\delta_1, \\delta_2)$。又因为$\\mathrm{lcm}(\\delta_1, \\delta_2) \\mid \\delta_1\\delta_2$，所以可以得到两者相等。由此可以得知$\\delta_1 \\bot \\delta_2$。<br/><br/>定理4 如果$n \\mid m$，那么$\\delta_n(a) \\mid \\delta_m(a)$。<br/><br/>证明 令$\\delta_1 = \\delta_n(a)$以及$\\delta_2 = \\delta_m(a)$。<br/>由于：<br/>$$<br/>\\begin{aligned}<br/>a^{\\delta_2} & \\equiv 1 & \\pmod{m} \\\\<br/>& \\equiv 1 \\equiv a^{\\delta_1} & \\pmod{n}<br/>\\end{aligned}<br/>$$<br/>所以可以推出$\\delta_1  \\mid \\delta_2$。<br/><br/>定理5 如果$m_1 \\bot m_2$，那么$\\delta_{m_1m_2}(a) = \\mathrm{lcm}(\\delta_{m_1}(a), \\delta_{m_2}(a))$。<br/><br/>证明 令$\\delta = \\delta_{m_1m_2}(a)$，$\\delta_1 = \\delta_{m_1}(a)$以及$\\delta_2 = \\delta_{m_2}(a)$，<br/>那么根据定理4，我们可以知道$\\delta_1 \\mid \\delta$和$\\delta_2 \\mid \\delta$。因此$\\mathrm{lcm}(\\delta_1, \\delta_2) \\mid \\delta$。<br/>由于：<br/>$$<br/>\\begin{aligned}<br/>a^{\\mathrm{lcm}(\\delta_1, \\delta_2)} \\equiv 1 \\pmod{m_1} \\\\<br/>a^{\\mathrm{lcm}(\\delta_1, \\delta_2)} \\equiv 1 \\pmod{m_2}<br/>\\end{aligned}<br/>$$<br/>同时成立，并且$m_1 \\bot m_2$，所以可以得到$a^{\\mathrm{lcm}(\\delta_1, \\delta_2)} \\equiv 1 \\pmod{m_1m_2}$，所以$\\delta \\mid \\mathrm{lcm}(\\delta_1, \\delta_2)$。所以可以推出$\\delta = \\mathrm{lcm}(\\delta_1, \\delta_2)$。<br/><br/>推论 如果$m_1, m_2, \\dots, m_k$两两互质，那么：<br/>$$ \\delta_{\\prod_{i=1}^k m_i}(a) = \\mathrm{lcm}(\\delta_{m_1}(a), \\delta_{m_2}(a), \\dots, \\delta_{m_k}(a)) \\tag{1.5} $$<br/><br/>原根<br/>如果一个数$a$满足$\\delta_m(a) = \\varphi(m)$，那么$a$是$m$的一个原根。<br/>一个数$m$存在原根当且仅当$m = 1, 2, 4, p^a, 2p^a$，其中$p$是奇素数。<br/>当$m$有原根$g$时，所有与$m$互质的数均可以用$g$的某次幂来表示。换句话说，与$m$互质的所有的数是：<br/>$$<br/>g^0, g^1, \\dots, g^{\\varphi(m) - 1}<br/>$$<br/>对于一个与$m$互质的数$a$，用$\\log_{m,g} a$表示模$m$意义下以原根$g$为底$a$的离散对数（有些地方也称为指标）。满足：<br/>$$<br/>g^{\\log_{m,g}a} \\equiv a \\pmod{m}<br/>$$<br/>求解一个数的离散对数可以使用大步小步算法 (BSGS)。大致想法就是$a$一定能表示成如下形式1：<br/>$$<br/>a \\equiv g^{i\\sqrt{\\varphi(m)} - j} \\pmod{m}<br/>$$<br/>相当于我们要求满足下列方程的解：<br/>$$<br/>a g^j \\equiv g^{i\\sqrt{\\varphi(m)}} \\pmod{m}<br/>$$<br/>其中$i, j \\leqslant \\sqrt{\\varphi(m)}$，因此可以在$\\Theta\\left(\\sqrt{\\varphi(m)}\\right)$的时间内求出一个解或者报告不存在解。<br/>为了方便，没有歧义的情况下，离散对数将不会写下标。<br/><br/>定理6 当$a$、$b$和$ab$的离散对数存在时，满足：<br/>$$ \\log_{m,g} ab \\equiv \\log_{m,g} a + \\log_{m,g} b \\pmod{\\varphi(m)} \\tag{2.1}$$<br/><br/>证明 根据离散对数的定义：<br/>$$<br/>ab \\equiv g^{\\log a} \\cdot g^{\\log b} \\equiv g^{\\log a + \\log b} \\equiv g^{\\log ab} \\pmod{m}<br/>$$<br/><br/>定理7 (离散对数换底公式)<br/>如果$g$和$\\hat g$是$m$的两个原根，那么：<br/>$$ \\log_{\\hat g} a \\equiv \\log_{\\hat g} g \\cdot \\log_{g} a \\pmod{\\varphi(m)} \\tag{2.2} $$<br/><br/>证明 根据离散对数的定义：<br/>$$<br/>\\begin{aligned}<br/>a & \\equiv g^{\\log_g a} \\equiv (\\hat g^{\\log_{\\hat g} g})^{\\log_g a} \\\\<br/>& \\equiv \\hat g^{\\log_{\\hat g} g \\cdot \\log_g a} \\pmod{m}<br/>\\end{aligned}<br/>$$<br/><br/>定理8 (指数与离散对数的关系)<br/>$$ \\delta_m(a) = { \\varphi(m) \\over \\gcd(\\log_{m, g} a, \\varphi(m))} \\tag{2.3}$$<br/><br/>证明 由于$a \\equiv g^{log_{m,g} a}$，利用定理2就可得到上式。<br/><br/>定理9 (原根的个数)<br/>如果$m$存在原根，那么一定有$\\varphi(\\varphi(m))$个原根。<br/><br/>证明 根据原根的定义，原根$g$必须满足$\\delta_m(g) = \\varphi(m)$。<br/>如果$m$存在一个原根$g$，根据$(2.3)$式，另外与$m$互质的数$a$如果是原根，必须满足$\\log_g a \\bot \\varphi(m)$。由于$0 \\leqslant \\log_g a \\lt \\varphi(m)$，所以这样的数共有$\\varphi(\\varphi(m))$个。<br/>最后来关注一个问题，如果$m$满足了存在原根的条件，如何求出它的原根？<br/>显然，利用定理9，如果我们求出了一个原根，那么其他的原根可以通过枚举所有与$\\varphi(m)$互质的数，从而很快地求出来。<br/>但是求出一个原根似乎现在没有好的办法，但是考虑到原根有$\\varphi(\\varphi(m))$个，一般的最小正原根都比较小。因此一般的方法就是枚举原根并检验其正确性。检验的方法就是利用$(1.1)$式，看这个数是不是只有$\\varphi(m)$次幂才是$1$，否则就不是原根。<br/><br/><br/><br/><br/>有另外一种形式$a \\equiv g^{i\\sqrt{\\varphi(m)} + j} \\pmod{m}$，但是这种形式最后将会需要逆元，计算过程和可推广性都不如$a \\equiv g^{i\\sqrt{\\varphi(m)} - j} \\pmod{m}$优。 ↩<br/><br/><br/>","tags": "数论 原根","url": "blog/2017-3-8/exp-and-primitive-root.html"},
{"title": "排列与组合","text": "排列与组合<br/>排列与组合是组合数学中最基础的东西了。在此做一点记录。<br/>阶乘<br/>在组合数学中，阶乘随处可见，它极大的简化了公式的形式。<br/>我们将$n!$记作$n$的阶乘，其定义如下：<br/>$$ n! = \\prod^n_{i=1} i \\tag{1.1} $$<br/>特别的，$0! = 1$。之所以$0$的阶乘这样定义，是为了使后面的公式更具有普遍性。<br/>我们来看一下阶乘函数的增长：<br/><br/>上图中，红色的阶乘函数$ f(x) = x! $，蓝色的是$g(x) = x^2 $，而绿色的是$ h(x) = x^3 $。<br/>由此可见阶乘函数的增长比平方快。与三次方相比，阶乘函数在之后也将赶超。<br/>因此如果时间复杂度里面出现了阶乘，那将是一件可怕的事情。<br/>排列<br/>对于一个集合$S$，其排列是$S$中的元素的有序放置。<br/>例如集合$S = \\{ a, b, c \\}$，它的1排列为：<br/>$$ a, b, c $$<br/>其2排列为：<br/>$$ ab, ac, ba, bc, ca, cb $$<br/>3排列为：<br/>$$ abc, acb, bac, bca, cab, cba $$<br/>由于$|S| < 4$，所以$S$没有4排列。<br/>为了方便计数，我们将一个含有$n$个元素的集合的$r$排列个数记为$ P(n, r) $1。<br/>如：$P(3,1)=3, \\; P(3,2)=P(3,3)=6 $。<br/>特别的，我们定义$P(n,0)=1$。<br/>如何计算这个值呢？当然我们是有公式的：<br/>定理 对于任意的$n, r \\in N_+$，并且$ r \\le n$，有：<br/>$$ P(n, r) = {n! \\over (n-r)!} \\tag{2.1} $$<br/>证明 我们有$r$个空位来摆放元素。在第一个空位我们有$n$种选择，在第二个空位我们有$n - 1$中选择......由此可以得知：<br/>$$ P(n, r) = \\prod^n_{i=n-r+1} i = {n! \\over (n-r)!} $$<br/>现在我们来运用一下排列。<br/>首先来计数由$1$至$9$的数构成的每一位均不同的$7$位数有多少个。<br/>这个非常简单，就是$P(9, 7) = 181440$。<br/>如果现在要求$5$和$6$不能连续出现，那么这样的数又有多少个？<br/>我们考虑将连续出现的数给计数出来，这样就可以得到答案。<br/>我们发现，通过向一个$5$位数中插入两个数就可以得到一个$7$位数，因此我们来考虑将$5$和$6$连续的插入一个$5$位数中。我们只会插入$56$或$65$，它们在一个$5$位数中一共有$6$个位置可以插入。因此$5$和$6$连续出现的数共有$ 2 \\times 6 \\times P(7, 5) = 30240 $个。<br/>因此最终的答案为$ 181440 - 30240 = 151200 $。<br/>组合<br/>与排列相对，一个集合的组合2是其元素的无序放置。<br/>其含义就是从集合中”选取”出几个元素。由于不考虑位置关系，所以像$abc$和$bac$3是等价的。<br/>组合这一概念在整个组合数学中用处十分巨大。接下来我们先看到如何计数它。<br/>首先我们将组合数记为${n \\choose r}$4，表示一个大小为$n$的集合的$r$组合的个数。例如，一个大小为$4$的集合$ S = \\{ a,b,c,d\\}$的3组合为：<br/>$$ \\{a,b,c\\}, \\{a,b,d\\}, \\{a,c,d\\}, \\{b,c,d\\} $$<br/>因此${4 \\choose 3} = 4$。<br/>同样，为了能够更加方便的计数它，我们当然也是有公式的。<br/>我们发现，任意一个$r$组合，都会有$P(r,r) = r! $种排列。而每一种排列，都会对应到一个组合。因此，一个集合的$r$组合与排列之间存在以下关系：<br/>$$ {n \\choose r}r! = P(n,r) \\tag{3.1} $$<br/>将排列数展开，我们可以得到下面的公式：<br/>$$ {n \\choose r} = {n! \\over (n-r)!r! } \\tag{3.2} $$<br/>其中，$n,r \\in N_+$，且$r\\le n$。<br/>组合数的基本性质<br/>组合数有着许多非常有用的性质。首先一个非常基本的等式就是：<br/>$$ {n \\choose r} = {n \\choose n-r} \\tag{4.1} $$<br/>直接利用组合数的公式可以得证这一性质。<br/>通过对组合数进行求和，我们可以得知一个集合的子集数量：<br/>$$ \\sum^n_{i=0} {n\\choose i} = 2^n \\tag{4.2} $$<br/>这个等式当然可以用求和来得出。我们可以换个角度来考量它。一个集合的子集中，某些元素要么没有出现，要么就出现了。因此对于每个元素一共有两种选择，因此子集的总数为$2^n$个。<br/>接下来是比较重要的帕斯卡公式：<br/>定理 对于所有的$ 1 \\le k \\le n-1$的整数$n$和$k$：<br/>$$ {n\\choose k} = {n-1\\choose k} + {n-1\\choose k-1} \\tag{4.3} $$<br/>证明 尝试将右式化为左式即可。<br/>$$<br/>\\begin{aligned}<br/>{n-1\\choose k} + {n-1\\choose k-1} &= {(n-1)! \\over k!(n-k-1)!} + {(n-1)! \\over (k-1)!(n-k)!} \\\\<br/>&= {(n-1)!(n-k) \\over k!(n-k)!} + {(n-1)!k \\over k!(n-k)!} \\\\<br/>&= {(n-1)!n \\over k!(n-k)!} \\\\<br/>&= {n! \\over k!(n-k)!} \\\\<br/>&= {n \\choose k}<br/>\\end{aligned}<br/>$$<br/>这样就完成了证明。注意，在上面的证明中，利用到了阶乘的性质：$(n-1)!\\cdot n=n!$。<br/>不难发现，帕斯卡公式实际上是组合数的一个递推公式。<br/><br/>上图是由帕斯卡公式得到的一个递推的关系图，这里以${4 \\choose 3}$为例。其中灰色的节点是无效的值。为了方便，直接将其设为$0$。除了${1 \\choose 0} = {1 \\choose 1} = 1$为初始值外，其它的值都是由其所指向的节点的值求和而来。<br/>上面的步骤就是动态规划中的状态转移的过程。利用这个公式，我们可以在$\\Theta(nr)$的时间来计算大量的组合数。因此可以将此作为一个预处理。<br/>在具体实现的时候只需注意一些无效的特殊情况，其中包括$ r > n $和$n < 0$或$r < 0$。这些情况下的值均设为$0$。然后通过${1 \\choose 0}$和${1 \\choose 1}$这两个初始值就可以完成递推。<br/><br/><br/><br/><br/>当然也可记作$_nP_r$或$P^n_r$。 ↩<br/><br/><br/>《组合数学》中称之为”子集”，也许更为恰当。 ↩<br/><br/><br/>下面将使用集合的方式表示组合，如$\\{a,b,c\\}$。 ↩<br/><br/><br/>也可记作$_nC_r$或$C(n,r)$或$C^n_r$。 ↩<br/><br/><br/>","tags": "组合数学","url": "blog/2016-5-7/permutation-and-combination.html"},
{"title": "收到一封奇怪的邮件","text": "收到一封奇怪的邮件<br/>今天翻垃圾箱时发现了一封邮件，内容如下：<br/><br/>My beloved friend,<br/>I sent this mail praying for it to reach you in good health, since I myself are in a very critical health condition in which I sleep every night without knowing if I may be alive next day. My name is Mrs. Sarah Al moubi, a widow suffering from long time illness. I have some funds I inherited from my late husband, which I will need the help of a person like you to assist for this desired project, as my Doctor told me recently that I would not last due to the illness. Having known my condition, I decided to donate this fund to a good person that will utilize it the way I am going to instruct herein. I need a very honest and God fearing person who can use it for Charity works, for orphanages, widows and also build schools for less privilege that will be named after my late husband if possible.<br/>The sum is currently deposited in an existing bank. Your role will be to:<br/>[1]. Receive the funds into a business/private bank account.<br/>[2]. Invest/donate the funds to any orphanage home.<br/>[3]. Value of funds: (USD) $10.5 Million.<br/>I accept this decision because I do not have any child who will inherit this money after me.<br/>Please I want your sincerely and urgent answer to know if you will be available for this project, and I will give you more information on how the fund will be transferred to you. And everything will be done legally to ensure that the funds are transferred to you.<br/>I am waiting for your reply.<br/>Thank you,<br/>Mrs. Sarah Al moubi.<br/><br/>并不知道是我的哪个邮箱收到的，所以猜不出是什么网站上得到的邮箱。<br/>我到底该不该相信呢？","tags": "Email","url": "blog/2016-10-30/strange-email.html"},
{"title": "数学问题杂记","text": "数学问题杂记<br/>这里放些我见到过的比较有意思的数学题吧。本文会不定期更新。所有问题的标题都是记录到博客上的时间。<br/>2017.6.14<br/>问题描述<br/>给你一个无限长度的空白的尺子，问最少在上面画多少个刻度，使得可以量出 $1$ 到 $10$ 每一个整数长度？<br/>假设一共画了 $n$ 个刻度，每个刻度到最左边的刻度的距离为 $a_1,\\; a_2, \\;..., \\;a_n$，那么称一个长度 $x$ 为可测量的当且仅当存在一对 $i, \\;j$，满足 $a_i - a_j = x$。<br/>解决方案<br/>首先我们可以 xjb 试一试，$7$ 个点的方案是非常 naïve 的：<br/><br/>通过一番尝试，我们可以构造出 $6$ 个点的方案：<br/><br/>当然，因为没有长度限制，所以更长的方案我也构造出来过。总而言之，$6$ 个点的方案不是非常困难。构造上面这个方案时，我先画了一个原点，然后向右走一步，画一个点，继续走两步，画一个点。随后回到原点左边四格的位置画一个点。然后钦定最右边的为 $10$，将 $0$ 刻度画出来。此时发现 $9$ 不存在，所以将 $1$ 也点上。<br/>那么现在问题来了，$5$ 个点的方案能否找出来？<br/>理论上，$5$ 个点两两配对刚好 $10$ 对，给人一种可以构造的感觉。不过很可惜，$5$ 个点的方案是不存在的，这一结论可以使用计算机暴力得出。<br/>下面给出一个不需要任何暴力的证明：<br/><br/>由于 $5$ 个点两两配对一共 $10$ 对，所以所有点对之间的距离刚好是 $1$ 到 $10$，即不存在两个不同的点对之间的距离相同。由此可以推出，最远的两个点之间的距离为 $10$，所以我们可以先钦定刻度 $0$ 和刻度 $10$ 上有两个点。<br/>剩下还有 $3$ 个点，它们将长度为 $10$ 的线段分为 $4$ 段，这四段的长度总和要为 $10$，而 $10$ 的四拆分只有 $10 = 1 + 2 + 3 + 4$，所以这四段的长度构成 $1$ 至 $4$ 的一个排列。<br/>根据第一点，我们知道 $1$ 不能与 $2$ 或 $3$ 相邻，因为那样相邻的两段的长度之和就会与单独的长度为 $3$ 或 $4$ 的一段冲突，因此 $1$ 只能与 $4$ 相邻，并且 $1$ 只能在第一位或者最后一位。这样 $2$ 和 $3$ 必须相邻。又因为 $1+4 = 2+3$，所以我们推出矛盾，故不存在 $5$ 个点的方案。<br/><br/>到此处，我们已经可以回答上面的问题了，最少使用 $6$ 个刻度。<br/>2017.6.14<br/>问题描述<br/>对于 $n$ 个非负实数 $x_1, \\;x_2, \\;...,\\;x_n$，证明：<br/>$$<br/>x_1x_2\\cdots x_n \\leqslant \\left( \\frac{x_1 + x_2 + \\cdots x_n}n \\right)^n<br/>$$<br/>即基本不等式。<br/>解决方案<br/>我是在《具体数学》一书的习题上看到的，居然可以用反向归纳法，只能表示我这种菜鸡根本想不出来。<br/>首先 $n = 1$ 时显然，就不再考虑了。<br/>其次，根据初中知识，$(x_1 + x_2)^2 - 4x_1 x_2 = (x_1 - x_2)^2 \\geqslant 0$，我们可以得到 $n = 2$ 时的结论。<br/>接下来就比较机智了，首先如果对于 $n$ 成立，那么对于 $2n$ 也成立。我们可以考虑 $2n$ 时的不等式，是这样子的（现在还不成立）：<br/>$$<br/>x_1x_2\\cdots x_{2n} \\leqslant \\left({x_1 + x_2 + \\cdots x_{2n} \\over 2n}\\right)^{2n}<br/>$$<br/>设 $n$ 个变量 $y_1, \\;y_2, \\;..., \\;y_n$ 和 $z_1, \\;z_2$。我们令：<br/>$$<br/>x_{i + (j - 1)n} = y_i z_j \\;\\;\\;\\; (1 \\leqslant i \\leqslant n, \\; j = 1, \\;2)<br/>$$<br/>所以之前的不等式可以变为：<br/>$$<br/>(y_1y_2\\cdots y_n)^2(z_1z_2)^n \\leqslant \\left( {y_1 + y_2 + \\cdots y_n \\over n} \\right)^{2n} \\left( {z_1 + z_2 \\over 2} \\right)^{2n}<br/>$$<br/>由于：<br/>$$<br/>\\begin{aligned}<br/>y_1y_2\\cdots y_n &\\leqslant \\left( {y_1 + y_2 + \\cdots + y_n \\over n} \\right)^n \\\\<br/>z_1z_2 &\\leqslant \\left( {z_1 + z_2 \\over 2} \\right)^2<br/>\\end{aligned}<br/>$$<br/>都成立，所以对于 $2n$ 时基本不等式也成立。<br/>最后一步就是反向数学归纳法证明。假设现在 $n$ 是成立的，那么需要证明 $n - 1$ 也是成立的。这个证明非常简单，只需要令 $x_n$ 为 $E = \\left(\\sum_{k=1}^{n-1}x_k\\right) / (n - 1)$，就可以发现：<br/>$$<br/>\\begin{aligned}<br/>x_1x_2\\cdots x_{n-1}E &\\leqslant \\left( {x_1 + x_2 + \\cdots + x_{n - 1} + E \\over n} \\right)^n \\\\<br/>x_1x_2\\cdots x_{n-1}E &\\leqslant \\left( {(n - 1)E + E \\over n} \\right)^n \\\\<br/>x_1x_2\\cdots x_{n-1}E &\\leqslant E^n \\\\<br/>x_1x_2\\cdots x_{n-1} &\\leqslant E^{n-1} \\\\<br/>x_1x_2\\cdots x_{n-1} &\\leqslant \\left( {x_1 + x_2 + \\cdots + x_{n - 1} \\over n - 1} \\right)^{n - 1}<br/>\\end{aligned}<br/>$$<br/>因此对于 $n - 1$ 也是成立的。<br/>最后综合一下，如果要想证明 $n > 2$ 成立，只需要从 $m = 2$ 开始，倍增 $m$ 直到 $m \\geqslant n$，然后反向归纳到 $n$ 即可。因此基本不等式对于所有正整数 $n$ 均成立。<br/>2017.12.16<br/>问题描述<br/>（哥德巴赫-欧拉定理）<br/>(1) （《具体数学》第二章习题 31）证明：<br/>$$<br/>\\sum_{j=2}^\\infty\\sum_{k=2}^\\infty \\frac1{j^k} = 1<br/>$$<br/>(2) （《具体数学》第二章习题 35）设集合 $P = \\{m^n \\mid m,\\;n \\geqslant 2,\\;m,\\;n\\in \\mathbf{N}\\}$，因此我们知道：<br/>$$<br/>P = \\{4,\\;8,\\;9,\\;16,\\;25,\\;27,\\;32,\\;36,\\;...\\}<br/>$$<br/>证明：<br/>$$<br/>\\sum_{k \\in P} {1 \\over k - 1} = 1<br/>$$<br/>解决方案<br/>(1) 第一问使用几何级数即可：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{j=2}^\\infty\\sum_{k=2}^\\infty {1\\over j^k} & = \\sum_{j=2}^\\infty \\left({1 \\over 1 - \\frac1j} - 1 - \\frac1j\\right) \\\\<br/>& = \\sum_{j=2}^\\infty \\left(\\frac1{j-1} - \\frac1j\\right) \\\\<br/>& = 1<br/>\\end{aligned}<br/>$$<br/>(2) 考虑到 (1) 计算出的答案是 $1$，这在隐隐约约之中指引着我们去寻找 (1) 和 (2) 之间的联系。<br/>经过一番考虑，我们发现如果分子分母同除 $k$ 会有奇效：<br/>$$<br/>{1 \\over k - 1} = \\frac1k \\cdot {1 \\over 1 - \\frac1k} = \\frac1k\\sum_{j=0}^\\infty {1 \\over k^j} = \\sum_{j=1}^\\infty {1 \\over k^j}<br/>$$<br/>所以原式变身为：<br/>$$<br/>\\sum_{k \\in P}\\sum_{j=1}^\\infty \\frac1{k^j}<br/>$$<br/>十分巧妙的是，我们可以找出一种一一对应的关系，满足 $p^q = k^j$，其中 $p,\\;q \\geqslant 2$ （即 (1) 中的下标 $j$ 和 $k$），而 $k \\in P,\\;j\\geqslant 1$ （上面那个式子的下标）。<br/>根据 $P$ 的定义，设 $k = m^n$。在这里，我们可以要求 $m \\notin P$，因为如果 $m \\in P$，那么意味着 $m$ 又可以被表示成 $a^b$ 的形式，这时我们只需令 $m = a$ 并且使 $n$ 乘上 $b$ 就可以了。所以具体对应方案如下：<br/><br/>当 $j > 1$ 时，我们显然可以直接令 $p = k$ 以及 $q = j$，就可以满足要求。<br/>当 $j = 1$ 时，由于 $k = m^n$，所以我们还是可以令 $p = m$ 而 $q = n$。<br/><br/>为了证明这是双射，所以我们还需要从另一个方向来对应：<br/><br/>若 $p \\in P$，则 $k = p$ 并且 $j = q$，这是因为 $k \\in P$。<br/>若 $p \\notin P$，则 $k = p^q$，此时 $j = 1$。从这里可以看出我们要求 $m \\notin P$ 的好处。<br/><br/>至此，我们就成功证明了 (2) 中的等式。<br/>2018.1.7<br/>问题描述<br/>证明：对于任意的正整数 $n$，均可被表示为 $\\left\\lfloor \\sqrt2 k \\right\\rfloor$ 或 $\\left\\lfloor (2 + \\sqrt2)k \\right\\rfloor$ 中的有且仅有一种形式，其中 $k$ 也是正整数。<br/>换句话说，集合 $A = \\left\\{\\left\\lfloor \\sqrt2 k \\right\\rfloor \\mid k \\in \\mathbf{N}^+\\right\\}$，$B = \\left\\{\\left\\lfloor (2 + \\sqrt2) k \\right\\rfloor \\mid k \\in \\mathbf{N}^+ \\right\\}$，证明 $A \\cap B = \\varnothing$ 并且 $A \\cup B = \\mathbf{N}^+$，就像把正整数集划分为两半一样。<br/>解决方案<br/>这个思路确实比较有趣，我们尝试证明，对于任意的正整数 $n$，集合 $A$ 中不大于 $n$ 的元素个数 $a$ 与集合 $B$ 中不大于 $n$ 的元素个数 $b$ 之和等于 $n$。如果得到了这个结论，原命题就很容易说明了。<br/>先考虑集合 $A$:<br/>$$<br/>\\begin{aligned}<br/>a & = \\sum_k  \\left[1 \\leqslant \\left\\lfloor \\sqrt2 k \\right\\rfloor \\leqslant n \\right] \\\\<br/>& = \\sum_k  \\left[1 \\leqslant \\sqrt2 k < n + 1\\right] \\\\<br/>& = \\left\\lceil {n + 1 \\over \\sqrt2} \\right\\rceil - \\left\\lceil {1 \\over \\sqrt2} \\right\\rceil \\\\<br/>& = \\left\\lceil {n + 1 \\over \\sqrt2} \\right\\rceil - 1<br/>\\end{aligned}<br/>$$<br/>同理可得：<br/>$$<br/>\\begin{aligned}<br/>b & = \\left\\lceil {n + 1 \\over 2 + \\sqrt2} \\right\\rceil - 1 = \\left\\lceil {(2 - \\sqrt2)(n + 1) \\over 2} \\right\\rceil - 1 \\\\<br/>& = n + 1 + \\left\\lceil -{\\sqrt2(n + 1) \\over 2} \\right\\rceil - 1 \\\\<br/>& = n - \\left\\lfloor {n + 1 \\over \\sqrt2} \\right\\rfloor<br/>\\end{aligned}<br/>$$<br/>因此：<br/>$$<br/>a + b = n - 1 + \\left\\lceil {n + 1 \\over \\sqrt2} \\right\\rceil - \\left\\lfloor {n + 1 \\over \\sqrt2} \\right\\rfloor \\tag{1}<br/>$$<br/>我们知道，对于任意实数 $r$：<br/>$$<br/>\\lceil r \\rceil - \\lfloor r \\rfloor  = \\begin{cases}<br/>0 &  (r \\in \\mathbf{N}) \\\\<br/>1 &  (\\text{otherwise})<br/>\\end{cases}<br/>$$<br/>而 $(n+1) / \\sqrt2$ 一定是无理数，故 $(1)$ 式中的取上整减取下整的部分恒为 $1$，即 $a + b = n$。<br/>事实上，对于任意的正无理数 $\\alpha$ 和 $\\beta$，只要满足 $1/\\alpha + 1/\\beta = 1$，集合 $A = \\left\\{\\left\\lfloor \\alpha k \\right\\rfloor \\mid k \\in \\mathbf{N}^+\\right\\}$ 和集合 $B = \\left\\{\\left\\lfloor \\beta k \\right\\rfloor \\mid k \\in \\mathbf{N}^+\\right\\}$ 就会是一个正整数的划分。具体的证明方法与上面类似。<br/>2018.1.13<br/>问题描述<br/>求下面这个递推式的通项公式：<br/>$$<br/>\\begin{aligned}<br/>R(1) & = 4  \\\\<br/>R(n + 1) & = 3R(n) + 2^{n-1}-4n ~~~~(\\forall n > 1)<br/>\\end{aligned}<br/>$$<br/>解决方案<br/>这里主要是记录一下 Repertoire Method 这种方法，不过现在我还不知道该怎么翻译这个名称…<br/>这个方法基于一个简单的观察：如果设<br/>$$<br/>\\begin{aligned}<br/>R(1) & = a \\\\<br/>R(n + 1) & = 3R(n) + b\\cdot 2^{n-1} + c\\cdot  n + d<br/>\\end{aligned}<br/>$$<br/>我们会发现：<br/>$$<br/>\\begin{aligned}<br/>R(1) & = a \\\\<br/>R(2) & = 3a + b + c + d \\\\<br/>R(3) & = 9a + 5b + 5c + 4d \\\\<br/>R(4) & = 27a + 19b + 18c + 13d \\\\<br/>R(5) & = 81a + 65b + 58c + 40d \\\\<br/>&\\cdots<br/>\\end{aligned}<br/>$$<br/>可以猜测，$R(n)$ 的通项公式可以被写成以下形式：<br/>$$<br/>R(n) = a\\cdot f(n) + b \\cdot g(n) + c\\cdot h(n) + d \\cdot \\varphi(n)<br/>$$<br/>其中 $f(n)$、$g(n)$、$h(n)$ 和 $\\varphi(n)$ 都是关于 $n$ 的简单函数。运用数学归纳法，不难证明可以一直保持这种形式。<br/>我们现在的目标就是求出这四个函数。接下来的步骤就比较投机了，我们可以猜测当 $a$、 $b$、$c$、$d$ 取不同值的时候 $R(n)$ 可能的形式，我们可以假设 $R(n) = 1$，尝试找出是否有对应的值。根据递推的等式，可以列出：<br/>$$<br/>\\begin{cases}<br/>1 = a \\\\<br/>1 = 3 \\times 1 + b \\cdot 2^{n-1} + c\\cdot n + d<br/>\\end{cases}<br/>$$<br/>不难发现：$a = 1$ 以及 $d = -2$，其余两个变量只能为 $0$。回代到 $R(n)$ 的通项公式中：<br/>$$<br/>R(n) = f(n) - 2\\varphi(n) = 1<br/>$$<br/>我们明白，如果能按照类似的方式找到 $4$ 个这样的方程，我们就可以把四个函数全部都解出来。现在继续尝试一些其它的函数。考虑到递推式中有 $n$ 这种东西，可以尝试当 $R(n) = n$ 时的情况：<br/>$$<br/>\\begin{cases}<br/>0 = a \\\\<br/>n + 1 = 3n + b \\cdot 2^{n-1} + c\\cdot n + d<br/>\\end{cases}<br/>$$<br/>可以解出 $a = 1,\\;c = -2,\\;d = 1$。因此 $f(n) - 2h(n) + \\varphi(n) = n$。<br/>根据同样的想法，尝试一下 $R(n) = 2^n$：<br/>$$<br/>\\begin{cases}<br/>2 = a \\\\<br/>2^{n+1} = 3 \\times 2^n + b \\cdot 2^{n-1} + c\\cdot n + d<br/>\\end{cases}<br/>$$<br/>此时 $a = 2,\\;b = -2$，同时我们有 $f(n) - g(n) = 2^{n-1}$。<br/>此外注意到第二个递推式中 $R(n)$ 前的系数是 $3$，说明通项公式中应该是有 $3^n$ 这种东西的。于是尝试 $R(n) = 3^n$：<br/>$$<br/>\\begin{cases}<br/>3 = a \\\\<br/>3^{n + 1} = 3^{n+1} + b \\cdot 2^{n-1} + c\\cdot n + d<br/>\\end{cases}<br/>$$<br/>So easy, $a = 3$，并且可以直接知道 $f(n) = 3^{n - 1}$。<br/>现在 $4$ 个方程集齐了，只需要解下面这个方程组：<br/>$$<br/>\\left\\{<br/>\\begin{aligned}<br/>f(n) - 2\\varphi(n) & = 1 \\\\<br/>f(n) - 2h(n) + \\varphi(n) & = n \\\\<br/>f(n) - g(n) &= 2^{n-1} \\\\<br/>f(n) & = 3^{n - 1}<br/>\\end{aligned}<br/>\\right.<br/>$$<br/>不难解出：<br/>$$<br/>\\left\\{<br/>\\begin{aligned}<br/>f (n) & = 3^{n - 1} \\\\<br/>g(n) & = 3^{n-1} - 2^{n - 1}\\\\<br/>h(n) & = \\frac14 3^n - \\frac12 n - \\frac14 \\\\<br/>\\varphi(n) & = \\frac12 3^{n - 1} - \\frac12<br/>\\end{aligned}<br/>\\right.<br/>$$<br/>现在来解决原问题。原问题中，$a = 4,\\;b = 1,\\;c = -4,\\;d = 0$，所以 $R(n) = 4f(n) + g(n) - 4h(n) = 2\\times 3^{n-1} - 2^{n-1}+2n+1$。纵观整个过程，Repertoire Method 并不简单，甚至有点繁琐，但仍不失为探究问题的一种好思路。<br/>2018.2.17<br/>问题描述<br/>证明，对于任意的整数 $n$ 和正整数 $m$，满足：<br/>$$<br/>\\left\\lceil {n \\over m} \\right\\rceil = \\left\\lfloor {n + m - 1 \\over m} \\right\\rfloor<br/>$$<br/>解决方案<br/>直接证明这个问题并不是特别困难，因为右边就是 $1 + \\lfloor n/m - 1/m \\rfloor$，然后分情况讨论 $n/m$ 是否为整数就可以得到结论。这里就不详细说了。<br/>另外一种方法比较有意思，考虑将 $n$ 表示为 $m\\lfloor n/m \\rfloor + n \\bmod m$ 的形式，然后上式左右同减 $\\lfloor n/m \\rfloor$ 可以得到：<br/>$$<br/>\\begin{aligned}<br/>& \\left\\lceil {n \\over m} \\right\\rceil = \\left\\lfloor {n + m - 1 \\over m} \\right\\rfloor \\\\<br/>\\Leftrightarrow \\  & \\left\\lceil {n \\over m} \\right\\rceil - \\left\\lfloor {n \\over m} \\right\\rfloor = \\left\\lfloor {m\\lfloor n/m \\rfloor + n \\bmod m + m - 1 \\over m} \\right\\rfloor  - \\left\\lfloor {n \\over m} \\right\\rfloor \\\\<br/>\\Leftrightarrow \\  & \\left[\\frac{n}m \\not\\in \\mathbf{Z} \\right] = \\left\\lfloor {n \\over m} \\right\\rfloor + \\left\\lfloor {n \\bmod m + m - 1 \\over m} \\right\\rfloor  - \\left\\lfloor {n \\over m} \\right\\rfloor \\\\<br/>\\Leftrightarrow \\  & [n \\bmod m \\neq 0] = [n \\bmod m + m - 1 \\geqslant m] \\\\<br/>\\Leftrightarrow \\  & [n \\bmod m > 0] = [n \\bmod m > 0]<br/>\\end{aligned}<br/>$$<br/>从而证明了等式。<br/>2018.4.4<br/>问题描述<br/>（IMO 2012 预选题 C2）<br/>在 $\\{1,2,...,n\\}$ 中最多能选出多少对不相交的二元组 $(a, b)$，满足 $a + b \\leqslant n$，并且任意两对的元素之和不同？<br/>如，当 $n = 6$ 时，可以找出 $2 + 4 = 6$ 和 $1 + 3 = 4$，并且最多也只能找出两对。<br/>解决方案<br/>首先考虑上界，假设找到了 $m$ 对，则选出来的数字之和至少是：<br/>$$<br/>\\sum_{k=1}^{2m}k = m(2m + 1)<br/>$$<br/>而每对的和两两不同，意思是数字之和至多为：<br/>$$<br/>\\sum_{k = 0}^{m-1}(n-k) = mn - {m(m-1) \\over 2}<br/>$$<br/>根据这两个界限，可知：<br/>$$<br/>m \\leqslant {2n - 1 \\over 5} \\Leftrightarrow m \\leqslant \\left\\lfloor {2n - 1 \\over 5} \\right\\rfloor<br/>$$<br/>现在我们来尝试构造，使得正好能选出 $\\lfloor (2n - 1)/5 \\rfloor$ 对二元组。为了更方便地考虑这个问题，首先构建一个直观一点的模型。设第 $k$ 个二元组（$1 \\leqslant k \\leqslant m$）为 $(a_k, b_k)$，以及 $c_k = a_k + b_k$。尝试 $a_k = k$ 以及 $c_k = n - k + 1$ 的情况（也就是选取的最小的 $m$ 个数字和最大的 $m$ 个和，因为这样看起来成功率高一些），建立一个表格，如下图所示，其中每一个在第 $x$ 行第 $y$ 列的单元格上的数字为 $c_y - a_x$，代表 $b_k$ 的候选值：<br/><br/>(Fig.1. $n = 11$，$m = 4$ 时的情况。 左边一竖列从上至下为 $a_1..a_m$，最上面一横排从左至右为 $c_m..c_1$，中间 $16$ 个单元格代表的是 $b_k$ 的候选值。图中给出了一种构造方案，即 $1 + 8 = 9$，$2+9=11$，$3+5=8$ 和 $4+6=10$，这也是最优的方案之一)<br/>观察这个表格，一个重要的信息就是每一个从左上至右下的斜列（后简称斜列）上的数字是一样的。正如上图中所展示的，我们需要从中间 $m^2$ 个单元格中圈出 $m$ 个数字作为 $b_1..b_m$。当然这是有讲究的。由于不能选相同的数字，所以每一行、每一斜列均只能圈一个；因为和要两两不同，所以每一竖列也只能圈一个。同时我们注意到左下角可能会有和 $a_1..a_m$ 相同的区域，姑且称其为 “禁区”，因为这个里面的数字也不能圈。如果这些条件均满足了，那么不难发现我们得到了一个合法方案。<br/>根据上面的限制，格子中究竟写了什么数字已经不再重要了。现在的麻烦主要在于左下角的 “禁区”，它导致我们不能随意选择。因此，在构造的时候，要尽可能远离那个区域，也就是左下角要尽可能留出空白。为了探究规律，手玩一下 $m$ 较小的情况：<br/><br/>(Fig.2. $m$ 为 $1..6$ 时的最优解？)<br/>上图中 $m = 6$ 的规律已经体现得很明显了。记第 $x$ 行第 $y$ 列为 $(x, y)$。我们从 $(1, 2)$ 开始，设当前处在 $(x, y)$ 处，则下一步移动到 $(x+1,y+2)$ 处。如果 $y + 2 > m$，则移动到 $(x + 1, 1)$ 处。这有点类似于象棋中的 “跳马”。<br/>这样构造出来的方案显然是满足要求的，但是我们还需要考察 $m$ 的最大值，因为随着 $m$ 的增大，“禁区” 的范围也会扩大。由于我们的 “马步” 走法的直线的斜率小于 “禁区” 边界的斜率，所以只需考虑第 $1$ 列中的情况。在表格中 $(x, y)$ 上的数字为 $n - m - x + y$，易知最左列中 “禁区” 最高点是倒数第 $3m - n$ 个格子，而在这一列中，我们选取的位置是倒数第 $\\lceil m/2 \\rceil$ 个格子，所以：<br/>$$<br/>\\begin{aligned}<br/>& 3m - n < \\left\\lceil {m\\over 2} \\right\\rceil \\\\<br/>\\Leftrightarrow \\: & 3m - n < \\frac{m}2 \\\\<br/>\\Leftrightarrow \\: & m < {2n \\over 5} \\\\<br/>\\Leftrightarrow \\: & m \\leqslant \\left\\lceil{2n \\over 5}\\right\\rceil - 1 = \\left\\lceil{2n - 5\\over 5}\\right\\rceil \\\\<br/>\\end{aligned}<br/>$$<br/>虽然我们得到的结果与之前不同，但实际上 $\\lceil (2n - 5) / 5 \\rceil = \\lfloor (2n - 1) / 5 \\rfloor$，这是因为：<br/>$$<br/>\\begin{aligned}<br/>&\\left\\lceil {2n - 5 \\over 5} \\right\\rceil = \\left\\lfloor {2n - 1 \\over 5} \\right\\rfloor \\\\<br/>\\Leftrightarrow \\: & \\left\\lceil {2n - 5 \\over 5} \\right\\rceil \\leqslant {2n - 1 \\over 5} < \\left\\lceil {2n - 5 \\over 5} \\right\\rceil + 1 \\\\<br/>\\Leftrightarrow \\: & \\left\\lceil {2n - 1 \\over 5} - \\frac45 \\right\\rceil \\leqslant \\left\\lfloor {2n - 1 \\over 5} \\right\\rfloor \\leqslant {2n - 1 \\over 5} < {2n \\over 5} \\leqslant \\left\\lceil {2n \\over 5} \\right\\rceil<br/>\\end{aligned}<br/>$$<br/>最后一行最左边的小于等于号是通过分 $(2n - 1) / 5$ 是否为整数的两种情况讨论得来的：当它是整数时取等，否则其小数部分不大于 $4/5$，所以不等式成立。综上，答案就是 $\\lceil (2n - 5) / 5 \\rceil = \\lfloor (2n - 1) / 5 \\rfloor$。<br/>2018.5.19<br/>问题描述<br/>(1) 给定自然数 $n$，计算 $\\newcommand{up}[1]{\\left\\lceil #1 \\right\\rceil}\\newcommand{dw}[1]{\\left\\lfloor #1 \\right\\rfloor} \\sum_{k=1}^\\infty 2^k\\lfloor n/2^k + 1/2\\rfloor^2$。<br/>(2) 给定实数 $x$，定义 $\\newcommand{\\dis}[1]{\\lVert #1 \\rVert} \\dis{x} = \\min\\{\\up{x} - x,\\ x - \\dw{x}\\}$ 即 $x$ 离最近的整数的距离，计算 $\\sum_{k \\in \\mathbf{Z}} 2^k \\lVert x / 2^k \\rVert^2$。<br/>解决方案<br/>(1) 计算这个和的思路有点非常规，考虑递推的方法，设 $S_n$ 为上面的和式。考虑到任意自然数 $n$ 均可被唯一分解为 $2^p \\cdot q$（$q$ 是奇数），当 $k = p + 1$ 时：<br/>$$<br/>\\begin{aligned}<br/>\\left\\lfloor {n \\over 2^k} + \\frac12 \\right\\rfloor & = \\left\\lfloor {q + 1 \\over 2} \\right\\rfloor = {q + 1 \\over 2} \\\\<br/>\\left\\lfloor {n - 1 \\over 2^k} + \\frac12 \\right\\rfloor & =  \\left\\lfloor {q + 1 \\over 2} \\right\\rfloor - 1 = {q - 1 \\over 2}<br/>\\end{aligned}<br/>$$<br/>所以 $S_n$ 和 $S_{n - 1}$ 中第 $k$ 项之差为 $2^k \\cdot q = 2n$，而其余项中 $n / 2^k$ 得不到像上面 $q$ 这样的奇数，两者结果相同。所以 $S_n = S_{n - 1} + 2n = n^2 + n$。<br/>(2) 第二问实际上除了形式与第一问类似，其实没有多少关联......<br/>为了方便书写和探究，记函数 $f(x)$ 为我们需要计算的式子。写个程序瞎试一下其实会发现 $f(x) = x \\ (x \\geqslant 0)$。此外由于平方的原因，$f(-x) = f(x)$，不难推测 $f(x) = \\lvert x \\rvert$。<br/>难的是如何证明猜出来的结论。首先无论 $k$ 趋向于正无穷还是负无穷，级数总是收敛的，故对于所有的 $x$，$f(x)$ 总存在。由于 $f(-x) = f(x)$，因此我们可以只用考虑 $x \\geqslant 0$ 的情况。另外可以注意到 $f(2x) = 2f(x)$。令 $f(x) = l (x) + r(x)$，将 $f(x)$ 中 $k \\leqslant 0$ 的项放入 $l(x)$ 中，其余的放入 $r(x)$ 中，分开处理这两部分。<br/>对于 $l(x)$，由于 $1/2^k$ 当 $k \\leqslant 0$ 时均为整数，所以 $\\lVert x / 2^k \\rVert = \\lVert (x + 1) /2^k \\rVert$，即 $l(x + 1) = l(x)$。因为 $\\lVert x \\rVert \\leqslant 1/2$，所以 $l(x) \\leqslant \\sum_{k = 0}^\\infty 2^k / 4 = 1/2$。<br/>对于 $r(x)$，$k > 0 \\Rightarrow 2^k \\geqslant 2$，$0 \\leqslant x < 1$ 时，$\\lVert x / 2^k \\rVert$ 和 $\\dis{(x+1)/2^k}$ 都可以简单地化简出来。此时 $r(x) = \\sum_{k=1}^\\infty x^2/2^k = x^2 < 1$，而 $r(x + 1) = (1-x)^2/2 + \\sum_{k=2}^\\infty (x+1)^2/2^k = x^2 + 1$。即 $r(x + 1) = r(x) + 1$。综上，当 $0 \\leqslant x < 1$ 时 $f(x + 1) = f(x) + 1$。<br/>是否有更一般的结论呢？对于任意自然数 $n$，$f(x + n) = f(x) + n$ 能否被证明？考虑到 $f(2x) = 2f(x)$，因此尝试将 $n$ 设为 $2^mq + r$ 的形式，其中 $m \\geqslant 1$，$r$ 为 $0$ 或 $1$ 从而使得 $m$ 的条件可以满足。对 $n$ 使用归纳法，当 $n = 0,\\ 1$ 时显然，之后 $f(x + n) = 2^mf((x+r)/2^m + q)$，由于 $q < n$ 且 $x + r < 2 \\leqslant 2^m$ 根据归纳假设，之前的式子等于 $2^mf((x+r)/2^m) + 2^mq = f(x + r) + n - r = f(x) + n$。<br/>根据以上结论，再结合 $f(0) = 0$，我们已经可以得到对于任意整数 $n$，$f(n) = \\lvert n \\rvert$。接下来的步骤非常巧妙的利用了夹逼原理：还是假设 $x \\geqslant 0$，对于任意正整数 $m$，我们有：<br/>$$<br/>\\begin{aligned}<br/>f(x) & = 2^{-m}f(2^mx) \\\\<br/>& = 2^{-m}\\dw{2^mx} + 2^{-m}f(\\{2^mx\\})<br/>\\end{aligned}<br/>$$<br/>现在是时候来证明我们的猜想了：<br/>$$<br/>\\begin{aligned}<br/>0 \\leqslant \\lvert f(x) - x \\rvert & = \\lvert 2^{-m}\\dw{2^mx} - x + 2^{-m}f(\\{2^mx\\}) \\rvert \\\\<br/>& \\leqslant 2^{-m}\\lvert \\dw{2^mx} - 2^mx \\rvert + 2^{-m}f(\\{2^mx\\}) \\\\<br/>& < 1\\cdot 2^{-m} + (1/2 + 1) \\cdot 2^{-m} = 5/2 \\times 2^{-m}<br/>\\end{aligned}<br/>$$<br/>当 $m$ 趋近于无穷大时，右式趋近于 $0$。因此不难得到 $f(x) = \\lvert x \\rvert$ 的结论。<br/>2018.6.10<br/>问题描述<br/>已知 $0 \\leqslant a < 1$，$b \\geqslant 0$，找出关于 $a$ 和 $b$ 的充要条件使得我们能够根据多重集合 $S(a,\\ b)$：<br/>$$<br/>S(a,\\ b) = \\{\\dw{na} + \\dw{nb}:\\ n \\in \\mathbf{N}^+\\}<br/>$$<br/>唯一确定 $a$ 和 $b$ 的值。<br/>解决方案<br/>对于这个题，关键的一个处理步骤就是令 $\\newcommand{fa}[1]{\\{ #1 \\}}b = \\dw{b} + \\fa{b}$。考虑到 $\\dw{b}$ 是整数，且 $0 \\leqslant \\fa{b} < 1$，可以尝试做出以下转化：<br/>$$<br/>\\begin{aligned}<br/>\\dw{na} + \\dw{nb} & = \\dw{na} + \\dw{n\\dw{b} + n\\fa{b}} \\\\<br/>& = \\dw{n(a + \\dw{b})} + \\dw{n\\fa{b}}<br/>\\end{aligned}<br/>$$<br/>换句话讲，$S(a,\\ b) = S(\\fa{b},\\ a + \\dw{b})$。因此可以得出其必要条件为 $a = \\fa{b}$。<br/>得到这个后证明它同时也是充分条件也就不难了。令 $n = 1$，可以得到 $\\dw{b}$。之后将所有的 $n\\dw{b}$ 从 $S(a,\\ b)$ 中减去，得到 $S(a,\\ \\fa{b})$。由于 $a = \\fa{b}$，所以将 $S(a,\\ \\fa{b})$ 中每个元素除以 $2$ 就是 $\\{\\dw{na}:\\ n \\in \\mathbf{N}^+\\}$，由此可以唯一确定 $a$。<br/>2018.11.16<br/>问题描述<br/>已知实数域上的 Thomae Function $f(x)$ 为：<br/>$$<br/>f(x) = \\begin{cases}<br/>1/p & x \\in \\mathbf Q,\\ x = q/p,\\ p \\in \\mathbf N^+,\\ q \\in \\mathbf Z \\\\<br/>0 & x \\in \\mathbf R \\backslash \\mathbf Q<br/>\\end{cases}<br/>$$<br/>证明：$f(x)$ 处处不可微。<br/>解决方案<br/>对于一元函数，可导和可微是等价的。由于这个函数在有理点不连续1，故只需要考虑对于无理数 $a$，下面这个极限：<br/>$$<br/>\\lim_{x\\rightarrow a} {f(x) - f(a) \\over x - a} \\xlongequal{a \\text{ irrational}} \\lim_{x \\rightarrow a} {f(x) \\over x - a}<br/>$$<br/>是否存在。不失一般性，假定 $a \\geqslant 0$，小于 $0$ 的情况的讨论是类似的。稍作尝试估计都会觉得不存在。首先，对于趋近于 $a$ 的无理数列 $\\{x_n\\}$，显然：<br/>$$<br/>\\lim {f(x_n) \\over x_n - a} = 0<br/>$$<br/>为了证明极限不存在，我们需要再构造一个趋近于 $a$ 的实数列 $\\{y_n\\}$，使得类似的极限不为 $0$。考虑构造一个有理数列？首先，所谓趋近于 $a$ 就是对任意小的 $\\varepsilon > 0$，从某一项开始都有 $|y_n - a| < \\varepsilon$。设 $y_n = q/p > a $，那么上面这个极限就可以写成：<br/>$$<br/>\\lim {1/p \\over q/p - a}<br/>$$<br/>如果 $0 < q/p - a \\leqslant 1/p$，那么若其有极限，则极限至少不小于 $1$，我们的目的就达成了。而我们总能找到这样的 $p$，满足 $1/p < \\varepsilon$。同时，$q$ 只需要满足 $ap < q \\leqslant ap + 1$。这样令 $q = \\lceil ap \\rceil$ 就 OK 了。于是我们就构造出了这样的有理数列。所以 $f(x)$ 处处不可导，同时也处处不可微。<br/>2018.11.17<br/>问题描述<br/>已知 $\\varphi$ 为任意实数，求：<br/>$$<br/>\\lim_{n\\rightarrow\\infty} \\prod_{k = 1}^n \\cos{\\varphi \\over 2^k}<br/>$$<br/>解决方案<br/>首先你需要跳出 $\\cos$ 的怪圈，想到 $\\sin$ 的倍角公式：<br/>$$<br/>\\sin x = 2\\cos \\frac{x}2 \\sin \\frac{x}2<br/>$$<br/>于是你发现可以继续展开下去，得到一堆 $\\cos$ 相乘：<br/>$$<br/>\\sin x = 2^n\\cos \\frac{x}2 \\cos \\frac{x}4 \\cdots \\cos \\frac{x}{2^n} \\sin \\frac{x}{2^n}<br/>$$<br/>所以我们求的极限就是：<br/>$$<br/>\\lim_{n\\rightarrow\\infty} \\prod_{k = 1}^n \\cos{\\varphi \\over 2^k} = \\lim_{n\\rightarrow\\infty} {\\sin \\varphi \\over 2^n \\sin \\frac{\\varphi}{2^n}}<br/>$$<br/>当然上面这里要求 $\\varphi/2^n \\neq 0$。首先当 $n$ 足够大时，$|\\varphi / 2^n| < \\pi / 2$，这样就只剩 $\\varphi = 0$ 的情况了。而若 $\\varphi = 0$，原来那个极限等于 $1$，之后我们就默认其不为 $0$。由于 $\\varphi / 2^n \\rightarrow 0$，利用 $x \\sim \\sin x$ ($x \\rightarrow 0$)，所以：<br/>$$<br/>\\lim_{n\\rightarrow\\infty} {\\sin \\varphi \\over 2^n \\sin \\frac{\\varphi}{2^n}} = \\lim_{n \\rightarrow \\infty} {\\sin \\varphi \\over 2^n \\frac{\\varphi}{2^n}} = {\\sin \\varphi \\over \\varphi}<br/>$$<br/><br/><br/><br/><br/>证明可以查看 Wikipedia：https://en.wikipedia.org/wiki/Thomae% 27s_function#Properties “$f$ is discontinuous at all rational numbers, dense within the real numbers”。虽然这个命题 Wikipedia 上也证明了，但是这里稍微初等一些。 ↩<br/><br/><br/>","tags": "数学","url": "blog/2017-12-16/math-problems.html"},
{"title": "无向图最小割","text": "无向图最小割<br/>基本定义<br/>对于一张无向带权图$G = (V, E, w)$，将点集$V$分为两个不相交的集合$S$和$T$，满足$S \\cup T = V$，那么称$C = (S, T)$是图$G$的一个割。割的权值定义为两个端点不在同一集合内的边的权值之和，记做$W(C)$：<br/>$$<br/>W(C) = \\sum_{u \\in S, v \\in T, (u, v) \\in E} w(u, v)<br/>\\tag{1.1}<br/>$$<br/>对于指定的$s$和$t$，如果存在一个割$C = (S, T)$满足$s \\in S, t \\in T$或者$s \\in T, t \\in S$，那么称这个割为$s$-$t$割。<br/>对于一张图，权值最小的割称为最小割。多数情况下，最小割不是唯一的。<br/>例如，在下图中：<br/><br/>$(\\{2\\}, \\{1,3,4,5,6\\})$和$(\\{4\\}, \\{1,2,3,5,6\\})$均是最小割，其权值为$3$。而$(\\{1,2,3\\}, \\{4,5,6\\})$是一个$1$-$6$最小割，其权值为$51$。<br/>为了方便，我们对于任意的不相交集合$U$、$V$，要求$U \\cup V \\subseteq V$，定义它们之间的权值为：<br/>$$<br/>W(U, V) = \\sum_{u \\in U, v \\in V, (u, v) \\in E} w(u, v)<br/>\\tag{1.2}<br/>$$<br/>换言之。权值是横跨$U$和$V$的边的权值之和。<br/>现在来考虑一个比较浅显的定理：<br/><br/>对于任意四个不相交集合$S_1$、$T_1$、$S_2$和$T_2$，满足$S_1 \\cup T_1 \\cup S_2 \\cup T_2 \\subseteq V$，那么一定有：<br/>$$ W(S_1, T_1) + W(S_2, T_2) \\leqslant W(S_1 \\cup S_2, T_1 \\cup T_2) \\tag{1.3}$$<br/><br/>证明：<br/>$$<br/>\\begin{aligned}<br/>& W(S_1 \\cup S_2, T_1 \\cup T_2) = W(S_1, T_1) + W(S_1, T_2) + W(S_2, T_1) + W(S_2, T_2) \\\\<br/>& \\because W(S_1, T_2), W(S_2, T_1) \\geqslant 0\\\\<br/>& \\therefore W(S_1 \\cup S_2, T_1 \\cup T_2) \\geqslant W(S_1, T_1) + W(S_2, T_2)<br/>\\end{aligned}<br/>$$<br/>求解$s$-$t$最小割<br/>利用最大流最小割定理，一个图的$s$-$t$最小割实际上就是将原图建成一个源点为$s$，汇点为$t$的网络上的最大流，因此可以采用各种最大流算法来解决。这里不再详细介绍。<br/>求解全局最小割<br/>所谓全局最小割就是无向图本身的最小割，没有限定$s$和$t$。考虑到一个$s$-$t$最小割可能成为全局最小割，所以可以想出以下的过程：<br/><br/><br/>令$i = 1, w_0 = \\infty$。<br/>如果$|V| \\leqslant 1$，返回$\\min\\{w_0, w_1, \\dots, w_{n - 1}\\}$。<br/>随便选定两个点$s$和$t$，求出其$s$-$t$最小割，记权值为$w_i$。<br/>将$s$和$t$合并，即将$E$中的每条边的$t$改成$s$，并从$V$中删去$t$。<br/>$i = i + 1$，跳回第二步。<br/><br/><br/>这样做的理由是：假设全局最小割为$(S, T)$，那么分两种情况：<br/><br/>如果$s$和$t$分别在$S$和$T$中，那么$s$-$t$的最小割就是全局最小割。<br/>如果$s$和$t$同在$S$或$T$内，那么将$s$和$t$合并为一个点后，不会影响割的权值。<br/><br/>这样我们可以在$\\Theta(n)$次网络流内求出最小割。但是由于网络流算法时间复杂度比较高，所以这并不是一个很优的过程。<br/>考虑到在第三步中，我们实际上并不关心$s$和$t$是谁，我们只在意得到一个$s$-$t$最小割。那么是不是可以实现一个更加高效的方法来求出任意一个$s$-$t$最小割呢？<br/>现在来考虑以下这个算法：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19function ST-MINCUT(G):<br/>    assert |V| > 1<br/><br/>    A = {}<br/>    B = V<br/>    s = 0<br/>    t = 0<br/>    while |B| > 0:<br/>        p = 0<br/>        for u in B:<br/>            if W(A, {u}) > W(A, {p}):  // Assume that W(A, 0) = 0<br/>                p = u<br/><br/>        A = A ∪ p<br/>        B = B - {p}<br/>        s = t<br/>        t = p<br/><br/>    return (s, t)<br/><br/><br/>该算法会返回一个二元组$(s, t)$，表示$(V - {t}, {t})$是一个$s$-$t$最小割。<br/>下面我们将证明这是对的：<br/><br/>设$s$和$t$为ST-MINCUT中$A$集合倒数第二个加入的点和最后加入的点，那么$(V - \\{t\\}, \\{t\\})$是一个$s$-$t$最小割。<br/><br/>证明1：<br/>我们令$S^\\prime = V - \\{t\\}$、$T^\\prime = \\{t\\}$。对于图中任意一个$s$-$t$割$C = (S, T)$，假设$t \\in T$并且$s \\in S$。设$t^\\prime = v_i$为$T$中除了$t$之外最后被加入$A$的点。令$V_i = \\{v_1, v_2, \\dots, v_i\\}$。此外我们注意到$V_i$实际上是ST-MINCUT算法在$G$关于$V_i$的导出子图上的运行结果。<br/>这几个集合内的点的一种可能如下表所示：<br/>$$<br/>\\begin{matrix}<br/>S        & = &     & v_2 &          & \\dots  & s &   \\\\<br/>T        & = & v_1 &     & t^\\prime &        &   & t \\\\<br/>S^\\prime & = & v_1 & v_2 & v_3      & \\dots  & s &   \\\\<br/>T^\\prime & = &     &     &          &        &   & t \\\\<br/>\\end{matrix}<br/>$$<br/>进行归纳假设，对于$|V| = 2$的图，以上结论显然成立。现在假设对于$|V| \\lt n$的图均满足，尝试证明对于$|V| = n$的图也满足。<br/>现在我们要证明$W(S^\\prime, T^\\prime) \\leqslant W(S, T)$，就可以得出算法的正确性。首先注意到：<br/>$$<br/>W(S, T) \\geqslant W(V_i \\cap S, V_i \\cap T) + W(V_{n - 1} - V_{i - 1}, \\{t\\})<br/>\\tag{3.1}<br/>$$<br/>以及：<br/>$$<br/>W(S^\\prime, T^\\prime) = W(V_{i - 1}, \\{t\\}) + W(V_{n - 1} - V_{i - 1}, \\{t\\})<br/>\\tag{3.2}<br/>$$<br/>根据归纳假设，我们有：<br/>$$<br/>W(V_{i - 1}, \\{t^\\prime\\}) \\leqslant W(V_i \\cap S, V_i \\cap T)<br/>\\tag{3.3}<br/>$$<br/>考虑到算法的$A$变为$V_{i - 1}$时，选择了$t^\\prime$而不是$t$加入$A$集合，那么说明：<br/>$$<br/>W(V_{i - 1}, \\{t\\}) \\leqslant W(V_{i - 1}, \\{t^\\prime\\}) \\leqslant W(V_i \\cap S, V_i \\cap T)<br/>\\tag{3.4}<br/>$$<br/>综上可知：<br/>$$<br/>\\begin{aligned}<br/>W(S^\\prime, T^\\prime) & = W(V_{i - 1}, \\{t\\}) + W(V_{n - 1} - V_{i - 1}, \\{t\\}) \\\\<br/>& \\leqslant W(V_i \\cap S, V_i \\cap T) + W(V_{n - 1} - V_{i - 1}, \\{t\\}) \\\\<br/>& \\leqslant W(S, T)<br/>\\end{aligned}<br/>$$<br/>这样，我们可以通过执行$\\Theta(n)$次ST-MINCUT算法来找出全局最小割。ST-MINCUT的直接实现是$\\Theta(n^2)$的，如果使用二叉堆这种数据结构来实现，那么可以做到$\\Theta((n + m) \\log n)$的复杂度。这个算法就是Stoer-Wanger算法。<br/><br/><br/><br/><br/>这个证明是原论文中的证明方式，个人认为其中有一些不妥之处，因为在最后一步时，好像忽略了$w(t^\\prime, t)$，导致不等式会不成立。不知道是不是个人的理解上的偏差还是确实有误，如果有看过原证明的大神希望能指点我一下。 ↩<br/><br/><br/>","tags": "最小割 网络流 图论 组合优化","url": "blog/2017-2-12/mincut.html"},
{"title": "无尽的黄金","text": "无尽的黄金 (gold.cpp/in/out)<br/>时间限制：3s / 空间限制：512MB / 打开-O2优化<br/>题目描述<br/>探险家Lunk发现了一个藏在大山深处的洞穴。经过五天五夜的探索，Lunk在洞中发现了一个非常神奇的地方。这里有一个不断生成黄金的小口，每分钟可以取出一个黄金，不然这个黄金就会马上消失。取出的黄金自然会变成Lunk的了。贪婪的资本家绝对不会错过这个发财的大好时机，Lunk想要取走大量的黄金。<br/>然而在这旁边却立着一个牌子，上面写着：<br/><br/>Hello, Lunk,<br/>恭喜你，你非常机智地发现了这个奇妙的地方，我早已知道你到底想干什么。不如我们来玩个游戏，你可随意取走黄金，但是任意连续的$K$分钟内，你不可以取走过多的黄金，否则，你将找不到出去的路。<br/>Best wishes<br/>——XL<br/><br/>这让Lunk感到十分害怕，它担心自己一不留神就会触犯的这个可怕的规则。但是贪婪的资本家是不会放弃的，Lunk想知道究竟有多少种取走黄金的方法（可以全都不取），使得自己不会葬身于山洞之中。<br/>Lunk现在还有一些时间，希望你能够快速给出答案。<br/>输入格式<br/>每个数据仅一行，包含三个整数$T$，$K$和$C$。<br/>$T$表示Lunk还剩下的时间，单位为分钟。<br/>$K$和$C$表示Lunk在任意连续的$K$分钟内可以取走少于$C$个黄金。<br/>输出格式<br/>输出一行一个整数，表示Lunk取走黄金的方案数。由于答案可能非常大，所以请将答案对$1073741824$取模。<br/>样例输入<br/>12 2 2<br/><br/><br/>样例输出<br/>13<br/><br/><br/>样例解释<br/>只要Lunk不把所有黄金取走就好了，共有三种取法。<br/>数据限制<br/>本题采用捆绑测试，共$6$个子任务。<br/>每个子任务和数据点约定如下：<br/><br/><br/><br/>子任务 (分值)<br/>$T$的限制<br/>$K$的限制<br/>$C$的限制<br/><br/><br/><br/><br/>$1$ ($10\\% $)<br/>$\\le 10^3$<br/>$= 2$<br/>$= 2$<br/><br/><br/>$2$ ($10\\% $)<br/>$\\le 10^3$<br/>$= 3$<br/>$= 2$<br/><br/><br/>$3$ ($10\\% $)<br/>$\\le 10^3$<br/>$\\le 9$<br/>$\\le K$<br/><br/><br/>$4$ ($20\\% $)<br/>$\\le 10^5$<br/>$\\le 9$<br/>$\\le K$<br/><br/><br/>$5$ ($20\\% $)<br/>$\\le 2 \\times 10^7$<br/>$\\le 6$<br/>$\\le K$<br/><br/><br/>$6$ ($30\\% $)<br/>$\\le 2 \\times 10^7$<br/>$\\le 9$<br/>$\\le K$<br/><br/><br/><br/>对于$100\\% $的数据，均保证$1 \\le T \\le 2 \\times 10^7$，$1 \\le K \\le 9$，$0 \\le C \\le K$。<br/>时间限制：$2\\text{s}$<br/>空间限制：$512\\text{MB}$","tags": "Problems","url": "blog/2016-10-3/gold.html"},
{"title": "曼哈顿距离最小生成树","text": "曼哈顿距离最小生成树<br/>问题<br/>给你平面上的$n$个点，$n$个点之间两两连边，边权为两点间的曼哈顿距离，构成一张完全图。求这张完全图的最小生成树。<br/>朴素算法<br/>由于完全图的边数是$\\Theta(n^2)$级别的，所以直接使用稀疏图的最小生成树算法将会得到$\\Omega(n^2)$级别的算法。这是比较难以接受的。<br/>平面划分<br/>鉴于完全图边数十分之多，然而生成树上的边却只有$n - 1$条，是不是真正有用的边数也是$O(n)$级别的？<br/>事实上确实如此，如果我们随意选择一个点作为中心$O$，用四条直线将平面划为八个对称的区域，如下图所示：<br/><br/>上图中$R_1$到$R_8$就是被八等分出来的区域。<br/>接下来我们将证明，对于每一个区域，只需要留下离$O$最近的点的连边，最后形成的图的最小生成树就是原图的最小生成树。<br/>假设现在在区域$R_1$有两个点$A$和$B$，并且满足$|OA| \\leqslant |OB|$。那么根据最小生成树的环切性质1，我们只需要证明$|OB| \\geqslant |AB|$就可以了。在这里，$|AB|$表示$A$到$B$的曼哈顿距离。<br/>设$A(x_1, y_1)$和$B(x_2, y_2)$，我们需要考虑$4$种情况：<br/>情况2：$x_1 \\leqslant x_2, \\;y_1 \\leqslant y_2$<br/><br/>此时有：<br/>$$<br/>|AB| = x_2 - x_1 + y_2 - y_1 \\leqslant x_2 + y_2 = |OB|<br/>$$<br/>情况2：$x_2 \\leqslant x_1, \\;y_1 \\leqslant y_2$<br/><br/>此时有：<br/>$$<br/>|AB| = x_1 - x_2 + y_2 - y_1<br/>$$<br/>如果$|OB| \\geqslant |AB|$，那么也就有$|OB| - |AB| \\geqslant 0$，于是：<br/>$$<br/>\\begin{aligned}<br/>|OB| - |AB| & = x_2 + y_2 - x_1 + x_2 - y_2 + y_1 \\\\<br/>& = 2x_2 - x_1 + y_1<br/>\\end{aligned}<br/>$$<br/>由于在区域$R_1$满足$x_1 \\leqslant y_1$，所以上式大于等于$0$，即满足$|OB| \\geqslant |AB|$。<br/>情况3：$x_1 \\leqslant x_2, \\;y_2 \\leqslant y_1$<br/><br/>此时有：<br/>$$<br/>\\begin{aligned}<br/>|AB| & = x_2 - x_1 + y_1 - y_2 \\\\<br/>|OB| - |AB| & = x_2 + y_2 - x_2 + x_1 - y_1 + y_2 \\\\<br/>& = 2y_2 + x_1 - y_1<br/>\\end{aligned}<br/>$$<br/>由于$|OA| \\leqslant |OB|$和$x_2 \\leqslant y_2$，那么我们知道：<br/>$$<br/>x_1 + y_1 \\leqslant x_2 + y_2 \\Longrightarrow y_1 \\leqslant x_2 + y_2 \\leqslant 2y_2<br/>$$<br/>所以$|OB| \\geqslant |AB|$。<br/>情况4：$x_2 \\leqslant x_1, \\;y_2 \\leqslant y_1$<br/><br/>这种情况违反了$|OA| \\leqslant |OB|$这个条件，故不考虑。<br/>综上，在区域$R_1$内，只用保留离$O$最近的点的连边就可以了。<br/>对于其它的区域，都可以通过对称或者旋转，从而变成$R_1$的情况。因此$8$个区域均满足这一性质。<br/>这样一来，每个点只用连出$8$条边，然后在得到的图上使用稀疏图的最小生成树算法，就可得到原图的最小生成树。由于这张图的边数是$O(n)$的，所以如果我们使用Kruskal算法，我们的算法也就是$O(n \\log n)$的。<br/>一条边在上面的图中被两个端点都被计数了一次，所以最终的边数是不超过$4n$的。<br/>求出最近点<br/>上面的性质中还留下一个问题：如何求出每个区域内离$O$最近的点？<br/>从之前的关于边数的讨论中可知，我们只用求$R_1$到$R_4$的最近点即可。此外，利用对称的性质，我们可以全部归结到在$R_1$求最近点的算法中，只需要提前做一个坐标的变换。下面也将只考虑$R_1$的算法。<br/>考虑使用扫描线算法：将所有点按照$x$坐标升序排好序，$x$坐标相同的就按照$y$降序排序。然后从前往后扫描。我们将每个点按照$y - x$进行离散化（也就是经过该点的斜率为$1$的直线的纵截距）。对于某个点$i$而言，在以$i$为原点的$R_1$区域内点$j$满足$y_j - x_j \\geqslant y_i - x_i$。而$R_1$内离$i$最近的点$j$满足$y_j + x_j$最小。因此我们可以使用简单的数据结构，如线段树或者树状数组，就可维护$[y - x, \\;\\infty]$内$y + x$最小的是谁，从而求得每一个点的最近点。<br/>这个算法是$O(n \\log n)$的。因此，$n$个点的最小曼哈顿生成树可以在$O(n \\log n)$计算出来。<br/>至于坐标变换，一个比较方便的顺序就是先关于$y = x$对称，也就是交换$x$和$y$。然后关于$y = 0$对称，也就是将$y$取反，然后再关于$y = x$对称。这样执行$4$次扫描线算法就可以完成构图。<br/><br/><br/><br/><br/>对于图上一个环，删去环上权重最大的边后的图的最小生成树与原图一致。证明在很多地方都有。 ↩<br/><br/><br/>","tags": "最小生成树 计算几何","url": "blog/2017-1-17/manhattan-mst.html"},
{"title": "替罪羊树(Scapegoat Tree)","text": "替罪羊树(Scapegoat Tree)<br/>热身：线性时间建树<br/>问题 给定有序排好的元素序列，现在要你在$ \\Theta(n) $的时间内建立一棵平衡的二叉搜索树。<br/>最朴素的做法就是将元素逐一插入，由于许多平衡树的插入是$O(\\log n)$的，因此总时间复杂度为$O(n\\log n)$的。<br/>考虑到元素已经是排好序的，我们可以在这里做点优化。<br/>众所周知，二叉搜索树是有序的，即它的中序遍历是有序的。那么在它的中序遍历中，假设一个节点所处的位置为$i$，那么$i-1$就是它的左子树的大小，$n-i$就是右子树的大小。<br/>现在我们希望建一棵平衡二叉树，所以左右子树的大小应当相近。最优的情况为左右子树大小一致，此时该节点在中序遍历的最中间。<br/>于是我们得到了一个较好的算法，就是选取中间的元素作为根节点，将序列切为两部分，递归的建立左右子树即可。对于每个元素需要花费$\\Theta(1)$的时间来建立，总共有$\\Theta(n)$个节点。因此该算法的时间复杂度为$\\Theta(n)$。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14def build(s):<br/>    return build(s, 1, len(s))<br/><br/>def build(s, left, right):<br/>    if right < left:<br/>        return None<br/><br/>    mid = (left + right) / 2<br/>    node = new Node()                      # 新建节点<br/>    node.left = build(s, left, mid - 1)    # 递归建立左子树<br/>    node.right = build(s, mid + 1, right)  # 递归建立右子树<br/>    node.update()                          # 对该节点做必要的更新<br/><br/>    return node<br/><br/><br/>α权重平衡<br/>上面的热身非常简单。下面要讲的替罪羊树其实也很简单。在介绍替罪羊树之前，我们先了解下它的一个基本理论：α权重平衡(α-weight-balanced)。下文所述的平衡均为α权重平衡。<br/>我们认为一棵树$x$是平衡的当且仅当它每一棵子树满足下列条件：<br/>$$<br/>\\begin{aligned}<br/>\\text{size}(x.\\text{left}) &\\le \\alpha \\cdot \\text{size}(x) \\\\<br/>\\text{size}(x.\\text{right}) &\\le \\alpha \\cdot \\text{size}(x)<br/>\\end{aligned}<br/>$$<br/>其中，$ \\alpha \\in [0.5, 1] $。<br/>这个$\\alpha$可能会令人非常疑惑。我们首先来思考一下两个极值：$1$和$0.5$。<br/>当$a = 1$时，无论什么二叉树都会被视为平衡的，因为左右子树的大小不会超过这棵树的大小。这正对应着普通的二叉搜索树。<br/>而当$ a = 0.5$时，这时的要求将非常严格，左右子树的大小都必须是这棵树的大小的一半，此时只有完全二叉树能满足平衡要求。AVL树就是尝试保持这种平衡。<br/>我们都知道，二叉搜索树极易退化，而AVL树又为了平衡导致常数相当大，并且代码又臭又长，几乎没有人写。<br/>作为AVL树的改进，红黑树并不追求完美的平衡。通过放宽一些严格的平衡限制，保证了$ \\alpha = 0.666\\dots $的平衡，同时降低了常数，有着优良的性能。现在绝大多数语言的标准库都有它的身影。然而，红黑树对于OI竞赛而言代码量太大，不适合现场发挥。<br/>较为常用的Treap和Splay树则对$ \\alpha$没有强制的限定，它们利用随机化的思想来使树尽可能平衡，即它们会尽量使$\\alpha$值降低。我粗略测定了Treap、非旋转式Treap和Splay的$\\alpha$。结果如下：<br/><br/><br/><br/>BST \\ 测试<br/>1<br/>2<br/>3<br/>4<br/>5<br/>平均<br/><br/><br/><br/><br/>Splay（5个不同数据）<br/>0.758<br/>0.588<br/>0.582<br/>0.612<br/>0.759<br/>0.659<br/><br/><br/>Treap（同一个数据）<br/>0.766<br/>0.578<br/>0.601<br/>0.587<br/>0.781<br/>0.662<br/><br/><br/>非旋转式Treap（同一个数据）<br/>0.914<br/>0.860<br/>0.613<br/>0.678<br/>0.803<br/>0.773<br/><br/><br/><br/>以上的结果仅供参考。可见一般的BST都能够使$\\alpha$维持在$0.6$到$0.7$之间。  <br/>替罪羊树<br/>替罪羊树是一种平衡二叉树，它有一个很大的特点，就是它可以人为设定一个$\\alpha$值，并且它会在操作中来维护指定的平衡。个人感觉替罪羊树“又懒又暴力”，但经过实测，它的速度完全不亚于上面提及的BST。<br/>暴力重构<br/>替罪羊树之所以能维持平衡，就是因为它把不平衡的树都暴力重构成一棵完全二叉树！<br/>但是这样一来时间复杂度就会暴涨。因此替罪羊树应当设置一个合适的$\\alpha$值，避免过多的重构，从而均摊时间复杂度。可以证明，只要$\\alpha$设置合理，替罪羊树的所有操作都是$O(\\log n)$的。<br/>首先考虑如何重构。在之前线性时间建树的基础上，我们先将树的中序遍历给复制出来，然后就可以直接在这个基础上重建。<br/>查询<br/>替罪羊树的查询和二叉搜索树一模一样，毕竟查找不会导致树的不平衡，那么它也没有必要进行重构。<br/>插入<br/>替罪羊树的插入操作和二叉搜索树是差不多的，只是最后要检查回溯时的树链上有哪棵子树违反了平衡。然后直接将其重构即可。<br/>在重构时你可能会考虑到一条树链上可能有多个子树违反了平衡。对此，你只需要将最大的那棵子树重构即可。但是这样在实际代码中会略显复杂。如果你想偷懒，就只在回溯时找到了第一棵不平衡的树重构也是可以的。因为在替罪羊树中，同时出现几个不平衡的子树的情况也不是很多。在实际测试中，偷懒的写法在上千万的数据量下性能差距小于1s。<br/>删除<br/>替罪羊树的删除操作很好的体现了Lazy思想。它在删除节点时，并不是真正的删除，而是将其标记。此后所有的操作都将其无视，重构就直接丢弃，除非有插入操作将其恢复。当然我们不能无止尽地进行标记。如果被标记的节点数超过了整棵树大小的一半，我们就直接将整棵树重构，同时清除删除的节点。<br/>实现细节及其时间复杂度<br/>节点定义<br/>除了存储键值外，我们还需要存储树的大小和删除标记。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25struct Node<KeyType, ValueType>:<br/>    key:     KeyType    # 键<br/>    value:   ValueType  # 值<br/>    size:    int        # 树的大小<br/>    deleted: bool       # 删除标记<br/>    left:    Node       # 左子树<br/>    right:   Node       # 右子树<br/><br/>    def update(self):<br/>        self.size = self.left.size + self.right.size<br/><br/>        if not self.deleted:  # 如果自己不是被删除的节点<br/>            self.size += 1<br/><br/># 空结点<br/>struct NoneNode<*, *>:<br/>    key     = None<br/>    value   = None<br/>    size    = 0<br/>    deleted = True<br/>    left    = NodeNode()<br/>    right   = NodeNode()<br/><br/>    def update(self):<br/>        pass<br/><br/><br/>选定α<br/>替罪羊树的好处在于我们有了更好的调控能力。$\\alpha$这个值可以选取$0.5$到$1$中的任意一个值。一般情况下选取$0.7$到$0.8$最佳。我们可以根据实际需要来作出适当调整。$\\alpha$越大插入速度就越快，而访问和删除速度就会降低。反之则插入变慢。这里我们选择$0.75$：<br/>1ALPHA = 0.75<br/><br/><br/>重构<br/>重构操作十分简单，只需要中序遍历一遍就可以重建树了。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21# 中序遍历<br/>def travel(h, s):<br/>    if h is NoneNode:<br/>        return<br/><br/>    travel(h.left, s)<br/>    if h is not deleted:  # 忽略删除的节点<br/>        s.append(h)<br/>    travel(h.right, s)<br/><br/>    if h is deleted:<br/>        del h<br/><br/>def refact(h):<br/>    assert h is not NoneNode<br/><br/>    s = []<br/>    travel(h, s)<br/><br/>    # 重建<br/>    return build(s)<br/><br/><br/>插入<br/>插入操作与二叉搜索树一致，只是在最后要重新从顶向下检查一遍是否有不平衡的子树。如果有就重构。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12def check(h, key):<br/>    if h is NoneNode:<br/>        return NoneNode()<br/>    elif max(h.left.size, h.right.size) > ALPHA * h.size:<br/>        return refact(h)<br/>    elif key < h.key:<br/>        h.left = check(h.left, key)<br/>    elif key > h.key:<br/>        h.right = check(h.right, key)<br/><br/>    h.update()<br/>    return h<br/><br/><br/>删除<br/>当我们命中删除的节点时，直接将其作删除标记，然后退回。删除结束后，检查整棵树中被删除的节点数是否超过了总结点数的一半，如果超过就整体重构。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12# 命中时<br/>h.deleted = True<br/>h.update()<br/>deleted_count += 1<br/><br/># ...<br/><br/># 删除完后<br/>if deleted_count > size / 2:<br/>    tree = refact(tree)<br/>    size -= deleted_count<br/>    deleted_count = 0<br/><br/><br/>时间复杂度<br/>替罪羊树的所有操作均摊复杂度为$O(\\log n)$。<br/><br/><br/><br/>操作<br/>时间复杂度（均摊）<br/><br/><br/><br/><br/>查询<br/>$O(\\log n)$<br/><br/><br/>插入<br/>$O(\\log n)$<br/><br/><br/>删除<br/>$O(\\log n)$<br/><br/><br/><br/>对于查询操作，因为替罪羊树是保持了$\\alpha$平衡的.只要$\\alpha$值是合理的，那么这棵树就能保持比较平衡的状态，故插入是$O(\\log n)$的。<br/>对于插入操作，我们假设一个刚好重构过的子树的大小为$x$。在最坏情况下，我们可以向它的一侧不停的插入节点。假设当向一侧插入了$k$个节点时恰好破坏了平衡，那么此时$k$将满足：<br/>$$ \\left\\lfloor\\frac{x}{2}\\right\\rfloor + k \\gt \\alpha \\cdot (x + k) $$<br/>即<br/>$$ k > {\\alpha - \\frac{1}{2} \\over 1 - \\alpha}x $$<br/>因此每${\\alpha - \\frac{1}{2} \\over 1 - \\alpha}x $次就会进行一次重构。重构的时间复杂度为$\\Theta(x)$。我们均摊它的时间复杂度：<br/>$$ {\\Theta(x) \\over (\\alpha - \\frac{1}{2}) / (1 - \\alpha) \\cdot x} = \\Omega(1) \\; (\\alpha = 0.75) $$<br/>因此最好情况下我们可以均摊到$\\Omega(1)$。由于树能保持$\\alpha$平衡，因此插入操作的时间复杂度为$O(\\log n)$。<br/>同时我们可见，$\\alpha$越大，均摊的常数就会越低。<br/>对于删除操作，我们假设我们进行了$\\frac{n}{2}$次删除，并且为此触发了重构。由于每次删除的时间复杂度为$O(\\log n)$的，因此总的时间复杂度为：<br/>$$ \\sum_1^{\\frac{n}{2}} O(\\log n) + \\Theta(n) = \\frac{n}{2}O(\\log n) + \\Theta(n) $$<br/>我们将其均摊到$\\frac{n}{2}$次操作上：<br/>$$ {\\frac{n}{2}O(\\log n) + \\Theta(n) \\over \\frac{n}{2}} = O(\\log n) + \\Theta(1) = O(\\log n) $$<br/>最终的时间复杂度为$ O(\\log n) $。<br/>更多操作<br/>替罪羊树作为一种“又懒又暴力”的平衡二叉树，代码简单易于实现，并且性能十分不错。当然我们会想拓展更多的操作。当然，由于替罪羊树只会定时重构，不依赖其它的操作，因此可以扩展许多操作。下面列举一些：<br/><br/>rank取排名：记录了子树的大小就可$O(\\log n)$求出了。  <br/>第k大：记录了size可以$O(\\log n)$求出。  <br/>split拆分：非旋转式Treap的搞法即可，$O(\\log n)$。  <br/>merge合并按照可合并堆的搞法即可，$O(\\log n)$。  <br/>slice提取区间Splay乱搞，$O(\\log n)$。  <br/>各种区间操作，乱套各种树…$O(\\log n)$、$O(\\log n)$、$O(\\log n)$…  <br/>…  <br/>（当然有些时候何苦来乱搞）<br/>","tags": "算法 数据结构 替罪羊树","url": "blog/2016-4-6/scapegoat.html"},
{"title": "最小树形图","text": "最小树形图<br/>问题引入<br/>在带权无向图中，最小生成树是一个广为人知的问题。对应的，在有向图中，我们也可以定义有向生成树（Directed Spanning Trees，简称 DST）。在有向图 $G = (V,\\ E)$ 中，我们选定一个生成树的根节点 $r$，以 $r$ 为根的有向生成树是图 $G$ 的一个子图 $T$，并且子图 $T$ 中 $r$ 到任意非 $r$ 节点 $u$ 的路径存在且唯一。根据树的定义，子图 $T$ 的形状就是一棵以 $r$ 为根的树，只不过所有的边都是从父亲指向儿子的有向边。所以也称为 “树形图”。<br/>需要注意的是，并非图 $G$ 中任意一个节点都能成为某个 DST 的根。具体而言，必须要满足从 $r$ 出发能够到达其它的顶点。如果将图 $G$ 的所有强连通分量缩点，得到一张拓扑图，且拓扑图中只有一个入度为 $0$ 的点 $u$，则 $r$ 必须来自 $u$ 所代表的强连通分量中。<br/>类比最小生成树，最小树形图就是带权有向图 $G = (V,\\ E,\\ w)$ 中边权总和最小的 DST，简称 MDST（Minimum DST）。虽然定义类似，但算法却不尽相同。因为在有向图中，给定 DST 的根 $r$，有一些边可能不能成为任何一个 DST 的树边1。这导致对于无向图的算法（Kruskal 算法、Prim 算法等等）都无法在有向图上算出最小树形图。<br/>1965 年，朱永津和刘振宏 [1] 最先提出了最小树形图时间复杂度为 $O(VE)$ 的算法。两年后，也就是 1967 年，Edmonds [2] 也独立发现了同样的算法。可能 Edmonds 名气比较大，现在英文资料里面关于这个算法的叫法总少不了 Edmonds 的名字 QAQ<br/>算法流程<br/>首先，DST 有一个特点：除根节点外，其它节点的入度为 $1$。此外，DST 是不存在环的。一个非常奇怪的想法就是，对于每个非根节点，选择入边中边权最小的。因为这样选择之后，如果图中没有环，不难发现就构成了一棵 DST，并且显然它的边权之和也是最小的，因此直接找到了 MDST。<br/>当然现实没有那么美好，很大概率下，这样选择会出现环。现在来考虑其中的一个环 $C$，这个环上至少有一条边是不能选的。但可能还有更多的边在真正的 MDST 中也不能选？然而事实却非常巧，注意到环 $C$ 不是一般的环，它是由边权最小的入边组成的环。我们可以证明，存在一棵 MDST，其中进入环 $C$ 的边只有一条。<br/><br/>Fig.1. 环 $C$ 的一个示意图。红色的边不是环上的边，是某棵 MDST 中的边。虚线边被红色边所取代。<br/>如上图所示，对于任意的 MDST，设为 $T$，如果只有一条进入环 $C$ 的边，那我们的目的就达成了。否则，将会有至少两条边进入。如上图所示，选择其中一个进入点 $y$（即上图中边 $u$ 和边 $v$ 进入的点），设边 $u$ 的另一个端点为 $x$。不难发现 $x$ 和 $y$ 在树 $T$ 上的 LCA（最近公共祖先）不在环 $C$ 上，所以将边 $v$ 从 $T$ 中删去，然后加入边 $u$，得到的依然是一棵 DST，设为 $T'$。而边 $u$ 是 $y$ 入边中边权最小者，即 $w(u) \\leqslant w(v)$，所以 $T'$ 的边权之和不超过 $T$ 的边权之和，所以 $T'$ 也是一棵 MDST。重复此操作我们可以得到只有一条进入环 $C$ 的边的 MDST。<br/>换句话说，我们可以只用考虑删去环 $C$ 的一条边的情况。想象一下，相当于环 $C$ 只有一条入边。这又与 DST 有相似之处。考虑将环 $C$ 缩成一个点，在得到的新图 $G'$ 中，图 $G'$ 中的一个 DST 可以对应我们所需要的考虑的一个 DST。这启发着我们进行一次递归的操作：假定原来我们选择了环 $C$ 中所有的边，但由于 DST 定义的要求，我们需要从中替换掉一条边 $u$，换成环 $C$ 外的一条边 $v$，此时边权之和会多增加 $w(v) - w(u)$。所以，将环 $C$ 缩为一个点 $c$ 时，设环 $C$ 中进入点 $x$ 的边为 $\\mathrm{in}(x)$，对图 $G$ 中的所有边 $e:\\ u \\rightarrow v$ 作如下处理：<br/><br/>如果 $u,\\ v \\notin C$，即环外一条边，该边保持不变。<br/>如果 $u,\\ v \\in C$，即内接在环上的一条边，将这条边删去。<br/>如果 $u \\in C$ 而 $v \\notin C$，相当于从环 $C$ 出发的边，则将 $u$ 改为 $c$。<br/>否则就是进入环 $C$ 的边，此时将 $v$ 改为 $c$，且边权变为 $w(e) - w(\\mathrm{in}(v))$。<br/><br/>在得到的新图 $G'$ 中计算 MDST，得到 $T'$，根据 $T'$ 进入 $c$ 的边的 “前身” 就可以知道环 $C$ 中应该抛弃哪一条边了。将原图 $G$ 中的自环排除后，每次这样的操作至少可以减少一个点，所以总的时间复杂度为 $O(VE)$。<br/>快速实现<br/>我们知道，无向图中最小生成树的时间复杂度取决与排序的复杂度，即 $O(E \\log E)$ 或比这更好的 $O(E + V \\log V)$。相比之下，之前的算法实在是太慢了。于是伟大的 Tarjan 老爷子 [3] 就出现了。Tarjan 在 1977 年提出了一个时间复杂度为 $O(E \\log V)$ 的实现，他将上述算进行了调整，使用一个迭代式的过程完成了算法。首先，为了方便，我们假定带权有向图 $G$ 是强连通的。即使没有强连通，可以添加 $V$ 条边将每个点顺次连成一个环，并且每条边的边权足够大，使得它们不会出现在 MDST 中，这样就可以保证强连通。<br/>算法开始时，选取图中任意一个点 $x$，然后选取 $x$ 的入边中边权最小的边 $e:\\ u \\rightarrow x$，如果 之前没有访问过 $u$，则将 $u$ 追加到 $x$ 后面，构成一条链，然后继续从 $u$ 开始执行同样的步骤。如果 $u$ 已经被访问过，说明在链中形成了一个环，此时则执行缩环操作。最后，由于强连通的特性，整张图会被缩成一个点。在此期间，我们可以存下缩环的操作结果，这用一棵树来表示：<br/><br/>Fig.2. 左边是一个 $4$ 个点的强连通图，右边是算法完成后所给出的树结构。首先将环 $1 \\rightarrow 2 \\rightarrow 3$ 缩为了点 $5$，然后将环 $5 \\rightarrow 4$ 缩为了点 $6$。这棵树展示了环与环之间嵌套的关系。<br/>得到这棵树之后，我们就可以从任意合法的根节点开始展开整个 MDST 了。上述过程中缩点一般采用并查集数据结构，而为了能够既完成缩点，又能随时从某个点中抽出边权最小的入边，这里则需要可并堆来高效实现。上面说的比较粗糙，因为仔细讲起来就太细节化了。我实现了朴素的 $O(VE)$ 算法和 Tarjan 的快速算法，用 POJ 3164 测试了下，如果细节上有问题的可以参考一下：<br/>$O(VE)$ 版本、$O(E \\log V)$ 版本<br/>另外，我是看的 Uri Zwick 教授 [4] 的讲稿写的算法，里面的实现部分写的比较详细。<br/>相关问题<br/>上面的讨论中，MDST 的树根都是给定了的。而在有些问题中，可能没有给定树根（更类似于无向图的最小生成树了）。解决这类问题并不需要进行 $O(V)$ 次展开。我们可以给图新增一个点 $x$，向原图中每一个点连一条边权足够大的边，这样以 $x$ 为根的 MDST 中，算法只会选择一条 $x$ 的出边，毕竟选择这样的边非常不划算。而此时 $x$ 的出边所指向的点就是原问题中 MDST 的树根。<br/>参考文献<br/>[1]. Chu, Y. J.; Liu, T. H. (1965), On the Shortest Arborescence of a Directed Graph, Science Sinica, 14: 1396–1400<br/>[2]. Edmonds, J. (1967), Optimum Branchings, J. Res. Nat. Bur. Standards, 71B: 233–240, doi:10.6028/jres.071b.032<br/>[3]. R.E. Tarjan. (1977), Finding optimum branchings, Networks, 7:25–35<br/>[4]. Uri Zwick. (2013), Directed Minimum Spanning Trees, Lecture notes on “Analysis of Algorithms”<br/>[5]. H.N. Gabow, Z. Galil, T.H. Spencer, and R.E. Tarjan. (1986), Efficient algorithms for finding minimum spanning trees in undirected and directed graphs, Combinatorica, 6:109–122<br/><br/><br/><br/><br/>例如，一棵 DST 上的所有 “返祖边”。 ↩<br/><br/><br/>","tags": "图论 数据结构 并查集 可并堆 最小树形图","url": "blog/2018-6-18/mdst.html"},
{"title": "最小费用最大流","text": "最小费用最大流<br/>之前一直想不明白最小费用流，今天翻了很多资料才理解了，在此做点记录。<br/>最小费用流<br/>我们首先定义流$f$的费用$w(f)$为：<br/>$$<br/>w(f) = \\sum_{(u,v)\\in f} w(u,v)f(u,v)<br/>$$<br/>那么最小费用（可行）流就是指一个在所有同流量的流中费用最小的流。<br/>最小费用最大流问题<br/>在给定的流网络$G$中，若$(u,v)\\in E$，则$c(u,v)$表示其容量，$w(u,v)$表示其单位流费用。设$f$为其中的可行流，最小费用最大流问题就是要求在使$f$为最大流的情况下，其总费用$w(f)$最小。<br/>增广路算法<br/>本文中我们只讨论增广路算法。最小费用流还有消圈法和神奇的ZKW算法。<br/>增广路算法有一个贪心的基本思想：已知一个最小费用流$f$，在流网络中找出一条费用最小的增广路对其增广得到$f^,$，那么$f^,$也是最小费用流。<br/>这个结论是显而易见的，因为原流费用最小，增广出来的新流费用也最小，那么总费用也是最小的。<br/>因此，寻找最小费用最大流的思路就出来了：<br/><br/>初始化零流$f$ <br/>寻找费用最小的增广路，如果没有则表明$f$已为最大流  <br/>增广流$f$，跳至第二步<br/><br/>在上面的步骤中，第二步是关键。<br/>我们首先要确定费用最小的衡量标准。首先考虑一条增广路会对流增加多少的费用。<br/>假设$p$是一条增广路，其瓶颈边（即剩余容量最小的边）的容量为$c_{min}$，那么增加的费用就是所有边所产生的费用之和：<br/>$$w(p) = \\sum_{(u,v)\\in p} w(u,v)c_{min} = c_{min}\\sum_{(u,v)\\in p} w(u,v)$$<br/>由于我们要保证每一步都是最小费用流，而流的大小并不在意，因为最后肯定能达到最大流。<br/>故我们不在乎每次流的增量$c_{min}$，而只要使单位费用之和最小即可。<br/>因此我们把每条弧的单位费用作为其边权，然后寻找一条从源点到汇点的最短路，这样就能使单位费用之和最小。<br/>实现细节<br/>现在我们来尝试实现增广路算法，首先我们定义边的结构体：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8# 表示有向边<br/>class DirectedEdge(object):<br/>    u:int                      # 出发点<br/>    v:int                      # 进入点<br/>    capacity:int               # 容量<br/>    flow:int                   # 现有流量<br/>    cost:int                   # 单位流费用<br/>    reverse_edge:DirectedEdge  # 表示其在残留网络中的反向边<br/><br/><br/>我们添加一个函数，计算边的的剩余流量：<br/>1<br/>2def r(edge:DirectedEdge):<br/>    return edge.capacity - edge.flow<br/><br/><br/>在残留网络中，如果剩余容量为0,它就已经不存在了。<br/>我们使G为一个有向边链表的数组，表示从某个点出发的边集合。<br/>现在思考下残留网络中反向边的费用。反向边本意是为了最大流算法能重新调整整个流，让算法能够“反悔”，<br/>因此我们给反向边的费用为-cost，能够与之前的选择抵消。这样导致出现了负边，因此找最短路不能使用Dijkstra算法，<br/>为了方便，我们添加一个add_edge函数来添加边：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10def add_edge(u:int, v:int, capacity:int, cost:int):<br/>    e  = DirectedEdge(u, v, capacity,  cost, flow=0)         # 初始为零流<br/>    re = DirectedEdge(v, u, capacity, -cost, flow=capacity)  # 注意是反向边<br/><br/>    # 设置反向边<br/>    e.reverse_edge = re<br/>    re.reverse_edge = e<br/><br/>    G[u].append(e)<br/>    G[v].append(re)<br/><br/><br/>这样就可方便的添加边<br/>最好采用Bellman Ford算法，这里使用其改进版SPFA算法：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23dist:int[]             = [INFTY...]  # 距离数组<br/>edge_to:DirectedEdge[] = [None...]   # 前趋边数组<br/><br/>def SPFA(s:int, t:int):<br/>    q:queue<br/>    q.push(s)<br/>    dist[s] = 0<br/><br/>    while q not empty:<br/>        u:int = q.pop()<br/><br/>        for edge in G[u]:<br/>            if r(edge) == 0:  # 如果剩余容量为0,这条边就不存在<br/>                continue<br/><br/>            # 松弛操作<br/>            v:int = edge.v<br/>            if dist[v] > dist[u] + edge.cost:<br/>                dist[v]    = dist[u] + edge.cost<br/>                edge_to[v] = edge  # 更新前趋边<br/><br/>                if v not in q:<br/>                    q.push(v)<br/><br/><br/>接下来就可以写最小费用最大流算法了：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29<br/>30<br/>31<br/>32<br/>33s:int  # 源点<br/>t:int  # 汇点<br/><br/>def compute_maxflow():<br/>    answer:int = 0<br/><br/>    while True:<br/>        SPFA(s, t)  # 寻找增广路<br/><br/>        if dist[t] == INFTY:  # 如果没有增广路，s到t的距离就不会更新<br/>            return<br/><br/>        minflow:int = INFTY  # 瓶颈边容量<br/><br/>        # 寻找瓶颈边<br/>        x:int = t<br/>        while edge_to[x] is not None:<br/>            minflow = min(minflow, r(edge_to[x]))<br/><br/>            x = edge_to[x].u<br/><br/>        # 增广<br/>        x = t<br/>        while edge_to[x] is not None:<br/>            DirectedEdge e = edge_to[x]<br/><br/>            answer += minflow * e.cost  # 更新总费用<br/>            e.flow += minflow<br/>            e.reverse_edge.flow -= minflow<br/><br/>            x = edge_to[x].u<br/><br/>    return answer<br/><br/><br/>至此，增广路算法就结束了。现在总结下其中涉及到的关键：<br/>1. 贪心选择：每次寻找费用最少的增广路<br/>2. 反向边边权：是相反的<br/>3. SPFA: 寻找最短路","tags": "算法 网络流 最小费用流 图论","url": "blog/2016-2-2/mincost-maxflow.html"},
{"title": "最近公共祖先(LCA)","text": "最近公共祖先(LCA)<br/><br/>NOTICE: 这是一篇旧文，可能存在一些没有被勘察出的错误。另有一篇同主题的文章在此。<br/><br/>1 概述<br/>1.1 什么是LCA？<br/>下面是一棵有根树，注意不一定是二叉树。<br/><br/>我们先定义深度函数$ d(u): u \\text{到根的最短距离} $。<br/>例如，在上图中$ d(1)=0,\\,d(3)=1,\\,d(9)=3$<br/>我们再定义一个函数$ LCA(u, v) $表示节点$ u $和$ v $的最小公共祖先。<br/>其定义为：<br/>$$ LCA(u,v):u和v的所有祖先p中,d(p)最大 $$<br/>举个例子：$ LCA(5,6)=3,\\,LCA(7,6)=3,\\,LCA(1,8)=1 $<br/>应该很简单吧。<br/>1.2 有什么卵用？<br/>一个简单的例子，计算完LCA后，可以在$ \\Theta (1) $的时间内算出任意两点的距离。<br/>还是下面这个图解释：<br/><br/>上面的树边上带了权重，两点之间的距离就是两点间的简单路径上的边权之和。<br/>例如$ distance(1,1)=0,\\,distance(2,3)=3,\\,distance(7,6)=6$<br/>如果用DFS或BFS来计算的话，需要$ O(n) $的时间复杂度。<br/>如果先预处理LCA，就只需$ \\Theta (1) $的时间。<br/>先不考虑是如何算出LCA的，先讲下如何快速求距离。<br/>上图中，dist数组表示节点到树根的距离，在图中已经计算出来。<br/>这个数组很好计算，根据下面的公式直接将树BFS一遍即可，其中$ u $是$ v $的父节点，$w[u, v]$表示$ u $到$ v $的边权。<br/>$$ dist[v] = dist[u] + w[u,v] \\tag{1.1}$$<br/>那么两点之间的距离$ distance(u,v) $的计算非常简单：<br/>$$ distance(u,v) = dist[u] + dist[v] - 2 \\times dist[LCA(u, v)] \\tag{1.2} $$<br/>可以想象成是Link这个人从$ u $先走到根节点，再从根节点走到$ v $。由于从根节点到$ LCA(u,v) $走了两遍，因此Link走的总路程，减去这一段来回走的即可。<br/>1.3 预备知识<br/>因为LCA的算法中会用到并查集，但我们还没学，因此并查集的实现不会过多纠结，我们只需知道并查集提供的几个函数即可。<br/>并查集提供查询和连接操作：<br/>1<br/>2def find(u) -> int<br/>def union(u, v) -> void<br/><br/><br/><br/><br/>find函数会返回节点u所在的集合编号，如果find(a) == find(b)则表示a和b处在一个集合中。<br/><br/><br/>union函数会将u和v所在的集合并起来，即使u和v处在一个集合中。<br/><br/><br/>后面会提到在线和离线的概念，只要知道离线是先将所有操作读入后再作处理就行了。<br/>2 LCA算法<br/>计算LCA的算法有很多，这里介绍三个。<br/>2.1 朴素算法<br/>朴素算法是最简单的了，按照国际惯例，先放图：<br/><br/>朴素算法的做法如下：<br/><br/><br/>先将两个结点调为同一深度<br/>将两个结点同时上调，直到这两个结点到达同一位置时，此时即为LCA<br/><br/><br/>伪代码如下：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14def Plain_LCA(u, v):<br/>    if d(u) < d(v):<br/>        swap(u, v)  # 始终保持u所处的深度较深<br/><br/>    while d(u) != d(v):<br/>        u = father(u)  # 将u上调<br/><br/>    # 将u和v同时上调<br/>    while u != v:<br/>        u = father(u)<br/>        v = father(v)<br/><br/>    # 最后会使u == v，即他们到达了LCA<br/>    return u<br/><br/><br/>2.2 离线算法：Tarjan-LCA<br/>朴素算法很简单，大多数情况下能很快算出LCA。<br/>然而在计算$ LCA(4,6) $时，需要从树的底部走到根节点。<br/>因此朴素算法的时间复杂度为$ O(n) $，很容易TLE。<br/>因此我们的前人想出了机智的Tarjan-LCA算法！<br/>Tarjan-LCA算法比较难理解，最好的理解方法是手动模拟一下。<br/>先放出伪代码：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18def Tarjan_LCA(u):<br/>    # ancestor数组表示一个集合的公共祖先<br/>    # 如ancestor[i]表示标号为i的集合中所有结点的公共祖先。<br/>    # marked数组表示结点是否被处理过<br/><br/>    ancestor[find(u)] = u<br/><br/>    for v in u.children:  # 遍历u的儿子节点<br/>        Tarjan_LCA(v)<br/>        union(u, v)<br/>        ancestor[find(u)] = u<br/><br/>    marked[u] = true<br/><br/>    # query数组表示查询操作，保存的是(x, y)，表示要计算LCA(x, y)<br/>    for (x, y) in query:<br/>        if y == u and marked[x] == True:<br/>            LCA(x, y) = LCA(y, x) = ancestor[x]<br/><br/><br/>这个算法的进行类似于DFS，是个递归调用的过程。<br/>因为DFS总是先将小的子树遍历完，因此ancestor数组中的祖先都是尽可能小的。<br/>拿一棵较小的子树作为示例：<br/><br/>一开始先DFS到7处。<br/><br/>处理到7时还并没有什么结点被处理过，只好默默的回到5。<br/><br/>5处将7和自己相连，形成集合{5, 7}，5是这个集合的公共祖先。<br/><br/>现在DFS到9。<br/><br/>假设我们询问了$ LCA(7,9) $，那么在处理9时，会发现7被处理过了，7所在的集合的公共祖先为5。<br/>而9是从5递归下来的，因此9与7的公共祖先中有5。<br/>又因为DFS会尽可能的处理较小的子树，因此5将会是$ LCA(7, 9) $。<br/>剩下的步骤都是一样的，大家可以自己手推一下。<br/>为了方便理解，大家可以将Tarjan-LCA算法换个说法：<br/><br/>一个熊孩子Link从一棵有根树的最左边最底下的结点灌岩浆，Link表示很讨厌这种倒着长的树。<br/>岩浆会不断的注入，直到注满整个树…<br/>如果岩浆灌满了一棵子树，Link发现树的另一边有一棵更深的子树，Link会先去将那棵子树灌满。<br/>岩浆只有在迫不得已的情况下才会向上升高，找到一个新的子树继续注入。<br/>机(yu)智(chun)的Link发现了找LCA的好方法，即如果两个结点都被岩浆烧掉时，他们的LCA即为那棵子树上岩浆最高的位置。<br/><br/>Tarjan-LCA算法能在$ \\Theta (n + q) $时间内计算出所有询问的LCA，其中$ q $为询问总数。<br/>这得益于并查集的高效。<br/>同样我们也能以此算出所有点对的LCA。<br/>2.3 在线算法：倍增法<br/>Tarjan-LCA算法速度很快，效果也很好，但有一个致命的问题…<br/>就是内存占用。<br/>首先它需要离线操作，如果空间比较紧且操作较多时，显然不合适。<br/>另外，如果要处理任意结点对的LCA，就需要一个巨大的二维数组来存储，这意味着如果$ n > 10000 $此算法将报废。<br/>但如果用朴素算法，就又太慢了…<br/>这时，倍增法就来拯救世界了。<br/>倍增法能以$ \\Theta (\\log n) $的时间复杂度和$ \\Theta (n \\log n) $的空间复杂度内完成LCA的计算。<br/>相比与Tarjan-LCA的$ \\Theta (n^2) $的空间复杂度，能节省更多的空间。<br/>并且它是在线算法，弥补了LCA算法的不足。<br/>倍增法运用了动态规划的思想，并利用二进制达到了$ \\Theta (\\log n) $的时间复杂度。<br/>2.3.1 预处理<br/>倍增法首先需要计算一个f数组，其含义为：<br/>$$ f[i, j] : 离节点i相距2^j的父节点 $$<br/>换言之<br/>$$ distance(i, f[i, j]) = 2^j \\tag{2.1} $$<br/><br/>又是这个图。我们将树上的每一条边的长度都视为1，那么$ f[7, 0] = 5,\\,f[7, 1] = 3 ... $，<br/>因此节点$ 5 $到$ 7 $的距离为$ 1 = 2^0 $，节点$ 3 $到$ 7 $的距离为$ 2 = 2^1 $。<br/>由此我们可以观察到f数组的一个特点：$ f[i, 0] $就是$ i $的父节点。<br/>为了算出f数组，我们有如下的状态转移方程：<br/>$$ f[i,j] = f[f[i, j - 1], j - 1] \\tag{2.2} $$<br/>如何理解这个转移方程呢？<br/>我么设$ u = f[i,j],\\,v=f[i, j-1] $，<br/>那么，根据$ (2.1) $式可得：<br/>$$<br/>\\begin{aligned}<br/>distance(i, v) & = 2^{j-1} \\\\<br/>distance(i, u) & = 2^j \\\\<br/>distance(v, u) & = distance(i, u) - distance(i, v) \\\\<br/>&                = 2^j-2^{j-1} \\\\<br/>&                = 2^{j-1} \\times 2 - 2^{j-1} \\times 1 \\\\<br/>&                = 2^{j-1} \\\\<br/>&                \\Rightarrow u = f[v, j - 1] \\\\<br/>&                \\Rightarrow u = f[f[i, j-1],j-1]<br/>\\end{aligned}<br/>$$<br/>即证明$ (2.2) $式。<br/>利用得到的状态转移方程，我们可以在$ \\Theta (n \\log n) $的时间内推出f数组。<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8# 初始化f[i, 0]<br/>for i in [1, n]:<br/>    f[i, 0] = father(i)<br/><br/># 计算整个f数组<br/>for j in [1, log(n)]:<br/>    for i in [1, n]:<br/>        f[i, j] = f[f[i, j - 1], j - 1]<br/><br/><br/>2.3.2 在线算法<br/>得到了f数组后，倍增法也就完成了50% 了，剩下的任务就是计算LCA。<br/>事实上，倍增法计算LCA的过程与朴素算法一样，也是要先调制同一深度，再同时上调。<br/>而巧妙的是倍增法利用算出的f数组来加速提升的过程，使得节点的上升的距离可以达到$ 2^j $，而不是一格一格往上调。<br/>思路已经很清晰了，然而难在如何运用f数组。<br/>下面的伪代码展示了倍增法求LCA的过程：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21def Double_LCA(u, v):<br/>    if d(u) < d(v):<br/>        swap(u, v)  # 始终保持u所处的深度较深<br/><br/>    # 将u上调dist个距离<br/>    dist = d(u) - d(v)<br/>    for i in [0, log(n)]:<br/>        if (1 << i) & dist  # KEY #1<br/>            u = f[u, i]<br/><br/>    if u == v:<br/>        return u  # 特判此时u, v是否在同一位置，如果是，u和v都站在LCA上<br/><br/>    # 将u和v同时上调<br/>    for i from log(n) to 0:<br/>        if f[u, i] != f[v, i]:  # KEY #2<br/>            u = f[u, i]<br/>            v = f[v, i]<br/><br/>    # 最后会使u和v成为LCA的子节点<br/>    return f[u, 0]<br/><br/><br/>在代码中有两处比较奇特的地方，被注释打上了KEY。<br/>先看KEY #1，这里的代码是尝试将$ u $与$ v $调制统一高度，而这里出现的位运算令人十分费解。<br/>首先我们思考一下二进制：<br/>对于一个二进制数$ k $，设其从右往左数的第$ i $位为$ k_i $，则当$ k_i = 1 $时，$ k - 2^i $的第$ i $位为$ 0 $。<br/>例如，对于二进制数$ 110010_{(2)} $，第$ 2 $位为$ 1 $，$ 2^2 = 10_{(2)} $，$ 110010_{(2)} - 10_{(2)} = 110000_{(2)} $，我们发现这个二进制数的第$ 2 $位变成了$ 1 $。<br/>利用这个特性，我们可以逐位将一个二进制数减成$ 0 $。<br/>在上面的代码中，就这样逐步上调节点$ u $，并使最后的深度差dist变为$ 0 $。<br/>下面有一张样例：<br/><br/>再来看KEY #2，此时$ u $和$ v $处在同一深度上，$ j $从大到小逐一测试。<br/>我们试图使$ u $和$ v $尽可能靠近LCA，但又不直接到达LCA。<br/>如果说$ 2^j $的距离上，$ u $和$ v $的父节点相同，则这个父节点是它们的公共祖先，如果跳上去就有可能超过LCA了，因此忽略。<br/>如果说$ 2^j $的距离上，$ u $和$ v $的父节点不同，则$ f[u, j] $和$ f[v, j] $的LCA也是$ u $和$ v $的LCA，因此可以将$ u $和$ v $上移至该位置，不影响结果。<br/>因为这两个节点到LCA的深度差可以被分解成多个$ 2 $的幂之和，因此我们有办法逐步将它们上移至LCA的位置。<br/>但是为了方便判断是否跳的太远，我们不让它们最后跳到LCA的位置，而是跳到LCA的儿子节点处。<br/>此时其父节点就是LCA。<br/>下面有一张样例：<br/><br/>至此，倍增法就结束了。<br/>以上三种算法是比较常见的求LCA的算法。似乎二叉树还有一种分治的LCA算法，我没有做过多了解了。","tags": "算法 LCA","url": "blog/2016-2-1/lca.html"},
{"title": "有关多项式的算法","text": "有关多项式的算法<br/>多项式<br/>一个度数为 $n$ 的多项式为最高项的次数为 $n - 1$ 的多个 $x$ 的幂次与对应系数之积的和，通常用大写字母表示多项式。<br/>如，下式是一个度数为 $4$ 的多项式。将 $x^2$ 的系数设为 $0$ 就可消除这一项。<br/>$$ A(x) = 3x^3 + 2x + 1 $$<br/>用 $\\text{degree}(A)$ 来表示一个多项式的度数。一个多项式中会含有 $\\text{degree}(A)$ 项。<br/>通常有两种表示多项式的方法：系数表达和点值表达。<br/>系数表达即按照从低次项到高次项1的顺序将每个项的系数放入一个向量中。如上面的多项式 $A(x)$ 还可以表示成这样：<br/>$$ \\hat A(x) = (1,\\;0,\\;2,\\;3) $$<br/>点值表达，顾名思义就是给定一些点，计算出多项式在这些点的值。<br/>计算多项式在一个点 $x_0$ 处的值可以用秦九韶算法2:<br/>$$ A(x_0) = a_0 + x_0(a_1 + x_0(a_2 + \\dots + x_0(a_{n-2} + x_0a_{n-1})\\dots)) \\tag{1.1}$$<br/>这样可以在 $\\Theta(\\text{degree}(A))$ 的时间内计算一个点处的值。<br/>计算 $n$ 个不同的点 $x_0,\\;x_1,\\dots,\\;x_{n-1}$ 处的值 $y_0,\\;y_1,\\dots,\\;y_{n-1}$，于是可以将多项式表示成 $n$ 个二元组，二元组的第一项是选取的点 $x_i$，第二项是该点计算出的值 $y_i$。<br/>因此之前的多项式可以表示成以下的形式：<br/>$$ \\hat A(x) = \\{(0,\\;1),\\;(1,\\;6),\\;(2,\\;29),\\;(3,\\;88)\\} $$<br/>可以证明，如果选择的求值点互不相同，那么一个含有 $n$ 个元素点值表达会有唯一的度数为 $n$ 的多项式。<br/>因为点值表达可以用下面的矩阵方程表示出来：<br/>$$<br/>\\left[<br/>\\begin{matrix}<br/>1 & x_0 & x_0^2 & \\cdots & x_0^{n-1} \\\\<br/>1 & x_1 & x_1^2 & \\cdots & x_1^{n-1} \\\\<br/>\\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\<br/>1 & x_{n-1} & x_{n-1}^2 & \\cdots & x_{n-1}^{n-1} \\\\<br/>\\end{matrix}<br/>\\right]<br/>\\left(<br/>\\begin{matrix}<br/>a_0 \\\\<br/>a_1 \\\\<br/>\\vdots \\\\<br/>a_{n-1}<br/>\\end{matrix}<br/>\\right)<br/>=\\left(<br/>\\begin{matrix}<br/>y_0 \\\\<br/>y_1 \\\\<br/>\\vdots \\\\<br/>y_{n-1}<br/>\\end{matrix}<br/>\\right)<br/>\\tag{1.2}<br/>$$<br/>方程左边的矩阵是一个范德蒙德矩阵，其行列式的值为：<br/>$$<br/>\\prod_{0 \\le i < j < n} (x_j - x_i)<br/>$$<br/>因此只要 $x_0,\\;x_1,\\;\\dots,\\;x_{n-1}$ 中没有相同的值，该矩阵的行列式就不会为 $0$。<br/>这意味着它一定会有一个逆矩阵，从而可以将方程右边的列向量乘以逆矩阵，就可以得到原多项式的系数向量。<br/>多项式加法<br/>多项式加法是很简单的，只需要将对应次数的项的系数相加即可。<br/>如果是点值表达，则需要两个多项式的采样点是一样的，然后对应点的值才可以直接相加减，最后得到的是新的多项式的点值表达。<br/>两个多项式 $A(x)$ 和 $B(x)$ 的加法可以在 $\\Theta(\\max\\{\\text{degree}(A),\\;\\text{degree}(B)\\})$ 的时间内完成。<br/>多项式乘法<br/>如果采用系数表达，我们可以暴力地将多项式乘开然后合并同类项，这样可以在 $O(\\text{degree}(A) \\cdot \\text{degree}(B))$ 的时间内完成。然而这个复杂度并不妙。<br/>相反，如果采用点值表达，则只需要 $\\Theta(\\max\\{\\text{degree}(A),\\;\\text{degree}(B)\\})$ 的时间，因为我们只要将对应采样点的值相乘就会得到新多项式的点值表达。<br/>然而，点值表达方式并没有系数表达更有用。考虑能否利用点值表达的多项式乘法线性时间来加快系数表达的多项式乘法。<br/>一个直接的方法就是先对原多项式在 $\\text{degree}(A) + \\text{degree}(B)$ 个点3处采样，然后做完点值表达的乘法之后，又进行插值操作，这样就可以得到系数表达的结果了。<br/>然而并没有什么很快的采样/插值算法，但是使用快速傅立叶变换可以在 $\\Theta(n\\log n)$ 的时间内完成采样和插值。<br/>复数<br/>快速傅立叶变换是用于快速计算离散傅立叶变换 (DFT)的结果的算法。由于 DFT 涉及到复数的运算，因此这里先扯一点复数的基本知识。<br/>首先定义单位复数根 $i = \\sqrt{-1}$，可以将其想象成是垂直于实数轴的一个单位向量，因此所有的复数都是由 $a + bi$这 种形式给出的，其中 $a$ 是实部，$b$ 是虚部。<br/>单位复数根与自然对数的底数 $\\text{e}$ 有着相当密切的关系，它们之间通过欧拉公式联系在一起：<br/>$$ \\text{e}^{xi} = \\cos x + i\\sin x \\tag{3.1.1}$$<br/>为了证明这个等式，首先考虑一下 $i$ 的幂次的规律：<br/>$$<br/>\\begin{aligned}<br/>& i^0 = 1,\\; i^1 = i,\\; i^2 = -1,\\; i^3 = -i \\\\<br/>& i^4 = 1,\\; i^5 = i,\\; i^6 = -1,\\; i^7 = -i \\\\<br/>& \\dots<br/>\\end{aligned}<br/>$$<br/>我们注意到 $i$ 的幂次是一个长度为 $4$ 的循环节。考虑 $\\text{e}$ 的泰勒展开：<br/>$$<br/>\\begin{aligned}<br/>\\text{e}^{xi} & = \\sum_{n=0}^{\\infty} {x^ni^n \\over n!} \\\\<br/>& = 1 + xi - \\frac{x^2}{2} - \\frac{x^3}{6}i + \\dots \\\\<br/>& = \\sum_{n = 2k,\\;k \\in \\mathbf{N}}^{\\infty} (-1)^k{x^n \\over n!} + i\\sum_{n = 2k + 1,\\;k \\in \\mathbf{N}}^{\\infty} (-1)^k{x^n \\over n!}<br/>\\end{aligned}<br/>$$<br/>和式左边就是 $\\cos x$ 的泰勒展开，而右边就是 $\\sin x$ 的泰勒展开。<br/>因此：<br/>$$ \\text{e}^{xi} = \\cos x + i\\sin x $$<br/>为了方便之后的公式书写，这里定义 $n$ 次单位复数根为：<br/>$$<br/>\\omega_n = \\text{e}^{2\\pi i/n}<br/>\\tag{3.1.2}<br/>$$<br/>从几何的角度来讲，相当于将一个周角均分成 $n$ 份，从每一个角度发出一个单位长度的向量。<br/>$\\omega_8$ 的每一个幂次在平面上的情况如下图，注意 $\\omega_8^0 = 1$。<br/><br/>DFT<br/>接下来介绍 DFT。标准的 DFT 是作用在一个长度为 $n$ 复数序列 $\\{x_0,\\;x_1,\\;x_2,\\;\\dots,\\;x_{n-1}\\}$，将其变换为另一个复数序列 $\\{X_0,\\;X_1,\\;X_2,\\;\\dots,\\;X_{n-1}\\}$，其定义如下：<br/>$$<br/>X_k = \\sum_{j=0}^{n-1} x_j\\omega_n^{-jk}<br/>\\tag{3.2.1}<br/>$$<br/>我们当然可以从 $\\{X_0,\\;X_1,\\;X_2,\\;\\dots,\\;X_{n-1}\\}$ 得到 $\\{x_0,\\;x_1,\\;x_2,\\;\\dots,\\;x_{n-1}\\}$，即逆 DFT：<br/>$$<br/>x_k = \\frac1n\\sum_{j=0}^{n-1}X_j\\omega_n^{jk}<br/>\\tag{3.2.2}<br/>$$<br/>如何可以得到这个逆 DFT 公式呢？可以将 DFT 的过程视为一次矩阵乘法：<br/>$$<br/>\\left[<br/>\\begin{matrix}<br/>1 & 1 & 1 & \\cdots & 1 \\\\<br/>1 & \\omega_n & \\omega_n^2 & \\cdots & \\omega_n^{n-1} \\\\<br/>1 & \\omega_n^2 & \\omega_n^4 & \\cdots & \\omega_n^{2(n-1)} \\\\<br/>\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\<br/>1 & \\omega_n^{n-1} & \\omega_n^{2(n-1)} & \\cdots & \\omega_n^{(n-1)(n-1)}<br/>\\end{matrix}<br/>\\right]<br/>\\left(<br/>\\begin{matrix}<br/>x_0 \\\\<br/>x_1 \\\\<br/>x_2 \\\\<br/>\\vdots \\\\<br/>x_{n-1}<br/>\\end{matrix}<br/>\\right)<br/>= \\left(<br/>\\begin{matrix}<br/>X_0 \\\\<br/>X_1 \\\\<br/>X_2 \\\\<br/>\\vdots \\\\<br/>X_{n-1}<br/>\\end{matrix}<br/>\\right)<br/>\\tag{3.2.3}<br/>$$<br/>设等式左边的矩阵为 $V$，下面将证明其逆矩阵 $V^{-1}$ 的元素 $[V^{-1}]_{jk} = \\omega_n^{-jk} / n$：<br/>因为<br/>$$<br/>[VV^{-1}]_{jk} = \\sum_{c=0}^{n-1}(\\omega_n^{jc})({\\omega_n^{-ck} \\over n}) = \\frac1n\\sum_{c=0}^{n-1}(\\omega_n^{j-k})^c<br/>\\tag{3.2.4}<br/>$$<br/>由于几何级数的求和对复数也适用，所以：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{j=0}^{n-1}(\\omega_n^k)^j & = {(\\omega_n^k)^n - 1 \\over \\omega_n^k - 1} \\\\<br/>& = {(\\omega_n^n)^k - 1 \\over \\omega_n^k - 1} \\\\<br/>& = 0<br/>\\end{aligned}<br/>$$<br/>注意，只有在 $n \\not\\mid k$ 时上式成立。当 $n \\mid k$ 时，$\\omega_n^k = 1$。<br/>于是 $V \\cdot V^{-1}$ 中只有 $j = k$ 的位置为 $1$，其余元素均为 $0$，即单位矩阵。所以 $V^{-1}$ 确实是 $V$ 的逆矩阵。<br/>FFT<br/>如果根据 DFT 的定义来计算，需要 $\\Theta(n^2)$ 的时间。可以利用复数的一些特殊性质，我们可以在 $\\Theta(n\\log n)$ 的时间内计算 DFT 及逆 DFT，这就是快速傅立叶变换 (FFT)。<br/>下面为了讨论方便，假设所有的给 FFT 处理的序列长度都是 $2$ 的某次幂。<br/>快速傅立叶变换是基于分治思想的。算法首先将序列分为两部分，一部分的元素的下标为偶数，另一部分为奇数：<br/>$$<br/>\\begin{aligned}<br/>A \\ \\ \\ & = \\{x_0,\\;x_1,\\;x_2,\\;x_3,\\;x_4,\\;x_5,\\;x_6,\\;x_7\\} \\\\<br/>A^{[0]} & = \\{x_0,\\;x_2,\\;x_4,\\;x_6\\} \\\\<br/>A^{[1]} & = \\{x_1,\\;x_3,\\;x_5,\\;x_7\\}<br/>\\end{aligned}<br/>$$<br/>可以注意到，下标为偶数就是下标的二进制表示的最后一位为 $0$ (它们放入 $A^{[0]}$)，奇数就是为 $1$ (放入 $A^{[1]}$)。<br/>分成两部分后，对于每一部分递归求解。然后尝试将这两部分合并，得到原序列的 DFT。<br/>考虑假设我们获得了变换后的 $A^{\\prime[0]}$ 和 $A^{\\prime[1]}$。<br/>$$<br/>\\begin{aligned}<br/>A^{\\prime[0]}(x) &= \\sum_{j=0}^{n/2-1}A^{[0]}_jx^j \\\\<br/>A^{\\prime[1]}(x) &= \\sum_{j=0}^{n/2-1}A^{[1]}_jx^j<br/>\\end{aligned}<br/>$$<br/>因此：<br/>$$<br/>A(x) = A^{\\prime[0]}(x^2) + xA^{\\prime[1]}(x^2) \\tag{4.3.1}<br/>$$<br/>将单位复数根带入：<br/>$$<br/>\\begin{aligned}<br/>A^{\\prime[0]}(\\omega_n^{2k}) + \\omega_n^kA^{\\prime[1]}(\\omega_n^{2k}) &= A(\\omega_n^k) \\\\<br/>A^{\\prime[0]}(\\omega_n^{2k}) - \\omega_n^kA^{\\prime[1]}(\\omega_n^{2k}) &= A^{\\prime[0]}(\\omega_n^{2k}) + \\omega_n^{k + n/2}A^{\\prime[1]}(\\omega_n^{2k}) \\\\<br/>&= A^{\\prime[0]}(\\omega_n^{2k + n}) + \\omega_n^{k + n/2}A^{\\prime[1]}(\\omega_n^{2k + n}) \\\\<br/>&= A(\\omega_n^{k+(n/2)})<br/>\\end{aligned}<br/>$$<br/>由此我们获得了如何将两部分合并为一部分的方法。<br/>对于逆变换，可以使用同样的方法，只是单位复数根的次数的符号恰好相反，并且最后需要对每一个数除以 $n$。<br/>FFT 实现<br/>递归式 FFT<br/>递归实现 FFT 的过程非常简单，首先判断序列长度是否为 $1$，如果为 $1$ 则直接返回。<br/>否则按照下标的奇偶性分为两部分，然后递归求解。<br/>最后合并这两部分的结果。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21function RECURSIVE-FFT(x, reverse = false):<br/>    if x.length == 1:  # 如果长度为1<br/>        return x<br/><br/>    将序列分为a[0]和a[1]<br/>    a'[0] = RECURSIVE-FFT(a[0])<br/>    a'[1] = RECURSIVE-FFT(a[1])<br/><br/>    X = [0..x.length - 1]<br/>    if reverse:  # 如果是逆变换<br/>        w_n = exp(0 + (-2 * pi / n)i)<br/>    else:<br/>        w_n = exp(0 + (2 * pi / n)i)<br/>    w = 1<br/>    for k in [0, x.length / 2 - 1]:<br/>        t = w * a'[1][k]<br/>        X[k] = a'[0] + t<br/>        X[x.length / 2 + k] = a'[0] - t<br/>        w *= w_n<br/><br/>    return X<br/><br/><br/>迭代式 FFT<br/>与递归式 FFT 相比，效率更高的是无需递归的迭代式。<br/>首先考虑求值的顺序。对于一个下标而言，它的二进制表示实际上已经决定了它将要移动的路径。<br/>即从低位开始，如果是 $0$ 则向左运动，否则向右运动，然后检查其高位。<br/>更进一步，观察划分完之后的序列，把每一个下标所对应的二进制翻转过来，这恰好是递增的顺序。<br/>因此我们可以实现一个从高位到低位的加法器，来计算下一个元素该是谁。利用位运算不难实现这个加法器。<br/>这个算法被称作雷德算法 (Rader’s algorithm)。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14function RADER(x):<br/>    n = x.length<br/><br/>    X = [0..n - 1]<br/>    k = 0<br/>    for i in [0..n - 1]:<br/>        X[i] = x[k]<br/>        y = n >> 1  # n 是 2 的幂次<br/>        while k & y:<br/>            k ^= y<br/>            y >>= 1<br/>        k |= y<br/><br/>    return X<br/><br/><br/>这样就可以按照顺序进行合并，第一次每 $2$ 个进行合并，然后每 $4$ 个进行合并， …，最后就是整体进行合并。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23function ITERATIVE-FFT(x, reverse = false):<br/>    x = RADER(x)<br/><br/>    n = x.length<br/>    s = 2<br/>    while s <= n:<br/>        if reverse:  # 如果是逆变换<br/>            w_n = exp(0 + (-2 * pi / n)i)<br/>        else:<br/>            w_n = exp(0 + (2 * pi / n)i)<br/>        for i in [0, n] by s:<br/>            left = i<br/>            right = i + s - 1<br/>            mid = (left + right) / 2<br/>            w = 1<br/>            for k in [0, mid - 1]:<br/>                t = w * x[mid + k]<br/>                x[mid + k] = x[left + k] - t<br/>                x[left + k] = x[left + k] + t<br/>                w *= w_n<br/>        s *= 2<br/><br/>    return x<br/><br/><br/>多项式乘法<br/>前面讲了那么多 DFT，那多项式乘法与 DFT 有什么关系呢？<br/>事实上，DFT 实际上就是一次在多项式上采样的过程。<br/>获得了点值表达之后，就可以在 $\\Theta(n)$ 的时间内完成乘法。<br/>最后进行一遍逆 DFT 可以得到结果！<br/>时间复杂是 $\\Theta(n\\log n)$的，$n$ 是两个多项式的度数和。<br/>需要注意的是，上面的 FFT 需要序列长度为 $2$ 的幂，解决方式就是将补 $0$ 来完成。<br/>实际实现中，需要注意 $\\text{e}$ 的复数幂，单位复数根的计算十分缓慢，因此对于递归式的 FFT，需要先预处理每一层的单位复数根。<br/><br/><br/><br/><br/>当然也可以从高次到低次，视情况选择方便的表示方法。 ↩<br/><br/><br/>也称作霍纳法则。 ↩<br/><br/><br/>因为新的多项式的度数为 $\\text{degree}(A) + \\text{degree}(B)$。 ↩<br/><br/><br/>","tags": "多项式 FFT","url": "blog/2016-7-21/fft.html"},
{"title": "杜教筛的时空复杂度分析","text": "杜教筛的时空复杂度分析<br/>背景<br/>杜教筛是 OI 界中一种常用的计算积性函数前缀和的技巧：对于积性函数 $f(n)$，设其前缀和为 $F(n) = \\sum_{k = 1}^n f(k)$。选定辅助函数 $g(n)$，尝试计算 $f \\times g$ 的前缀和：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{k = 1}^n (f \\times g)(k) &= \\sum_{k = 1}^n \\sum_{d \\mid k} f\\left({k \\over d}\\right)g(d) \\\\<br/>&= \\sum_{d = 1}^n g(d) \\sum_{k = 1}^{\\lfloor n / d \\rfloor} f(k) = \\sum_{k = 1}^n g(k)F\\left(\\left\\lfloor{n \\over k}\\right\\rfloor\\right)<br/>\\end{aligned}<br/>$$<br/>将 $g(1)F(n)$ 移出来，得到：<br/>$$<br/>F(n) = \\frac1{g(1)}\\left(\\sum_{k = 1}^n(f \\times g)(k) - \\sum_{k = 2}^ng(k)F\\left(\\left\\lfloor{n \\over k}\\right\\rfloor\\right)\\right)<br/>$$<br/>关键在于 $\\lfloor n / k \\rfloor$ 的不同取值只有 $\\Theta(\\sqrt n)$ 个。如果我们可以：<br/><br/>快速计算 $\\sum_{k = 1}^n (f \\times g)(k)$。<br/>快速计算 $\\sum_{k = 1}^n g(k)$。<br/><br/>那么利用哈希表，我们就可以以比较低的时空复杂度计算 $F(n)$。<br/>具体分析<br/>考虑一个具体的例子：计算欧拉函数 $\\varphi(n)$ 的前缀和。因为 $\\sum_{d \\mid n} \\varphi(d) = n$，所以选取 $g(n) = 1$ 作为辅助函数。那么可以得到 $\\varphi(n)$ 的前缀和 $\\Phi(n) = \\sum_{k = 1}^n \\varphi(k)$ 为：<br/>$$<br/>\\Phi(n) = {n(n + 1) \\over 2} - \\sum_{k = 2}^n \\Phi\\left(\\left\\lfloor {n \\over k} \\right\\rfloor\\right)<br/>$$<br/>定义 $R(n) = \\{\\lfloor n / k \\rfloor: 2 \\leqslant k \\leqslant n,\\,k \\in \\mathbf N\\}$，即对于 $x \\in R(n)$，$\\Phi(x)$ 是需要递归计算的前缀和。<br/>引理 1　$\\forall n,\\,m \\in \\mathbf N \\geqslant 1$，若 $m \\leqslant \\sqrt n$，则 $\\lfloor n / \\lfloor n / m \\rfloor \\rfloor = m$。<br/>证明　令 $k = \\lfloor n / m \\rfloor$，则 $mk \\leqslant n < m(k + 1)$，那么 $m \\leqslant n / k < m(k + 1) / k$，若要 $\\lfloor n / k \\rfloor = m$，则需要 $m(k + 1) / k \\leqslant m + 1$，因此 $m + m / k \\leqslant m + 1$ 即 $m \\leqslant \\lfloor n / m \\rfloor$，这等价于 $m^2 \\leqslant n$，即 $m \\leqslant \\sqrt n$。$\\blacksquare$<br/>引理 2　对于任意连续单增函数 $f(x)$，并且满足：<br/>$$<br/>f(x) \\in \\mathbf Z \\Longrightarrow x \\in \\mathbf Z<br/>$$<br/>则 $\\lfloor f(x) \\rfloor = \\lfloor f(\\lfloor x \\rfloor) \\rfloor$，以及 $\\lceil f(x) \\rceil$ = $\\lceil f(\\lceil x \\rceil) \\rceil$。<br/>这个引理来自 Concrete Mathematics [1] 的 (3.10)，这里就不再证明。<br/>引理 3　令正整数 $a,\\,b$ 为常数，则对于正整数 $x$，有 $\\lfloor\\lfloor x / a \\rfloor / b \\rfloor = \\lfloor x / ab \\rfloor$。<br/>证明　令 $f(x) = \\lfloor x / b \\rfloor$，运用引理 2 即可。$\\blacksquare$<br/>定理 1　$\\forall n \\in \\mathbf N \\geqslant 1$，记 $s = \\lfloor \\sqrt n \\rfloor$，$A = \\{1,\\,2,\\,3,\\,...,\\,s\\}$，$B = \\{\\lfloor n / 2 \\rfloor,\\,...,\\,\\lfloor n / s \\rfloor\\}$，则 $R(n) = A \\cup B$ 并且 $|R(n)| = 2\\sqrt n + \\Theta(1)$。<br/>证明　对于 $x \\in A$，根据引理 1，$\\lfloor n / \\lfloor n / x \\rfloor \\rfloor = x$，所以 $x \\in R(n)$。<br/>对于 $x \\in R(n)$ 并且 $x > s$，$n / x \\leqslant s$，意思是在 $R(n)$ 的定义中能够得到 $x$ 的 $k \\in [2,\\,s]$，所以 $S \\ \\backslash\\ A \\subseteq B$。根据 $B$ 的定义，$B \\subseteq S$，由此可得出 $S = A \\cup B$。<br/>对于 $1 \\leqslant x < y \\leqslant s$，$n / x - n / y \\geqslant n/(y - 1) - n / y > 1$，所以 $\\lfloor n / x \\rfloor \\neq \\lfloor n / y \\rfloor$，所以 $|R(n)| = 2\\sqrt n + \\Theta(1)$。$\\blacksquare$<br/>定理 2　对于任意正整数 $n$，$\\forall m \\in R(n)$，有 $R(m) \\subseteq R(n)$。<br/>证明　因为 $m \\in R(n)$，所以可设 $m = \\lfloor n / a \\rfloor$。对于 $z \\in R(m)$，有 $z = \\lfloor m / b \\rfloor$，根据引理 3，可知 $z = \\lfloor  n / ab \\rfloor$。因为 $a,\\,b > 1$，且 $a \\leqslant n$，$b \\leqslant n / a$，所以 $1 < ab \\leqslant n$，所以 $z \\in R(n)$。$\\blacksquare$<br/>定理 2 揭示了这个技巧的巧妙所在：只需要对每个 $m \\in R(n)$ 和 $m = n$ 计算 $\\Phi(m)$ 即可。此外，计算 $\\Phi(n)$ 时单独还需要 $\\Theta(\\sqrt n)$ 的枚举，因此总的枚举次数为：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{k = 1}^{\\lfloor \\sqrt n \\rfloor} \\sqrt k + \\sum_{k = 1}^{\\lfloor \\sqrt n \\rfloor} \\sqrt{n \\over k} = \\Theta\\left( \\int_1^{\\sqrt n} \\left(\\sqrt x + \\sqrt{n \\over x}\\right) \\mathrm dx \\right) = \\Theta(n^{3/4})<br/>\\end{aligned}<br/>$$<br/>当然空间复杂度是 $\\Theta(\\sqrt n)$。一般都还会采取预处理的方法来继续优化这个算法：利用线性筛算出前 $S > \\sqrt n$ 个前缀和，那么时间复杂度变为：<br/>$$<br/>S + \\sum_{k = 1}^{\\lfloor n / S\\rfloor} \\sqrt{n \\over k} = \\Theta\\left( S + \\int_1^{n/S} \\sqrt{n \\over x} \\mathrm{d}x \\right) = \\Theta\\left(S + {n \\over \\sqrt S}\\right)<br/>$$<br/>取 $S = n^{2/3}$ 可以得到最优时间复杂度 $\\Theta(n^{2/3})$。注意此时空复杂度相同。<br/>后记<br/>之所以会写这篇博客，主要是我第二次看杜教筛的资料的时候，终于想通了它的时间复杂度分析，也就上面这一堆东西。但实际上和任之洲的集训队论文 [2] 相比，只多出了一个简单的定理 2。没有意识到这一点之前，我一直无法理解为什么那两个和式就可以代表杜教筛的时间复杂度。另外，更重要的一点就是看到了 tangjz 的《浅谈一类积性函数的前缀和》中的分析，个人认为那是在自欺欺人，稍有用心的人就会发现其中描述时间复杂度的 $T(n)$ 忽略了记忆化这个操作。所以我才想写一个详细一点的分析，希望对大家有帮助。<br/>参考资料<br/>[1]. Ronald L. Graham, Donald E. Kunth, Oren Patashnik, 2002, Concrete Mathematics (2th edition), 978-7-111-10576-3<br/>[2]. 任之洲，2016，《积性函数求和的几种方法》，2016 年信息学奥林匹克中国国家队候选队员论文","tags": "时空复杂度 杜教筛 数论","url": "blog/2018-9-11/time-space-complexity-dyh-algo.html"},
{"title": "极限与导数","text": "极限与导数<br/>最近学了一些基础微积分，这里稍微记录一下。<br/>极限<br/>极限可以当做是一个函数$f(x)$的$x$无限趋近于某一个常数或无穷远处时，函数数值所逼近的一个值。<br/>例如，对于函数$f(x) = {2x \\over x + 1}$，当$x$趋近于无穷大时，$f(x)$无限趋近于$2$。我们将此记成这样子：<br/>$$<br/>\\lim_{x \\rightarrow \\infty} f(x) = <br/>\\lim_{x \\rightarrow \\infty} {2x \\over x + 1} = <br/>2<br/>$$<br/>求极限需要会一点代数技巧，我反正是老是求不出......<br/>极限有一些方便的性质：<br/>当然，这些等式的左边都是存在极限的。<br/>$$ \\lim_{x \\rightarrow c} a \\cdot f(x) = a \\cdot \\lim_{x \\rightarrow c} f(x) $$<br/>对于两个函数$f(x)$和$g(x)$之间极限的关系：（当然$f(x)$和$g(x)$都要存在极限）<br/>$$ \\lim_{x \\rightarrow c} [f(x) + g(x)] = \\lim_{x \\rightarrow c} f(x) + \\lim_{x \\rightarrow c} g(x) $$<br/>$$ \\lim_{x \\rightarrow c} [f(x) - g(x)] = \\lim_{x \\rightarrow c} f(x) - \\lim_{x \\rightarrow c} g(x) $$<br/>$$ \\lim_{x \\rightarrow c} f(x) \\cdot g(x) = \\lim_{x \\rightarrow c} f(x) \\cdot \\lim_{x \\rightarrow c} g(x) $$<br/>$$ \\lim_{x \\rightarrow c} {f(x) \\over g(x)} = {\\lim_{x \\rightarrow c} f(x) \\over \\lim_{x \\rightarrow c} g(x)} \\; (\\lim_{x \\rightarrow c} g(x) \\neq 0)$$<br/>简而言之，极限这东西可以加减乘除。<br/>导数<br/>对于函数$f(x)$而言，它在$x_0$处的导数是这么定义的：<br/>$$ \\lim_{\\Delta x \\rightarrow 0} {f(x_0 + \\Delta x) - f(x_0) \\over \\Delta x} $$<br/>从几何意义上讲，这个值可以视为是$f(x)$的图像在$x_0$处的切线的斜率。<br/>当然不是所有的函数都是可以求导数的，只有在那一段上是连续的函数时，才会有导数。<br/>连续的函数$f(x)$在其定义域内的每一点上都可以计算导数，意味着每一个$x$都会对应一个导数，这样就形成了一个函数关系。我们将这个函数叫作导函数，记作$f^\\prime(x)$。<br/>如何求导函数呢？根据导数的定义，我们将$x_0$换为$x$，然后求极限就好了。然而说的轻巧，实际上很多都比较难以求出，因此早有先人为我们把各种导函数算好了。<br/>举一个典型的例子$f(x) = x^2$。按照求导数的方法：<br/>$$<br/>\\begin{aligned}<br/>f^\\prime(x) &= \\lim_{\\Delta x \\rightarrow 0} {f(x + \\Delta x) - f(x) \\over \\Delta x} \\\\<br/>&= \\lim_{\\Delta x \\rightarrow 0} {(x + \\Delta x)^2 - x^2 \\over \\Delta x} \\\\<br/>&= \\lim_{\\Delta x \\rightarrow 0} {\\Delta x^2 + 2x\\Delta x \\over \\Delta x} \\\\<br/>&= \\lim_{\\Delta x \\rightarrow 0} (\\Delta x + 2x) \\\\<br/>&= 2x<br/>\\end{aligned}<br/>$$<br/>事实上，对于幂函数$f(x) = x^\\alpha$，其导函数为$f^\\prime(x) = \\alpha x^{\\alpha - 1}$。<br/>导数与导数之间存在运算关系，有了这些运算关系，我们就可以方便地进行求导。<br/>类似于线性的性质：<br/>$$ [a \\cdot f(x) + b \\cdot g(x)]^\\prime = a \\cdot f^\\prime(x) + b \\cdot g^\\prime(x) $$<br/>两个导数相乘：<br/>$$ [f(x)g(x)]^\\prime = f^\\prime(x)g(x) + f(x)g^\\prime(x) $$<br/>两个导数相除：<br/>$$ \\left[{f(x) \\over g(x)} \\right]^\\prime = {f^\\prime(x)g(x) - f(x)g^\\prime(x) \\over g^2(x)} \\; (g(x) \\neq 0) $$<br/>复合函数：<br/>$$ [f(g(x))]^\\prime = f^\\prime(g(x)) \\cdot g^\\prime(x) $$<br/>一些基本函数的导函数就放这里了，当我们要求一个特定函数的导函数时，可以利用上面的规则，然后根据导函数表来计算。下面只有$x$是变量。<br/>$$ c^\\prime = 0 $$<br/>$$ x^\\prime = 1 $$<br/>$$ (x^\\alpha)^\\prime = \\alpha x^{\\alpha - 1} $$<br/>$$ (\\text{e}^x)^\\prime = e^x $$<br/>$$ (a^x)^\\prime = a^x\\ln a $$<br/>$$ (\\ln x)^\\prime = \\frac1x $$<br/>$$ (\\log_a x)^\\prime = \\frac1{x\\ln a} $$<br/>$$ \\sin^\\prime x = \\cos x $$<br/>$$ \\cos^\\prime x = -\\sin x $$<br/>$$ \\tan^\\prime x = \\frac1{\\cos^2 x} $$<br/>$$ \\cot^\\prime x = -\\frac1{\\sin^2 x} $$<br/>对数求导法<br/>上面的求导公式已经能够应对大部分基本函数的求导了，但是对于下面的函数：<br/>$$ f(x) = x^{1/x} $$<br/>该如何求导呢？<br/>这就要用到对数来进行求导。<br/>我们知道，对于一个函数$f(x)$：<br/>$$ [\\ln f(x)]^\\prime = \\ln^\\prime f(x) \\cdot f^\\prime(x) $$<br/>换言之：<br/>$$ f^\\prime(x) = {[\\ln f(x)]^\\prime \\over \\ln^\\prime f(x)} \\tag{1}$$<br/>利用这一点，我们就可以对$f(x) = x^{1/x}$求导。<br/>首先，为了方便我们设：<br/>$$ y = x^{1/x} $$<br/>由于两者相等，所以两者的对数也应相等：<br/>$$ \\ln y = \\ln x^{1/x} = \\frac1x\\ln x $$<br/>将两边对$x$求导。注意按照$(1)$式，左式需要乘上$y^\\prime$两者才能相等。<br/>$$ {y^\\prime \\over y} = {1 - \\ln x \\over x^2} $$<br/>于是我们可以得到：<br/>$$ y^\\prime = {1 - \\ln x \\over x^2}y = {1 - \\ln x \\over x^2}x^{1/x} = f^\\prime(x) $$<br/>这样我们就完成了求导。<br/>既然都对这个函数求过导了，我们来验证一下它的一个性质。<br/>将$\\text{e}$代入导函数：<br/>$$<br/>\\begin{aligned}<br/>f^\\prime(\\text{e}) & = {1 - \\ln \\text{e} \\over \\text{e}^2}\\text{e}^{1/\\text{e}} \\\\<br/>& = {1 - 1 \\over \\text{e}^2} \\\\<br/>& = 0<br/>\\end{aligned}<br/>$$<br/>因此我们发现$x = \\text{e}$是这个函数的极值点。","tags": "数学 极限 导数","url": "blog/2016-6-23/limit-and-derivative.html"},
{"title": "染色计数","text": "染色计数<br/>置换<br/>置换是一个满射，例如：<br/>$$<br/>f(1) = 2, f(2) = 4, f(3) = 3, f(4) = 1<br/>$$<br/>也写做：<br/>$$<br/>f = \\left(<br/>\\begin{matrix}<br/>1 & 2 & 3 & 4 \\\\<br/>2 & 4 & 3 & 1<br/>\\end{matrix}<br/>\\right)<br/>$$<br/>置换可以合成。假如我们有：<br/>$$<br/>\\begin{aligned}<br/>f = \\left(<br/>\\begin{matrix}<br/>1 & 2 & 3 & 4 \\\\<br/>2 & 3 & 4 & 1<br/>\\end{matrix}<br/>\\right) \\\\<br/>g = \\left(<br/>\\begin{matrix}<br/>1 & 2 & 3 & 4 \\\\<br/>4 & 1 & 2 & 3<br/>\\end{matrix}<br/>\\right)<br/>\\end{aligned}<br/>$$<br/>那么它们按照一定顺序加合的结果是：<br/>$$<br/>g \\circ f = \\left(<br/>\\begin{matrix}<br/>1 & 2 & 3 & 4 \\\\<br/>1 & 2 & 3 & 4<br/>\\end{matrix}<br/>\\right)<br/>$$<br/>即从右至左地执行这些置换。同时上面这个置换是不变元，无论什么置换与它加合都不会变化。另外，置换的加合满足结合律，但不一定满足交换律。置换的另外一种表示方式就是置换矩阵。这也可以说明为什么置换不满足交换律。<br/>由于置换具有这些性质，所以置换的加合运算和置换可以构成置换群。<br/>染色<br/>首先回答一个简单的问题：给正方形四个顶点分别染成黑色或白色的方案有多少个？显然每个顶点都有两种选择，所以答案为$2^4 = 16$。<br/>现在做出一点限制，如果一个染过色的正方形通过旋转或者轴对称后与另外一个染过色的正方形相同，就说这两种染色是本质相同的。那么问你有多少种本质不同的染色方案。通过枚举，我们也可以知道答案是$6$。这$6$中方案如下 (本质相同的只画了一种)：<br/><br/>对我们而言，难以考虑的是同构的问题。假如我们给顶点标号，分别为$1$、$2$、$3$和$4$：<br/><br/>那么上面这个图的染色为：<br/>$$<br/>c_1 = \\left(<br/>\\begin{matrix}<br/>1 & 2 & 3 & 4 \\\\<br/>\\mathrm{W} & \\mathrm{B} & \\mathrm{W} & \\mathrm{W}<br/>\\end{matrix}<br/>\\right)<br/>$$<br/>经过对称，与之同质的染色是这样的：<br/>$$<br/>c_2 = \\left(<br/>\\begin{matrix}<br/>1 & 2 & 3 & 4 \\\\<br/>\\mathrm{W} & \\mathrm{W} & \\mathrm{B} & \\mathrm{W}<br/>\\end{matrix}<br/>\\right)<br/>$$<br/>事实上，这个变换可以看做是将$2$和$3$调换了一下。于是我们将这个对称定义成这样一个置换：<br/>$$<br/>f = \\left(<br/>\\begin{matrix}<br/>1 & 2 & 3 & 4 \\\\<br/>1 & 3 & 2 & 4<br/>\\end{matrix}<br/>\\right)<br/>$$<br/>然后定义$\\times$运算，表示一个染色的顶点经过一个置换后，得到的新的染色，于是有：<br/>$$<br/>f \\times c_1 = c_2<br/>$$<br/>可以发现，置换的加合和上面的变换在一起时也满足结合律。<br/>这样，我们就将颜色的同构用置换表示出来了。我们定义正方形所有的变换为一个置换，它们构成一个集合：<br/>$$<br/>G = \\{e = p^0, p, p^2, p^3, f_1, f_2, f_3, f_4\\}<br/>$$<br/>其中$e$是置换的不变元。$p$是顺时针旋转$90^\\circ$的置换：<br/>$$<br/>p = \\left(<br/>\\begin{matrix}<br/>1 & 2 & 3 & 4 \\\\<br/>4 & 1 & 2 & 3<br/>\\end{matrix}<br/>\\right)<br/>$$<br/>而$p$的幂次就是多次旋转。$f_1$到$f_4$是沿着正方形的四条对角线的置换。可以验证这个集合和置换的加合运算构成了一个置换群。因此，对于两种染色$c_1$和$c_2$，它们本质相同当且仅当存在一个$f \\in G$，满足$f \\times c_1 = c_2$。<br/>另外，设图形的所有染色方案为$C$，定义$G(c)$为$\\{f : f \\times c = c, \\;\\forall f \\in G\\}$，即不改变染色$c$的置换的集合。以及$C(f)$为$\\{c : f \\times c = c, \\; \\forall c \\in C\\}$，即经过置换后不变的所有的染色方案的集合。之后的讨论中将会用到它们。<br/>Burnside定理<br/>首先来考虑与$c$本质相同的染色的个数：<br/><br/>定理：与$c$本质相同的染色的个数为：<br/>$$ {|G| \\over |G(c)|} \\tag{3.1} $$<br/><br/>证明：考虑每个$f \\times c, f \\in G$，$G(c)$中都存在$|G(c)|$个$g$, 满足$(f \\circ g) \\times c = f \\times (g \\times c) = f \\times c$。即对于任意染色方案，都有$|G(c)|$种置换使得染色方案不变。所以总数为$|G| / |G(c)| $。<br/>接下来将采用双重计数来证明下面的Burnside定理：<br/><br/>(Burnside定理)<br/>设关于染色集$C$与置换群$G$上本质不同的染色方案数为$N(G, C)$，那么满足：<br/>$$ N(G, C) = \\frac1{|G|}\\sum_{f \\in G} |C(f)| \\tag{3.2} $$<br/><br/>证明：我们现在来考虑满足$f \\times c = c$的二元组$(f, c)$的个数。首先我们从$C(f)$的角度考虑，可以知道答案为：<br/>$$<br/>\\sum_{f \\in G} |C(f)|<br/>$$<br/>另外，从$G(c)$的角度考虑，也可以知道答案为：<br/>$$<br/>\\sum_{c \\in C} |G(c)|<br/>$$<br/>为了方便，我们设$A(c) = \\{f \\times c, \\; \\forall f \\in G\\}$，即与$c$本质相同的染色的集合。根据$(3.1)$，我们知道：<br/>$$<br/>|G(c)| = {|G| \\over |A(c)|}<br/>$$<br/>那么可以得到：<br/>$$<br/>\\sum_{f \\in G} |C(f)| = |G|\\sum_{c \\in C} \\frac1{|A(c)|}<br/>$$<br/>对右边的和式做如下的考虑：假设每个等价的集合的贡献是$1$，那么每个染色的贡献就是$1/|A(c)|$，所以上式可以改写为：<br/>$$<br/>\\sum_{f \\in G} |C(f)| = |G|N(G, C)<br/>$$<br/>所以：<br/>$$ N(G, C) = \\frac1{|G|}\\sum_{f \\in G} |C(f)| $$<br/>回到之前正方形染色的例子，我们对于每一个置换这样考虑：<br/><br/>对于不变元$e$，总共有$2^4 = 16$中染色不变。<br/>对于$2$个顺时针旋转 (除了旋转$180^\\circ$)，它们都只有全是黑或者全是白的染色不变，贡献为$2 \\times 2 = 4$。<br/>对于旋转$180^\\circ$，只需要满足两个相邻的顶点颜色相同即可，所以贡献为$2^2 = 4$。<br/>对于$2$个对角线对称，只要满足对角颜色相同即可，贡献为$2^3 \\times 2 = 16$。<br/>对于另外$2$个对称，需要满足两边颜色相同，贡献为$2^2 \\times 2 = 8$。<br/><br/>所以答案为$(16 + 4 + 4 + 16 + 8) / 8 = 6$。<br/>进一步考虑计算$C(f)$。假如我们将置换写成置换环的形式，例如：<br/>$$<br/>f = \\left(<br/>\\begin{matrix}<br/>1 & 2 & 3 & 4 \\\\<br/>2 & 1 & 4 & 3<br/>\\end{matrix}<br/>\\right)<br/>$$<br/>可以写成：<br/>$$<br/>f = [2\\;1][4\\;3]<br/>$$<br/>可以发现，如果要满足经过置换后染色不变，那么每一个置换环内的颜色必须相同。于是，对于这一个置换环而言，计算就可以直接简便为$2^2 = 4$，而不需要去做讨论。<br/>简单图计数<br/>【HNOI 2009】图的同构<br/>现在来讨论一个更加复杂的问题，就是$n$个点的本质不同的简单无向图的数量12。简单图是没有重边和自环的图。记为$a(n)$。<br/>首先，我们可以直接列举可以得知：<br/>$$<br/>a(0) = 1, a(1) = 1, a(2) = 2, a(3) = 4<br/>$$<br/>更大的$n$如果采用列举的方法实在无法想象。为了能够利用Burnside定理，我们考虑将其转为一个染色问题。注意到大小为$n$的简单图的边已经全部确定，只是存在选或不选的问题。所以可以视为是这些边是染成黑色还是染成白色的问题。此外我们要将本质相同的计数去掉。如果两个图相同，那么存在一个与点编号相关的置换，使得两张图的边集是一样的。所以我们考虑所有的点的置换，总数为$n!$个，每一个将会对应到一个边的置换，即用于判定同构的置换。可以证明从点的置换转来的边的置换是一个置换群。<br/>现在来考虑点的置换是如何转成边的置换的。由于我们已经可以根据置换环的数量来计算$C(f)$了，所以我们不需要关注置换到底长什么样，只需要知道有多少个置换环即可。对于一个边的置换，里面的每一条边的两个端点要么在点置换的一个置换环内，要么在不同的置换环内。<br/>首先观察一下在同一个置换环内的情况：<br/><br/>黄色的边是置换环上的边，而红色的就是边置换中的边。由于将整条边随着置换环旋转，会得到许多一样的边，所以我们将一个点固定，来考虑另外一个点。可以发现实线的边是不同的，而虚线的边则是和实线的边是同构的。所以，对于长度为$L$的置换环，在边的置换中对应了$\\lfloor L / 2 \\rfloor$个置换环。<br/>然后考虑不在同一个置换环的情况：<br/><br/>设两个置换环的长度分别为$A$和$B$，可以发现，每一条连接两个置换环的边，都会有$\\mathrm{lcm}(A, B)$条边与它同构。而总边数为$AB$，所以这个点置换的置换环就对应了边置换中的$\\gcd(A, B)$个置换环。<br/>考虑完点置换和边置换的一一对应关系后，我们考虑来计数点置换集中有多少个置换环长度分别为$L_1, L_2, L_3, \\dots$的置换。设长度为$i$的置换环的个数为$S_i$，那么这个数量是：<br/>$$<br/>{n! \\over L_1 L_2 L_3 \\cdots S_1!S_2!S_3!\\cdots}<br/>$$<br/>因为对于每个置换环，随意循环旋转都是同构的，而大小相同的置换环互相之间也是一样的，所以需要除去上面那个分母。<br/>所以我们就可以算出所有置换的贡献，然后除以置换的总个数$n!$，就是我们的答案。<br/>最后，我们只需要枚举置换中置换环的情况，这个其实就是$n$的分拆。利用这个方法，我们可以计算更大的$n$的方案 (但是还是难以计算近百的级别)。<br/><br/><br/><br/><br/>这个数列在OEIS上有。 ↩<br/><br/><br/>我的另外一篇博客简单分析了下本质不同的简单无向连通/非连通图的数量的计算。 ↩<br/><br/><br/>","tags": "Burnside定理 组合数学","url": "blog/2016-12-19/burnside.html"},
{"title": "树状数组","text": "树状数组<br/>树状数组是一种快速统计前缀和的简单数据结构。<br/>基本问题<br/>很多情况下，我们需要查询区间内的和，通常万能的做法就是线段。写过线段树的都知道，它其实并不简单，当然也不太难。而有了树状数组后，就可以以比线段树少很多代码，来统计区间和。<br/>区间求和的问题一般是这样的：<br/><br/>给你一个长度为$n$的数列，然后每次给你一个区间询问，询问这段区间内数的总和。<br/><br/>求区间和可以通过求前缀和而得。即查询$S[l, r]$可以转变为$S[1, R] - S[1, L - 1]$。其中$S$表示区间和。<br/>点修改区间查询<br/>我们将先看到几个特化过的区间求和问题。树状数组的最基本用场就是点修改 + 区间查询了。它要求支持两个操作：<br/><br/><br/>修改某一位置上的数<br/>查询某一位置前缀和<br/><br/><br/><br/>树状数组是套在原数组上的一层2，用来进行一些维护。上图中的树状数组被画成了它该有的样子，实际上就是一个数组。<br/>对于数组中的每一个元素，其箭头所指向的元素(包括他自己)都被它所维护。<br/>对于任意一个元素，其往前的一个区间距离和到它父亲的距离是相同的，即一个被称为$\\text{lowbit}$的东西。这个东西定义如下：<br/>1<br/>2function LOWBIT(x):<br/>    return x & (-x)<br/><br/><br/>这里面用到一个很玄乎的位运算，至于为什么是这样，这里就不多说了。<br/>对于LOWBIT有一个需要注意的地方，就是LOWBIT(0) = 0。即树状数组不能处理下标为$0$的情况1。如果不注意，就很容易出现死循环。<br/>对于每次单点的更新，我们都要将它的父亲给更新，因为它是被其父亲所管辖的。<br/>而查询可以向前进行统计，这样就可统计前缀和。<br/>下面用fenwick表示树状数组，n表示其长度。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18// 修改单点<br/>function MODIFY(x, delta):<br/>    if x < 1:<br/>        return<br/><br/>    while x <= n:<br/>        fenwick[x] += delta<br/>        x += LOWBIT(x)<br/><br/>// 查询前缀和<br/>function QUERY(right):<br/>    answer = 0<br/><br/>    while right > 0:<br/>        answer += fenwick[right]<br/>        right -= LOWBIT(right)<br/><br/>    return answer<br/><br/><br/>对于每个操作，其中的循环只要进行$\\Theta(\\log n)$次，故它们的时间复杂度为$\\Theta(\\log n)$的。<br/>区间修改点查询<br/>对于区间修改 + 点查询的问题通常要支持一下两种操作：<br/><br/><br/>修改一段前缀和<br/>查询某一个位置上数的大小<br/><br/><br/><br/>考虑到能够影响到一个点的值的，只有其父亲。因此每次修改前缀和时，只需要修改它们的某一个父亲即可。查询单点时，也只需要访问其每一个父亲，从而可以得知自己被加上了多少。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18// 修改<br/>function MODIFY(right, delta):<br/>    while right > 0:<br/>        fenwick[right] += delta<br/>        right -= LOWBIT(right)<br/><br/>// 查询<br/>function QUERY(x):<br/>    if x < 1:<br/>        return 0<br/><br/>    answer = 0<br/><br/>    while x <= n:<br/>        answer += fenwick[x]<br/>        x += LOWBIT(x)<br/><br/>    return answer<br/><br/><br/>与前面一样，这两个操作的时间复杂度也是$\\Theta(\\log n)$。<br/>区间修改区间查询<br/>事实上，上面两种特化版本并不是太常见，最常见的因该是完整的区间和问题。对于这个问题，我们只要实现一下两种操作：<br/><br/><br/>修改一段前缀和<br/>查询一段前缀和<br/><br/><br/>由于树状数组的一些特殊性，它的查询不是从所谓的根节点开始的，因此在父亲信息都会丢失掉。然而要将他们统计回来时，却需要很高的代价。因此一个树状数组不好解决这个问题。<br/>所以我们同时使用两个树状数组，一个用于查询其儿子们的信息，另外一个则用于查询父亲的信息。<br/>具体实现时，我们使用fenwick1来记录其父亲的信息，fenwick1[x]表示的是前x个数每个都被加上的数。使用fenwick2来记录儿子的信息，fenwick2[x]表示的是第x个元素所管辖的范围内的元素之和。这样对两个数组都查询一次，就可以得到完整的信息。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29<br/>30<br/>31<br/>32// 修改<br/>function MODIFY(right, delta):<br/>    if right < 1:<br/>        return<br/><br/>    i = right<br/>    while i > 0:<br/>        fenwick1[i] += delta<br/>        i -= LOWBIT(i)<br/>    i = right<br/>    while i <= n:<br/>        fenwick2[i] += delta * right  // 注意是区间每一个数都加上了delta<br/>        i += LOWBIT(i)<br/><br/>function QUERY(right):<br/>    if right < 1:<br/>        return 0<br/><br/>    answer = 0<br/><br/>    i = right<br/>    while i <= n:  // 统计父亲上的信息<br/>        answer += fenwick1[i]<br/>        i += LOWBIT(i)<br/>    answer *= right  // 因为是每个数所加上的数，所以要乘以个数<br/><br/>    i = right - 1<br/>    while i > 0:  // 统计儿子信息<br/>        answer += fenwick2[i]<br/>        i -= LOWBIT(i)<br/><br/>    return answer<br/><br/><br/>按照国际惯例，时间复杂度依然保持在$\\Theta(\\log n)$。<br/>更高维度<br/>有时候我们需要对二维或三维上进行求和，线段树当然可以做，只是代码量将以$O(2^k)$的复杂度暴涨，并且巨大的常数也难以接受。但此时树状数组却可以很好的因对。<br/>那是因为每一个树状数组的的最后一个元素实际管辖的是整个数列的和，因此我们可以将它单独挑出来代表这一个数列。当我们有很多个数列时，我们将这些代表也用一个树状数组来维护。这样就实现了树状数组向高维度的扩展。<br/>具体实现方面就是在每个操作中多了几层循环，用于在每一个维度中的统计。最后要得知一段区间中的和时，利用容斥原理即可。<br/>由于在每一维上都需要花费$\\Theta(\\log n)$的时间，因此对于$k$为空间的操作的复杂度一般都是$\\Theta(\\log^k n)$。<br/>优势与缺点<br/>树状数组有着很多的优点：<br/><br/>代码短小，常数小<br/>易于调试<br/>容易扩展到高维度的数据<br/><br/>也正因为如此，树状数组也有着许多的局限性：<br/><br/>只能用于求和3，不能求最大/小值<br/>不能动态插入，面多多维数据时空间压力大<br/>不能可持久化<br/><br/>因此，在树状数组与线段树中进行抉择时，是需要小心的。树状数组虽好，但不是万能的。要根据实际情况来确定。<br/><br/><br/><br/><br/>如果下标一定要为$0$，可以考虑将其全部加$1$。 ↩<br/><br/><br/>当然也可以直接替代原数组。 ↩<br/><br/><br/>或者说具有区间减法性质的数据。 ↩<br/><br/><br/>","tags": "树状数组 数据结构","url": "blog/2016-6-3/fenwick.html"},
{"title": "树链剖分","text": "树链剖分<br/>用途<br/>问题: 给你一棵无根树，每条边有边权，请你实现以下操作：<br/><br/>查询$u$到$v$的路径上边权之和。<br/>查询$u$到$v$的路径上边权最大值。<br/>修改$u$到$v$的路径上每条边的边权。<br/>…<br/><br/>这些操作利用树链剖分，都可以在$O(\\log n)$的时间内解决。<br/>无根树与有根树<br/>一般来说，无根树是很不好处理的，因此将其转为有根树就会好处理些。<br/>我们只要选定一个节点为根，然后进行DFS即可转化为有根树。<br/>转换的时候，我们需要额外记录以下信息：<br/><br/>$x.\\text{father}$: $x$的父亲节点。<br/>$x.\\text{children}$: $x$的所有孩子。<br/>$x.\\text{size}$: 以$x$为根的这一棵子树的大小。<br/>$x.\\text{depth}$: $x$在树中的深度，即$x$到树根的距离$+1$。<br/><br/><br/>这是一棵以$1$为根的树。为了解释更加清楚，这里举几个例子：<br/><br/>$10.\\text{father} = 5,\\; 1.\\text{father} = nil$<br/>$1.\\text{children} = \\{2, 5, 6\\},\\;7.\\text{children} = \\varnothing$<br/>$1.\\text{size} = 17,\\;6.\\text{size} = 8,\\;3.\\text{size} = 1$<br/>$1.\\text{depth} = 1,\\;10.\\text{depth} = 3,\\;14.\\text{depth} = 4$<br/><br/>为了进行树链剖分，我们在立树的过程中需要计算一个重儿子，记作$x.\\text{next}$：<br/>$$ x.\\text{next} = u: u \\in x.\\text{children},\\;u.\\text{size}\\text{最大} $$<br/>即所有儿子中大小最大的一个，就记为重儿子，其它的儿子就是轻儿子。同时称与重儿子相连的边为重边，与轻儿子相连的边为轻边。<br/>下面的伪代码是建立有根树的过程(假设我们输入的是无根树$G$，这是一张无向图，其中与$u$相连的顶点集合为$G[u].\\text{neighbors}$)：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24function MAKE-ROOT(G, u):  // 以u为树根<br/>    u.visited = true  // u已经访问过了<br/>    u.father = nil // u没有父亲<br/>    u.depth = 1<br/><br/>    REAL-MAKE-ROOT(G, u)<br/><br/>function REAL-MAKE-ROOT(G, u):  // DFS过程<br/>    u.size = 1<br/>    u.next = nil<br/><br/>    foreach v in G[u].neighbors:<br/>        if not v.visited:  // 如果还未访问<br/>            v.visited = true<br/>            u.children += v  // 添加儿子节点<br/>            v.father = u<br/>            v.depth = u.depth + 1<br/><br/>            REAL-MAKE-ROOT(G, v)  // 递归向下<br/><br/>            u.size += v.size  // 更新子树大小<br/><br/>            if u.next = nil || v.size > u.next.size:  // 更新重儿子<br/>                u.next = v<br/><br/><br/>剖分<br/>在介绍树链剖分的算法之前，我们先来看看剖分后的树是个什么样子：<br/><br/>剖分后的树信息量一下子大了很多。我将会逐条解释上面都画了些什么。<br/><br/>树链(重链): 所有红色的边所连成的一条链都是剖分后的结果。某些树链没有边，就只有一个节点，这个节点是红色的。在上面，1-6-8-11-13-17是剖分出来的最长的树链，而3独自一个节点形成了树链。<br/>树链起点: 红色的节点是每一条树链的起点。<br/>重儿子: 蓝色的节点是重儿子。<br/>编号: 每一条边上的数字为剖分后的编号。<br/><br/>可以看出，树中的每一个节点都会在一条树链中。因此我们需要对树链也进行编号。我们以树链顶端的节点作为树链的编号，并记为$x.\\text{top}$。例如，$8.\\text{top} = 1,\\;16.\\text{top} = 16$。<br/>如果两个节点$u$和$v$在同一树链中，当且仅当$u.\\text{top} = v.\\text{top}$。<br/>对于边$u \\rightarrow v$的编号，我们记边为二元组$(u, v)$，那么记编号为$(u,v).\\text{id}$。<br/>但是这样不方便在程序中储存，因此我们将边的编号放到节点里面。在上面的写法中，如果$u$是$v$的父亲，那么我们将边$(u,v)$的编号放到$v$中，即$v.\\text{id}$。这样表示$v$与其父亲相连的边$(u,v)$的编号为$v.\\text{id}$。<br/>边的编号是树剖的关键，给边赋予编号后，就可以实现很多操作了。<br/>我们首先来看这些编号有什么特点：<br/><br/>每个边的编号都不一样。<br/>同一条的树链的边的编号从高处向低处编号递增。这样做的好处就是同一条链上面的数据可以用一些数据结构(如线段树、Splay等)来维护。<br/>对于节点$u$，其重边的编号是$u$与所有儿子的连边中最小的。<br/><br/>估计你已经猜到计算$\\text{top}$和$\\text{id}$的用处了。但不要着急，下面就将计算这些值。<br/>计算的过程也是一遍DFS。这次的DFS是在第一次建立好的有根树上进行的。<br/>当我们处理到节点$u$时，我们将$u$和$u.\\text{next}$相连来形成树链。之所以选取重儿子，是因为重儿子的大小最大，因此所生成的树链将尽可能长1。那么其它的儿子将自己成为新的树链。<br/>此时来考虑编号。因为同一条树链上的边的编号是递增的，因此要优先对重儿子进行DFS。由于轻儿子是新创建的树链，因此DFS的顺序并不重要。<br/>至此，树链剖分的算法就结束了。当算法完成时，每个节点就会有正确的$\\text{top}$和$\\text{id}$。<br/>下面是树链剖分的伪代码：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23count = 0  // 已编号的数量<br/><br/>function TREE-SPLIT(x):  // 剖分子树u<br/>    x.id = 0  // 根节点没有父亲<br/>    x.top = x  // 根节点是第一条链<br/><br/>    REAL-TREE-SPLIT(x)<br/><br/>function REAL-TREE-SPLIT(x):  // DFS过程<br/>    if x.next != nil:  // 如果有重儿子<br/>        count += 1<br/>        x.next.id = count<br/>        x.next.top = x.top<br/><br/>        REAL-TREE-SPLIT(x.next)  // 优先重儿子<br/><br/>    foreach v in x.children:  // 对于轻儿子则新创一条链<br/>        if v != x.next:  // 检查是不是重儿子<br/>            count += 1<br/>            v.id = count<br/>            v.top = v<br/><br/>            REAL-TREE-SPLIT(v)<br/><br/><br/>基础操作<br/>树链剖分完有什么用呢？<br/>就像一开场所说的：<br/><br/><br/>查询$u$到$v$的路径上边权之和。<br/>查询$u$到$v$的路径上边权最大值。<br/>修改$u$到$v$的路径上每条边的边权。<br/>…<br/><br/><br/>下面将介绍如何进行路径边权之和的查询和修改路径边权这两个操作。其它的操作可以在此思想上扩展。<br/>查询<br/>假如我们要查询$u$到$v$的路径上的权值之和，那么就会有两种情况：<br/><br/>$u$和$v$在同一条树链上。<br/>$u$和$v$不在同一条树链上。<br/><br/>对于第一种情况，非常好解决。我们可以用线段树来维护每一条边的权值，直接按照编号来排列。由于同一条链上的编号是递增的，如果$u.\\text{depth} < v.\\text{depth}$，则可以直接查询$[u.\\text{next}.\\text{id}, v.\\text{id}]$的和。如果$u.\\text{depth} = v.\\text{depth}$，由于$u$和$v$是在同一条树链上的，也就是意味着$u = v$，那么就不需要统计。<br/>对于第二种情况，我们考虑使它们不断逼近到同一条链上来，从而就转为了第一种情况。但是，在其中一个节点变化到另一条树链上时，要将经过的树链的值进行统计。<br/>我们按照一下步骤来处理：<br/><br/>如果$u.\\text{top}.\\text{depth} < v.\\text{top}.\\text{depth}$，那么交换$u$和$v$，使$u$所在的树链为所处位置较深的一个。<br/>计算$[u.\\text{top}.\\text{id},u.\\text{id}]$的值并累加。<br/>令$u = u.\\text{top}.\\text{father}$。<br/>如果$u.\\text{top} = v.\\text{top}$，则转化为第一种情况。否则跳转第一步。<br/><br/>上面步骤的思想就是将上升期间的每一条树链的和统计出来，这样实则就是统计了这条路径上的和。<br/>第一步的操作是为了方便后续的处理。第二步是计算这一条链上的和，包括这条链上面的一条轻边，因为在第三步中要走这条轻边到达上面一条树链。最后一步是检查是否成为了第一种情况。<br/>下面是上面步骤的参考伪代码：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18function QUERY-SUM(u, v):<br/>    sum = 0<br/><br/>    // 如果不在同一条树链<br/>    while u.top != v.top:<br/>        if u.top.depth < v.top.depth:<br/>            SWAP(u, v)  // 交换u和v<br/><br/>        sum += QUERY(u.top.id, u.id)  // 利用线段树等数据结构来求和<br/>        u = u.top.father  // 走轻边进入上面的树链<br/><br/>    if u == v:  // 如果处在相同位置<br/>        return sum<br/><br/>    if u.depth > v.depth:  // 使u成为深度较小的节点<br/>        SWAP(u, v)<br/><br/>    return QUERY(u.next.id, v.id) + sum<br/><br/><br/>如果不能理解，这里给出一个示例：<br/><br/>假设我们查询$16$到$17$：<br/>首先会发现它们不在同一条链上，由于$16$所处的链的深度较大，为$5$，因此将$16$进行上移，上移至$14$，并统计$[13, 13]$的和。<br/>然后$14$和$17$依然不在同一条链中，由于$14$所处的链的深度为$2$，因此将$14$上移。上移至$1$，并统计$[9, 11]$的和。<br/>最后发现$1$和$17$已经在同一条链中了，直接统计$[1, 5]$的和即可。<br/>修改<br/>事实上，修改操作和查询几乎是一模一样的，只是将求和的地方变成了相应的数据结构的修改操作。这里就不再多说了。<br/>时间复杂度<br/>每当学习了一个新算法，我们最关切的就是它的时间复杂度了。<br/>如果树链剖分的时间复杂度高到爆，我们写的时候估计得虚死。<br/>但是可以证明，树链剖分后的树，从根节点到任意一个叶节点的路径只会与$O(\\log n)$条树链相交。这意味着将两个节点逼近到同一条链上时，只需经过$O(\\log n)$次跳转。<br/>即基于树剖的其它操作的时间复杂度为$\\Omega(\\log n)$(注意是下界，具体的上界取决于操作本身的附加的复杂度)。<br/>为什么会只有$O(\\log n)$条呢？<br/>我们来考虑树链剖分时最坏的情况：<br/><br/>想象这是树剖是最坏的情况(因为实际上并不会这样)。因为树剖总是尝试将最长的剖分出来，因此树链都是向右的。如果最左链再加一个节点，树链就会向左剖分了。<br/>为了达到这样的效果，这棵有根树是接近平衡的，即树高为$\\Theta(\\log n)$。<br/>因此最坏的情况下，当查询最左边的节点时，只需要使用$O(\\log n)$次跳转就可完成。<br/>当然上面并不是严格的证明，只是一个形象的说明罢了。我们只需要知道树链剖分能保证很好的时间复杂度即可。<br/>正确的证明思路因该是这样的：<br/>可以考虑一棵树中轻边的数量。由于从某一个节点开始，每走一条轻边，子树的大小都会减小一倍。因此任意一条树链上只有$O(\\log n)$条轻边，即意味着只有$O(\\log n)$。<br/>树链剖分计算LCA<br/>LCA即最近公共祖先。计算LCA的算法可以说是各种各样，有暴力的爬山法，炸空间的Tarjan算法，开挂的倍增法，莫名高大上的ST跳表的搞法，还有不知所云的转成RMQ问题......在与树相关的操作中，经常需要一些求LCA的操作。其中最常用的就是倍增法，它能在$O(\\log n)$的时间内求出LCA，并且其空间复杂度为$\\Theta(n \\log n)$。<br/>当我们树剖后的操作需要借助到LCA时，是不是就要写个LCA的算法呢？<br/>其实并不需要，我们可以直接利用树剖的结果来计算LCA。<br/>然而，求LCA的过程和之前查询也是差不多的：在同一条链上的时候，深度值较小的就是LCA。如果不在同一条链上，就不断往上跳即可。这样可以在$O(\\log n)$时间内求出LCA。并且仅使用了$\\Theta(n)$的空间复杂度，优势十分显著。<br/>当然，单纯拿树链剖分来求LCA也煞是浪费。既然树剖有能求LCA的能力，因此在面对需要LCA的时候就不必求助于其它的算法了。<br/>树链剖分与DFS序<br/>【NOI2015】软件包管理器<br/>当我们既需要维护链上信息，又需要维护子树信息时，就有点棘手了。<br/>维护子树信息的通常做法是DFS序。为了能够将树链剖分与DFS序结合起来，目标就是将树链剖分的编号与DFS序统一起来。<br/>考虑到DFS序实际上不是唯一的，因此在树链剖分的过程中可以先对重儿子进行DFS，这样就可以保证一条重链上的DFS序也是递增的了。于是，我们可以继续按照DFS序维护子树的方法，同时树链剖分的信息也会被同时更新。<br/><br/><br/><br/><br/>实际上，按照子树大小来剖分不一定能剖分出最长的树链，但这并不影响最终的操作的效率。如果要剖分出的链真正最长，应当选择秩最大的儿子作为重儿子。 ↩<br/><br/><br/>","tags": "数据结构 树链剖分 LCA","url": "blog/2016-4-20/tree-split.html"},
{"title": "欧拉回路","text": "欧拉回路<br/>定义<br/>欧拉回路通常用来解决”一笔画”问题。具体而言就是询问一张图上是否存在一条回路使得它经过所有的边一次。如果有，那么求出这条回路。<br/>例如，在下面这个图里面：<br/><br/>一条欧拉回路是1 - 4 - 2 - 3 - 4 - 5 - 2 - 1。<br/>存在性<br/>无向图<br/>考虑在走一条欧拉回路的时候，如果不是起点，我们每进入一个点，就一定会走出去。如果是起点，每出去一次，就一定又会回来一次。这说明如果有欧拉回路，那么每个点的度数应当是偶数。<br/>同时，从另一方面来讲，如果某个点的度数是奇数，那么在某一次进入这个点之后，我们就出不来了。如果起点的度数是奇数，那么之后必定有一次无法回到起点。<br/>总而言之，对于无向图，每个点的度数必须是偶数。<br/>此外考虑当图不连通时，一般是没有欧拉回路的。但是如果有连通块上本来就没有边，像下面这样：<br/><br/>此时1这个点是不需要考虑的。但是并不意味着大小为$1$的连通块就不必考虑，因为它们可能有自环，如同下面这样：<br/><br/>但是很多的这样的连通块不行，我们的程序在判定的时候需要注意这些细节：<br/><br/>有向图<br/>有向图与无向图是类似的。同样按照之前的方式考虑，进入一点就意味着需要出来，那么就说明每个点的入度与出度相同。<br/>此外考虑连通性，与无向图类似，我们要求这个图只存在一个有边的强连通分量。<br/>构造算法<br/>如果满足了存在性的要求，那么这张图将被称为欧拉图。<br/>构造一条欧拉回路看上去是可以随意走的，因为你每走一个点总能保证你有地方出去。但是这样的算法却不能保证你走过了每一条边。举一个经典的例子：<br/><br/>在这张无向图中，一条欧拉回路是1 - 2 - 4 - 5 - 2 - 3 - 1。如果采用随便走的策略，那么有可能走出1 - 2 - 3 - 1这样的路径就终止了。<br/>这是因为欧拉回路实际上是由一些环以点相交构成的。观察上面正确的欧拉回路，可以发现它是由1 - 2 - 3 - 1和2 - 4 - 5 - 2构成的。<br/>因此正确的方法应当是实现一个DFS搜索，每搜到一个环就将其插入之前的欧拉回路中，这样可以实现欧拉回路的构造。<br/>实际上我们没有必要显式地实现插入环，而是可以通过下面这个DFS来实现：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9tour = []  # 欧拉回路<br/><br/>def construct(x):<br/>    for e in x.adj:<br/>        x.adj.remove(e)  # 边被访问<br/>        construct(e.either(x))  # 沿着边走下去<br/>        tour.append(e)<br/><br/># 最后将tour中的边倒序输出就是欧拉回路<br/><br/><br/>这里关键是为什么是先递归后将边加入欧拉回路，并且需要倒序输出。假设现在正在考虑$u$，那么就可能会有一些环会从$u$开始并且以$u$结束，那么它们在之后的递归中又会回到$u$，因此我们先将后面的环放入欧拉回路是没有问题的。如果从$u$出发后就回不来了，那么这条”不归路应当在那些会回到$u$的环之后插入。所以这个DFS就保证了这一点。<br/>此外，对于每一条访问过的边，我们应当将其删除 (或者使用其它方法保证之后不会再次遍历)。否则当我们进入一个点多次的时候，这些边也会遍历多次，复杂度就会变得很高。<br/>事实上，这个无向图的构造算法对有向图也通用。<br/><br/>判定算法<br/>为什么要先说构造算法然后再说判定算法呢？以为构造算法可以帮助我们判定图的连通性，而在构造之前，我们需要保证基础的度数限制是满足的。<br/>如果度数限制满足以后，那么图中的每一个连通块 (或者强连通分量) 都可以使用之前的构造算法构造出欧拉回路。因此我们只用找到一个有边的连通块 (或强连通分量) 就可开始构造。如果构造完之后图中依然有边剩余，那么说明这张图没有欧拉回路。<br/>完整的判定算法如下：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16def evaluate(G):<br/>    if G is directed:<br/>        for v in G:<br/>            if v.indegree != v.outdegree:<br/>                return False<br/>    else:<br/>        for v in G:<br/>            if v.degree %  2 > 0:<br/>                return False<br/><br/>    for v in G:<br/>        if len(v.adj) > 0:<br/>            construct(v)<br/>            break<br/><br/>    return len(tour) == len(G.E)<br/><br/><br/>其他<br/>欧拉路径<br/>与欧拉回路相似，欧拉路径是一条经过所有边的路径。由于欧拉路径比欧拉回路少一条边，所以在无向图上，当且仅当存在两个点的度数是奇数。而在有向图上，则必须存在一个点入度比出度大$1$，以及另一个点出度比入度大$1$。对于有向图，只要满足单联通即可。<br/>中国邮递员问题<br/><br/>假设现在有一张联通的无向图，保证度数为奇数的点的个数是偶数，问你最短的经过所有边至少一次的环的长度。<br/><br/>之所以称其为邮递员问题，因为原问题是在邮递员送信的背景下提出的。<br/>假设图的边数为$m$，那么欧拉回路可以给出一个$2m$条边的方案。因为我们将原图中每一条边都复制一遍，我们将得到一张$n$个点$2m$条边的图，并且由于每个点的度数都被乘以$2$，那么这张新图必定存在欧拉路径，同时也可以给出上述问题的一个答案。","tags": "欧拉回路 图论","url": "blog/2016-12-13/eular-tour.html"},
{"title": "正式开始编写ne2d","text": "正式开始编写ne2d<br/><br/>一直想找个好点的2D渲染引擎，但看了很多似乎都不合胃口，也许有点挑剔。之前看到的bgfx似乎也有点操蛋，毕竟操作上还是麻烦了点。<br/>因此，趁着时间还多，多造点轮子，学点东西。索性开始自己做个适合的2D渲染引擎。<br/>之前这个自制的渲染引擎ne2d一直处于极其不稳定状态，动辄几千行代码的改动。<br/>今天总算有个大致框架了。目前计划做成一个单纯的2D渲染引擎，不打算管平台相关的代码。<br/>只要能够提供OpenGL上下文就能使其工作。<br/>目前这个工程才刚刚起步，暂时还没法使用。<br/>这里记录下目前的想法和进度：<br/>基本功能：  <br/><br/> OpenGL 3.3 core profile  <br/> Alpha支持<br/> Layer抽象，支持图层深度<br/> RenderObject，所有渲染对象实例化<br/> Sprite绘制材质<br/> 矩阵变换（使用glm）<br/> TrueType字体（SDL_ttf or raw Freetype?）<br/><br/>计划中的功能：  <br/><br/> 动画<br/> *.layout文件载入图层（JSON or XML?）<br/> 自定Shader<br/> 粒子系统<br/><br/>至于不处理平台相关的代码，因为我觉得SDL做得比我好，我个人也是很喜欢SDL的接口风格的（只是SDL在渲染方面似乎并不怎么样…）。<br/>所以所有的窗口创建、OpenGL上下文创建、事件管理......这些东西都交给SDL吧！当然你喜欢glfw也是可以的。<br/>最后把GitHub repo放一下吧：<br/><br/>ne2d: 理论上是稳定版  <br/>ne2d/develop: 理论上是最新版  <br/>ne2d/unstable: 激进版<br/><br/>另外，欢迎有兴趣的同志一起开发！","tags": "C/C++ ne2d 图形","url": "blog/2016-2-4/ne2d-1.html"},
{"title": "测试","text": "pagegen.py的试炼<br/>希望pagegen.py能正确工作。  <br/>常规Markdown测试<br/>h1<br/>h2<br/>h3<br/>h4<br/>h5<br/>h6<br/>上面是六级标题。  <br/><br/>上面是六级标题。<br/>这是一段引用  <br/><br/>很好，inline-code和Hello, world：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9#include <iostream><br/><br/>using namespace std;<br/><br/>int main(int argc, char *argv[]) {<br/>    cout << \ Hello, world!\  << endl;<br/><br/>    return 0;<br/>}<br/><br/><br/>别忘了Python：<br/>1<br/>2<br/>3<br/>4#!/usr/bin/env python3<br/><br/>if __name__ == \ __main__\ :<br/>    print(\ Hello, world!\ )<br/><br/><br/>1<br/>2Tab也可以直接代码<br/>Yeah!!!<br/><br/><br/>重要的话说三遍<br/>重要的话说三遍<br/>重要的话说三遍<br/>下划线是什么鬼<br/>打表A题：<br/><br/><br/><br/>NOI<br/>A<br/>B<br/>A + B<br/><br/><br/><br/><br/>1<br/>1<br/>2<br/>3<br/><br/><br/>2<br/>2<br/>2<br/>4<br/><br/><br/>3<br/>5<br/>5<br/>10<br/><br/><br/>4<br/>3<br/>4<br/>7<br/><br/><br/><br/><br/><br/><br/>列1<br/>列2<br/>列3<br/><br/><br/><br/><br/>233333333333333<br/>23333333<br/>233<br/><br/><br/><br/>我的GitHub: https://github.com/riteme<br/>GitHub<br/>我的E-mail: riteme@qq.com<br/>脚注1？  <br/>GFM breaks!<br/>应该不在一行!<br/>应该不在一行!!<br/>应该不在一行!!!!!<br/>deleted<br/>inserted<br/>–smartpants—<br/>“a“‘b‘“c“‘d‘“e”“’<br/>Mathjax测试: $e^{ix} = \\cos x + i\\sin x$<br/>这个应该不得出问题......<br/>$$ \\sum_{i = 1}^{\\infty} i = - {1 \\over 12} \\tag{1.1} $$<br/>$$ a^2 + b^2 = c^2 \\Rightarrow \\triangle ABC\\text{是直角三角形} \\tag{1.2} $$<br/>$$<br/>\\begin{aligned}<br/>X_k & = \\sum^{n - 1}_{j = 0} x_ke^{-2\\pi ijk/n} \\\\<br/>    & = \\sum^{n - 1}_{j = 0} x_kw_n^{-jk}<br/>\\end{aligned}<br/>$$<br/>$$<br/>\\begin{aligned}<br/>x_k & = \\frac1n\\sum^{n - 1}_{j = 0} X_ke^{2\\pi ijk/n} \\\\<br/>    & = \\frac1n\\sum^{n - 1}_{j = 0} X_kw_n^{jk}<br/>\\end{aligned}<br/>$$<br/>$$ $$$$ $ $<br/>行内公式inline-math在此$ 233 \\neq 244 $233333<br/>特殊语法测试<br/>FBI Warning<br/>肯定有BUG<br/><br/>Markdown in it<br/>STRONG, inline-code.<br/><br/>中文<br/>Not Supported…<br/>乱搞<br/>233444<br/><br/>233<br/><br/>Goodbye!<br/><br/><br/><br/><br/>真的行吗...... ↩<br/><br/><br/>","tags": "test","url": "blog/2016-1-31/test.html"},
{"title": "测试多说","text": "测试多说<br/>欢迎大家在下面按照基本法放肆评论，我看看我pagegen.py写对没有。<br/>打个广告吧： 多说","tags": "test","url": "blog/2016-2-4/comments.html"},
{"title": "监听计划","text": "监听计划 (HNSDFZ #7)<br/>题目描述<br/>黑猫警长Lunk最近发现了$n$个MHA集团，从$1$到$n$编号。鉴于MHA集团数量庞大，Lunk需要先对他们进行全面了解后才可以动手。<br/>Lunk决定派遣间谍渗入MHA集团的通信网络中来监听他们。MHA集团的通信网络是依靠两两集团之间的通信线路构成的。消息可以通过多条通信线路到达其他集团。Lunk的间谍十分强大，他们也可以通过这些通信线路来监听每一个能到达的集团。<br/>然而Lunk是资本家，他不希望花费太多资本用于雇佣间谍。他只想用最少的间谍来监听所有的MHA集团。很不幸的是，这些集团间的通信线路质量不好，有一定的寿命，MHA集团每天都会添加一些新的通信线路来确保通信畅通。因此Lunk希望知道每天通信网络稳定后，最少需要多少个间谍才可以监听所有的集团。<br/>实现<br/>本题采用交互式测评。请在下载一栏中获取样例交互库。<br/>样例交互库包含network.h和implementer.cpp两个文件。选手源程序需要包含network.h这个头文件。<br/>你需要实现以下四个函数：<br/><br/>$\\text{initialize}(n, \\;q)$：在交互库初始化时会调用该函数，用于初始化你的程序。<br/>$n$表示MHA集团的数量。<br/>$q$表示天数，意思是Lunk将只关注第$1$到第$q$天的情况。<br/><br/><br/>$\\text{add-connection}(u, \\;v, \\;t)$：单个数据点中将会被调用$q$次，表示每天MHA集团加入的新的通信线路。<br/>$u$、$v$表示在编号为$u$和$v$的两个MHA集团间架设通信线路。<br/>$t$表示通信线路的寿命。如果该线路是第$i$天加入的，那么这条线路只会在$[i, \\;i + t)$这段时间内有效。<br/><br/><br/>$\\text{query}()$：每次调用完$\\text{add-connection}$之后会被调用，用于回答Lunk的询问。<br/>$\\text{finalize}()$：交互库结束时将调用该函数，用于释放你程序所使用的资源。<br/><br/>network.h中也有对这四个函数的注释文档。<br/>implementer.cpp是样例交互库。假设你编写的源文件为network.cpp，那么使用以下命令编译：<br/>1g++ implementer.cpp network.cpp -o exec<br/><br/><br/>exec是可执行文件。<br/>输入格式<br/>第一行输入两个正整数$n$、$q$，表示集团的个数和总共的天数。<br/>接下来$q$行每行输入三个正整数$u$、$v$和$t$，表示每天通信网络中集团$u$和集团$v$之间添加了一条寿命为$t$的通信网络。<br/>最开始MHA集团之间没有通信线路。<br/>输出格式<br/>输出$q$行，每行一个正整数，表示每天通信网络变动完毕后最少需要派遣的间谍的人数。<br/>样例输入<br/>1<br/>2<br/>3<br/>4<br/>54 4<br/>1 2 3<br/>2 3 2<br/>3 4 1<br/>4 4 10086<br/><br/><br/>样例输出<br/>1<br/>2<br/>3<br/>43<br/>2<br/>1<br/>4<br/><br/><br/>限制<br/>本题共$10$个测试点，其限制如下：<br/><br/><br/><br/>数据编号<br/>$n$<br/>$q$<br/><br/><br/><br/><br/>1<br/>$10$<br/>$40$<br/><br/><br/>2<br/>$2 \\times 10^3$<br/>$7 \\times 10^3$<br/><br/><br/>3<br/>$3 \\times 10^3$<br/>$7 \\times 10^3$<br/><br/><br/>4<br/>$5 \\times 10^3$<br/>$2 \\times 10^4$<br/><br/><br/>5<br/>$5 \\times 10^3$<br/>$10^5$<br/><br/><br/>6<br/>$5 \\times 10^3$<br/>$2 \\times 10^5$<br/><br/><br/>7<br/>$5 \\times 10^3$<br/>$2 \\times 10^5$<br/><br/><br/>8<br/>$10^5$<br/>$10^5$<br/><br/><br/>9<br/>$10^5$<br/>$2 \\times 10^5$<br/><br/><br/>10<br/>$10^5$<br/>$2 \\times 10^5$<br/><br/><br/><br/>对于所有数据，满足$1 \\leqslant t \\leqslant 2 \\times 10^5$。<br/>时间限制：$1\\mathrm{s}$<br/>空间限制：$512\\mathrm{MB}$<br/>注意：交互库本身的运行所用时间不会超过$0.1\\mathrm{s}$，所用内存不会多于$32\\mathrm{MB}$。","tags": "Problems","url": "blog/2017-1-3/network.html"},
{"title": "砍木棍问题","text": "砍木棍问题<br/>问题描述<br/>初始时有一根长为 $a$ 的木棍，每次会随机砍掉木棍的一段，问期望多少次后木棍的长度小于 $b$ ？<br/>还有一种离散的版本：初始时有一个数字 $n$，每次可以随机减去一个 $[0, n]$ 内的整数，问期望多少次后变为 $0$ ？<br/>离散版本<br/>首先考虑一下我们可以手算的问题，记 $F(n)$ 表示初始时为 $n$ 的期望次数，不难得到下面的递推式：<br/>$$<br/>\\begin{cases}<br/>F(0) = 0 \\\\<br/>F(n) = {n + 1 \\over n} + \\frac1n\\sum_{k = 0}^{n - 1} F(k) & (n > 0)<br/>\\end{cases}<br/>$$<br/>上面的 $(n + 1) / n$ 是停留在 $n$ 的期望次数，也就是 $\\sum_{k = 0}^\\infty (1/(n + 1))^k$，因为每次都有 $1/(n + 1)$ 的概率不减小。通过差分不难解得：<br/>$$<br/>F(n) = 1 + H_n = 1 + \\ln n + \\mathrm{O}(1)<br/>$$<br/>其中 $H_n$ 表示调和级数。<br/>原始问题<br/>从离散版本中我们可以估计出答案应该是对数级别的。为了解决这个问题，首先将模型转化一下：每次砍掉随机的长度，可以视为随机一个 $X \\in (0, 1)$，将原长度 $a$ 变为 $Xa$，问期望多少次后小于 $b$。假设是 $k$ 次后满足要求，那么可以得到 $k$ 个独立随机变量 $X_1, X_2, ..., X_k$ 与 $a$ 和 $b$ 的关系：<br/>$$<br/>a \\prod_{j = 1}^k X_j < b<br/>$$<br/>也就是：<br/>$$<br/>\\prod_{j = 1}^k X_j < \\frac{b}a<br/>$$<br/>为了方便，令 $n = a / b$，那么上式右边变为 $< 1/n$。现在来考虑左边那个乘积，处理乘积的一个好方法就是取对数，即：<br/>$$<br/>\\ln \\prod_{j=1}^k X_j = \\sum_{j=1}^k \\ln Xj < -\\ln n<br/>$$<br/>不等式两边同时算期望：<br/>$$<br/>\\mathbf{E}\\left[\\sum_{j=1}^k \\ln X_j\\right] = \\sum_{j = 1}^k \\mathbf{E}[\\ln X_j] < - \\ln n<br/>$$<br/>而 $E[\\ln X_j] = \\lim_{y \\rightarrow 0}\\int_y^1 \\ln x \\ \\mathrm{d}x = \\int_{-\\infty}^0 e^x \\ \\mathrm{d}x = -1$，所以可知期望 $\\ln n$ 次后满足不等式。因此原问题的答案就是 $\\ln a/b$。<br/>相关的概率问题<br/>现在来考虑一个扩展的问题：$n$ 个独立随机变量 $X_1, X_2, ..., X_n \\in [0, 1]$ 的乘积 $X = \\prod_{k = 1}^n X_k$ 小于一个常数 $a \\in (0, 1]$ 的概率？<br/>首先考虑一些特殊的情况：<br/><br/>$n = 1$ 时，显然概率就是 $a$。<br/>$n = 2$ 时，设这两个随机变量分别为 $x$ 和 $y$，那么可以看做在以原点为左下角，坐标 $(1, 1)$ 为右上角的正方形中随机投点，问这个点处于 $xy = a$ 的图像（即反比例函数）的左下方的概率。由于这个正方形的面积为 $1$，所以概率就是围出的面积，关于 $x$ 积分，即 $a + \\int_a^1 a / x \\ \\mathrm{d}x = a - a\\ln a$。<br/><br/>当 $n \\geqslant 3$ 时没有那么好想了，但是我们可以考虑一下递推：设 $P(n, a)$ 表示这个概率（可以是关于 $a$ 的函数），仿照 $n = 2$ 的情况，我们要求的是函数 $X = a$ 在超立方体内围出的超体积。设这 $n$ 个变量中的任意一个为 $z$，考虑下面两种情况：<br/><br/>若 $z < a$，那么 $X$ 一定小于 $a$，这种情况发生的概率为 $a$。<br/>若 $z \\geqslant a$，那么 $X < a \\Leftrightarrow X/z < a/z$，注意这里 $a \\leqslant a/z \\leqslant 1$，并且 $X/z$ 是 $n - 1$ 个独立随机变量的乘积。依此，我们可以将问题规模缩减。通过关于 $z$ 求积分，我们可以求出这种情况的概率为 $\\int_a^1 P(n - 1, a/z) \\ \\mathrm{d}z$。<br/><br/>综上所述，我们可以归纳出 $P(n, a)$ 的递推式（假设 $0$ 个元素的乘积为 $1$）：<br/>$$<br/>\\begin{cases}<br/>P(0, a) = 0 \\\\<br/>P(n, a) = a + \\int_a^1 P(n - 1, a / z) \\ \\mathrm{d} z & (n > 0)<br/>\\end{cases}<br/>$$<br/>看上去并不好直接得出 $P(n, a)$ 的表达式，所以我尝试用 Mathematica 算了一下 $n \\leqslant 6$ 的情况1：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9In[1]:= P[0, a_] := 0<br/>        P[n_, a_] := a + Integrate[P[n - 1, a/Subscript[z, n]], {Subscript[z, n], a, 1}, Assumptions -> 0 < a < 1]<br/>        Table[Expand[P[i, a]], {i, 6}]<br/>Out[1]:= {a,<br/>          a - a Log[a],<br/>          a - a Log[a] + 1/2 a Log[a]^2,<br/>          a - a Log[a] + 1/2 a Log[a]^2 - 1/6 a Log[a]^3,<br/>          a - a Log[a] + 1/2 a Log[a]^2 - 1/6 a Log[a]^3 + 1/24 a Log[a]^4,<br/>          a - a Log[a] + 1/2 a Log[a]^2 - 1/6 a Log[a]^3 + 1/24 a Log[a]^4 - 1/120 a Log[a]^5}<br/><br/><br/>Wow! $P(n, a)$ 看上去可以表示成 $a \\cdot Q(\\ln a)$ 的形式，并且 $Q(x)$ 是个多项式。进一步的，我们把这个多项式的系数写出来：<br/>$$<br/>+1, -1, +\\frac12, -\\frac16,+\\frac1{24},-\\frac1{120},...<br/>$$<br/>如果对阶乘比较熟悉，不难发现 $Q(x)$ 中 $x^k$ 的系数就是 $(-1)^k / k!$。于是我们可以猜想：<br/>$$<br/>P(n, a) = a\\sum_{k = 0}^{n - 1} \\frac{(-1)^k}{k!} \\ln^k a \\:\\:\\:\\: (n > 0) \\tag{1}<br/>$$<br/>为了确认这个结论，数学归纳法应该是个比较好的选择：上面已经验证了 $1 \\leqslant n \\leqslant 6$ 的情况。现在假设对于任意的 $1 \\leqslant k \\leqslant n - 1$，$P(k, a)$ 均满足 $(1)$ 式，现在证明 $P(n, a)$ 也满足 $(1)$ 式。首先利用 $P(n, a)$ 的递推式：<br/>$$<br/>\\begin{aligned}<br/>P(n, a) & = a + \\int_a^1 P(n - 1, a / x) \\ \\mathrm{d}x \\\\<br/>& = a + \\int_a^1 \\frac{a}x\\sum_{k = 0}^{n - 2} {(-1)^k \\over k!} \\ln^k \\frac{a}x \\ \\mathrm{d} x \\\\<br/>& = {a + \\sum_{k = 0}^{n - 2} {(-1)^k \\over k!} \\int_a^1 \\frac{a}x\\ln^k \\frac{a}x \\ \\mathrm{d}x \\:\\:\\:\\:\\:\\:\\:\\: (2)}<br/>\\end{aligned}<br/>$$<br/>单独考虑积分：<br/>$$<br/>\\int \\frac{a}x \\ln^k \\frac{a}x \\ \\mathrm{d} x<br/>$$<br/>进行换元：令 $u = \\ln(a/x)$，那么可知 $\\mathrm{d}u = \\mathrm{d}\\ln(a/x) = {\\mathrm{d}(a/x) \\over a/x} = -{\\mathrm{d}x \\over x}$，即 $-x\\mathrm{d} u = \\mathrm{d}x$，所以上述积分为：<br/>$$<br/>\\begin{aligned}<br/>\\int \\frac{a}x \\ln^k \\frac{a}x \\ \\mathrm{d} x & = a\\int\\frac1x u^k (-x \\mathrm{d}u) \\\\<br/>& = -a \\int u^k \\ \\mathrm{d}u \\\\<br/>& = -{au^{k + 1} \\over k + 1} + C \\\\<br/>& = -{a\\ln^{k  + 1} (a/x) \\over k + 1} + C<br/>\\end{aligned}<br/>$$<br/>将结果代回到 $(2)$ 中，得到：<br/>$$<br/>\\begin{aligned}<br/>P(n, a) & = a + \\sum_{k = 0}^{n - 2} {(-1)^k \\over k!} \\left(- {a \\ln^{k + 1} a \\over k + 1}\\right) \\\\<br/>& = a + a\\sum_{k = 0}^{n - 2} {(-1)^{k + 1} \\over (k + 1)!} \\ln^{k  + 1}a \\\\<br/>& = a\\sum_{k = 0}^{n - 1} {(-1)^k \\over k!} \\ln^k a<br/>\\end{aligned}<br/>$$<br/>所以归纳假设成立。$\\blacksquare$<br/>非常有趣的事情是，这个多项式 $Q(x)$ 实际上就是 $\\mathrm{e}^{-x}$ 的前 $n$ 项泰勒展开。这里我们回忆一下：<br/>$$<br/>\\begin{aligned}<br/>\\mathrm{e}^x & = \\sum_{k = 0}^\\infty {x^k \\over k!} \\\\<br/>\\mathrm{e}^{-x} & = \\sum_{k = 0}^\\infty {(-1)^k x^k \\over k!}<br/>\\end{aligned}<br/>$$<br/>又一次与自然常数美妙的邂逅，也难怪它值得配上一个专用符号在各种场合大显身手。<br/><br/><br/><br/><br/>代码里面的定积分的积分变量用的是 Subscript[z, n]，主要原因是 Mathematica 是直接展开函数来计算的，如果使用 z 计算，积分变量会不对，因而出来的结果也会不对。 ↩<br/><br/><br/>","tags": "概率论","url": "blog/2018-3-2/cut-the-stick.html"},
{"title": "秩平衡树(Rank Balanced Tree)","text": "秩平衡树(Rank Balanced Tree)<br/><br/>riteme: “这是并查集和Treap的杂交品种。”<br/>tplink: “贼式二叉树！”<br/>ruanxz: “ZY！”<br/><br/>1 秩<br/>1.1 树的秩高<br/>这里先介绍“秩”的概念。我们定义一棵二叉树的秩为从为从根节点开始到其叶节点中最长的一条树链上结点的个数。<br/>对于空结点$nil$，它的秩为$0$。<br/>$$ nil.\\text{rank} = 0 \\tag{1.1} $$<br/>那么对于任意非空节点$x$，它的秩可以如下定义：<br/>$$ x.\\text{rank} = \\max\\{x.\\text{left}.\\text{rank}, x.\\text{right}.\\text{rank}\\} + 1 \\tag{1.2}$$<br/>树的秩我们使用UPDATE函数来维护：<br/>1<br/>2function UPDATE(h):<br/>    h.rank = max(h.left.rank, h.right.rank) + 1<br/><br/><br/>现在我们来看一棵二叉搜索树。<br/><br/>上图中，a的秩为$1$，e的秩为$2$，c的秩为$3$，根节点j的秩为$6$。<br/>1.2 按秩合并<br/>在并查集的优化方法中有一个是启发式按秩合并。做法是将秩小的树接在秩大的树下面，这样就可以尽可能避免树的高度的暴涨。同样，在秩平衡树中，也要利用到这种思想。<br/>2 旋转<br/>众所周知，二叉搜索树的旋转操作可以保持树的有序性，同时可以通过旋转的组合来实现许多操作。因此我们先实现左旋(LEFT-ROATE)和右旋(RIGHT-ROTATE)。<br/>左旋是将左子树旋转上来顶替自己的位置，右旋类似。<br/>旋转时要确保左子树或右子树不是$nil$。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23function LEFT-ROTATE(h):<br/>    ASSERT h.left != nil<br/><br/>    x = h.left<br/>    h.left = x.right<br/>    x.right = h<br/><br/>    UPDATE(h)<br/>    UPDATE(x)<br/><br/>    return x  // 使用左子树来替代原来的节点<br/><br/>function RIGHT-ROTATE(h):<br/>    ASSERT h.right != nil<br/><br/>    x = h.right<br/>    h.right = x.left<br/>    x.left = h<br/><br/>    UPDATE(h)<br/>    UPDATE(x)<br/><br/>    return x  // 使用右子树来替代原来的节点<br/><br/><br/>例如，要对节点x进行左旋转时，我们这样调用：<br/>1x = LEFT-ROTATE(x)<br/><br/><br/>3 普通秩平衡树<br/><br/>P: 并查集 x Treap<br/>-> F1: “贼式二叉树”<br/><br/>秩平衡树的样子与二叉搜索树并没有什么区别。<br/>普通的秩平衡树的实现非常简单。它将利用秩的信息来使树保持平衡。<br/>3.1 查询<br/>查询中没有对树的形状的修改，因此什么特殊的操作都不要。<br/>故查询操作和普通的二叉搜索树是一样的。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10function QUERY(h, key):<br/>    if h = nil:<br/>        return nil  // 没有查找到<br/><br/>    if key < h.key:<br/>        return QUERY(h.left, key)  // 结果在左子树中<br/>    else if key > h.key:<br/>        return QUERY(h.right, key)  // 结果在右子树中<br/>    else:<br/>        return h  // 命中节点<br/><br/><br/>3.2 平衡<br/>准确的说，这个操作并不能维护平衡，而只是能使树向平衡的方向发展。<br/>进行平衡的依据就是树的秩。当左右子树的秩差距太大，我们就要采取行动来使其减小差距。<br/>首先我们设定一个秩的差距的最大容忍值$t$。这个值是一个正整数，并且值选取的愈小树就会变得愈平衡。当$t=1$时，秩平衡树大多数情况下就是完全平衡的二叉树。<br/>在普通的秩平衡树中，我们一般选定为$1$：<br/>1TOLERANCE = 1<br/><br/><br/>设定这个值的意义在于定义了平衡的触发标准。如果左右子树的秩的差距大于$t$，那么就要减小差距。<br/>减小差距的方法就是将树根通过旋转的方式进入秩较小的子树中，这样使得秩较小的子树的秩增加，秩较大的子树的秩减小。<br/>于是我们得到了一个大致的平衡代码：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10function BALANCE(h):<br/>    if h.left.rank > h.right.rank and<br/>       h.left.rank - h.right.rank > TOLERANCE:   // 左子树的秩过大<br/>        h = LEFT-ROTATE(h)<br/>    else if h.left.rank < h.right.rank and<br/>            h.right.rank - h.left.rank > TOLERANCE:   // 右子树的秩过大<br/>        h = RIGHT-ROTATE(h)<br/><br/>    UPDATE(h)  // 更新节点<br/>    return h  // 返回调整后的节点<br/><br/><br/>实际上，这样还不足够。<br/>考虑下面的情况：<br/><br/>现在我们要平衡b节点。左子树的秩比右子树大。倘若按照上面的方法进行调整，将会得到下面的结果：<br/><br/>呃…你会发现并没有什么变化。<br/>其原因在于左子树的右儿子的秩太大，导致旋转过去之后没有太大效果。<br/>这样导致中间的子树的深度下移一位。加之它本来就秩比较大，如此一来这个平衡就毫无作用。<br/>然而，如果左子树的连个儿子如果秩是一样的，就不会有太大的影响，因为这样就只会导致秩的差距为$1$。倘若右儿子的秩更小，就不会有这样的问题。<br/>为了解决这个问题，我们考虑使左子树右儿子的秩减小，这样就不会因为中间的子树而导致无用的平衡。<br/>首先我们将左子树的右儿子通过右旋上移，这样使得右儿子的秩减小：<br/><br/>然后再进行左旋操作，完成平衡：<br/><br/>这时左右子树的秩的差距就减小了。<br/>同样，对于右子树的平衡操作也是类似的处理方法。这里就不再多说。具体的可以参考实现伪代码。<br/>完整的平衡代码如下：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17function BALANCE(h):<br/>    if h.left.rank > h.right.rank and<br/>       h.left.rank - h.right.rank > TOLERANCE:   // 左子树的秩较大<br/>        if h.left.right.rank > h.left.left.rank:  // 如果左子树的右儿子的秩较大<br/>            h.left = RIGHT-ROTATE(h.left)<br/><br/>        h = LEFT-ROTATE(h)<br/>    else<br/>    if h.left.rank < h.right.rank and<br/>       h.right.rank - h.left.rank > TOLERANCE:   // 右子树的秩较大<br/>        if h.right.left.rank > h.right.right.rank:  // 如果右子树的左儿子的秩较大<br/>            h.right = LEFT-ROTATE(h.right)<br/><br/>        h = RIGHT-ROTATE(h)<br/><br/>    UPDATE(h)  // 更新节点<br/>    return h  // 返回调整后的节点<br/><br/><br/>这个平衡操作运用到了类似于并查集中“路径压缩”的思想。在并查集中可以直接全部接在根节点处，从而极大的提高了效率。但限于二叉树的性质，平衡操作只能使每个节点的秩尽可能的小。<br/>3.3 插入<br/>插入与普通的二叉搜索树差不多，只是在最后回溯的时候维护树的平衡。<br/>因此我们可以很快的写出插入操作：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10function INSERT(h, key):<br/>    if h = nil:<br/>        return new node with key<br/><br/>    if key < h.key:<br/>        h.left = INSERT(h.left, key)<br/>    else if key > h.key:<br/>        h.right = INSERT(h.right, key)<br/><br/>    return BALANCE(h)  // 最后要进行平衡<br/><br/><br/>3.4 删除<br/>与插入类似，删除的代码和二叉搜索树的保持一致，只要最后记得进行平衡即可。<br/>这里我们采用将被删除节点下沉的方法来进行删除：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29<br/>30<br/>31<br/>32<br/>33<br/>34function REAL-REMOVE(h):  // 删除指定的节点<br/>    if h.left != nil and h.right != nil:<br/>        // 如果有两个非空子树就继续下沉<br/>        // 尽量往秩小的子树中下沉，同时将另一棵子树的秩尽量减小<br/>        // 从而达到平衡的目的<br/>        if h.left.rank > h.right.rank:<br/>            h = LEFT-ROTATE(h)<br/>            h.right = REAL-REMOVE(h->right)<br/>        else:<br/>            h = RIGHT-ROTATE(h)<br/>            h.left = REAL-REMOVE(h->left)<br/>    else:<br/>        // 如果只有一个子树，就可以直接删除，将唯一的子树顶替自己的位置<br/>        // 如果没有子树，说明是叶节点，返回nil<br/>        next = nil<br/>        if h.left != nil:<br/>            next = h.left<br/>        else:<br/>            next = h.right<br/><br/>        delete h  // 删除<br/>        return next<br/><br/>    return BALANCE(h)<br/><br/>function REMOVE(h, key):<br/>    if key < h.key:<br/>        h.left = REMOVE(h.left, key)<br/>    else if key > h.key:<br/>        h.right = REMOVE(h.right, key)<br/>    else:<br/>        return REAL-REMOVE(h)  // 找到指定的节点后进行删除<br/><br/>    return BALANCE(h)<br/><br/><br/>3.5 时间复杂度<br/>如果$t$选取得当，秩平衡树将是非常平衡的。因此操作都是$O(\\log n)$的：<br/><br/><br/><br/>操作<br/>时间复杂度<br/><br/><br/><br/><br/>平衡<br/>$\\Theta(1)$<br/><br/><br/>查询<br/>$O(\\log n)$<br/><br/><br/>插入<br/>$O(\\log n)$<br/><br/><br/>删除<br/>$O(\\log n)$<br/><br/><br/><br/>在实际效率上，秩平衡树比Treap略快，与伸展树相比常数稍大一些。在查询操作很多的时候，秩平衡树比较占优势。<br/>4 可合并秩平衡树<br/><br/>F1: “贼式二叉树” x 可持久化Treap<br/>-> F2: “可合并秩平衡树”<br/><br/>如果只是一棵单纯BST，未免太过无聊......<br/>现在各种BST都玩出花出来了，然而在这之中支持区间操作的BST却非常少。据我所知还只有可持久化Treap和伸展树。<br/>那秩平衡树能不能也支持区间操作呢？<br/>一种思路是类似于伸展树的做法：将区间变为开区间，然后将区间的两个端点上浮，然后就可以截取区间了。秩平衡树可以进行上浮，上浮时不考虑树的平衡。当区间用完后，再将上浮的顶点依次下沉，同时维护平衡，这样就可以实现区间操作。<br/>事实上，如果这样进行处理，有着诸多的缺点：<br/><br/>又要增加上浮和下沉操作，并且这两个操作并不简单，代码量急剧增长。  <br/>如果有懒惰标记之类的东西，难以正确处理。  <br/>常数变大，尽管理论上时间复杂度都是$O(\\log n)$。<br/><br/>但是…又不是不能写，毕竟我是写过的，所以我才会知道这些。<br/>这样写出来的秩平衡树能比可持久化Treap快，但与伸展树相比差距较大。<br/>另一种思路就是类似于可持久化Treap的做法：将树从第$k$小的位置拆开，然后又合并......<br/>可合并秩平衡树就是这种做法。<br/>接下来我们会继续用到秩平衡树的BALANCE操作，同时将增加两个基本操作：SPLIT和MERGE，表示拆分和合并。以及一个辅助操作RANK1来查找第$k$小的节点，这样我们就可以利用这些操作来实现各种各样的操作。<br/>4.1 拆分<br/>拆分操作是将树从第$k$小的节点处拆成$[1, k]$和$[k+1, n]$的两棵子树。<br/>因为需要计算排名，所以每个节点都要记录一个$\\text{size}$，表示子树中节点的个数，即子树的大小。同样，空节点的大小为$0$：<br/>$$ nil.\\text{size} = 0 \\tag{4.1} $$<br/>对于每个节点$x$，它的大小定义如下：<br/>$$ x.\\text{size} = x.\\text{left}.\\text{size} + x.\\text{right}.\\text{size} + 1 \\tag{4.2} $$<br/>此时我们将在UPDATE函数中维护树的大小：<br/>1<br/>2<br/>3function UPDATE(h):<br/>    h.size = h.left.size + h.right.size + 1<br/>    h.rank = max(h.left.rank, h.right.rank) + 1<br/><br/><br/>拆分操作时先沿着寻找第$k$小的树链不断的将树切开，然后在回溯的时候进行拼装。这是一个递归的过程。<br/>假设我们在对子树$x$进行拆分，我们考虑下面两种情况：<br/><br/>如果$k \\le x.\\text{left}.\\text{size}$，那么说明第$k$小的节点在左子树中，因此只需要将左子树拆开，拆开后的左边是$[1, k]$的子树，右边是大于$k$的子树。  <br/>如果$k \\ge x.\\text{left}.\\text{size}$，那么说明左子树完全小于$k$，子树的根必定不大于$k$，因此可以确定左子树和树根都在$[1,k]$的范围内。但我们不确定右子树中是否有在这个范围内的。如果有，则它在右子树中的排名为$k-x.\\text{left}.\\text{size} - 1$，因此我们将右子树按照这个值进行拆分，那么拆开的左边属于$[1,k]$。<br/><br/>这个过程非常简单，代码实现也是如此：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16function SPLIT(h, k):<br/>    if h = nil:<br/>        return (nil, nil)  // 如果是空树，那么不需要拆分<br/><br/>    if k <= h.left.size:  // 情况1<br/>        a, b = SPLIT(h.left, k)  // 拆分左子树<br/>        h.left = b               // b不属于[1, k]<br/>        UPDATE(h)<br/><br/>        return (a, h)<br/>    else:                 // 情况2<br/>        a, b = SPLIT(h.right, k - h.left.size - 1)  // 拆分右子树<br/>        h.right = a                                 // a属于[1, k]<br/>        UPDATE(h)<br/><br/>        return (h, b)<br/><br/><br/>4.2 合并<br/>之前我们把树给拆开了，用完了当然还要还回去，因此我们必然需要合并操作。<br/>同时我们注意到，拆分时我们并没有维护平衡，因此平衡的重任就交给了合并。<br/>进行合并时，我们必须保证合并的左子树必须完全小于合并的右子树，即左子树的最大值必须小于右子树的最小值。<br/>合并时要遵循按秩合并的思想，始终选取秩较大的子树作为树根。然后将另一棵子树与树根的对应儿子继续进行合并。<br/>这是一个递归向下的过程。在回溯的时候，使用BALANCE操作进行平衡。<br/>如果我们在合并两棵子树$a$和$b$，其中$a$完全小于$b$。由于二叉搜索树的有序性，合并只会出现两种情况：<br/><br/>$a$作为树根，$a.\\text{right}$与$b$继续合并。  <br/>$b$作为树根，$a$和$b.\\text{left}$继续合并。<br/><br/>作为特例，如果$a$和$b$中有一个是空树，那么就没有必要合并了。<br/>合并的伪代码如下：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17function MERGE(a, b):<br/>    if a = nil:<br/>        return b<br/>    if b = nil:<br/>        return a<br/><br/>    ASSERT max(a) < min(b)  // a < b<br/>    if a.rank > b.rank:  // 按秩合并<br/>        a.right = MERGE(a.right, b)<br/>        UPDATE(a)<br/><br/>        return BALANCE(a)  // 最后进行平衡<br/>    else:<br/>        b.left = MERGE(a, b.left)<br/>        UPDATE(b)<br/><br/>        return BALANCE(b)<br/><br/><br/>4.3 排名<br/>由于SPLIT操作需要排名$k$，而一般的调用是给定节点的键，因此我们需要一个能将节点在树中的排名计算出来的算法。<br/>因此RANK操作也成为了非常重要的操作之一。<br/>利用节点储存的子树大小值，我们可以快速算出一个节点的排名。<br/>这个操作也是一个递归操作的过程：<br/><br/>如果指定的节点在左子树，我们直接在左子树中继续查询。  <br/>如果指定的节点在右子树，我们查询它在右子树中的排名，然后加上左子树和树根的大小。  <br/>如果直接命中，那么直接计算排名，其排名为左子树的大小加$1$。  <br/>对于没有命中的空节点，排名的意义在于查询一个新节点插入树后的排名。为此，对于空节点，我们视为它的排名为$1$。<br/><br/>根据上面的讨论，我们可以写出查询排名的操作：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10function RANK(h, key):<br/>    if h = nil:<br/>        return 1<br/><br/>    if key < h.key:<br/>        return RANK(h.left, key)<br/>    else if key > h.key:<br/>        return RANK(h.right, key) + h.left.size + 1<br/>    else:<br/>        return h.left.size + 1<br/><br/><br/>当然，我们希望这个操作越快越好。现代绝大部分的语言的编译器/解释器…都能够对尾递归进行优化。上面的RANK操作可以被我们改为尾递归，从而充分利用优化的优势：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10function RANK(h, key, offest = 0):  // 利用offest进行尾递归优化<br/>    if h = nil:<br/>        return 1 + offest<br/><br/>    if key < h.key:<br/>        return RANK(h.left, key, offest)<br/>    else if key > h.key:<br/>        return RANK(h.right, key, offest + h.left.size + 1)<br/>    else:<br/>        return h.left.size + 1 + offest<br/><br/><br/>如果没有优化，也没有关系，因为能尾递归的函数，基本上都可以写成迭代的形式：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13function RANK(h, key):<br/>    offest = 0<br/><br/>    while h != nil:                          // 向左走<br/>        if key < h.key:<br/>            h = h.left<br/>        else if key > h.key:                 // 向右走<br/>            offest += h.left.size + 1<br/>            h = h.right<br/>        else:<br/>            return h.left.size + 1 + offest  // 直接命中<br/><br/>    return offest + 1  // 最后没有命中<br/><br/><br/>4.4 时间复杂度<br/>显然时间复杂度是我们最关心的。通过BALANCE操作，秩平衡树在合并过程中能够维持很好的平衡。<br/>因此对于所有的操作，递归深度不会超过$O(\\log n)$。因此时间复杂度都是$O(\\log n)$的。<br/><br/><br/><br/>操作<br/>时间复杂度<br/><br/><br/><br/><br/>拆分<br/>$O(\\log n)$<br/><br/><br/>合并<br/>$O(\\log n)$<br/><br/><br/>排名<br/>$O(\\log n)$<br/><br/><br/><br/>4.5 衍生操作<br/>有了SPLIT、MERGE和RANK三大利器，我们就可以随心所欲的进行各种操作了。下面将对一些操作进行说明，大家可以在此基础上开发更多操作。<br/>4.5.1 查询<br/>这个实际上没有必要动用拆分和合并，直接查就好。<br/>4.5.2 插入<br/>设要插入的节点的排名为$k$，那么先将树拆分为$[1, k-1]$和$[k, n]$两部分，然后依次合并。<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7function INSERT(h, key):<br/>    x = new node with key<br/><br/>    k = RANK(h, key)<br/>    a, b = SPLIT(h, k - 1)<br/><br/>    return MERGE(MERGE(a, x), b)<br/><br/><br/>4.5.3 删除<br/>设要删除的节点的排名为$k$，那么将树拆分为$[1,k-1]$、$[k+1,n]$和被删除的节点三部分，然后只将左右合并即可。<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8function REMOVE(h, key):<br/>    k = RANK(h, key)<br/>    a1, a2 = SPLIT(h, k - 1)<br/>    b1, b2 = SPLIT(a2, 1)<br/><br/>    delete b1  // 删除节点<br/><br/>    return MERGE(a1, b2)<br/><br/><br/>4.5.4 第k小<br/>直接拆就好了。<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6function KTH(h, k):<br/>    a1, a2 = SPLIT(h, k - 1)<br/>    b1, b2 = SPLIT(a2, 1)<br/><br/>    MERGE(a1, MERGE(b1, b2))<br/>    return b1<br/><br/><br/>4.5.5 截取区间<br/>这才是区间操作的关键吧…<br/>但是我们只要拆拆合合就搞定了…<br/>最后要记得合并就好了。<br/>1<br/>2<br/>3<br/>4<br/>5function SLICE(h, left, right):<br/>    a1, a2 = SPLIT(h, left - 1)<br/>    b1, b2 = SPLIT(a2, right - left + 1)<br/><br/>    return b1<br/><br/><br/>4.6 总结<br/>在实际的测试中，秩平衡树的表现非常不错，比可持久化Treap快了很多，并且在区间操作上能和伸展树不相上下。<br/>但是，与可持久化Treap相比，因为依赖于BALANCE操作，所以就无法进行可持久化了。<br/>最后我们重新来考虑$t$这个容忍值的选取。在之前普通的秩平衡树中，我们认为$1$是最好的。而现在就未必。如果数据完全随机，我们其实并不需要平衡。但这样在极端数据的情况下，不平衡容易退化为一条链。但是过多的平衡会影响常数。因此，$t$可以稍微取大一点，但不能太大。一般情况下，最好选择$2$到$6$中的值。<br/><br/><br/><br/><br/>这里的英文解释为“排名”，不是秩。 ↩<br/><br/><br/>","tags": "数据结构 平衡二叉树 Rank-Tree Treap Splay 并查集 贼爷我真的错了","url": "blog/2016-4-10/rank-tree.html"},
{"title": "空袭","text": "空袭 (airstrike.c/cpp)<br/>时间限制：N/A / 内存限制：1024 MB / 打开-O2优化 / 支持C11\\C++11<br/>题目描述<br/>这是一道交互题。<br/>注意本交互库不提供Pascal支持。只支持C\\C++。<br/>统计学家Lunk所居住的城市遭到的软斯兰国的空袭，弄得Lunk心神不定。<br/>然而伟大的统计学家怎么会就因为空袭而四处避难呢？Lunk决定弄出个大新闻。<br/>由于各种原因，Lunk所居住的城市的市区的形状十分奇怪。Lunk将其大致的轮廓画在地图上，形成了一个多边形的形状。软斯兰国的飞机每丢下一枚炸弹，Lunk就会马上观测到炸弹的位置，并将其画在地图上。但是，他所想要统计的只是智障的软斯兰国有多少枚炸弹攻击到了市区。<br/>于是Lunk放弃了在地图上画下每一个炸弹的位置，而是转而在地下室里直接统计。<br/>现在它所需要的就是一个能帮他统计的程序。他希望能在你们写的程序中选出一个精确度高并且跑得比香港记者还快的程序来帮助它完成这个任务。<br/>我该如何编写这个程序<br/>选手目录下将会下发interface.h这个文件。<br/>你需要实现interface.h中的接口。<br/>你需要在同一目录下新建一个文件airstrike.cpp，其中包含以下内容：<br/>1<br/>2<br/>3#include \ interface.h\ <br/><br/>// 实现部分<br/><br/><br/>你需要实现的接口在头文件中有简要说明。这里做详细说明。<br/>1void initialize(const double *x, const double *y, const size_t n, const int id);<br/><br/><br/>是载入程序的入口。在进行查询之前，会调用这个函数。<br/>载入所用的时间不会计入你的程序用时。但是载入时间不能超过$3\\text{s}$。<br/>x和y是两个数组，给出的是市区的轮廓，即Lunk绘制的多边形的顶点，按照逆时针顺序给出。<br/>n是多边形的顶点数量。<br/>id是当前数据点的标号，在下文会有解释。<br/>1bool query(const double dx, const double dy);<br/><br/><br/>是Lunk的操作，每次调用即查询炸弹是否炸在市区内。如果炸在市区内则返回true，否则返回false。<br/>dx和dy是炸弹炸到的坐标。<br/>该函数的用时会被计入程序用时。<br/>1void finalize();<br/><br/><br/>是结束程序。这个函数将在所有查询任务完成后调用。<br/>用于释放你的程序所用的资源。<br/>该函数的用时不会计入程序用时，但是其运行时间不能超过$3\\text{s}$。<br/>注意，请不要使用delete[]删除掉之前initialize参数中给你的顶点数组，否则后果自负。<br/>我该如何测试这个程序<br/>选手目录下将会下发main.cpp这个文件。<br/>首先你需要有输入的数据，其格式将在下文给出。<br/>假设你的程序文件是airstrike.cpp，那么使用以下命令来编译：<br/>1g++ main.cpp airstrike.cpp -std=c++11 -o main<br/><br/><br/>或者你需要调试：<br/>1g++ main.cpp airstrike.cpp -std=c++11 -o main -g<br/><br/><br/>打开-O2优化：<br/>1g++ main.cpp airstrike.cpp -std=c++11 -o main -O2<br/><br/><br/>对于C语言，将main.cpp改名为main.c，使用gcc，并且将-std=c++11改为-std=c11即可。<br/>然后使用：<br/>1./main<br/><br/><br/>来运行程序。<br/>如果需要使用文件输入输出，你可以使用管道，也可以修改main.cpp，将其中的两行带有注释的freopen取消注释，然后重新编译即可。<br/>注意，该程序不会测试你的用时并给你评分。并且与最终评测时的运行程序不同。<br/>输入格式<br/>此处的输入格式是根据上面的测试程序所说的。<br/>第一行输入两个整数$n$和$d$，表示顶点数量和数据编号。<br/>下面$n$行描述市区，每一行给出一个整点$(x,\\;y)$，表示一个顶点。<br/>之后给出若干行，一直到文件尾，每行给出一个整点$(x_q,\\;y_q)$，表示炸弹的位置。<br/>输出格式<br/>对于每一个Lunk的询问，输出对应的信息 (YES或NO)。<br/>样例输入1<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>93 1<br/>0 0<br/>6 1<br/>8 7<br/><br/>6 5<br/>2 7<br/>8 1<br/>3 1<br/><br/><br/>样例输出1<br/>1<br/>2<br/>3<br/>4YES<br/>NO<br/>NO<br/>YES<br/><br/><br/>样例解释1<br/>样例输入1如下图所示：<br/><br/>样例输入2<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>157 1<br/>1 1<br/>7 1<br/>4 2<br/>3 4<br/>7 5<br/>5 6<br/>1 6<br/><br/>0 4<br/>2 4<br/>4 4<br/>5 3<br/>5 5<br/>3 1<br/><br/><br/>样例输出2<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6NO<br/>YES<br/>NO<br/>NO<br/>YES<br/>YES<br/><br/><br/>样例解释2<br/>样例输入2如下图所示：<br/><br/>数据限制<br/>共$7$个数据测试点，限制如下：<br/><br/><br/><br/>数据编号<br/>$n$的规模<br/>特殊限制<br/><br/><br/><br/><br/>$1$<br/>$\\le 10$<br/>无<br/><br/><br/>$2$<br/>$\\le 10^3$<br/>无<br/><br/><br/>$3$<br/>$\\le 10^5$<br/>无<br/><br/><br/>$4$<br/>$\\le 2 \\times 10^5$<br/>无<br/><br/><br/>$5$<br/>$\\le 10^6$<br/>左右的边与$y$轴平行，下边与$x$轴平行，上边顶点$x$递增，均高于下边，输入数据从左下角开始。<br/><br/><br/>$6$<br/>$\\le 10^6$<br/>凸多边形<br/><br/><br/>$7$<br/>$\\le 10^3$<br/>$0 \\le x,\\;y \\le 10^3$<br/><br/><br/><br/>对于$100\\% $的数据，满足$3 \\le n \\le 10^6,\\;|x|,\\;|y|,\\;|x_q|,\\;|y_q| \\le 10^9$。<br/>顶点按照逆时针顺序输入，没有两个顶点一样，并且为简单多边形。<br/>评分标准<br/>对于不同的数据点，分值和时间限制如下表所示：<br/><br/><br/><br/>数据编号<br/>分值<br/>时间限制<br/><br/><br/><br/><br/>$1$<br/>$5$<br/>$0.1\\text{s}$<br/><br/><br/>$2$<br/>$10$<br/>$1\\text{s}$<br/><br/><br/>$3$<br/>$15$<br/>$1\\text{s}$<br/><br/><br/>$4$<br/>$30$<br/>$1\\text{s}$<br/><br/><br/>$5$<br/>$10$<br/>$1\\text{s}$<br/><br/><br/>$6$<br/>$15$<br/>$1\\text{s}$<br/><br/><br/>$7$<br/>$15$<br/>$1\\text{s}$<br/><br/><br/><br/>在时间限制内，如果程序不出意外 (如运行时错误)，将会不断的给出询问。设你的程序完成的询问个数为$x$。对于每一个点的评分标准如下：<br/><br/><br/><br/>数据编号<br/>$20\\% $<br/>$40\\% $<br/>$60\\% $<br/>$80\\% $<br/>$100\\% $<br/><br/><br/><br/><br/>$1$<br/>$\\ge 10^5$<br/>$\\ge 2\\times 10^5$<br/>$\\ge 3 \\times 10^5$<br/>$\\ge 4 \\times 10^5$<br/>$\\ge 5 \\times 10^5$<br/><br/><br/>$2$<br/>$\\ge 5 \\times 10^4$<br/>$\\ge 10^5$<br/>$\\ge 2 \\times 10^6$<br/>$\\ge 3 \\times 10^6$<br/>$\\ge 4 \\times 10^6$<br/><br/><br/>$3$<br/>$\\ge 5 \\times 10^2$<br/>$\\ge 10^3$<br/>$\\ge 2 \\times 10^5$<br/>$\\ge 4 \\times 10^5$<br/>$\\ge  5 \\times 10^5$<br/><br/><br/>$4$<br/>$\\ge 10^3$<br/>$\\ge 1 \\times 10^5$<br/>$\\ge 2 \\times 10^5$<br/>$\\ge 3 \\times 10^5$<br/>$\\ge 4 \\times 10^5$<br/><br/><br/>$5$<br/>$\\ge 10^3$<br/>$\\ge 8 \\times 10^5$<br/>$\\ge 10^6$<br/>$\\ge 1.2 \\times 10^6$<br/>$\\ge 1.4 \\times 10^6$<br/><br/><br/>$6$<br/>$\\ge 5 \\times 10^2$<br/>$\\ge 8 \\times 10^5$<br/>$\\ge 10^6$<br/>$\\ge 1.2 \\times 10^6$<br/>$\\ge 1.4 \\times 10^6$<br/><br/><br/>$7$<br/>$\\ge 10^6$<br/>$\\ge 2 \\times 10^6$<br/>$\\ge 3 \\times 10^6$<br/>$\\ge 4 \\times 10^6$<br/>$\\ge 10^7$<br/><br/><br/><br/>你的$x$需要达到对应的要求才能得到对应的百分比。评测程序将选取你能达到的最高的百分比。<br/>其中百分比是将该点总分乘上该百分比并向下取整，作为你该点的分数。<br/>如果询问回答错误，将每回答错误一次扣除$1$分，扣分到$0$分为止，分数不会变为负数。<br/>如果发生运行时错误，或者运行严重超时，将导致该点得$0$分。<br/>如果你的initialize或finalize超时，该点得$0$分。<br/>关于评测机<br/>出于一些原因，GCC编译出来的评测器并不是很稳定，可能出现成绩波动的情况，所以评测时最好采用Clang进行编译，得到的结果会稳定一些。<br/>如果你对你的算法十分自信，然而在评测时却没有得到满分，可以进行重测。<br/>温馨提示<br/>评测时限很长，请不要恶意卡评测，谢谢合作！<br/>后记<br/>Lunk的孙子Lnk完成了这个大新闻。<br/>无奖竞猜：Lnk是谁？<br/><br/>第一次出交互题，祝你们早日AC这个智障题！QAQ<br/>","tags": "Problems","url": "blog/2016-8-25/airstrike.html"},
{"title": "编译并使用bgfx","text": "编译并使用bgfx<br/>最近发现了一个似乎很好的图形引擎bgfx。<br/>它是使用C++进行编写的，也有C99的接口，功能还比较丰富，支持DirectX 9/11和OpenGL 2.1+。<br/>这是一个跨平台的库，我在Ubuntu 14.04上编译了成功了。<br/>编译过程十分简单。本文就介绍Linux下的编译过程。<br/>编译<br/>这里我只写了Linux的编译过程，其他平台我还没试过，具体参见bgfx’s document。<br/>首先需要编译器支持，确保你的编译器满足下列要求：<br/><br/>Clang 3.3及以上  <br/>GCC 4.6及以上<br/><br/>同时准备依赖库：<br/>1sudo apt-get install libgl1-mesa-dev x11proto-core-dev libx11-dev<br/><br/><br/>然后从GitHub上下载源码。因为bgfx依赖于bx，因此我们还要下载bx：<br/>1<br/>2<br/>3<br/>4cd ~/Downloads  # 下载到Downloads目录<br/>git clone git://github.com/bkaradzic/bx.git<br/>git clone git://github.com/bkaradzic/bgfx.git<br/>cd bgfx  # 进入源码目录，准备编译<br/><br/><br/>使用make生成工程：<br/>1make<br/><br/><br/>接下来进行编译：<br/>1make linux-release64<br/><br/><br/>提示<br/>使用make还可以生成其他版本的，其格式是：<br/><br/>wzxhzdk:4<br/><br/>例如，如果要生成32位的bgfx，使用以下命令：<br/><br/>wzxhzdk:5<br/><br/><br/>如果编译过程中没有报错，那么在.build/文件夹下会有对应的编译后的文件。<br/>运行样例<br/>bgfx提供了很多样例，编译后的样例在.build/对应的文件夹下(我的就在.build/linux64_gcc/bin/下），在目前bgfx没有什么教程的情况下是很好的学习资料。<br/>由于样例需要很多资源文件（如着色器、材质之类的），而它们都在exmaples/runtime目录下，<br/>因此需要在exmaples/runtime目录下用相对路径来运行。<br/>首先我们切换到样例的目录。对我而言，使用以下命令：<br/>1cd .build/linux64_gcc/bin/<br/><br/><br/>如果你编译的是32位，将上面的64改成32即可。<br/>然后使用ls命令查看样例，可以看到目前有28个样例（包括Hello, world!）：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17example-00-helloworldRelease         example-17-drawstressRelease<br/>example-01-cubesRelease              example-18-iblRelease<br/>example-02-metaballsRelease          example-19-oitRelease<br/>example-03-raymarchRelease           example-20-nanovgRelease<br/>example-04-meshRelease               example-21-deferredRelease<br/>example-05-instancingRelease         example-22-windowsRelease<br/>example-06-bumpRelease               example-23-vectordisplayRelease<br/>example-07-callbackRelease           example-24-nbodyRelease<br/>example-08-updateRelease             example-25-c99Release<br/>example-09-hdrRelease                example-26-occlusionRelease<br/>example-10-fontRelease               example-27-terrainRelease<br/>example-11-fontsdfRelease            geometrycRelease<br/>example-12-lodRelease                libbgfxRelease.a<br/>example-13-stencilRelease            libbgfx-shared-libRelease.so<br/>example-14-shadowvolumesRelease      libexample-commonRelease.a<br/>example-15-shadowmaps-simpleRelease  shadercRelease<br/>example-16-shadowmapsRelease         texturecRelease<br/><br/><br/>可以看到每个样例都十分具有代表性，今后的学习就从它们开始。<br/>同时注意到，有两个.a的静态库和一个.so的动态库，我们可以用它们来编译程序。<br/>然而并不是在这里运行样例，我们要回到runtime目录来运行：<br/>1cd ../../../examples/runtime<br/><br/><br/>假如要运行00-helloworld，使用以下命令：<br/>1../../.build/linux64_gcc/bin/example-00-helloworldRelease<br/><br/><br/>如果不出意外，能看到以下窗口（图片来自bgfx document）：<br/><br/>bgfx的文档也给出了样例的列表。<br/>编译我们自己的bgfx程序<br/>为了通用性，这里使用最基础的终端编译的方法，我们直接用g++进行编译。<br/>首先，我们创建一个目录来存放我们的程序：<br/>1<br/>2mkdir my-first-bgfx<br/>cd my-first-bgfx<br/><br/><br/>然后将bgfx的静态库复制过来：<br/>1cp [bgfx的目录]/.build/linux64_gcc/bin/*.a .<br/><br/><br/>这时目录下会多出两个.a文件： libbgfxRelease.a和libexample-commonRelease.a<br/>静态库 vs 动态库<br/>我们在这里选用了静态库，而不是动态库，是考虑了用户的原因。<br/>因为bgfx没有什么很方便的安装方法，使用静态库就可以避免安装的过程，尽可能少的对用户的系统进行修改。<br/>当然，使用静态库会增大程序体积。静态链接后，我们的bgfx程序会有3MB多…<br/><br/>然后需要将bgfx及其依赖库的bx的头文件给复制进来。为了方便，我们还将bgfx用于样例的common库也复制进来：<br/>1<br/>2<br/>3cp -rf [bgfx的目录]/include/* .         # bgfx<br/>cp -rf [bgfx的目录]/examples/common/ .  # bgfx-common<br/>cp -rf [bx的目录]/include/* .           # bx<br/><br/><br/>下面我们来照着bgfx的hello, world来写第一个程序。我们将会在窗口的左上角打出Hello, world!的字样：<br/>创建程序main.cpp：<br/>1<br/>2touch main.cpp<br/>[使用你的编辑器] main.cpp<br/><br/><br/>首先添加头文件：<br/>1<br/>2<br/>3<br/>4#include <cstdint>  // uint32_t<br/><br/>#include \ bgfx/bgfx.h\       // bgfx<br/>#include \ common/common.h\   // bgfx-common<br/><br/><br/>然后添加_main_函数。注意之所以是_main_而不是main，是因为bgfx的common库为了更好的处理以已经将main实现了，<br/>于是设置_main_作为程序入口。<br/>1<br/>2<br/>3int _main_(int argc, char *argv[]) {<br/>    /* 代码 */<br/>}<br/><br/><br/>在_main_函数内，我们先做一些设定：<br/>1<br/>2<br/>3<br/>4uint32_t width  = 1280;              // 窗口宽度<br/>uint32_t height = 720;               // 窗口高度<br/>uint32_t debug  = BGFX_DEBUG_TEXT;   // debug模式开启，可以直接在窗口输出文字<br/>uint32_t reset  = BGFX_RESET_VSYNC;  // 设置垂直同步<br/><br/><br/>注意<br/>似乎width和height的设置是没有用的，似乎无论设为多少，打开后都会变成1280x720，我也不知道是为什么...<br/>如果你也出现了这种情况，不要惊慌，不要害怕...<br/><br/>下面是加载bgfx：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10bgfx::init();                             // 载入<br/>bgfx::reset(width, height, reset);        // 设置<br/>bgfx::setDebug(debug);                    // 启用调试<br/>bgfx::setViewClear(                       // 设置清空的状态<br/>    0,                                    // bgfx中有View的概念，默认情况下是View 0<br/>    BGFX_CLEAR_COLOR | BGFX_CLEAR_DEPTH,  // 表示要清空颜色缓冲和深度缓冲<br/>    0xFFFFFFFF,                           // 颜色缓冲的清空值，0xFFFFFFFF是白色<br/>    1.0f,                                 // 深度缓冲的清空值，默认为1.0f<br/>    0                                     // 模板缓冲的清空值，默认为0<br/>);<br/><br/><br/>接下来就是渲染了，我们使用一个循环同时处理事件和渲染：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15// entry::processEvents是common库一个很方便的函数<br/>// 它能帮我们处理几乎所有的窗口事件。<br/>// 如果窗口大小有变化，width和height的值就会变化<br/>// 如果窗口被关闭，就会返回true<br/>while (not entry::processEvents(width, height, debug, reset)) {<br/>    bgfx::setViewRect(0, 0, 0, width, height);  // 由于窗口大小会变化，因此这里要重新设置<br/><br/>    bgfx::touch(0);  // 切换到View 0<br/><br/>    bgfx::dbgTextClear();                                                      // 清空调试输出的文字<br/>    bgfx::dbgTextPrintf(0, 0, 0x4F, \ Hello, world!\ );                          // 打印\ Hello, world!\ <br/>    bgfx::dbgTextPrintf(0, 1, 0x4F, \ width = % d, height = % d\ , width, height); // 输出窗口大小<br/><br/>    bgfx::frame();  // 提交所有的渲染操作，准备切换到下一帧<br/>}<br/><br/><br/>注意<br/>在函数bgfx::dbgTextPrintf中，第三个参数是设置文字的前景色和背景色。<br/>其中，bgfx用0-F作为颜色的标记。在上面两位的十六进制数中，第一个指定背景色，第二个制定前景色。<br/>这里将这些颜色标记列出来：<br/>0: 无色<br/>1: 暗红色  2: 暗绿色  3: 黄色，<br/>4: 蓝色，  5: 紫色，  6: 深蓝色<br/>7: 灰色，  8: 深灰色  9: 红色，<br/>A: 嫩绿色  B: 米黄色  C: 浅蓝色<br/>D: 浅紫色  E: 天蓝色  F: 白色<br/><br/>最后，当窗口关闭时，entry::processEvents就会返回true，于是退出循环，最后要退出bgfx：<br/>1bgfx::shutdown();<br/><br/><br/>现在来编译main.cpp：<br/>1g++ -std=c++11 main.cpp -o exec -L. -lbgfxRelease -lexample-commonRelease -lpthread -lGL -lX11<br/><br/><br/>注意编译器要打开C++11支持，如果你的编译器不支持C++11，那我很好奇你是怎么把bgfx编译成功的。<br/>-lpthread、-lGL和-lX11是bgfx依赖的库，分别是POSIX线程库、OpenGL库和X11库。<br/>如果没有错误报出，运行exec就能看到以下窗口：<br/>1./exec<br/><br/><br/><br/>如果你出现了什么意外，下面贴出了完整的程序用于对照：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29<br/>30<br/>31<br/>32<br/>33<br/>34<br/>35<br/>36#include <cstdint>  // uint32_t<br/><br/>#include \ bgfx/bgfx.h\ <br/>#include \ common/common.h\ <br/><br/>int _main_(int argc, char *argv[]) {<br/>    uint32_t width = 1280;<br/>    uint32_t height = 720;<br/>    uint32_t debug = BGFX_DEBUG_TEXT;<br/>    uint32_t reset = BGFX_RESET_VSYNC;<br/><br/>    bgfx::init();<br/>    bgfx::reset(width, height, reset);<br/>    bgfx::setDebug(debug);<br/>    bgfx::setViewClear(<br/>        0,<br/>        BGFX_CLEAR_COLOR | BGFX_CLEAR_DEPTH,<br/>        0xFFFFFFFF,<br/>        1.0f,<br/>        0<br/>    );<br/><br/>    while (not entry::processEvents(width, height, debug, reset)) {<br/>        bgfx::setViewRect(0, 0, 0, width, height);<br/><br/>        bgfx::touch(0);<br/><br/>        bgfx::dbgTextClear();<br/>        bgfx::dbgTextPrintf(0, 0, 0x4F, \ Hello, world!\ );<br/>        bgfx::dbgTextPrintf(0, 1, 0x4F, \ width = % d, height = % d\ , width, height);<br/><br/>        bgfx::frame();<br/>    }<br/><br/>    bgfx::shutdown();<br/>}<br/><br/><br/>至此，我们的第一个bgfx程序就完成了。解决了编译的问题，就可以继续学习使用bgfx了。","tags": "C/C++ 图形 引擎 bgfx","url": "blog/2016-2-3/learn-bgfx-1.html"},
{"title": "莫比乌斯反演","text": "莫比乌斯反演<br/><br/>我把《组合数学》抄了一遍，免得我记不住......<br/><br/>偏序集<br/>这里的莫比乌斯反演是从关联代数的角度来介绍的。首先介绍一个基础的概念：偏序集。<br/>它通常写作$(X_n,\\;\\leqslant)$，其中$X_n$是一个有限或者无限的集合，$\\leqslant$是代指偏序关系，而不是特指小于等于符号。<br/>所谓偏序关系，就是指$a,\\;b,\\;c \\in X_n$并且$a \\leqslant b,\\;b \\leqslant c$，有$a \\leqslant c$的性质的关系。<br/>这种偏序关系一般是比较符$\\leqslant$、集合的$\\subseteq$符号和整除$\\;\\mid\\;$。<br/>卷积<br/>对于定义在偏序集$(X_n,\\;\\leqslant)$上的二元函数$f(x,\\;y)$，我们假定当$x \\not\\leqslant y$时，$f(x,\\;y)$均为$0$，这样是为了方便我们之后的讨论。<br/>考虑偏序集$(X_n, \\leqslant)$上的二元函数$f(x,\\;y)$和$g(x,\\;y)$，定义它们的卷积为：<br/>$$<br/>(f \\times g)(x,\\;y) = \\sum_{x \\leqslant z \\leqslant y} f(x,\\;z)g(z,\\;y) \\tag{2.1}<br/>$$<br/>这个卷积满足结合律：<br/>$$<br/>(f \\times g) \\times h = f \\times (g \\times h) \\tag{2.2}<br/>$$<br/>注意，这个卷积不一定1满足交换律。<br/>以及三种强行定义的莫名其妙的函数：<br/>$\\delta$ (delta) 函数：<br/>$$<br/>\\delta(x,\\;y) = [x = y] \\tag{2.3}<br/>$$<br/>任意函数卷$\\delta$函数均会得到原函数。<br/>$\\zeta$ (zeta) 函数：<br/>$$<br/>\\zeta(x,\\;y) = [x \\leqslant y] \\tag{2.4}<br/>$$<br/>以及莫比乌斯$\\mu$函数是定义为$\\zeta$函数的逆函数，即：<br/>$$<br/>\\mu \\times \\zeta = \\zeta \\times \\mu = \\delta \\tag{2.5}<br/>$$<br/>展开卷积可得：<br/>$$<br/>\\begin{aligned}<br/>\\delta = \\mu \\times \\zeta \\Longrightarrow \\delta(x,\\;y) & = \\sum_{x \\leqslant z \\leqslant y} \\mu(x,\\;z)\\zeta(z,\\;y) \\\\<br/>& = \\sum_{x \\leqslant z \\leqslant y} \\mu(x,\\;z)<br/>\\end{aligned}<br/>$$<br/>因此，当$x \\neq y$时：<br/>$$<br/>\\mu(x,\\;y) = - \\sum_{x \\leqslant z \\lt y} \\mu(x,\\;z) \\tag{2.6}<br/>$$<br/>莫比乌斯反演公式<br/><br/>(莫比乌斯反演公式)<br/>对于有限偏序集$(X_n,\\;\\leqslant)$上的两个函数$F(x,\\;y)$和$G(x,\\;y)$，如果：<br/>$$ G(x,\\;y) = \\sum_{x \\leqslant z \\leqslant y} F(x,\\;z) \\tag{3.1}$$<br/>那么：<br/>$$F(x,\\;y) = \\sum_{x \\leqslant z \\leqslant y} G(x,\\;z)\\mu(z,\\;y)  = (G \\times \\mu)(x,\\;y) \\tag{3.2}$$<br/><br/>证明 首先将式子展开：<br/>$$<br/>\\begin{aligned}<br/>F(x,\\;y) & = \\sum_{x \\leqslant z \\leqslant y} G(x,\\;z)\\mu(z,\\;y) \\\\<br/>& = \\sum_{x \\leqslant z \\leqslant y} \\mu(z,\\;y) \\sum_{x \\leqslant m \\leqslant z} F(x,\\;m)<br/>\\end{aligned}<br/>$$<br/>我们使用$\\zeta$函数来表示上下界，于是式子改写为以下形式：<br/>$$<br/>\\sum_{x \\leqslant z \\leqslant y} \\mu(z,\\;y) \\sum_{m \\in X_n} F(x,\\;m)\\zeta(x,\\;m)\\zeta(m,\\;z)<br/>$$<br/>改变求和的枚举顺序，先枚举$m$，其值依然不变：<br/>$$<br/>\\sum_{m \\in X_n} \\sum_{x \\leqslant z \\leqslant y} \\zeta(m,\\;z)\\mu(z,\\;y)\\zeta(x,\\;m)F(x,\\;m)<br/>$$<br/>由于当$m \\lt x$的时候$\\zeta(x,\\;m)$为$0$，因此只用考虑$m \\geqslant x$。<br/>同理，我们可以得出$z \\geqslant m$是必须的。<br/>因此可以改写下界：<br/>$$<br/>\\sum_{m \\in X_n} \\sum_{m \\leqslant z \\leqslant y} \\zeta(m,\\;z)\\mu(z,\\;y)F(x,\\;m)<br/>$$<br/>然后变成了卷积的形式：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{m \\in X_n} F(x,\\;m) \\sum_{m \\leqslant z \\leqslant y} \\zeta(m,\\;z)\\mu(z,\\;y) & = \\sum_{m \\in X_n} F(x,\\;m) \\delta(m,\\;y) \\\\<br/>& = F(x,\\;y)<br/>\\end{aligned}<br/>$$<br/>当$m = y$时，$\\delta(m,\\;y)$才为$1$，所以综上所述：<br/>$$<br/>F(x,\\;y) = \\sum_{x \\leqslant z \\leqslant y} G(x,\\;z)\\mu(z,\\;y) \\tag{3.2}<br/>$$<br/>偏序集直积<br/>对于两个偏序集$(A,\\;\\leqslant_1)$和$(B,\\;\\leqslant_2)$，它们的直积$C = A \\times B = (A \\times B,\\;\\leqslant)$也是偏序集，其中的元素为$(x,\\;y)\\;\\;(x \\in A,\\;y \\in B)$。其关系$\\leqslant$的定义如下：<br/>$$<br/>(x_1,\\;y_1) \\leqslant (x_2,\\;y_2) \\Longleftrightarrow x_1 \\leqslant_1 x_2 \\land y_1 \\leqslant_2 y_2<br/>$$<br/>对于偏序集的直积，我们有以下定理：<br/><br/>设$A$和$B$的莫比乌斯函数分别为$\\mu_1$和$\\mu_2$，那么$C$的莫比乌斯函数满足：<br/>$$\\mu((x_1,\\;y_1),\\;(x_2,\\;y_2)) = \\mu_1(x_1,\\;x_2)\\mu(y_1,\\;y_2) \\tag{4.1}$$<br/><br/>证明 对于$(x_1,\\;y_1) \\not\\leqslant (x_2,\\;y_2)$和$(x_1,\\;y_1) = (x_2,\\;y_2)$的情况，上式显然成立。<br/>假设对于满足$(x_1,\\;y_1) \\leqslant (u,\\;v) \\lt (x_2,\\;y_2)$的二元组均满足，那么有：<br/>$$<br/>\\begin{aligned}<br/>\\mu((x_1,\\;y_1),\\;(x_2,\\;y_2)) & = - \\sum_{(x_1,\\;y_1) \\leqslant (u,\\;v) \\lt (x_2,\\;y_2)} \\mu((x_1,\\;y_1),\\;(u,\\;v)) \\\\<br/>& = - \\sum_{(x_1,\\;y_1) \\leqslant (u,\\;v) \\lt (x_2,\\;y_2)} \\mu_1(x_1,\\;u)\\mu_2(y_1,\\;v) & (\\text{根据归纳假设}) \\\\<br/>& = - \\sum_{x_1 \\leqslant_1 u \\lt_1 x_2} \\sum_{y_1 \\leqslant_2 v \\lt_2 y_2} \\mu_1(x_1,\\;u)\\mu_2(y_1,\\;v) & (\\text{分别枚举}) \\\\<br/>& =  - \\sum_{x_1 \\leqslant_1 u \\leqslant_1 x_2} \\sum_{y_1 \\leqslant_2 v \\leqslant_2 y_2} \\mu_1(x_1,\\;u)\\mu_2(y_1,\\;v) \\\\<br/>&\\;\\;\\;\\, + \\mu_1(x_1,\\;x_2)\\sum_{y_1 \\leqslant_2 v \\leqslant_2 y_2} \\mu_2(y_1,\\;v) \\\\<br/>&\\;\\;\\;\\, + \\mu_2(y_1,\\;y_2)\\sum_{x_1 \\leqslant_1 u \\leqslant_1 x_2} \\mu_1(x_1,\\;u) \\\\<br/>&\\;\\;\\;\\, \\color{red}{+} \\mu_1(x_1,\\;x_2)\\mu_2(y_1,\\;y_2) & (\\text{扩展上界})<br/>\\end{aligned}<br/>$$<br/>(2016.12.22: 上述证明最后一步展开存在问题 (红色正号)，但是《组合数学》上没有这一步的详细推导，正确的证明方式还请大神们指出)<br/>由于：<br/>$$<br/>\\begin{aligned}<br/>0<br/>& = \\sum_{y_1 \\leqslant_2 v \\leqslant_2 y_2} \\mu_2(y_1,\\;v) \\\\<br/>& = \\sum_{x_1 \\leqslant_1 u \\leqslant_1 x_2} \\mu_1(x_1,\\;u)  \\\\<br/>& = \\sum_{x_1 \\leqslant_1 u \\leqslant_1 x_2} \\sum_{y_1 \\leqslant_2 v \\leqslant_2 y_2} \\mu_1(x_1,\\;u)\\mu_2(y_1,\\;v)<br/>\\end{aligned}<br/>$$<br/>所以定理成立。<br/>在$(X_n,\\;\\leqslant)$上的莫比乌斯函数<br/>注意这里的是真正的小于等于号了......<br/>这个比较智障，分析一下就好了：<br/>对于$y = x$，我们有：<br/>$$<br/>\\mu(x,\\;y) = \\mu(x,\\;x) = 1<br/>$$<br/>对于$y = x + 1$，我们有：<br/>$$<br/>\\mu(x,\\;y) = \\mu(x,\\;x + 1) = -\\mu(x,\\;x) = -1<br/>$$<br/>对于$y = x + 2$，我们有：<br/>$$<br/>\\mu(x,\\;y) = \\mu(x,\\;x + 2) = -\\left[\\mu(x,\\;x) + \\mu(x,\\;x + 1)\\right] = 0<br/>$$<br/>不难发现，对于$y \\gt x + 1$的函数值就全都变为$0$了。<br/>总结一下就是：<br/>$$<br/>\\mu(x,\\;y) =<br/>\\begin{cases}<br/>1 & (y = x) \\\\<br/>-1 & (y = x + 1) \\\\<br/>0 & (\\text{otherwise})<br/>\\end{cases}<br/>\\tag{5.1}<br/>$$<br/>在$(X_n,\\;\\subseteq)$上的莫比乌斯函数<br/><br/>试证明：<br/>偏序集$(X_n,\\;\\subseteq)$的莫比乌斯函数是：<br/>$$\\mu(A,\\;B) = (-1)^{|B| - |A|} \\tag{6.1}$$<br/><br/>运用归纳法证明：<br/>首先对于$A = B$，显然成立：<br/>$$<br/>\\mu(A, B) = \\mu(A, A) = 1 = (-1)^0<br/>$$<br/>假设对于$|B| - |A| \\leqslant k$均成立，尝试证明对于$|B| - |A| = k + 1$也成立：<br/>$$<br/>\\begin{aligned}<br/>\\mu(A,\\;B) & = -\\sum_{A \\subseteq C \\subset B} \\mu(A,\\;C) \\\\<br/>& = -\\sum_{A \\subseteq C \\subset B} (-1)^{|C| - |A|} \\\\<br/>& = -\\sum_{i = 0}^{k} {k + 1 \\choose i}(-1)^i \\\\<br/>& = -\\left[(1 - 1)^{k + 1} - (-1)^{k + 1} \\right] \\\\<br/>& = (-1)^{k + 1} \\\\<br/>& = (-1)^{|B| - |A|}<br/>\\end{aligned}<br/>$$<br/>在$(X_n,\\;\\mid)$上的莫比乌斯函数<br/>对于$(X_n, \\;\\mid)$这个偏序集，有如下定理：<br/>$$<br/>a \\mid b \\Longrightarrow \\mu(a,\\;b) = \\mu(1,\\;\\frac{b}a) \\tag{7.1}<br/>$$<br/>证明 我们尝试使用归纳法证明。首先对于$a = b$的情况显然成立：<br/>$$<br/>\\mu(a,\\;b) = \\mu(a,\\;a) = \\mu(1,\\;1) = 1<br/>$$<br/>假设对于$a \\leqslant c \\lt b$的莫比乌斯函数$\\mu(a,\\;c)$均满足上述定理，下面证明对于$\\mu(a,\\;b)$也满足。<br/>根据莫比乌斯函数的性质可得：<br/>$$<br/>\\mu(a,\\;b) = -\\sum_{a \\mid c \\mid b, \\;c \\neq b} \\mu(a,\\;c)<br/>$$<br/>由于$a \\mid b$，所以：<br/>$$<br/>-\\sum_{c \\mid (b / a), \\;c \\neq (b / a)} \\mu(a,\\;ac)<br/>$$<br/>根据归纳假设，可以将上式变为：<br/>$$<br/>-\\sum_{c \\mid (b / a), \\;c \\neq (b / a)} \\mu(1,\\;c) = \\mu(1,\\;\\frac{b}a)<br/>$$<br/>因此定理成立。<br/>由于有上面的定理，所以我们只用关心$\\mu(1,\\;n)$。<br/>首先可以递归计算：<br/>$$<br/>\\mu(1,\\;n) = -\\sum_{a \\mid n,\\;a\\neq n} \\mu(1,\\;a)<br/>$$<br/>考虑对$n$进行质因数分解：<br/>$$<br/>n = p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_m^{\\alpha_m}<br/>$$<br/>对于$n$的任意一个因子$d$都有：<br/>$$<br/>d = p_1^{\\beta_1}p_2^{\\beta_2}\\cdots p_m^{\\beta_m} \\;\\;\\;\\; (0 \\leqslant \\beta_i \\leqslant \\alpha_i)<br/>$$<br/>相当于可以看作$m$个大小为$\\alpha_1 + 1,\\;\\alpha_2 + 1,\\;\\dots,\\;\\alpha_m + 1$的偏序集的直积的结果。<br/>于是可以得到：<br/>$$<br/>\\mu(1,\\;n) = \\prod_{i=1}^m\\mu(1,\\;p_i^{\\alpha_i}) \\tag{7.2}<br/>$$<br/>注意到，对于$\\varphi(p) = p - 1$：<br/>$$<br/>\\mu(1,\\;1) = 1 \\\\<br/>\\mu(1,\\;p) = -\\mu(1,\\;1) = -1 \\;\\; \\\\<br/>\\mu(1,\\;p^2) = -\\left[ \\mu(1,\\;1) + \\mu(1,\\;p) \\right] = 0 \\\\<br/>\\dots<br/>$$<br/>总结一下就是：<br/>$$<br/>\\mu(1,\\;p^k) =<br/>\\begin{cases}<br/>1 & (k = 0) \\\\<br/>-1 & (k = 1) \\\\<br/>0 & (\\text{otherwise})<br/>\\end{cases}<br/>\\tag{7.3}<br/>$$<br/>运用直积，可以知道：<br/>$$<br/>\\mu(1,\\;n) =<br/>\\begin{cases}<br/>1 & (n = 1) \\\\<br/>(-1)^k & (n = p_1p_2\\cdots p_k, \\;\\;\\varphi(p_i) = p_i - 1) \\\\<br/>0 & (\\text{otherwise})<br/>\\end{cases}<br/>\\tag{7.4}<br/>$$<br/>为了方便，通常把$\\mu(1,\\;n)$记作$\\mu(n)$，就变成常见的莫比乌斯函数了。<br/>据此，我们可以证明莫比乌斯函数是积性函数，即：<br/>$$<br/>a \\bot b \\Longrightarrow \\mu(ab) = \\mu(a)\\mu(b) \\tag{7.5}<br/>$$<br/>证明：<br/>1. 如果$a$、$b$中有一者为$1$，结论显然成立。<br/>2. 如果$a$、$b$中有一者不为素数连乘的形式，它们的积也一定不会是素数连乘的形式，故等于$0$。<br/>3. 此时假设$a$、$b$都是素数连乘的形式，又因为$a$与$b$互质，所以它们的素因子中没有相同的。设$a = p_1p_2\\cdots p_m$和$b = q_1q_2\\cdots q_n$所以可以知道$\\mu(ab) = (-1)^{n + m} = \\mu(a)\\mu(b)$。<br/>反演示例：容斥原理<br/>设$S$为有限集，$A_1,\\;A_2,\\;\\dots,\\;A_n$是$S$的子集，$K \\subseteq \\{1,\\;2,\\;\\dots,\\;n\\}$。<br/>定义函数$F(K)$计数$s$同时满足下列条件：<br/>$$<br/>s \\not\\in \\bigcup_{i \\in K} A_i \\\\<br/>s \\in \\bigcap_{i \\not\\in K} A_i<br/>$$<br/>即：<br/>$$<br/>F(K) = \\left| \\bigcap_{i \\not\\in K} A_i - \\bigcup_{i \\in K} A_i \\right| \\tag{8.1}<br/>$$<br/>如何脑补这个函数？可以想象成是用$K$把$S$中的很多东西挖走了，然后剩下的集合再求交集。<br/>对于此，再定义函数$G(K)$：<br/>$$<br/>G(K) = \\sum_{L \\subseteq K} F(L) \\tag{8.2}<br/>$$<br/>这货居然计数的是：<br/>$$<br/>G(K) = \\left| \\bigcap_{i \\not\\in K} A_i \\right| \\tag{8.3}<br/>$$<br/>如何脑补其正确性？可以想象是一个智障用$K$把本来属于它们交集的东西挖去了，然后又一个一个吐出来，于是就还原了原本的交集......<br/>根据莫比乌斯反演公式可以知道：<br/>$$<br/>G(K) = \\sum_{L \\subseteq K} F(K) \\Longrightarrow F(K) = \\sum_{L \\subseteq K} (-1)^{|K| - |L|} G(L)<br/>$$<br/>所以取$K = \\{1,\\;2,\\;\\dots,\\;n\\}$可以得到：<br/>$$<br/>F(K) = \\sum_{L \\subseteq K} (-1)^{n - |L|} G(L) \\tag{8.4}<br/>$$<br/>这个时候的$F(K)$计数的东西有了新的含义：<br/>$$<br/>F(K) = \\left|\\bigcup_{i \\in K} A_i\\right| = \\left|\\bigcap_{i \\in K} \\overline{A}_i \\right| \\tag{8.5}<br/>$$<br/>用$F(K)$和$G(K)$本身的含义来替换，就可以得到容斥原理 (感觉好神奇)：<br/>$$<br/>\\left|\\bigcap_{i = 1}^n \\overline{A}_i \\right| = \\sum_{K \\subseteq \\{1,\\;,2,\\;,\\dots,\\;n\\}} (-1)^{|K|} \\left| \\bigcap_{i \\in K} A_i \\right| \\tag{8.6}<br/>$$<br/>反演示例：$\\varphi(n)$通项公式<br/>欧拉$\\varphi(n)$函数计数的是不大于$n$的与$n$互质的正整数个数。<br/>对于欧拉$\\varphi$函数，我们有如下的定理：<br/>$$<br/>n = \\sum_{d \\mid n} \\varphi(d) \\tag{9.1}<br/>$$<br/>有两种证明方法：<br/>第一种考虑不与$n$互质的数，如果存在一个数$d$与$n$不互质，那么必有$\\gcd(d, n) = a \\gt 1$，换言之$\\gcd(d / a, n / a) = 1$，所以一个数不与$n$互质，那么必定与$n$的一个因子互质。所以上式成立。<br/>另一种是使用归纳法证明：<br/>首先考虑$1$，是显然成立的。<br/>然后考虑质数$p$，$\\varphi(1) + \\varphi(p) = p$，所以也是成立的。<br/>考虑质数$p$的幂$p^k$，它的因子有$1,\\;p,\\;p^2,\\;\\dots,\\;p^k$，由于：<br/>$$<br/>\\varphi(p^k) = (p - 1)p^{k-1} \\;\\;\\;\\; (\\varphi(p) = p - 1)<br/>$$<br/>所以我们对其进行等比数列求和：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{d \\mid n} \\varphi(d) & = 1 + (p - 1)\\sum_{i=0}^{k-1} p^i \\\\<br/>& = 1 + (p - 1) \\cdot {1 - p^k \\over 1 - p} \\\\<br/>& = 1 + p^k - 1 \\\\<br/>& = p^k<br/>\\end{aligned}<br/>$$<br/>故对质数的幂也成立。<br/>假设对于一个数$c$，所有小于$c$的数均成立，那么选取$n$的两个互质的因子$a$、$b$使得$ab = c$，那么有：<br/>$$<br/>\\sum_{n \\mid a} \\varphi(n) \\sum_{m \\mid b} \\varphi(m) = a \\cdot b = c<br/>$$<br/>下面证明$\\sum_{n \\mid a} \\varphi(n) \\sum_{m \\mid b} \\varphi(m) = \\sum_{d \\mid c} \\varphi(d)$，即可证明原式：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{n \\mid a} \\varphi(n) \\sum_{m \\mid b} \\varphi(m) & = \\sum_{n \\mid a}\\sum_{m \\mid b}\\varphi(n)\\varphi(m) & (\\text{改变枚举顺序}) \\\\<br/>& = \\sum_{n \\mid a}\\sum_{m \\mid b} \\varphi(nm) & (\\text{由于}n \\bot m) \\\\<br/>& = \\sum_{nm \\mid ab} \\varphi(nm) & (\\text{由于}a \\bot b) \\\\<br/>& = \\sum_{d \\mid c} \\varphi(d) & (\\text{等价代换}) \\\\<br/>& = c<br/>\\end{aligned}<br/>$$<br/>注意到$(9.1)$式是一个明显的莫比乌斯反演的形式。根据莫比乌斯反演公式，我们可以得到：<br/>$$<br/>\\begin{aligned}<br/>\\varphi(n) & = \\sum_{d \\mid n} d \\cdot \\mu(d,\\;n) \\\\<br/>& = \\sum_{d \\mid n} d \\cdot \\mu(1,\\;n / d) \\\\<br/>& = \\sum_{d \\mid n} d \\cdot \\mu(n / d) \\\\<br/>& = \\sum_{d \\mid n} \\mu(d) \\cdot n/d<br/>\\end{aligned}<br/>$$<br/>考虑一下$\\mu$函数的取值，对于因子$1$，和式中的结果为$n$。对于由素数相乘的因子，这些素因子必定来自$n$。而其它情况就都为$0$。<br/>设$n = p_1^{k_1}p_2^{k_2}\\cdots p_m^{k_m}$。<br/>因此可以得到下面的式子：<br/>$$<br/>\\varphi(n) = n\\left[1 - \\sum \\frac1{p_i} + \\sum \\frac1{p_ip_j} - \\cdots + (-1)^{m}\\sum \\frac1{\\prod_{i=1}^m p_i} \\right] \\tag{9.2}<br/>$$<br/>这恰好是下面的式子展开的形式：<br/>$$<br/>\\varphi(n) = n\\prod_{i=1}^m \\left( 1 - \\frac1{p_i} \\right) \\tag{9.3}<br/>$$<br/>因此：<br/>$$<br/>\\varphi(n) = n\\prod_{p \\mid n,\\;\\varphi(p) = p - 1} \\left( 1 - \\frac1p\\right) \\tag{9.4}<br/>$$<br/>反演示例：多重集合的循环排列<br/><br/>我们有一个多重集合$\\{\\infty \\cdot 1,\\;\\infty \\cdot 2,\\;\\dots,\\;\\infty \\cdot k\\}$。易知长度为$n$的全排列数为$k^n$。<br/>现在对于两个排列$A$和$B$，如果$A$通过”旋转” (即将最后一个变成第一个，并且把之前的全部后移) 能变成$B$，那么$A$和$B$是等价的。<br/>换言之，最小表示法相同的排列是等价。<br/>求不同的长度为$n$的循环排列数量。<br/><br/>对于这个计数问题，我们记$h(n)$为长度为$n$时的答案，$f(n)$为长度为$n$并且旋转$n$次才会变为原排列 (即循环节长度为$n$) 的排列的数量。显然，一个排列的循环节长度$m$必须满足$m \\mid n$。<br/>那么可以知道：<br/>$$<br/>h(n) = \\sum_{d \\mid n} \\frac{f(d)}d \\tag{10.1}<br/>$$<br/>由于循环节长度小于$n$的排列都可以由循环节不断重复而得来。因此我们设：<br/>$$<br/>g(n) = \\sum_{d \\mid n} f(d)<br/>$$<br/>$g(n)$就计数了所有长度为$n$的排列数量。<br/>所以：<br/>$$<br/>g(n) = k^n \\tag{10.2}<br/>$$<br/>根据莫比乌斯反演公式可得：<br/>$$<br/>\\begin{aligned}<br/>f(n) & = \\sum_{d \\mid n} g(d)\\mu(n/d) \\\\<br/>& = \\sum_{d \\mid n} k^d\\mu(n/d)<br/>\\end{aligned}<br/>\\tag{10.3}<br/>$$<br/>带入$h(n)$的计算公式可得：<br/>$$<br/>h(n) = \\sum_{d \\mid n} \\frac1d \\sum_{e \\mid d} k^e\\mu(d/e) \\tag{10.4}<br/>$$<br/>由于$e \\mid d$并且$d \\mid n$，所以我们设$n = rd,\\;d = me$，所以$n = rem$，这样将方便我们变换公式：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{d \\mid n} \\frac1d \\sum_{e \\mid d} k^e\\mu(d/e) & = \\sum_{e \\mid n} k^e \\sum_{m \\mid (n/e)} \\frac1{me}\\mu(m) \\\\<br/>& =\\sum_{e\\mid n} \\frac{k^e}n \\sum_{r \\mid (n/e)} r\\cdot\\mu(\\frac{n}e/r)<br/>\\end{aligned}<br/>$$<br/>由于：<br/>$$<br/>\\varphi(n) = \\sum_{d \\mid n} d \\cdot \\mu(n/d)<br/>$$<br/>所以：<br/>$$<br/>h(n) = \\frac1n \\sum_{d \\mid n} k^d \\varphi(n/d) \\tag{10.5}<br/>$$<br/>莫比乌斯函数示例：最大公约数<br/>除了莫比乌斯反演公式，莫比乌斯函数本身的性质也是很好的。<br/>考虑下面一个问题：<br/><br/>给定$n$和$m$，求$\\gcd(x,\\;y)\\;\\;(1 \\leqslant x \\leqslant n,\\;1 \\leqslant y \\leqslant m)$为素数的二元组$(x,\\;y)$个数。<br/><br/>换言之，我们要求的是这个：<br/>$$<br/>\\sum_{x=1}^n\\sum_{y=1}^m \\left[\\varphi(\\gcd(x,\\;y)) = \\gcd(x,\\;y) - 1\\right] \\tag{11.1}<br/>$$<br/>首先，我们可以换个思路，就是枚举最大公约数的答案：<br/>$$<br/>\\sum_{\\varphi(p) = p - 1}^{\\min\\{n,\\;m\\}}\\sum_{x=1}^n\\sum_{y=1}^m \\left[ \\gcd(x,\\;y) = p \\right] \\tag{11.2}<br/>$$<br/>由于$\\gcd(x,\\;y) = p \\Longrightarrow \\gcd(x/p,\\;y/p) = 1$，所以就变成了枚举互质的数的对数：<br/>$$<br/>\\sum_{\\varphi(p) = p - 1}^{\\min\\{n,\\;m\\}}\\sum_{x=1}^{\\left\\lfloor \\frac{n}p\\right\\rfloor}\\sum_{y=1}^{\\left\\lfloor \\frac{m}p \\right\\rfloor} \\left[ \\gcd(x,\\;y) = 1 \\right] \\tag{11.3}<br/>$$<br/>由于莫比乌斯函数有这样的性质：<br/>$$<br/>\\sum_{d \\mid n} \\mu(d) = [n = 1] \\tag{11.4}<br/>$$<br/>所以可以使用莫比乌斯函数来测试一个数是否为$1$：<br/>$$<br/>\\sum_{\\varphi(p) = p - 1}^{\\min\\{n,\\;m\\}}\\sum_{x=1}^{\\left\\lfloor \\frac{n}p\\right\\rfloor}\\sum_{y=1}^{\\left\\lfloor \\frac{m}p \\right\\rfloor} \\sum_{d \\mid \\gcd(x,\\;y)} \\mu(d) \\tag{11.5}<br/>$$<br/>因为$d \\mid \\gcd(x,\\;y)$当且仅当$d \\mid x$并且$d \\mid y$，所以可以变成这样：<br/>$$<br/>\\sum_{\\varphi(p) = p - 1}^{\\min\\{n,\\;m\\}}\\sum_{x=1}^{\\left\\lfloor \\frac{n}p\\right\\rfloor}\\sum_{y=1}^{\\left\\lfloor \\frac{m}p \\right\\rfloor} \\sum_{d \\mid x \\,\\land\\, d \\mid y} \\mu(d) \\tag{11.6}<br/>$$<br/>现在东西越来越多了，是时候考虑简化一下了。<br/>首先对于一堆和式的一个技巧就是调整枚举顺序。<br/>尝试先枚举$d$，这样合法的$d$就可以直接计算了：<br/>$$<br/>\\sum_{\\varphi(p) = p - 1}^{\\min\\{n,\\;m\\}} \\sum_{d=1}^{\\min\\{n,\\;m\\}} \\left\\lfloor \\frac{n}{dp} \\right\\rfloor \\left\\lfloor \\frac{m}{dp} \\right\\rfloor \\mu(d) \\tag{11.7}<br/>$$<br/>其实这个式子已经可以用来计算答案了。注意到对于一个数$n$，$\\lfloor n / i \\rfloor$的取值最多有$O(\\sqrt{n})$种，因为：<br/><br/>如果$i \\leqslant \\sqrt{n}$，这样的$i$只有$O(\\sqrt{n})$种。<br/>如果$i > \\sqrt{n}$，那么$\\lfloor n / i \\rfloor \\leqslant \\sqrt{n}$，这样的取值只有$O(\\sqrt{n})$种。<br/><br/>所以两个向下取整的乘积最多有$O(\\sqrt{n} + \\sqrt{m})$个不同的取值，左边枚举的素数约为$O({n \\over \\ln n})$个，故根据此公式计算的时间复杂度为$O({n (\\sqrt{n} + \\sqrt{m}) \\over \\ln n})$。<br/>然而我们可以做得更快一些。<br/>设$T = dp$，现在改成先枚举$T$：<br/>$$<br/>\\sum_{T = 1}^{\\min\\{n,\\;m\\}} \\left\\lfloor \\frac{n}T \\right\\rfloor \\left\\lfloor \\frac{m}T \\right\\rfloor \\sum_{p \\mid T,\\;\\varphi(p) = p - 1} \\mu(T / p) \\tag{11.8}<br/>$$<br/>这样左边就可以在$O(\\sqrt{n} + \\sqrt{m})$的时间内进行枚举。<br/>枚举大概是这样的一个过程：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6lastpos = 0<br/>i = 1<br/>while i <= min(n, m):<br/>    lastpos = min(n / (n / i), m / (m / i))<br/>    # Do something...<br/>    i = lastpos + 1<br/><br/><br/>我们企图能使右边快速计算。因此我们来研究一下右边这个玩意。<br/>设：<br/>$$<br/>g(x) = \\sum_{p \\mid x,\\;\\varphi(p) = p - 1} \\mu(x/p) \\tag{11.9}<br/>$$<br/>考虑使用线性筛来计算$g(x)$。<br/><br/>当$x = 1$时，$g(x) = 0$。<br/>当$x$为素数时，$g(x) = 1$。<br/>在线性筛的处理过程中，设当前数为$i$，枚举到的素数为$p$，我们将要计算$g(ip)$：<br/>当$\\mu(i) = 0$时，说明$i$的质因数分解中至少存在一个一个素因子的次数大于$1$。<br/>   在这种情况下，除非只有一个素因子的次数为$2$，其它均为$1$，否则无论如何$g$的函数值都为$0$。<br/>   假设只存在一个素因子的次数为$2$，记这个素因子为$f(i)$。<br/>若$p \\mid i$，那么将会导致无论是哪个素因子，$\\mu$函数的值都为$0$。因此$g$函数的值为$0$。<br/>若$p \\not\\mid i$，那么就只有除以$f(i)$时会有值，此时的值为$\\mu(i / f(i) \\cdot p)$。<br/><br/><br/>当$\\mu(i) \\neq 0$时，意味着$i$将是多个素数之积。同样我们来考虑两种情况：<br/>若$p \\mid i$，那么就只有$p$的次数为$2$，此时$g(ip) = \\mu(i)$。<br/>若$p \\not\\mid i$，那么$\\mu(ip)$依然不为$0$。假设$i$有$r$个素因子，那么$g(i) = r(-1)^{r-1}$，并且$g(ip) = (r + 1)(-1)^r = -r(-1)^{r-1} + (-1)^{r+1}$，这意味着它们符号相反且绝对值差$1$。这样就可以直接计算。<br/><br/><br/><br/><br/><br/>经过一番分类讨论，我们总算成功地找到了预处理$g(x)$的方法。<br/>在这中间有一个问题还亟待解决，就是我们需要计算$f(x)$，事实上它也可以用线性筛计算。<br/>假设存在这样的素因子$p$，就记$f(x) = p$。如果$x$还是多个素数相乘，就记$f(x) = 1$。否则记作$0$，又称为”没救了”。这样就只有$f(x) \\gt 1$时才有我们需要的结果。<br/><br/>当$x = 1$或$x$为质数时，$f(x) = 1$。<br/>每次往一个数$i$加入一个素数$p$时，需要考虑下面的情况：<br/>若$f(i) = 0$，那么没救了。<br/>若$p \\mid i$，并且$f(i) = 1$，那么$ip$将不再是素数连乘的形式，此时可以记下$f(ip) = p$。如果$f(i) > 1$，那么它没救了。<br/>若$p \\not\\mid i$，那么$f$函数值不会改变。<br/><br/><br/><br/>这样就可以欢快地计算$f$函数啦~<br/>回到之前的问题，我们能够计算$g(x)$函数后，预处理出它的前缀和，就可以在前面伪代码中展示的迭代过程计算答案了。时间复杂度是$O(\\sqrt{n} + \\sqrt{m})$。<br/>莫比乌斯函数示例：DIVCNT2<br/>SPOJ DIVCNT2<br/><br/>要求求出：<br/>$$ \\sum_{a = 1}^n \\sigma(a^2) $$<br/>的值。其中$\\sigma(n)$表示$n$的因子个数。<br/><br/>考虑这么几个等式关系：<br/>$$<br/>\\sigma(n^2) = \\sum_{d \\mid n} 2^{\\omega(d)}<br/>\\tag{12.1}<br/>$$<br/>其中$\\omega(n)$表示$n$的质因子个数。为什么这是正确的呢？考虑每个$n$的因子$d$，$d^2$都是$n^2$的因子。另外，对于任意$n$的任意两个不同的因子，它们的质因数分解中至少有一个素数的次数的差不小于$1$，那么经过平方后，这个差值将不小于$2$。于是它们的平方任意删去一个素数后，是不会冲突的。这样，我们只要对每个$d^2$，都枚举一下删去素数的方案，就可以得到$n^2$的所有因子。答案也就是上式。<br/>$$<br/>2^{\\omega(n)} = \\sum_{d \\mid n} \\mu^2(d)<br/>\\tag{12.2}<br/>$$<br/>考虑到$\\mu$函数的取值：<br/>$$<br/>\\mu(n) =<br/>\\begin{cases}<br/>1 & (n = 1) \\\\<br/>(-1)^k & (n = p_1p_2\\cdots p_k, \\;\\;\\varphi(p_i) = p_i - 1) \\\\<br/>0 & (\\text{otherwise})<br/>\\end{cases}<br/>$$<br/>因此：<br/>$$<br/>\\mu^2(n) =<br/>\\begin{cases}<br/>1 & (n = 1) \\\\<br/>1 & (n = p_1p_2\\cdots p_k, \\;\\;\\varphi(p_i) = p_i - 1) \\\\<br/>0 & (\\text{otherwise})<br/>\\end{cases}<br/>$$<br/>即只要是$d$是素数连乘的形式，就会对答案贡献。否则没有贡献。这也正是$2^{\\omega(n)}$想要统计的。<br/>对于省去了第一维的数论函数$f$和$g$，定义它们的狄利克雷卷积是下面的形式：<br/>$$<br/>(f \\times g)(n) = \\sum_{d \\mid n} f(d)g\\left(\\frac{n}{d}\\right)<br/>\\tag{12.3}<br/>$$<br/>也就是在偏序集$(X_n, \\;\\mid)$上的卷积。令$f(n) = \\sigma(n^2)$，$g(n) = 2^{\\omega(n)}$，$h(n) = \\mu^2(n)$以及$\\epsilon(n) = 1$，这样我们可以把之前的结果简写为：<br/>$$<br/>f = g \\times \\epsilon \\\\<br/>g = h \\times \\epsilon<br/>$$<br/>利用卷积的结合律，可以得到：<br/>$$<br/>\\begin{aligned}<br/>f & = (h \\times \\epsilon) \\times \\epsilon \\\\<br/>& = h \\times (\\epsilon \\times \\epsilon)<br/>\\end{aligned}<br/>$$<br/>注意到：<br/>$$<br/>\\begin{aligned}<br/>\\epsilon \\times \\epsilon & = \\sum_{d \\mid n} 1 \\\\<br/>& = \\sigma(n)<br/>\\end{aligned}<br/>$$<br/>所以，我们要求的东西也就是：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{i = 1}^n f(i) & = \\sum_{i = 1}^n \\sum_{d \\mid i} \\mu^2(d) \\sigma\\left({i \\over d}\\right) \\\\<br/>& = \\sum_{i = 1}^n \\mu^2(i) \\sum_{j = 1}^{\\left\\lfloor {n \\over i} \\right\\rfloor} \\sigma(j)<br/>\\end{aligned}<br/>$$<br/>首先考虑$\\sigma(n)$的前缀和如何计算：<br/>$$<br/>\\sum_{i = 1}^n \\sigma(i) = \\sum_{i = 1}^n \\left\\lfloor {n \\over i} \\right\\rfloor<br/>\\tag{12.4}<br/>$$<br/>由于下取整可以分段，所以可以在$O(\\sqrt{n})$的复杂度内计算。<br/>然后考虑$\\mu^2(n)$的前缀和如何计算：<br/>$$<br/>\\sum_{i = 1}^n \\mu^2(i) = \\sum_{i = 1}^{\\sqrt{n}} \\mu(i)\\left\\lfloor {n \\over i^2} \\right\\rfloor<br/>\\tag{12.5}<br/>$$<br/>这是为什么？结合$\\mu^2(n)$的意义，这个前缀和就是统计前$n$个数里面，有多少个数是素数连乘的形式。当$i = 1$时，所有数字均被统计了一遍。然后枚举$1$到$\\sqrt{n}$的每个数字，如果不是素数连乘的形式，$\\mu(i)$会返回$0$。如果是素数连乘的形式，那么它的任意大于$1$的次数的幂都不是答案，此时应当删去。于是$\\mu$函数在此充当了容斥系数。<br/>回到之前的式子：<br/>$$<br/>\\sum_{i = 1}^n \\mu^2(i) \\sum_{j = 1}^{\\left\\lfloor {n \\over i} \\right\\rfloor} \\sigma(j)<br/>$$<br/>对于$\\sigma(n)$的前缀和的上标也是可以分段的，这样就需要用到$\\mu^2(n)$的前缀和。<br/>所以最后的复杂度可以这样估计：<br/>$$<br/>\\sum_{k = 1}^{\\sqrt{n}} \\sqrt{k} + \\sum_{k = 1}^{\\sqrt{n}} \\sqrt{{n \\over k}}<br/>\\tag{12.6}<br/>$$<br/>显然右边的代价更高。用积分可以估计一下：<br/>$$<br/>\\sum_{k = 1}^{\\lfloor \\sqrt{n} \\rfloor} \\sqrt{n \\over k} \\leqslant \\int_0^{\\lfloor \\sqrt{n} \\rfloor} \\sqrt{n \\over x} \\;\\mathrm{d}x = O(n^{3/4})<br/>$$<br/>如果预处理前$S$个前缀和的答案，当询问$\\mu^2(n)$和$\\sigma(n)$的前缀和时，如果$n \\leqslant S$，就直接返回预处理的值。那么复杂度大约为：<br/>$$<br/>\\sum_{k = 1}^{\\min\\{\\lfloor \\sqrt{n} \\rfloor, \\lfloor n / S \\rfloor\\}} \\sqrt{n \\over x}<br/>\\tag{12.7}<br/>$$<br/>当$S \\lt \\sqrt{n}$时，时间复杂度的分析不变。否则时间复杂度上界变为：<br/>$$<br/>O\\left(S + {n \\over \\sqrt{S}}\\right)<br/>$$<br/>当$S = n / \\sqrt{S}$时取得最小值，此时$S = n^{2/3}$，时间复杂度为$O(n^{2/3})$。注意，这里空间上也要付出同样的代价。<br/><br/><br/><br/><br/>在偏序集$(X_n,\\;\\mid\\;)$上简化后的卷积 (即狄利克雷卷积)，会满足交换律。 ↩<br/><br/><br/>","tags": "数学 组合数学 莫比乌斯反演","url": "blog/2016-8-18/mobius.html"},
{"title": "计算分拆数的一种方法","text": "计算分拆数的一种方法<br/>原始问题<br/>给定 $n$，要求计算 $p(n)$ 和 $q(n)$，其中 $p(n)$ 表示 $n$ 的分拆方案总数，$q(n)$ 表示 $n$ 的不使用重复元素的分拆方案总数。<br/>例如 $p(4) = 5$，因为有以下几种分拆方案：<br/>$$<br/>\\begin{aligned}<br/>4 & = 4 \\\\<br/>4 & = 3 + 1 \\\\<br/>4 & = 2 + 2 \\\\<br/>4 & = 2 + 1 + 1 \\\\<br/>4 & = 1 + 1 + 1 + 1<br/>\\end{aligned}<br/>$$<br/>而 $q(4) = 2$，因为在上面只有前两种没有出现重复元素。<br/>为了方便，这里将与数字相关的基本运算的时间复杂度均视为常数时间。<br/>基本思路<br/>主要还是利用双计数的套路，对于 $p(n)$，容易得知：<br/>$$<br/>np(n) = \\sum_{k=1}^n k \\sum_{t=1}^{\\lfloor n / k \\rfloor} p(n - kt)<br/>$$<br/>对于 $q(n)$，双计数貌似就没法直接使用了。但是我们可以证明1：<br/><br/>将 $n$ 拆分为不同的部分的方案数等于将 $n$ 拆分为各部分都是奇数的方案数。<br/><br/>证明 $1$： 考虑构造双射。<br/>由于每个数 $n$ 都可以被唯一表示为 $2^k \\cdot t$ 的形式，其中 $t$ 是奇数。利用这一点可以沟通上述两种拆分方法。<br/><br/>给定一个每个部分不同的拆分方案，构造一个新的拆分方案：对于每个数 $n = 2^k \\cdot t$，在新方案中加入 $2^k$ 个 $t$。易知新方案中的每个部分都是奇数。<br/>从上面给出的新方案还原原来的方案：统计每个奇数 $t$ 的出现次数 $c$，并将其表示为二进制，即 $c = c_0c_1...{c_p}_{(2)}$。对于 $0 \\leqslant k \\leqslant p$，如果 $c_k = 1$，那么表示原方案中有一个数为 $2^k \\cdot t$。<br/><br/>举个例子，如 $6 = 1 + 2 + 3$，按照上述方法转为全部都是奇数的方案就是 $6 = 1 + 1 + 1 + 3$，这里 $1$ 出现了 $3 = 11_{(2)}$ 次，所以知道原方案中有 $2^0 \\times 1 = 1$ 和 $2^1 \\times 1 = 2$ 这两个数。<br/>证明 $2$： 利用生成函数直接证明。据说是欧拉当时给出的证明。<br/>根据几何级数，我们知道：<br/>$$<br/>\\begin{aligned}<br/>1 + x^k & = \\sum_{k = 0}^\\infty x^k - x^{2k}\\sum_{k = 0}^\\infty x^k \\\\<br/>& = {1 - x^{2k} \\over 1 - x^k} \\;\\;\\;\\; (|x| < 1)<br/>\\end{aligned}<br/>$$<br/>注意到分子部分总是偶数次幂。因此设 $o(n)$ 表示将 $n$ 分为每个部分均为奇数的方案数，则：<br/>$$<br/>\\begin{aligned}<br/>\\sum_{k = 0}^\\infty q(k)x^k & = \\prod_{k = 1}^\\infty (1 + x^k) \\\\<br/>& = \\prod_{k = 1}^\\infty {1 - x^{2k} \\over 1 - x^k} \\\\<br/>& = {1 - x^2 \\over 1 - x}{1 - x^4 \\over 1 - x^2}{1 - x^6 \\over 1 - x^3}{1 - x^8 \\over 1 - x^4}\\cdots \\\\<br/>& = \\prod_{k = 0}^\\infty {1 \\over 1 - x^{2k + 1}} \\\\<br/>& = \\prod_{k = 0}^\\infty \\left(\\sum_{j = 0}^\\infty x^{j(2k + 1)} \\right) = \\sum_{k = 0}^\\infty o(k)x^k<br/>\\end{aligned}<br/>$$<br/>即 $q(n)$ 的生成函数与 $o(n)$ 是一样的，从而证明它们相等。<br/>现在回到原来的问题，由于只是要求每个部分都是奇数，所以可以再一次运用双计数：<br/>$$<br/>nq(n) = \\sum_{k = 1}^n (k \\bmod 2) k \\sum_{t = 1}^{\\lfloor n / k \\rfloor} q(n - kt)<br/>$$<br/>现在令 $T = kt$ 换元，我们可以得到：<br/>$$<br/>nq(n) = \\sum_{T = 1}^n q(n - T) \\sum_{k | T} (k \\bmod 2)k<br/>$$<br/>令 $c(n) = \\sum_{k | n} (k \\bmod 2)k$，即 $n$ 的所有奇数因子之和，并且易知 $c(0) = 0$，所以上面的式子可以简化为：<br/>$$<br/>nq(n) = \\sum_{k = 0}^n c(k)q(n - k)<br/>$$<br/>变成了一个卷积的形式。$c(1)$ 到 $c(n)$ 显然可以在$O(n \\ln n)$ 的时间内计算出来，此外使用 “分治 + FFT” 就可以在 $O(n \\log^2 n)$ 的时间内计算 $q(1)$ 到 $q(n)$ 所有的值。上述推导过程对于 $p(n)$ 来讲是一样的。<br/>实现<br/>下面的程序实现了计算 $q(0)$ 到 $q(n)$ 所有的值在模 $998244353$ 意义下的值：<br/>  1<br/>  2<br/>  3<br/>  4<br/>  5<br/>  6<br/>  7<br/>  8<br/>  9<br/> 10<br/> 11<br/> 12<br/> 13<br/> 14<br/> 15<br/> 16<br/> 17<br/> 18<br/> 19<br/> 20<br/> 21<br/> 22<br/> 23<br/> 24<br/> 25<br/> 26<br/> 27<br/> 28<br/> 29<br/> 30<br/> 31<br/> 32<br/> 33<br/> 34<br/> 35<br/> 36<br/> 37<br/> 38<br/> 39<br/> 40<br/> 41<br/> 42<br/> 43<br/> 44<br/> 45<br/> 46<br/> 47<br/> 48<br/> 49<br/> 50<br/> 51<br/> 52<br/> 53<br/> 54<br/> 55<br/> 56<br/> 57<br/> 58<br/> 59<br/> 60<br/> 61<br/> 62<br/> 63<br/> 64<br/> 65<br/> 66<br/> 67<br/> 68<br/> 69<br/> 70<br/> 71<br/> 72<br/> 73<br/> 74<br/> 75<br/> 76<br/> 77<br/> 78<br/> 79<br/> 80<br/> 81<br/> 82<br/> 83<br/> 84<br/> 85<br/> 86<br/> 87<br/> 88<br/> 89<br/> 90<br/> 91<br/> 92<br/> 93<br/> 94<br/> 95<br/> 96<br/> 97<br/> 98<br/> 99<br/>100<br/>101<br/>102<br/>103<br/>104<br/>105<br/>106<br/>107<br/>108<br/>109<br/>110<br/>111<br/>112<br/>113<br/>114<br/>115<br/>116<br/>117<br/>118<br/>119<br/>120<br/>121<br/>122<br/>123<br/>124<br/>125<br/>126<br/>127#include <cstring><br/><br/>#include <algorithm><br/>#include <iostream><br/><br/>using namespace std;<br/><br/>#define NMAX 400000<br/>#define MOD 998244353<br/>#define G 3<br/><br/>typedef long long i64;<br/><br/>inline i64 qpow(i64 a, int b) {<br/>    i64 r = 1;<br/>    for (; b; a = a * a %  MOD, b >>= 1)<br/>        if (b & 1) r = r * a %  MOD;<br/>    return r;<br/>}<br/><br/>inline i64 inv(i64 x) {<br/>    return qpow(x, MOD - 2);<br/>}<br/><br/>inline void add(i64 &a, i64 b) {<br/>    a += b;<br/>    if (a >= MOD) a -= MOD;<br/>    else if (a < 0) a += MOD;<br/>}<br/><br/>inline int nxtp(int n) {<br/>    int r = 1;<br/>    for (; r < n; r <<= 1);<br/>    return r;<br/>}<br/><br/>void fft(i64 *a, int n, bool in = false) {<br/>    static i64 b[NMAX + 10];<br/>    memcpy(b, a, sizeof(i64) * n);<br/>    for (int i = 0, k = 0, j; i < n; k |= j, i++) {<br/>        a[i] = b[k];<br/>        for (j = n >> 1; k & j; k ^= j, j >>= 1); <br/>    }<br/><br/>    for (int s = 2; s <= n; s <<= 1) {<br/>        int l = s >> 1;<br/>        i64 wn = qpow(G, in ? MOD - (MOD - 1) / s - 1 : (MOD - 1) / s);<br/>        for (int i = 0; i < n; i += s) {<br/>            i64 w = 1;<br/>            for (int j = i; j < i + l; j++) {<br/>                i64 t = a[j + l];<br/>                a[j + l] = (a[j] - w * t) %  MOD;<br/>                a[j] = (a[j] + w * t) %  MOD;<br/>                w = w * wn %  MOD;<br/>            }<br/>        }<br/>    }<br/><br/>    if (in) {<br/>        i64 d = inv(n);<br/>        for (int i = 0; i < n; i++) {<br/>            a[i] = a[i] * d %  MOD;<br/>        }<br/>    }<br/>}<br/><br/>static int n;<br/>static i64 q[NMAX + 10], c[NMAX + 10];<br/><br/>void initialize() {<br/>    ios::sync_with_stdio(false);<br/><br/>    cin >> n;<br/>    q[0] = 1;<br/><br/>    for (int i = 1; i <= n; i += 2) {<br/>        for (int j = i; j <= n; j += i) {<br/>            add(c[j], i);<br/>        }<br/>    }<br/>}<br/><br/>static i64 a[NMAX + 10], b[NMAX + 10];<br/><br/>void solve(int l, int r) {<br/>    if (l == r) {<br/>        if (l) q[l] = q[l] * inv(l) %  MOD;<br/>        return;<br/>    }<br/><br/>    int m = (l + r) >> 1;<br/>    solve(l, m);<br/><br/>    int alen = m - l + 1, blen = r - l + 1;<br/>    int len = nxtp(blen - 1);<br/><br/>    memset(a, 0, sizeof(i64) * len);<br/>    memset(b, 0, sizeof(i64) * len);<br/>    memcpy(a, q + l, sizeof(i64) * alen);<br/>    memcpy(b, c, sizeof(i64) * blen);<br/><br/>    fft(a, len);<br/>    fft(b, len);<br/>    for (int i = 0; i < len; i++) {<br/>        a[i] = a[i] * b[i] %  MOD;<br/>    }<br/>    fft(a, len, true);<br/><br/>    for (int i = alen; i < blen; i++) {<br/>        add(q[m + i - alen + 1], a[i]);<br/>    }<br/><br/>    solve(m + 1, r);<br/>}<br/><br/>int main() {<br/>    initialize();<br/><br/>    solve(0, n);<br/><br/>    for (int i = 0; i <= n; i++) {<br/>        cout << q[i] << \  \ ;<br/>    }<br/>    cout << \ \\n\ ;<br/><br/>    return 0;<br/>}<br/><br/><br/><br/><br/><br/><br/>这里也有下面两个证明：https://math.stackexchange.com/q/54976 ↩<br/><br/><br/>","tags": "分拆数 组合数学 FFT","url": "blog/2017-10-1/p-and-q.html"},
{"title": "计算纯电阻网络的等效电阻","text": "计算纯电阻网络的等效电阻<br/><br/>计算纯电阻网络的等效电阻，与计算烷烃的同分异构体数量，是许多学习 OI 的高中生想要解决的问题。不过相比于计算烷烃的同分异构体数量而言，这个问题简单很多。本文将介绍一种简单的等效电阻计算方法，并给出一个计算所有接入电路方案的等效电阻的算法。<br/><br/>基本概念<br/><br/>上图是电阻网络的一个示意图。其中矩形表示纯电阻，上面可能会标注它的阻值。粗线表示导线，导线的交点通常会是接线柱之类的东西，称之为节点，可以连入外部电路。我们的目标是，给出这个网络的结构、每个电阻的阻值以及接入外电路的两个节点（一个是电流流入的位置，另一个是电流流出的位置，如上图中的左边和右边两个不闭合的导线），计算出它的等效电阻，即电流经过电阻网络时的电压 $U$ 与流入电流 $I$ 之比。例如，上图表示的电阻网络的等效电阻为 $159/71\\;\\Omega \\approx 2.239\\;\\Omega$。<br/>为了方便表示，这里将电阻网络转为图论的模型。图中一共有 $n$ 个节点和 $m$ 个电阻，每个节点对应图中的点，每个电阻对应图中的一条边，用边权表示电阻的阻值。例如，上面展示的电阻网络可以表示为下面的形式：<br/><br/>接入电路后，每个电阻上都会通有电流，记为 $I$。电流有方向之分，如果某条边 $(u,\\;v)$ 上的的电流是从 $u$ 流向 $v$ 的，那么 $I_{uv} = -I_{vu} \\geqslant 0$。设这条边的电阻为 $R_{uv} = R_{vu}$，那么它的电压为 $U_{uv} = -U_{vu} = I_{uv}R_{uv}$。<br/>为了方便，我们称外部电流流入网络的节点为源点 $s$，从网络流出到外部电路的节点为汇点 $t$，$(s,\\;t)$ 称作一个点对。显然不同的源点和汇点计算出来的等效电阻会是不同的。<br/>计算一个点对<br/>首先我们需要知道比较直观的基尔霍夫定律：<br/><br/>基尔霍夫电流定律：所有进入某节点的电流的总和等于所有离开该节点的电流的总和。<br/>基尔霍夫电压定律：沿着闭合回路所有元件两端的电压的代数和等于零。<br/><br/>根据这两点，如何求出等效电阻呢？首先可以假定流入的电流为 $1\\;\\mathrm{A}$，然后就只需求出源点到汇点的电压即可。根据电压定律，我们可以知道从源点到汇点的任意一条路径的电压是定值。原因非常简单，对于两条不同的路径：<br/><br/>如果存在不重合的部分，我们对这个部分进行调整，在电压不变的情况下，将一条路径变为另外一条路径。如上图，设左边的分岔点为 $A$，右边的分岔点为 $B$，由于回路电压为 $0$，所以下面那一条从 $A$ 到 $B$ 的路径的电压 $U_1$ 与从 $B$ 到 $A$ 的电压 $U_2$ 的代数和为 $0$，即 $U_1 + U_2 = 0$，而靠上面的从 $A$ 到 $B$ 的电压 $U_3 = -U_2$，因此 $U_1 = U_3$，从而发现上述规律。由于假定流入的电流是 $1\\;\\mathrm{A}$，所以等效电阻等于电压的绝对值。<br/>为了求出电压，我们可以考虑求出每个电阻上的电流的情况。根据电流定律，对于每个节点，我们可以列出 $n$ 个方程。不过很不幸，这 $n$ 个方程中任意一个都可以被剩下 $n - 1$ 个方程表示出来，意思是我们只有 $n - 1$ 个方程是真正有用的。边数一共有 $m$ 条，也就是 $m$ 个未知数，还需要找出 $m - n + 1$ 个线性独立的方程才可以解出具体情况。碰巧的是，如果网络是连通的，那么对于它的任意一棵生成树，刚好有 $m - n + 1$ 条非树边，每条非树边均对应了一个环，可以依此和电压定律列出剩下的方程。<br/>得到了 $m$ 个方程，就可以直接使用高斯消元在 $\\Theta(m^3)$ 的时间复杂度内求出电流的分配情况了。得到每个电阻上经过的电流后，从源点到汇点任意找一条路径计算电压，就可以知道等效电阻。一般我们会选取 DFS 生成树来列出电压的方程，主要的原因就是 DFS 生成树上的非树边都是返祖边，方便遍历对应的环上的所有的边。<br/>我使用 Python 实现了上面所说的过程。不过偷了懒，是用 SymPy 解的方程......所以算的不是很快。具体的代码可以查看这里。<br/>计算所有点对<br/>想到可以计算所有点对等效电阻的初衷是由于计算不同点对时的列出方程组其实没有多大差别，只有源点和汇点列出的电流方程存在着一个常数。根据这一点，我们不妨多写几个变量 $x_1,\\;x_2,\\;...,\\;x_{n - 1}$，表示每个节点从外部电路得到的电流。之所以只到 $x_{n - 1}$，是因为电流方程只列出了 $n - 1$ 个。如果 $x_i = 0$ 表示节点 $i$ 没有直接与外部电路相连，而 $x_i = 1$ 和 $x_i = -1$ 分别表示从外部电路流入和流出到外部电路。在不预先指定源点和汇点的情况下把它们当做已知量写入方程。虽然现在有 $m + n - 1$ 个未知数却只有 $m$ 个方程，但是这个时候执行高斯消元可以得到每个电流与 $x_1,\\;...,\\;x_{n-1}$ 的关系（如 $I_1 = 2x_1 + 0.3x_3$）。如果再给出 $x_1,\\;...,\\;x_{n - 1}$ 的值，就可以直接算出每个电流的具体值。<br/>现在来指定源点 $s$ 和汇点 $t$。相当于之前新设的变量中，令 $x_s = 1$ 和 $x_t = -1$，其它的均为 $0$。因此只用 $\\Theta(n)$ 的时间就可以计算出所有电流值，也就可以算出电阻。由于点对总数只有 $\\Theta(n^2)$ 对，因此高斯消元后只需要 $\\Theta(n^3)$ 的时间就可以计算所有的等效电阻。在连通图中，存在 $m \\geqslant n - 1$，因此总的复杂度依然为 $\\Theta(m^3)$。<br/>我的 C++ 实现可以在这里查看。","tags": "电阻网络 高斯消元","url": "blog/2017-10-28/resist.html"},
{"title": "诱导排序与SA-IS算法","text": "诱导排序与SA-IS算法<br/>SA-IS是一种在实际运用中相当快速的线性时间构建字符串的后缀数组的算法。本文将通过对原论文1进行一些翻译和总结来介绍该算法。最后会提供一个SA-IS算法的C++实现。<br/>1. 记号<br/>现在先规定一些记号，以方便之后的讨论。<br/>我们通常使用大写字母$S, A, B, \\dots$来表示一个字符串，小写字母$a, b, c, \\dots$表示单个的字符。字符通常被认为是一个整数。字符在一定条件下数量是有限的，我们将所有会用到的字符放入字符集$\\Sigma$中，此时$|\\Sigma|$表示字符集的大小。字符串之间可以任意连接，如$AB$表示字符串$A$与字符串$B$依次连接而成的新字符串。字符串与单个字符之间也是如此。特别的，我们将空串记为$\\epsilon$。<br/>对于一个字符串我们可以访问其中的任意字符，用$S[x]$表示$S$中下标为$x$的字符。下标从$0$开始。我们用$S[a, b]$表示$S$的一个子串，即下标为$a$的字符开始一直到下标为$b$的字符依次连接而成的字符串，其中必须满足$0 \\le a \\le b \\lt |S|$。定义一个字符串$S$的前缀为$\\text{prefix}(S, i) = S[0, i]$，其后缀为$\\text{suffix}(S, i) = S[i, |S| - 1]$。<br/>两个字符串$A$和$B$之间存在比较关系。当$A$与$B$的长度相同，且其中对应下标的字符也相同时，则为$A = B$。当从左至右出现第一对不相同的字符时，则以这两个字符的大小关系作为$A$和$B$间的大小关系，这称为字典序。为了简化一些操作，定义$\\#$是字典序最小的字符，并且将其默认作为每个字符串的最后一个字符2，即作为$S[|S|]$。<br/>另外，定义函数$\\text{lcp}(A, B)$表示$A$和$B$的最长公共前缀的长度，即两者所有相同的前缀中，最长的一个的长度。由此我们可以得知字典序的一个性质：<br/>定理 1.1 $A < B$当且仅当$A[\\text{lcp}(A, B)] < B[\\text{lcp}(A, B)]$。<br/>证明 这个结论显然成立，因为$\\text{prefix}(A, \\text{lcp}(A, B) - 1) = \\text{prefix}(B, \\text{lcp}(A, B) - 1)$。<br/>2. SA-IS算法<br/>SA-IS算法是基于诱导排序这种思想。基本想法就是将问题的规模缩小，通过解决更小的问题，获取足够信息，就可以快速的解决原始问题。从这里也可以看出，这一过程需要递归处理子问题。<br/>在介绍SA-IS算法前，我们先来看一下该算法的基本框架：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17function SA-IS(S):<br/>    t = bool[]<br/>    S1 = int[]<br/>    P = int[]<br/>    bucket = int[]<br/>    扫描倒序字符串确定每一个后缀的类型 -> t<br/>    扫描t数组确定所有的LMS子串 -> P<br/>    对所有的LMS子串进行诱导排序<br/>    对每一个LMS子串重新命名，生成新的串S1<br/><br/>    if S1中的每一个字符都不一样:<br/>        直接计算SA1<br/>    else<br/>        SA1 = SA-IS(S1)  # 递归计算SA1<br/><br/>    利用SA1来进行诱导排序，计算SA<br/>    return SA<br/><br/><br/>现在你不会明白这里面都写了些什么东西，因为这只是一个简单的流程。接下来将会介绍其中的每一步并证明其正确性。<br/>2.1 后缀类型<br/>在第6行中，确定后缀的类型可能会令人无法理解，这是因为我们还没有定义什么是后缀的类型......<br/>对于每一个后缀$\\text{suffix}(S, i)$，当$\\text{suffix}(S, i) < \\text{suffix}(S, i + 1)$时，是$S$型后缀。当$\\text{suffix}(S, i) > \\text{suffix}(S, i + 1)$时，是$L$型后缀。对于特殊的后缀$\\text{suffix}(S, |S|) = \\#$，它默认为$S$型。<br/>例如，对于字符串mmiissiissiippii，每一后缀的类型为：<br/>1<br/>2<br/>3      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16<br/>S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #<br/>t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S<br/><br/><br/>既然我们需要得知每一个后缀类型，就需要一个快速的算法来计算。在此之前，我们发现它们有如下的性质：<br/>引理 2.1 (后缀类型递推性质) 对于任意的$i \\in [0, |S| - 1]$:<br/>如果$t[i] = \\text{S-type}$，当且仅当下面任意一项成立：<br/><br/>$S[i] < S[i + 1]$<br/>$S[i] = S[i + 1]$且$t[i + 1] = \\text{S-type}$<br/><br/>如果$t[i] = \\text{L-type}$，当且仅当下面任意一项成立：<br/><br/>$S[i] > S[i + 1]$<br/>$S[i] = S[i + 1]$且$t[i + 1] = \\text{L-type}$<br/><br/>证明 这里证明$S$型的，$L$型是类似的。对于第一种情况，显然是成立的。对于第二种情况，我们设$\\text{suffix}(S, i) = aA, \\text{suffix}(S, i + 1) = aB$。由于第一个字符是相同的，因此我们需要比较$A$和$B$的大小。因为它们是连续的后缀，所以$A = \\text{suffix}(S, i + 1), B = \\text{suffix}(S, i + 2)$。由于我们是从右往左推出$t$，所以$A$与$B$的关系实际上可以由$t[i + 1]$给出。故$t[i] = t[i + 1]$。<br/>因此，我们可以在$\\Theta(|S|)$的时间内，推出整个$t$数组。<br/>关于后缀类型，我们还可得出另外一个比较重要的性质：<br/>引理 2.2 (后缀类型指导排序) 对于两个后缀$A$和$B$，如果$A[0] = B[0]$且$A$是$S$型，$B$是$L$型，则$A < B$。<br/>证明 设$A = abX, B = acY$，这里假设$a \\neq b, a \\neq c$。因为$A$是$S$型，所以可知$a < b$。同理，$B$是$L$型，可知$a > c$。故$ c < a < b$，所以$A < B$。如果$a = b, a = c$，则我们可以将第一个字符去掉，得到新的后缀来进行比较。根据引理 2.1，去掉第一个字符后的后缀类型不变。因此我们可以通过这样的操作从而变为第一种情况。<br/>2.2 LMS子串<br/>然而光有后缀类型，还不足以进行排序。因此我们在后缀类型的$S$型中挑出特别的一类，记为$*$型。$*$型是$S$型的一种，它的特殊之处在于它要求它的左边的后缀必须是$L$型的。依然以mmiissiissiippii为例：<br/>1<br/>2<br/>3<br/>4      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16<br/>S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #<br/>t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S<br/>            *           *           *                 *<br/><br/><br/>可以将其理解为一连串的$S$型中最靠左的一个。LMS (LeftMost S-type)也正是这个意思。同时我们注意到，后缀$\\#$始终是$*$型的。<br/>对于每一个$*$型所对应上的字符，我们称为LMS字符。上面的示例中，下标为$2, 6, 10, 16$都是LMS字符。<br/>位置相邻的两个LMS字符中间(包括这两个字符)所构成的子串，称为LMS子串。对于mmiissiissiippii，其LMS子串依次为iissi、iissi、iippii#和#。<br/>通过观察，我们发现LMS子串具有以下的性质：<br/>引理 2.3 #是最短的LMS子串。<br/>引理 2.4 对于任意的非#的LMS子串，其长度大于$2$。<br/>证明 因为两个LMS字符中间必定有一个$L$型的后缀。<br/>引理 2.5 (原串折半) 一个字符串中LMS子串的数量不超过$\\left\\lceil{|S| / 2}\\right\\rceil$。<br/>证明 根据引理2.4可知。<br/>引理 2.6 一个字符串的所有LMS子串的长度之和为$O(|S|)$。<br/>此外，对于LMS子串间的大小比较，除了对每个字符的字典序进行比较外，还要对比每个字符所对应的后缀类型。$S$型的有更高的优先权，因为根据引理2.2可得，$S$型的后缀字典序更大。只有当每一个字符与其后缀类型都相同时，这两个LMS子串才被称为是相同的。<br/>之所以这样定义，是因为在之后我们会利用LMS子串来进行对后缀的排序。如果缺少后缀类型的信息，就不能够任务。<br/>根据引理2.6，我们可以利用基数排序在$O(|S|)$的时间内对所有的LMS子串排序3。对LMS子串排序完后，我们按照字典序依次重新命名4，注意，如果两个LMS子串相同，则使用同样的名称5。这样给每个LMS子串命名后，按照其子串原有的顺序排出一个新串$S_1$。继续以mmiissiissiippii为例：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16<br/>S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #<br/>t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S<br/>            *           *           *                 *<br/>新名称      2           2           1                 0<br/>S1:   2 2 1 0<br/><br/><br/>这样有什么用呢？我们发现，这实际上是将所有$*$型的后缀进行了缩减，从而减小了问题的规模。对于这一点，我们有如下的引理：<br/>引理 2.7 (问题缩减) $S_1$中两个后缀的字典序关系，就是$S$中对应的$*$型后缀的字典序关系。<br/>证明 我们可以将$S_1$视为是将$*$后缀中不重合的部分进行切割并缩减。这样每一个LMS子串就可作为一个整体来进行比较。从而保持了这两者的一致性。<br/>需要注意的是这里只是$*$型后缀的字典序关系，与其它后缀无关。<br/>2.3 从SA1诱导至SA<br/>从上面的引理2.7我们得知，只要获得了$S_1$的后缀数组$SA_1$，就可以得到所有$*$型后缀的相对顺序。如果我们可以利用$*$型后缀的相对顺序来对其它的$L$型和$S$型后缀6进行排序，就可以完成后缀数组的计算。<br/>在这里我们先假定$SA_1$已经计算出来，只需考虑如何计算$SA$。在这之前，我们先观察一下后缀数组的形式。以aabaaaab为例，它的后缀数组是这样的：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9#<br/>aaaab#<br/>aaab#<br/>aab#<br/>aabaaaab#<br/>ab#<br/>abaaaab#<br/>b#<br/>baaaab#<br/><br/><br/>不难发现，首字母相同的后缀是连续排布的，这一点可以用反证法来证明。因此我们可以利用桶排序的思想，为每一个出现过的字符建立一个桶，用$SA$数组来存储这些桶，每个桶之间按照字典序排列，这样就可以使后缀数组初步有序。<br/>我们对每个后缀都赋予了一个后缀类型，那么在首字母一样的情况下，$S$型或$L$型会连续分布吗？答案是肯定的。因为根据引理2.2，首字母相同的后缀如果后缀类型不同，则相对顺序是确定的。因此易知不会出现$S$型和$L$型交替出现的情况。更进一步，由于$L$型后缀更小，因此总是先排布$L$型后缀，再排布$S$型后缀。因此每一个字符的桶可以分为两部分，一个用于放置$L$型后缀，另一个则用于$S$型后缀。为了方便确定每一个桶的起始位置，$S$型后缀的桶的放置是倒序的。<br/>但是如果首字母和后缀类型都一致，我们不能直接快速地判断大小关系。在这里就要利用到诱导排序了。<br/>诱导排序的过程分为以下几步：<br/><br/>将$SA$数组初始化为每个元素都为$-1$的数组。<br/>确定每个桶$S$型桶的起始位置。将$SA_1$中的每一个$*$型后缀按照$SA_1$中的顺序放入相应的桶内。<br/>确定每个桶$L$型桶的起始位置。在$SA$数组中从左往右扫一遍。如果$SA[i] > 0$且$t[SA[i] - 1] = \\text{L-type}$，则将$SA[i] - 1$所代表的后缀放入对应的桶中。<br/>重新确定每个桶$S$型桶的起始位置，因为所有的$*$型后缀要重新被排序。由于$S$型桶是逆序排放的，所以这次从右至左地扫描一遍$SA$。如果$SA[i] > 0$且$t[SA[i] - 1] = \\text{S-type}$，则将$SA[i] - 1$所代表的后缀放入对应的桶中。<br/><br/>这样我们就可以完成从$SA_1$诱导到$SA$的排序工作。这里简单说明一下为什么这样做是正确的：首先对于所有的$*$型后缀，都是有序排放的。从左至右扫描$SA$数组实际上就是按照字典序扫描现有的已排序的后缀。对于两个相邻的$L$型后缀$A$和$B$，这里假设$|A| > |B|$，则必定有$A > B$。由于$B$会被先加入$SA$中，所以我们保证了$A$和$B$之间的有序性。又因为$L$型桶是从左往右的顺序加入的，所以所有的$L$型后缀会逐步地按顺序加入到$SA$中。最后所有的$L$型后缀将会有序。<br/>对于$S$型后缀，除了要注意是相反的顺序和需要重新对$*$型后缀排序外，其余的原理与$L$型的排序类似。<br/>之前的讨论都是基于我们已知$SA_1$的情况下进行的。现在我们来考虑如何计算$SA_1$。由于$S_1$也是一个字符串，计算其后缀数组时可以考虑两种情况：<br/><br/>如果$S_1$中每一个字符都不一样，则可以直接利用桶排序直接计算$SA_1$。<br/>否则，递归计算$SA_1$。就如之前的算法框架所展示的一样。<br/><br/>2.4 对LMS子串排序<br/>到这里，SA-IS算法几乎已经结束了，只是还有一个问题需要解决，就是对LMS子串的排序。<br/>之前我们所提及的，我们可以利用基数排序。虽然可以在$O(|S|)$的时间内完成，但是事实上，这个基数排序不但常熟大，而且十分复杂(请想象一下对字符串进行基数排序......)。这个排序直接成为了整个算法的性能瓶颈。因此我们急切的需要一种新的算法来胜任这一任务。<br/>这个算法依然是诱导排序。<br/>与之前从$SA_1$诱导到$SA$的算法一样，只是我们这里将第二步改为：<br/><br/>确定每个桶$S$型桶的起始位置。将每一个LMS子串的首字母按照任意顺序放入对应的桶中。<br/><br/>待算法完成，我们会获得一个$SA$数组，其中LMS子串之间是排好了序的。<br/>为什么这个算法是正确的，我们需要扯到一个新的概念：LMS前缀。<br/>规定LMS前缀函数$\\text{pre}(S, i)$表示 (1) 如果$\\text{suffix}(S, i)$是$*$型的，则$\\text{pre}(S, i) = S[i]$，即LMS字符的LMS前缀就是自己。 (2) 否则是从$S[i]$开始，到下一个LMS字符之间(包括首尾)的子串。同样的，按照$\\text{suffix}(S, i)$的后缀类型的不同，LMS前缀也同样分为$S$型和$L$型。<br/>例如，在mmiissiissiippii中，$\\text{pre}(S, 2) = S[2] =$ i，而$\\text{pre}(S, 3) = S[3, 6] =$ issi。<br/>因此上面的算法实际上是在对每个LMS前缀进行排序。<br/>接下来将证明2-4步都是正确的，即每一步完成时$SA$数组中，LMS前缀都是有序的。<br/><br/>对于第二步，由于放入的LMS前缀都只有一个字符，因为桶的排列是按照字典序的，所以保证放置后一定有序。<br/>对于第三步，当放入第一个$L$型LMS前缀时，$SA$数组必定是有序的(根据引理2.2)。假设我们已经放置了$k$个$L$型LMS前缀，且它们在$SA$数组中保持有序，现在考虑放入的第$k + 1$个LMS前缀是否会保证有序。我们设这个LMS前缀为$\\text{pre}(S, i)$，因为首字母不同的LMS前缀一定是保持有序的，因此我们只需要考虑它与其首字母相同的LMS前缀之间的关系。因为我们是从左至右扫描来使$L$型LMS前缀从小至大放置，那么对于所有之前放置的且首字母与其相同的LMS前缀$\\text{pre}(S, j)$，应该都有$\\text{pre}(S, j) < \\text{pre}(S, i)$。假设我们存在一个这样的LMS前缀，使得$\\text{pre}(S, j) > \\text{pre}(S, i)$，由于$\\text{pre}(S, j)[0] = \\text{pre}(S, i)[0]$，所以我们得知$\\text{pre}(S, j + 1) > \\text{pre}(S, i + 1)$。而$\\text{pre}(S, j + 1)$与$\\text{pre}(S, i + 1)$都是之前所加入过的，因此它们之间应当保持有序。而$\\text{pre}(S, j) > \\text{pre}(S, i)$告诉我们之前的$SA$数组不是有序的，与假设相反，故不存在这样的$\\text{pre}(S, j)$。因此，当$\\text{pre}(S, i)$放置后，$SA$数组保持有序。直到所有的$L$型LMS前缀加入完毕。<br/>对于第四步的正确性的证明，与第三步的证明是类似的。读者可以自行推理一下。<br/><br/>这样，我们就完成了对这个诱导排序的正确性的证明。但我们需要注意的是，这只是对LMS前缀的排序，我们期望是对LMS子串进行排序。我们注意到每一个LMS子串都可以视为是一个LMS字符与一个LMS前缀连接而成的，因此我们只需要判断两个LMS字符和其后一位对应的LMS前缀的大小关系，就可以判断LMS子串之间的大小关系。<br/>然而，我们其实可以做得更简单。下面的引理说明了上面的算法结束后的$SA$数组就是排好序的LMS子串的数组。<br/>引理 2.8 (LMS子串排序) $SA$数组中每一个LMS字符所对应的LMS前缀已经按照其对应的LMS子串的顺序排好。<br/>证明 对于首字母不同的LMS子串，这个结论是显然的。<br/>对于首字母相同的LMS子串，它必定是由一个$L$型LMS前缀从右至左的推导过来的。由于不同的LMS子串必定对应着不同的递推的顺序，并且在第二步中，所有的$L$型LMS前缀已经排好了序。所以结论成立。<br/>根据这个引理，我们可以直接对$SA$数组扫描一遍，就可以得到LMS子串的字典序，同时对它们进行命名。<br/>3. 时空复杂度分析<br/>在之前的讨论中，我们已经成功的运用诱导排序使每一步都是$\\Theta(|S|)$。但是由于有一个递归的过程，时间复杂度似乎并不一定是线性的。<br/>我们注意到，每次递归都是计算$S_1$的后缀数组。如果我们能够知道$S_1$的规模，就能够计算SA-IS的事件复杂度。<br/>根据引理2.5，我们得知$|S_1| \\le \\left\\lceil|S| / 2\\right\\rceil$。因此每一层的递归的问题规模都会减半。因此我们可以用以下的递归式来表示时间复杂度：<br/>$$ T(n) = T(\\left\\lceil n/2\\right\\rceil) + \\Theta(n) \\tag{3.1} $$<br/>求解可得：<br/>$$ T(n) = \\Theta(n) \\tag{3.2} $$<br/>因此总时间复杂度是$\\Theta(n)$的。<br/>对于这个递归式，我们可以理解为是递归了$O(\\log n)$层，其中每一层的问题规模从小到大排序是$2^0, 2^1, 2^2, \\dots, 2^{\\left\\lfloor\\log n\\right\\rfloor}$。因此总复杂度就是对它们进行求和：<br/>$$ \\sum^{\\left\\lfloor\\log n\\right\\rfloor}_{k=0} 2^k = 2 \\times 2^{\\left\\lfloor\\log n\\right\\rfloor} = \\Theta(2^{\\left\\lfloor\\log n\\right\\rfloor}) = \\Theta(n) \\tag{3.3} $$<br/>对于空间复杂度的分析，与时间复杂度是如出一辙的。<br/>4. 运行示例<br/>下面将用aabaaaab作为输入字符串，展示计算其后缀数组的每一步。希望能通过这个示例能够更清晰地展现SA-IS算法的运作流程。由于涉及到对桶的操作，这里用@表示正在被处理的元素，而用^表示每个桶的起始位置。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28<br/>29<br/>30<br/>31<br/>32<br/>33<br/>34<br/>35<br/>36<br/>37<br/>38<br/>39<br/>40<br/>41<br/>42<br/>43<br/>44<br/>45<br/>46<br/>47<br/>48<br/>49<br/>50<br/>51<br/>52<br/>53<br/>54<br/>55<br/>56<br/>57<br/>58<br/>59<br/>60<br/>61<br/>62<br/>63<br/>64<br/>65<br/>66<br/>67<br/>68<br/>69<br/>70<br/>71<br/>72<br/>73<br/>74<br/>75<br/>76<br/>77<br/>78<br/>79<br/>80<br/>81<br/>82<br/>83           0  1  2  3  4  5  6  7  8<br/>S:         a  a  b  a  a  a  a  b  #<br/>扫描后缀类型<br/>t:         S  S  L  S  S  S  S  L  S<br/>LMS characters:     *              *<br/>         |# |       a         |  b  |  # 桶的名称<br/>SA:       -1|-1 -1 -1 -1 -1 -1|-1 -1<br/>对LMS子串进行排序<br/>1. 放入LMS子串<br/>SA:       08|-1 -1 -1 -1 -1 03|-1 -1<br/>2. 从*型LMS前缀诱导到L型LMS前缀<br/>SA:       08|-1 -1 -1 -1 -1 03|-1 -1<br/>          @^  ^                 ^<br/>SA:       08|-1 -1 -1 -1 -1 03|07 -1<br/>           ^  ^             @      ^<br/>SA:       08|-1 -1 -1 -1 -1 03|07 02  # pre(S, 6)不是L型的<br/>           ^  ^                @   ^<br/>SA:       08|-1 -1 -1 -1 -1 03|07 02<br/>           ^  ^                   @^<br/>SA:       08|-1 -1 -1 -1 -1 03|07 02<br/>3. 从L型LMS前缀诱导到S型前缀<br/>SA:       08|-1 -1 -1 -1 -1 03|07 02<br/>           ^                 ^    @^<br/>SA:       08|-1 -1 -1 -1 -1 01|07 02<br/>           ^              ^    @   ^<br/>SA:       08|-1 -1 -1 -1 06 01|07 02<br/>           ^           ^    @      ^<br/>SA:       08|-1 -1 -1 00 06 01|07 02<br/>           ^        ^    @         ^<br/>SA:       08|-1 -1 05 00 06 01|07 02  # 不存在pre(S, -1)<br/>           ^     ^    @            ^<br/>SA:       08|-1 -1 05 00 06 01|07 02<br/>           ^     ^ @               ^<br/>SA:       08|-1 04 05 00 06 01|07 02<br/>           ^  ^ @                  ^<br/>SA:       08|03 04 05 00 06 01|07 02<br/>           ^ @^                    ^<br/>SA:       08|03 04 05 00 06 01|07 02  # pre(S, 7)不是S型的<br/>          @^  ^                    ^<br/>SA:       08|03 04 05 00 06 01|07 02<br/>扫描并重命名LMS子串<br/>name:      1  2<br/>S1:       2 1 0<br/>由于每一个字符都不一样，直接计算SA1<br/>SA1：     2 1 0<br/>从SA1诱导到SA<br/>         |$ |       a         |  b  |<br/>SA:       -1|-1 -1 -1 -1 -1 -1|-1 -1<br/>1. 按照SA1的原顺序放入(忽略S1最后的字符)<br/>SA:       08|-1 -1 -1 -1 -1 03|-1 -1<br/>           ^  ^                 ^<br/>2. 从*型后缀诱导到L型后缀<br/>SA:       08|-1 -1 -1 -1 -1 03|-1 -1<br/>          @^  ^                 ^<br/>SA:       08|-1 -1 -1 -1 -1 03|07 -1<br/>           ^  ^             @      ^<br/>SA:       08|-1 -1 -1 -1 -1 03|07 02<br/>           ^  ^                @   ^<br/>SA:       08|-1 -1 -1 -1 -1 03|07 02<br/>           ^  ^                   @^<br/>3. 从L型后缀诱导到S型后缀<br/>SA:       08|-1 -1 -1 -1 -1 03|07 02<br/>           ^                 ^    @^<br/>SA:       08|-1 -1 -1 -1 -1 01|07 02<br/>           ^              ^    @   ^<br/>SA:       08|-1 -1 -1 -1 06 01|07 02<br/>           ^           ^    @      ^<br/>SA:       08|-1 -1 -1 00 06 01|07 02<br/>           ^        ^    @         ^<br/>SA:       08|-1 -1 05 00 06 01|07 02<br/>           ^     ^    @            ^<br/>SA:       08|-1 -1 05 00 06 01|07 02<br/>           ^     ^ @               ^<br/>SA:       08|-1 04 05 00 06 01|07 02<br/>           ^  ^ @                  ^<br/>SA:       08|03 04 05 00 06 01|07 02  # pre(S, 2)是L型<br/>           ^ @^                    ^<br/>SA:       08|03 04 05 00 06 01|07 02<br/>          @^  ^                    ^<br/>后缀数组构造完毕<br/>SA: 8 3 4 5 0 6 1 7 2<br/><br/>return SA<br/><br/><br/>5. 具体实现及性能对比<br/>在原论文中说道SA-IS算法可以在100行左右的代码完成。我试了一下，基本符合这个要求。下面将会给出一个C++实现。需要注意的是，为了方便，这份代码中并没有回收分配的内存。<br/>  1<br/>  2<br/>  3<br/>  4<br/>  5<br/>  6<br/>  7<br/>  8<br/>  9<br/> 10<br/> 11<br/> 12<br/> 13<br/> 14<br/> 15<br/> 16<br/> 17<br/> 18<br/> 19<br/> 20<br/> 21<br/> 22<br/> 23<br/> 24<br/> 25<br/> 26<br/> 27<br/> 28<br/> 29<br/> 30<br/> 31<br/> 32<br/> 33<br/> 34<br/> 35<br/> 36<br/> 37<br/> 38<br/> 39<br/> 40<br/> 41<br/> 42<br/> 43<br/> 44<br/> 45<br/> 46<br/> 47<br/> 48<br/> 49<br/> 50<br/> 51<br/> 52<br/> 53<br/> 54<br/> 55<br/> 56<br/> 57<br/> 58<br/> 59<br/> 60<br/> 61<br/> 62<br/> 63<br/> 64<br/> 65<br/> 66<br/> 67<br/> 68<br/> 69<br/> 70<br/> 71<br/> 72<br/> 73<br/> 74<br/> 75<br/> 76<br/> 77<br/> 78<br/> 79<br/> 80<br/> 81<br/> 82<br/> 83<br/> 84<br/> 85<br/> 86<br/> 87<br/> 88<br/> 89<br/> 90<br/> 91<br/> 92<br/> 93<br/> 94<br/> 95<br/> 96<br/> 97<br/> 98<br/> 99<br/>100<br/>101<br/>102<br/>103<br/>104<br/>105<br/>106<br/>107<br/>108<br/>109<br/>110<br/>111<br/>112<br/>113<br/>114<br/>115<br/>116<br/>117<br/>118<br/>119<br/>120<br/>121<br/>122<br/>123<br/>124<br/>125<br/>126<br/>127<br/>128<br/>129<br/>130// 后缀类型<br/>#define L_TYPE 0<br/>#define S_TYPE 1<br/><br/>// 判断一个字符是否为LMS字符<br/>inline bool is_lms_char(int *type, int x) {<br/>    return x > 0 && type[x] == S_TYPE && type[x - 1] == L_TYPE;<br/>}<br/><br/>// 判断两个LMS子串是否相同<br/>inline bool equal_substring(int *S, int x, int y, int *type) {<br/>    do {<br/>        if (S[x] != S[y])<br/>            return false;<br/>        x++, y++;<br/>    } while (!is_lms_char(type, x) && !is_lms_char(type, y));<br/><br/>    return S[x] == S[y];<br/>}<br/><br/>// 诱导排序(从*型诱导到L型、从L型诱导到S型)<br/>// 调用之前应将*型按要求放入SA中<br/>inline void induced_sort(int *S, int *SA, int *type, int *bucket, int *lbucket,<br/>                         int *sbucket, int n, int SIGMA) {<br/>    for (int i = 0; i <= n; i++)<br/>        if (SA[i] > 0 && type[SA[i] - 1] == L_TYPE)<br/>            SA[lbucket[S[SA[i] - 1]]++] = SA[i] - 1;<br/>    for (int i = 1; i <= SIGMA; i++)  // Reset S-type bucket<br/>        sbucket[i] = bucket[i] - 1;<br/>    for (int i = n; i >= 0; i--)<br/>        if (SA[i] > 0 && type[SA[i] - 1] == S_TYPE)<br/>            SA[sbucket[S[SA[i] - 1]]--] = SA[i] - 1;<br/>}<br/><br/>// SA-IS主体<br/>// S是输入字符串，length是字符串的长度, SIGMA是字符集的大小<br/>static int *SAIS(int *S, int length, int SIGMA) {<br/>    int n = length - 1;<br/>    int *type = new int[n + 1];  // 后缀类型<br/>    int *position = new int[n + 1];  // 记录LMS子串的起始位置<br/>    int *name = new int[n + 1];  // 记录每个LMS子串的新名称<br/>    int *SA = new int[n + 1];  // SA数组<br/>    int *bucket = new int[SIGMA];  // 每个字符的桶<br/>    int *lbucket = new int[SIGMA];  // 每个字符的L型桶的起始位置<br/>    int *sbucket = new int[SIGMA];  // 每个字符的S型桶的起始位置<br/><br/>    // 初始化每个桶<br/>    memset(bucket, 0, sizeof(int) * (SIGMA + 1));<br/>    for (int i = 0; i <= n; i++)<br/>        bucket[S[i]]++;<br/>    for (int i = 1; i <= SIGMA; i++) {<br/>        bucket[i] += bucket[i - 1];<br/>        lbucket[i] = bucket[i - 1];<br/>        sbucket[i] = bucket[i] - 1;<br/>    }<br/><br/>    // 确定后缀类型(利用引理2.1)<br/>    type[n] = S_TYPE;<br/>    for (int i = n - 1; i >= 0; i--) {<br/>        if (S[i] < S[i + 1])<br/>            type[i] = S_TYPE;<br/>        else if (S[i] > S[i + 1])<br/>            type[i] = L_TYPE;<br/>        else<br/>            type[i] = type[i + 1];<br/>    }<br/><br/>    // 寻找每个LMS子串<br/>    int cnt = 0;<br/>    for (int i = 1; i <= n; i++)<br/>        if (type[i] == S_TYPE && type[i - 1] == L_TYPE)<br/>            position[cnt++] = i;<br/><br/>    // 对LMS子串进行排序<br/>    fill(SA, SA + n + 1, -1);<br/>    for (int i = 0; i < cnt; i++)<br/>        SA[sbucket[S[position[i]]]--] = position[i];<br/>    induced_sort(S, SA, type, bucket, lbucket, sbucket, n, SIGMA);<br/><br/>    // 为每个LMS子串命名<br/>    fill(name, name + n + 1, -1);<br/>    int lastx = -1, namecnt = 1;  // 上一次处理的LMS子串与名称的计数<br/>    bool flag = false;  // 这里顺便记录是否有重复的字符<br/>    for (int i = 1; i <= n; i++) {<br/>        int x = SA[i];<br/><br/>        if (is_lms_char(type, x)) {<br/>            if (lastx >= 0 && !equal_substring(S, x, lastx, type))<br/>                namecnt++;<br/>            // 因为只有相同的LMS子串才会有同样的名称<br/>            if (lastx >= 0 && namecnt == name[lastx])<br/>                flag = true;<br/><br/>            name[x] = namecnt;<br/>            lastx = x;<br/>        }<br/>    }  // for<br/>    name[n] = 0;<br/><br/>    // 生成S1<br/>    int *S1 = new int[cnt];<br/>    int pos = 0;<br/>    for (int i = 0; i <= n; i++)<br/>        if (name[i] >= 0)<br/>            S1[pos++] = name[i];<br/><br/>    int *SA1;<br/>    if (!flag) {<br/>        // 直接计算SA1<br/>        SA1 = new int[cnt + 1];<br/><br/>        for (int i = 0; i < cnt; i++)<br/>            SA1[S1[i]] = i;<br/>    } else<br/>        SA1 = SAIS(S1, cnt, namecnt);  // 递归计算SA1<br/><br/>    // 从SA1诱导到SA<br/>    lbucket[0] = sbucket[0] = 0;<br/>    for (int i = 1; i <= SIGMA; i++) {<br/>        lbucket[i] = bucket[i - 1];<br/>        sbucket[i] = bucket[i] - 1;<br/>    }<br/>    fill(SA, SA + n + 1, -1);<br/>    for (int i = cnt - 1; i >= 0; i--)  // 这里是逆序扫描SA1，因为SA中S型桶是倒序的<br/>        SA[sbucket[S[position[SA1[i]]]]--] = position[SA1[i]];<br/>    induced_sort(S, SA, type, bucket, lbucket, sbucket, n, SIGMA);<br/><br/>    // 后缀数组计算完毕<br/>    return SA;<br/>}<br/><br/><br/>SA-IS的实现还可以参考一篇很好的博文: A walk through the SA-IS Suffix Array Construction Algorithm，这篇文章的作者使用Python一步一步地介绍了如何实现一个基础的SA-IS算法。<br/>我们看到SA-IS作为一个后缀排序的算法，代码量也并不小，然而实际上它速度非常快，其中一个重要的原因就是SA-IS算法几乎所有的操作都是顺序访问的，这样就可以很好地提高缓存命中率7。原论文中实测SA-IS算法击败了KA算法，不愧为目前为止速度最快的后缀数组的构建算法。<br/>对中学OI界，构造后缀数组通常是使用倍增法和DC3算法。倍增法速度比DC3算法慢是众所周知的了，下面我将用不同规模的随机字符串来比较DC3算法与SA-IS算法。<br/><br/><br/><br/>数据规模<br/>DC3<br/>SA-IS<br/><br/><br/><br/><br/>$10^4$<br/>$0.015\\text{s}$<br/>$0.011\\text{s}$<br/><br/><br/>$10^5$<br/>$0.055\\text{s}$<br/>$0.036\\text{s}$<br/><br/><br/>$10^6$<br/>$0.365\\text{s}$<br/>$0.270\\text{s}$<br/><br/><br/>$2\\times 10^6$<br/>$0.997\\text{s}$<br/>$0.593\\text{s}$<br/><br/><br/>$5\\times 10^6$<br/>$2.803\\text{s}$<br/>$2.085\\text{s}$<br/><br/><br/>$10^7$<br/>$4.012\\text{s}$<br/>$3.326\\text{s}$<br/><br/><br/><br/>编译命令: g++ SAIS.cpp/DC3.cpp -o sais/dc3 -O3<br/>运行环境: Ubuntu 14.04 LTS x64 / CPU: 2.0GHz 奔腾某CPU / 4GB内存 / 未启动X window<br/>从上面的结果可以看出，SA-IS算法速度上明显优于DC3算法，并且数据规模越大，两者的速度差距越明显。<br/>总而言之，SA-IS算法是一个相当不错的后缀数组的构建算法。似乎SA-IS算法所利用的诱导排序的思想还可以解决其它的一些字符串的问题，如计算LCP数组8，我并没有对此做过多的了解了。<br/><br/><br/><br/><br/>Nong, Ge; Zhang, Sen; Chan, Wai Hong (2009): Linear Suffix Array Construction by Almost Pure Induced-Sorting ↩<br/><br/><br/>这里的$\\#$并不是指井号，而是一个特殊记号。字符串中不会出现这个字符。 ↩<br/><br/><br/>后面我们将会有更好的算法来对LMS子串排序，时间复杂度一致，但在实际运用中速度快很多。 ↩<br/><br/><br/>注意之后会创建新字符串$S_1$，其字符集$\\Sigma$是不同的。 ↩<br/><br/><br/>判断两个LMS子串是否相等可以暴力判断，基于引理2.6，可以证明其总复杂度为$O(|S|)$。 ↩<br/><br/><br/>注意$*$型后缀也属于$S$型后缀，因此会对它们进行重排，从而确保新加入的$S$型后缀的顺序是对的。 ↩<br/><br/><br/>即降低cache-missing。 ↩<br/><br/><br/>Johannes Fischer (2011): Inducing the LCP-Array ↩<br/><br/><br/>","tags": "数据结构 字符串 后缀数组 诱导排序 SA-IS","url": "blog/2016-6-19/sais.html"},
{"title": "辛普森积分法","text": "辛普森积分法<br/>辛普森积分法是一种快速求函数定积分的方法。与普通的直线拟合方法相比，辛普森积分法采用的是二次函数来拟合函数，而效果十分显著。<br/>用抛物线拟合<br/>假设我们有三个不重合的点，那么可以唯一确定一个抛物线经过这三个点。如下图所示：<br/><br/>辛普森积分法就是在积分区间$[a,\\;b]$上去三个点$a$、$b$和$m = (a + b) / 2$，计算其原函数的在此处的值，然后用抛物线来拟合原函数，即使用该二次函数的积分值代替原函数的积分值，达到近似积分的效果。<br/>如何计算这个二次函数？我们自然可以解三元三次方程组，但更方便的方法是拉格朗日差值公式：<br/>$$<br/>g(x) = {(x - m)(x - b) \\over (a - m)(a - b)}f(a) + {(x - a)(a - b) \\over (m - a)(m - b)}f(m) + {(x - a)(x - m) \\over (b - a)(b - m)}f(b)<br/>$$<br/>其中$f(x)$是原函数，$g(x)$是拟合后的函数。下文中$f$和$g$也表示同样的意义，不再复述。<br/>二次函数的积分<br/>有了二次函数后，计算其积分是十分简单的事，但是这一切还不够完美。下面我们将推导出一个更简单的公式。<br/>设：<br/>$$<br/>g(x) = Ax^2 + Bx + C \\\\<br/>m = \\frac{(a + b)}2 \\\\<br/>f(a) = g(a), \\; f(m) = g(m), \\; f(b) = g(b)<br/>$$<br/>那么：<br/>$$<br/>\\int_a^b f(x) \\;\\mathrm{d}x \\approx \\int_a^b (Ax^2 + Bx + C)\\;\\mathrm{d}x<br/>$$<br/>所以：<br/>$$<br/>\\int_a^b (Ax^2 + Bx + C)\\;\\mathrm{d}x = \\frac{A}3(b^3-a^3) + \\frac{B}2(b^2-a^2) + C(b-a)<br/>$$<br/>因为：<br/>$$<br/>b^3 - a^3 = (b^2 + ab + a^2)(b-a)\\\\<br/>b^2 - a^2 = (b+a)(b-a)<br/>$$<br/>所以之前的式子可变为：<br/>$$<br/>{b-a \\over 6}[2A(b^2 + ab + a^2) + 3B(b+a) + 6C]<br/>$$<br/>调整可得：<br/>$$<br/>{b-a \\over 6}\\left[(Aa^2 + Ba + C) + (Ab^2 + Bb + C) + 4A\\left({b+a \\over 2}\\right)^2 + 4B\\left({b+a \\over 2}\\right) + 4C\\right]<br/>$$<br/>于是就是：<br/>$$<br/>\\int_a^b f(x) \\;\\mathrm{d}x = {b - a \\over 6}(f(a) + 4f(m) + f(b))<br/>$$<br/>这就是辛普森法则。<br/>辛普森积分<br/>下面将用Python简单实现一下辛普森积分，首先我们需要一个计算积分的函数：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8def sample(f, a, b):<br/>    \ \ \ 用二次函数近似计算函数f的积分<br/>    f: 函数<br/>    a: 积分下界<br/>    b: 积分上界<br/>    \ \ \ <br/><br/>    return (b - a) * (f(a) + 4.0 * f((a + b) * 0.5) + f(b)) * 0.5<br/><br/><br/>然后就是对f分成n段，每一段使用二次函数近似计算：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17def simpson(f, a, b, n = 1000):<br/>    \ \ \ 计算定积分<br/>    f: 原函数<br/>    a: 积分下界<br/>    b: 积分上界<br/>    n: 划分的区间数<br/>    \ \ \ <br/><br/>    delta = (b - a) / n<br/>    result = 0<br/><br/>    for i in range(0, n):<br/>        left = a + i * delta<br/>        right = left + delta<br/>        result += sample(f, left, right)<br/><br/>    return result<br/><br/><br/>用它来试着算一下圆周率：<br/>1<br/>2In [1]: simpson(lambda x : 2.0 * sqrt(1 - x**2), -1, 1, 100000)<br/>Out[1]: 3.1415926390691236<br/><br/><br/>可以发现分为$100000$个区间就获得了$7$位的精度。事实上，如果你将sample换为直线的拟合，你将只能得到$6$位的精度。<br/>自适应辛普森积分<br/>然而控制区间个数不是一个控制答案精度的好办法，通常我们将使用特定的$\\varepsilon$来控制精度误差。<br/>如何让算法知道应当继续细分来达到特定精度呢？通常的方法就是将当前区间分为两半，用这两半的拟合值与当前计算的值做差。如果小于$\\varepsilon$，那么我们就认为精度达到了要求。否则我们就递归下去，计算两个子区间的积分。注意，此时$\\varepsilon$也应当缩小，从而避免累积的误差超过了$\\varepsilon$。<br/>这样我们就将得到一个递归算法，具体实现如下：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25<br/>26<br/>27<br/>28def _adaptive_simpson(f, a, b, eps, current):<br/>    \ \ \ 递归过程<br/>    f: 原函数<br/>    a: 积分下界<br/>    b: 积分上界<br/>    eps: 精度<br/>    current: [a, b]的定积分近似值，用于减少计算量<br/>    \ \ \ <br/><br/>    mid = (a + b) * 0.5<br/>    leftans = sample(f, a, mid)<br/>    rightans = sample(f, mid, b)<br/><br/>    if abs(leftans + rightans - current) < eps:  # 如果达到要求<br/>        return current<br/>    else:  # 否则将递归下去计算<br/>        return (_adaptive_simpson(f, a, mid, eps * 0.5, leftans) +<br/>                _adaptive_simpson(f, mid, b, eps * 0.5, rightans))<br/><br/>def adaptive_simpson(f, a, b, eps):<br/>    \ \ \ 自适应辛普森积分<br/>    f: 原函数<br/>    a: 积分下界<br/>    b: 积分上界<br/>    eps: 精度<br/>    \ \ \ <br/><br/>    return _adaptive_simpson(f, a, b, eps, sample(f, a, b))<br/><br/><br/>我将其与线性拟合的算法对比了一下速度。他们共用一个递归的框架，只是sample函数有二次函数拟合和直线拟合两种：<br/>直线拟合：<br/>1<br/>2<br/>3<br/>4In [1]: % time adaptive_simpson(sin, 0, 1000, 0.00001)<br/>CPU times: user 5.58 s, sys: 0 ns, total: 5.58 s<br/>Wall time: 5.58 s<br/>Out[1]: 0.4376209161316862<br/><br/><br/>二次函数拟合：<br/>1<br/>2<br/>3<br/>4In [26]: % time adaptive_simpson(sin, 0, 1000, 0.00001)<br/>CPU times: user 60 ms, sys: 0 ns, total: 60 ms<br/>Wall time: 59.6 ms<br/>Out[26]: 0.43762092534838204<br/><br/><br/>可见辛普森积分法是相当迅速的。<br/>异常情况<br/>由于是使用二次函数拟合，所以辛普森积分法对光滑的函数效果较好。但下面几种情况需要谨慎考虑：<br/><br/>上下震荡十分剧烈的函数（如$y = \\sin(1/x)$）不适用，事实上这种函数一般都不好积。<br/>突变的函数（如$y = |x|$，在$x = 0$处无导数）不适用。<br/><br/>对于存在没有导数的点的函数，通常的解决方法就是从这些点分开，然后就可以分段计算了。","tags": "辛普森积分法","url": "blog/2016-11-16/simpson.html"},
{"title": "长链剖分","text": "长链剖分<br/><br/>WC听课时听到可以$\\Theta(1)$查询树上祖先的算法，叫长链剖分。然而讲课人非常厉害，说网上这种资料很多就没讲了。然而我姿势不够并搜不到。打听到该算法后在这里记录一下。<br/><br/>查询树上祖先的一般算法<br/>静态树<br/>静态的树上之前我只知道$O(\\log n)$的倍增算法，即先构造出这棵树的倍增表$f[n][k]$，表示$n$号节点往树根走$2^k$步走到的祖先。这个东西可以在$O(n \\log n)$的时间内预处理出来，具体的这里不再介绍，网上或者本博客一篇关于LCA的文章内都有介绍。<br/>构建出倍增表后，如果我们想往上方走$d$步，那么可以将$d$按照二进制分解成几个$2$的幂的和，那么就可以利用倍增表进行$O(\\log n)$次上跳，到达距离为$d$的祖先处。<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10function find_ancestor(u, d):<br/>    k = 0<br/><br/>    while d:<br/>        if d & 1:<br/>            u = f[u][k]<br/>        d >>= 1<br/>        k++<br/><br/>    return u<br/><br/><br/>动态树<br/>当然需要LCT啦。首先access到$u$，然后对于LCT上的平衡树，额外记录下每个节点的大小就可在平衡树上找出对应位置的祖先。<br/>长链剖分<br/>十分出名的树链剖分是按照儿子节点的大小来挑选重儿子的，这种剖分方法保证了每个节点到根的路径上的轻边数量为$O(\\log n)$条。如果我们换用其它标准，如按照儿子节点的秩 (即节点到其子树内的叶子节点的最远距离) 为标准选取重儿子，称其为长链剖分，那么可以分析出轻边数量是$O(\\sqrt n)$级别1的。但这就无法体现出它的优势。<br/>但是我们考虑另外一个事情：长链剖分之后，对于每个节点$u$，其子树中其它节点$v$到$u$的距离不超过$u$所处长链的长度。假设这个距离超过了链长，那么说明按照节点的秩来剖分的时候，就会朝着$v$的方向走。除非有多个最远点距离一样，否则这个最远点会与$u$在同一条长链上。所以它的距离不会超出链长。<br/>那这有什么用？考虑另外一个事情：对于一个距离$d$，找到一个最大的$k$使得$2^k \\leqslant d$，那么必定有$d - 2^k \\lt 2^k$。同时，假如我们从一个点$u$往上走了$2^k$步到了$u^\\prime$，那么根据之前的事实，$u^\\prime$所处的长链的长度至少为$2^k$。令链长为$x$，由于剩下的步数小于$2^k$，所以我们如果有这条长链以及链顶往上走$x$步的所有顶点信息，那么就是存储$2x$个点，保存在一个数组内，然后就可以直接查找祖先了。总的时间复杂度为$\\Theta(1)$。另外，由于由于所有长链的长度之和为$n$，所以最多记录$2n$个信息，即它的空间复杂度是$\\Theta(n)$的。<br/>因此实现的时候，需要计算倍增表和长链，这一步可以在$O(n \\log n)$的时间复杂度内解决。然后查询的实现如下面的C++代码所示：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25/**<br/> * @param u (int) 当前节点<br/> * @param d (int) 距离<br/> * @return (int) 返回从当前节点往上走d步的祖先<br/> */<br/>int find_ancestor(int u, int d) {<br/>    assert(0 <= d && d <= depth[u]);  // 必须保证祖先存在<br/><br/>    if (d == 0)  // d = 0特判<br/>        return u;<br/><br/>    int h = highbit[d];  // highbit用于记录数字1..n的最高位，提前预处理<br/>    u = f[h][u];  // f是倍增表，上跳2^k步<br/>    d -= 1 << h;<br/><br/>    assert(d < (1 << h));  // 满足事实1<br/><br/>    int t = top[u];  // top记录每个节点所处的链的链顶<br/>    int pos = len[t] - 1 - (depth[u] - depth[t]) + d;  // len记录链长<br/><br/>    // chain是存储了2 * len[t]个节点的vector<br/>    assert(0 <= pos && pos < chain[t].size());  // 满足事实2<br/><br/>    return chain[t][pos];  // 返回答案<br/>}<br/><br/><br/>倍增表和长度为$2x$的数组还可以存储其它信息。就以长度为$2x$的数组而言，可以记录前缀和或者利用ST表记录最大/最小值，配合快速的LCA算法从而能够$\\Theta(1)$的时间复杂度回答两点间的路径上的特定信息的查询。<br/>此外，如果不考虑倍增表，我们依然可以利用事实1从而达到在$O(\\log n)$步跳到根节点，即每次跳到当前链能访问到的最后一个节点的父亲处。由于每次上跳到的新的链的长度必定翻倍，所以能做到这个复杂度。因此，长链剖分也可以以同样的时间复杂度实现树链剖分的功能。<br/><br/><br/><br/><br/>考虑一个最坏情况，将长度为$1..n$的链摆成一排，将每条链的端点依次相连，那么将会有一个节点到根的路径上有$n - 1$条轻边，而此时树上有$n(n + 1) / 2$个节点。故上界至少是$\\Omega(\\sqrt n)$ ↩<br/><br/><br/>","tags": "长链剖分 树上祖先查询 数据结构","url": "blog/2017-2-6/long-chain.html"},
{"title": "附中 2018 夏令营课件","text": "附中 2018 夏令营课件<br/>最近到附中讲了 6 天课，这里挂上本人拙劣的课件......<br/><br/>Day 1 - 栈、队列<br/>Day 2 - 链表、DLX、并查集<br/>Day 3 - 分块、线段树、树状数组<br/>Day 5 - 贪心问题选讲<br/>Day 7 - 简单图论<br/>Day 8 - 树上算法选讲<br/>原始文档<br/><br/>夏令营是针对初中生冲提高组的，所以课件内容偏易，各路大神轻喷 QAQ<br/>另外顺带一提，这次夏令营一共 12 天，剩下六天都是 ruanxingzhi 阮大爷讲的。","tags": "OI","url": "blog/2018-7-23/sdfzsc-2018.html"},
{"title": "静态树上的最近公共祖先问题","text": "静态树上的最近公共祖先问题<br/>基本概念<br/>树 $T = (V,\\;f,\\;r)$ 是一张无向图，其中 $V$ 是点的集合，$f(u)$ 表示点 $u$ 的父亲，$r$ 是树的根，并且 $f(r) = \\varnothing$，即根不存在父亲。下文中通常用正整数表示点，为了方便，令 $f(r) = 0$，点 $0$ 是一个不存在的点。树中除 $r$ 外，每个点都与它的父亲连边构成边集。记录 $\\mathrm{ch}(u)$ 表示 $u$ 的儿子的集合，定义为 $\\mathrm{ch}(u) = \\{v:\\;f(v) = u,\\;v \\in V\\}$<br/>。定义 $d(u)$ 表示点 $u$ 到根 $r$ 的简单路径上边的数量，即到根的距离，也称深度，因此有 $d(r) = 0$。令 $\\max\\{d(u):\\;u \\in V\\}$ 表示树的高度，通常记为字母 $h$。<br/>一个点 $u$ 到根 $r$ 的简单路径上的所有点都称为 $u$ 的祖先，构成的集合记做 $C(u)$（为了方便，自己可以是自己的祖先）。而两个点 $u$ 和 $v$ 的最近公共祖先（Least Common Ancestors，LCA）为 $C(u) \\cap C(v)$ 中深度最大的点，记为 $\\mathrm{lca}(u,\\;v)$。所有祖先中有 $u$ 的点的导出子图同样也构成一棵树，记为 $T_u$，称作以 $u$ 为根的子树。<br/>接下来，为了方便，通常记 $n = |V|$，表示树中的点数。此外，由于下面介绍的算法都要处理多组询问（通常记作 $q$ 组），所以在讨论到某个算法时空复杂度的时候，用 $O(f(n))$-$O(g(n))$ 表示该算法的空间复杂度为 $O(f(n))$，以及单次询问的时间复杂度为 $O(g(n))$。<br/>解决方案<br/>朴素算法<br/>既然是要求公共祖先，那么我们一个直接的想法就是现将一个点 $u$ 的祖先全部标记出来，然后 $v$ 在从最深的祖先开始（也就是 $v$ 自己），一个一个检查是不是已经被标记过。如果找到了一个被标记的点，那么这个点就是最近公共祖先。<br/><br/>（Fig. 1. 蓝色代表 $u$ 的祖先，橙色代表 $v$ 检查过的祖先，红色是最近公共祖先）<br/>一般的实现如下：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10function LCA(u, v):<br/>    // mark: 大小为 n 的整数数组<br/>    // cur: 一个整型，记录该函数被调用了多少次<br/>    cur += 1<br/>    while u != 0:<br/>        mark[u] = cur<br/>        u = f(u)<br/>    while mark[v] != cur:<br/>        v = f(v)<br/>    return v<br/><br/><br/>这样的算法的复杂度为 $\\Theta(n)$-$O(h)$。也就是说最坏情况下可能需要 $O(n)$ 的代价来找到最近公共祖先。由于随机一棵树的树高期望为 $O(\\log n)$，所以该算法在一般情况下比较高效。<br/>另外值得一提的是，在一般图最大匹配的带花树算法中，由于有 “缩花” 这种操作，并且本身对求最近公共祖先的复杂度要求不高，所以很多带花树算法的实现中使用朴素算法。<br/>倍增算法<br/>通过进一步观察，可以发现到达某个深度之后，继续往上走都会是公共祖先，而最近公共祖先就是它们中深度最深的。利用这一点，就可以使用二分这一技巧。二分一个向上走的距离 $x$，找到 $v$ 向上走 $x$ 步的点 $p$，并检查 $p$ 是否是 $u$ 的祖先。如果 $p$ 是 $u$ 的祖先，则 $d(\\mathrm{lca}(u,\\;v)) \\geqslant d(p)$，所以需要减小 $x$，反之则需要增大 $x$。<br/>现在就需要解决两个问题：<br/><br/>找到 $v$ 向上走 $x$ 步的点 $p$。<br/>确认 $p$ 是否是 $u$ 的祖先。<br/><br/>对于第一个问题，我们有一个 $O(n\\log h)$-$\\Theta(1)$ 的长链剖分算法，但是这里暂不讨论这个算法。考虑到二分实际上可以转变为倍增的形式，即可以将目标 $x$ 转为二进制位，并且从高位向低位试位：如果某一位赋为 $1$ 导致找到的 $p$ 是 $u$ 的祖先，则将其赋为 $0$，否则赋为 $1$。这样就保证试位过程中的 $p$ 始终不是 $u$ 的祖先，最后 $f(p)$ 就正好是 $\\mathrm{lca}(u,\\;v)$。<br/>转为倍增的好处在于现在只用关心每个点 $v$ 向上走 $2^k$ 步的点 $p$ 了，而这样的点对于每个 $v$ 而言只有 $O(\\log h)$ 个，因此总共只用记录 $O(n \\log h)$ 这么多的信息。现在令 $g(u,\\;k)$ 表示点 $u$ 向上走 $2^k$ 步的点 $p$，然后之前的倍增的过程就是这样：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6function LCA(u, v):<br/>    for k = int(log(h)) to 0:<br/>        p = g(v, k)<br/>        if p is not an ancestor of u:<br/>            v = p<br/>    return f(v)<br/><br/><br/>现在需要求出 $g(u,\\;k)$ 中的值。首先关注到 $g(u,\\;0) = f(u)$，这一部分可以直接得到。接下来，对于向上走 $2^k$ 步，相当于是走两次 $2^{k-1}$ 步，所以我们得到：<br/>$$ g(u,\\;k) = g(g(u,\\;k - 1),\\;k - 1)  \\;\\;\\;\\; \\forall k \\gt 0 $$<br/>所以 $g$ 可以在 $O(n \\log h)$ 的时间内计算出来。<br/>接下来对于第二个问题，我们可以使用 DFS 序来解决这个判定问题。也就是记录每个点在以 $r$ 为起点的 DFS 过程中入栈和出栈的时间。由于 DFS 的性质，$T_u$ 中的所有点的入栈时间是一个连续的区间，所以就可以利用这一点在 $\\Theta(n)$-$\\Theta(1)$ 的复杂度完成判定任务。<br/>当然，我们可以不用 DFS 序。想象一下，如果 $u$ 和 $v$ 所处的深度相同，那么可以将 $u$ 和 $v$ 同时向上面走同样的步数 $x$。如果走到了同一个点上，则说明 $x$ 需要减小，否则说明需要增大。那么在此之前，就需要将 $u$ 和 $v$ 调到同一个深度。<br/>这里将再次利用二进制和我们的 $g$ 函数。如果现在 $u$ 所处的深度比 $v$ 深，则 $u$ 需要向上走 $x = d(u) - d(v)$ 步。例如，如果 $x = 1011_{(2)}$，就是相当于分别走 $2^0$、$2^1$ 和 $2^3$ 步。而这都可以利用 $g$ 函数实现。最后的实现一般是下面这样：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24<br/>25// 计算 g 函数<br/>for u = 1 to n:<br/>    g(u, 0) = f(u)<br/>for k = 1 to int(log(h)):<br/>    for u = 1 to n:<br/>        g(u, k) = g(g(u, k - 1), k - 1)<br/><br/>function LCA(u, v):<br/>    if d(u) < d(v):<br/>        u, v = v, u  // 交换 u 和 v<br/><br/>    x = d(u) - d(v)<br/>    for k = 0 to int(log(x)):<br/>        if (x >> k) & 1:<br/>            u = g(u, k)<br/><br/>    if u == v:  // 需要特判 v 是 u 的祖先的情况<br/>        return u<br/><br/>    for k = int(log(n)) to 0:<br/>        if g(u, k) != g(v, k):<br/>            u = g(u, k)<br/>            v = g(v, k)<br/><br/>    return f(u)<br/><br/><br/>最后，倍增算法的复杂度为 $O(n\\log h)$-$O(\\log h)$。相对于朴素算法而言，虽然花费了更多的空间，但是获得了时间复杂度的巨大提升，是一个非常不错的改进。另外，值得注意的是，如果实现良好，倍增法在随机树的情况下期望复杂度为 $O(\\log \\log n)$。<br/>倍增的思想可以扩展到更多的问题上，例如，我们可以仿照 $g$ 数组记录一些其它的信息，如最大 / 最小值，就可以用来求树上两点间最短路径的边权最大 / 最小值。在后缀数组构建算法中，也有一个运用了倍增思想的时间复杂度为 $\\Theta(n\\log n)$ 的简单算法。<br/>链剖分<br/>看到这里的时候：<br/>1<br/>2if u == v:  // 需要特判 v 是 u 的祖先的情况<br/>    return u<br/><br/><br/>不知道是否会想到，既然我们可以 $\\Theta(1)$ 判定 $v$ 是否是 $u$ 的祖先，那为什么还要浪费时间来上跳呢？因为即使利用这一点可以减少计算量，却没有改进复杂度。但是并不意味着这种想法没有什么用，我们可以发现一个更深刻的道理：如果树是链状的，那么最近公共祖先问题就十分的 naïve 了，只需要比较 $d(u)$ 和 $d(v)$ 的大小即可。<br/>现在我们要对付的树并不能如我们所愿的是链状，但是可不可以把 $u$ 和 $v$ 上跳，从而调到 $u$ 是 $v$ 的祖先呢？不妨尝试将树划分成许多长链，更形式化的说，就是用两两不相交的简单路径覆盖整棵树，从而使得每个点都在唯一的一条路径上：<br/><br/>（Fig. 2. 上图表示了一种划分方案，注意蓝色的路径只有一个点）<br/>当然，为了方便，简单路径上的点的深度是单调的（即不会出现先上行后下行的情况）。这些简单路径也称为链。这样一来在同一条链上的的情况就十分简单了。为了方便称呼，链中深度最小的点叫做链顶，如果一条树边不存在于任何一条链上，则称为轻边，否则称为重边。当 $u$ 和 $v$ 不在同一条链上时，可以让 $u$ 或者 $v$ 沿着链顶的轻边走上去，就会到达另外一条链。例如，如果 $u$ 在上图中的绿色点中，而 $v$ 在橙色点中，我们可以让 $u$ 沿着绿色和橙色之间的轻边走上去。到达橙色链，从而变成了一条链上的情况。具体的实现就大概就是这样：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14function LCA(u, v):<br/>    // top: 一个整型数组，top[u] 表示 u 所处的链的链顶<br/>    while top[u] != top[v]:<br/>        // 挑选链顶深度较深的一个点向上跳<br/>        if d(top[u]) > d(top[v]):<br/>            u = f(top[u])<br/>        else:<br/>            v = f(top[v])<br/><br/>    // 此时 u 和 v 在同一条链上<br/>    if d(u) < d(v):<br/>        return u<br/>    else:<br/>        return v<br/><br/><br/>现在的目标就是找出一种链剖分的方案，使得这种 “走轻边” 的情况尽量少。由于我们链剖分的方法所决定的，每个点沿着链向下走最多能走到一个儿子处，姑且称这个儿子为重儿子。当我们为每个点选取好重儿子后，链剖分的方案也就出来了。当然，随便选取重儿子是不可取的，就像在下面这棵树中：<br/><br/>（Fig. 3. 一条长链的每个点都多挂了一个点）<br/>如果随机选取，那么长链上的每条边就有 $1/2$ 的概率成为轻边，如果从底端走到根节点，期望要走 $h / 2$ 条轻边。<br/>所以需要换一种思路，我们希望树上划分出的链尽量少，一种思路就是每次挑出最长的一条链。显然对于一个点 $u$，它的重儿子 $v \\in \\mathrm{ch}(u)$ 应当满足 $T_v$ 的树高最高。如果按照此标准选取重儿子，最多又会走多少条轻边呢？<br/><br/>（Fig. 4. 这只是一种可能的情况）<br/>不妨来分析一下如果已经走过了 $x$ 条轻边后，树中至少有多少个点。如上图所示，从最左下角的蓝色点 $u$ 开始走轻边，那么 $u$ 所经过的路径上至少有 $x + 1$ 个点。假设现在走到了 $p$，那么 $T_p$ 中的最长链至少为 $x + 1$，因为 $p$ 所在的长链是最长的，所以 $p$ 所处的长链的长度也至少为 $x + 1$。由此可以分析出：<br/>$$ n \\geqslant \\sum_{k = 1}^{x + 1} k = {(x + 1)(x + 2) \\over 2} \\geqslant x^2 $$<br/>换句话讲就是 $ x = O(\\sqrt{n}) $。即任意一个点开始只要走 $O(\\sqrt{n})$ 条轻边就可以到达根节点。最后这种方法的复杂度为 $\\Theta(n)$-$O(\\sqrt{n})$。实际上这种方法在之前提到过，通常称作长链剖分，它使用较少的空间和不是很坏的时间复杂度完成了最近公共祖先的计算任务。<br/>但是这还没有结束，$O(\\sqrt{n})$ 的时间复杂度相比之于倍增算法，还不是一个很理想的结果。回忆一下之前的分析过程中发现了什么：<br/><br/>如果 $T_u$ 中存在一条长度 $l$ 的链，那么 $u$ 所处的长链的长度至少为 $l$。<br/><br/>因为这一点，上述分析中每次到达的新的长链的长度至少加 $1$。由此，我们可以提出一个大胆的想法：每次向上走链长 $l$ 步，那么新到达的长链的长度就会翻倍，从而可以达到 $O(\\log h)$ 的时间复杂度。<br/>为了实现这一点，我们需要对于每一条长链记录它的长度 $l$，以及从链顶向上走 $l$ 步到达的点 $p$（如果链顶的深度不足 $l$ 则为根节点 $r$）。然后固定 $v$，不断上跳 $u$，直到 $p$ 是 $v$ 的祖先。这个时候发现仅这样做无法知道最近公共祖先，因为我们可能过头了，但是可以得知最近公共祖先一定在 $u$ 到 $p$ 的长链上，并且它满足二分性质。因此稍加改动，对于每条链，存储这条链本身的所有点，以及从链顶向上走至多 $l$ 步的所有点（总长最多为 $2l$），就可以完成最后一个二分过程了。<br/>虽然每条链花费了 $2l$ 的空间来存储这些点，但是由于所有链长加起来只有 $n$，故最后的复杂度为 $\\Theta(n)$-$O(\\log h)$。我们成功实现了在倍增算法的基础上，减小空间开销的任务。<br/>看到上面啰哩吧嗦一大堆，有的人可能一开始想法就不一样。可能会想尝试将重儿子 $v$ 选取为 $T_v$ 的大小最大的那一个。按照这个标准，之前长链剖分的最坏情况的那棵树，应该被划分成这样：<br/><br/>（Fig. 5. 实际上，除了最左下角，其它部分一定会被划分成这样）<br/>Aha！EXCITED！我们发现这样无论什么询问，最多走一次轻边了，显然科学了很多。在这种剖分中，如果使用之前长链剖分的 $O(\\sqrt{n})$ 算法，现在的时间复杂度会变成什么了呢？<br/>套用之前的分析过程，当一个点 $v$ 每走一条轻边到 $u$，我们就会知道 $u$ 的重儿子 $x$ 一定满足 $T_x$ 的大小不小于 $T_v$ 的大小，也就是说 $T_u$ 的大小相对于 $T_v$ 而言至少翻了一倍。最后得出结论，任意一个点走到根节点只会经过 $O(\\log n)$ 条轻边。通过简单的调整选取重儿子的策略，我们直接获得了更加优秀的时间复杂度。实际上，这种剖分方法称为轻重链路径剖分（Heavy-Light Decomposition，HLD，又称树链剖分），这种思想在动态树（LCT、Toptree 之类）上发挥了极大的作用。<br/>接下来又是一个老生常谈的问题，有了这种剖分方法，长链剖分就没有用处了吗？并不。之前提到了用长链剖分在 $O(n\\log h)$-$\\Theta(1)$ 的复杂度完成求一个点向上走 $k$ 步的点，这是一般算法无法做到的。经过之前对长链剖分的分析，相信你一定能想出具体方法。作为一个提示，那 $O(n \\log h)$ 的空间实际上是被倍增算法中的 $g$ 函数吃掉了。<br/>与倍增算法类似，链剖分方法实质上完成了对树上任意简单路径划分为少量链的目标，从而使得线性数据结构可以在树上大显身手。由于本文只讨论最近公共祖先问题，对于链剖分的其他扩展可以去寻找其他资料。<br/>转化为 RMQ<br/>就目前为止，我们一直在考虑直接在树上处理问题。有的时候，将一个问题转换为另外一个等价的问题，不失为一种奇妙的思路。<br/>现在退回到一种十分朴素的实现方法：从点 $u$ 开始，搜索 $T_u$，如果 $v$ 在 $T_u$ 中，则最近公共祖先为 $u$。否则令 $u = f(u)$，继续执行以上过程。当然，如果某些点已经被遍历过了，则不需要再次访问。或者可以换一个角度：将树上的每条无向边拆为两条有向边。对于属于同一条无向边的两条有向边，我们优先走向下走的边。每进入一个点的时候，就记录一下，最后会构成一个序列。这实际上就是 DFS 序。<br/><br/>（Fig. 6. 这棵树的 DFS 序是 1 2 4 2 5 6 5 2 1 3 1）<br/>假设 $u$ 的 DFS 入栈时间早于 $v$ ，那么之前的朴素方法相当于从 $u$ 开始沿着这些边来搜索，直到到达 $v$。搜索过程中访问到的深度最小的点就是 $u$ 和 $v$ 的最近公共祖先。<br/><br/>（Fig. 7. 几个小例子，分别为查询 $\\mathrm{lca}(4,\\;6)$、$\\mathrm{lca}(4,\\;3)$ 和 $\\mathrm{lca}(1,\\;4)$）<br/>现在情况就十分清楚了，由于这个 DFS 序是固定的，而且因为每条无向边都被拆成了两条有向边，加上进入根节点的一次记录，所以序列的长度为 $2n - 1$。现在我们将 DFS 序上每个位置的点 $u$ 换为 $u$ 的深度，称之为深度序列。这样相当于在一个长为 $2n - 1$ 的序列上，查询一个区间内的最小值。也就是静态区间最值问题（Range Minimum / Maximum Query，RMQ）。使用平衡树和线段树均可以做到 $\\Theta(n)$-$O(\\log n)$ 的复杂度，但这里不会讨论它们。接下来将会转为讨论专门用于解决静态 RMQ 问题的稀疏表算法（Sparse Table，又称 ST 表）。<br/>稀疏表<br/>首先注意到区间 $[l,\\;r]$ 的最值可以由多个区间 $[l_1,\\;r_1],\\;[l_2,\\;r_2],\\;...,\\;[l_k,\\;r_k]$ 的最值得来，只要满足这些区间的并集是 $[l,\\;r]$。基于这种思想，我们可以先预处理一些区间的最值，然后对于每一个询问，只要确保能找出一些已经处理过的区间并起来满足询问的要求，就可以回答询问。一个简单的想法就是拆成两个区间，一个是前缀一个是后缀：<br/><br/>（Fig. 8. 一个区间被拆为两个子区间）<br/>嗯，分成两个区间，不难想到 $2^k + 2^k = 2^{k + 1}$。也就是说只用计算所有长度为 $2^k$ 的区间的最值，就可以在 $\\Theta(1)$ 的时间内计算任意区间的最值。记 $f(i,\\;j)$ 表示以 $i$ 为左端点，长度为 $2^j$ 的区间最值，然后令 $\\mathrm{highbit}(n) = \\lfloor \\log n \\rfloor$，即最大的 $k$ 满足 $2^k \\leqslant n$。这个东西可以简单的在 $\\Theta(n)$ 的时间内预处理出来。之后，每次查询就是这样的：<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7highbit[1] = 0<br/>for i = 2 to n:<br/>    highbit[i] = highbit[i >> 1] + 1<br/><br/>function QUERY(l, r):<br/>    k = highbit[r - l + 1]<br/>    return min(f(l, k), f(r - (1 << k) + 1, k))  // 或者 max<br/><br/><br/>现在就只需要考虑如何计算 $f(i,\\;j)$ 了。计算一个序列中所有长度为 $l$ 的区间的最值，可以使用一种叫做单调队列的方法。使用一个双端队列，来维护当前区间内从左至右的一个单调递减（或递增）序列，相当于是一个最值的候选队列。每次从后面加入一个元素时，就会导致队列里面不单调，所以需要不断地从尾部弹出元素，使得新的元素加入后，依然满足单调性。这样，队首的元素始终是最大（或最小）值。如果收缩左边界，导致队首元素被弹出，新的队首依然是最大（或最小）值。上述方法中每个元素只会入栈一次，出栈一次，所以单次复杂度为 $\\Theta(n)$。由于我们需要计算的长度 $l$ 都是 $2$ 的幂，总共只有 $\\Theta(\\log n)$ 个，所以总的复杂度为 $\\Theta(n \\log n)$-$\\Theta(1)$。<br/>当然，我们有更简单的方法。因为每个长度为 $2^k$ 的区间可以拆成两个长度为 $2^{k-1}$ 的区间，因而可以递推计算，也就是 $f(i,\\;j)$ 满足下面的关系（以最大值为例，$a_i$ 是目标序列）：<br/>$$ \\begin{aligned} f(i,\\;0) & = a_i \\\\ f(i,\\;j) & = \\max\\{f(i,\\;j-1),\\;f(i+2^{j-1},\\;j-1)\\} \\;\\;\\;\\; \\forall j > 0 \\end{aligned}$$<br/>同样，它的复杂度也为 $\\Theta(n \\log n)$-$\\Theta(1)$。如果将这个算法运用到最近公共祖先问题上面，我们就首次获得了单次询问时间为常数的算法。这是一个相当大的突破。<br/>然而一切都还没有结束，我们不禁会想，能否继续优化，从而达到 $\\Theta(n)$-$\\Theta(1)$ 的理论下界呢（因为这是输入输出的复杂度）？答案是肯定的。就目前来看，我们只需要降低稀疏表的空间消耗，同时保证它的时间复杂度即可。<br/>如何降低空间复杂度呢？一个奇葩的想法就是，如果只有 $n / \\log n$ 个元素，那空间复杂度不就自然变成 $\\Theta(n)$ 了吗？但如何实现这个看起来很不科学的想法呢？这时分块的技巧就可用上了。首先设定一个块大小 $S$，然后从前往后每 $S$ 个元素划为一块，注意最后一块可能没有 $S$ 个元素。这样整个序列就划为了 $\\Theta(n / S)$ 块。考虑一下每一次询问可能出现的情况：<br/><br/>（Fig. 9. 上面的序列划为了 $6$ 块）<br/>就上图列举的三种情况而言，实际上只有两种：<br/><br/>询问跨越的块与块之间的分界线。<br/>询问没有跨越这个分界线。<br/><br/>此时不难发现，对于第一种情况，询问区间是由一些连续的块（可能没有）和首尾两个块的一个后缀和一个前缀构成。连续的块我们可以使用稀疏表解决，即用每个块内的最值表示这个块，构成一个序列，然后建立一个大小为 $\\Theta(n/S)$ 的稀疏表；前缀和后缀部分，由于每个块的前缀最值和后缀最值总共只有 $\\Theta(n)$ 个，也可以提前处理。这一部分的复杂度做到了 $\\Theta(n)$-$\\Theta(1)$。<br/>对于第二种情况，似乎就没有那么方便了。现在我们对付的是一个大小为 $O(S)$ 的 RMQ 问题，如果直接尝试对每个块建立小的稀疏表，计算可知我们现在的空间复杂度是：<br/>$$\\Theta((n/S) \\cdot S \\log  S+ (n / S) \\cdot \\log (n/S)) = \\Theta(n \\log S + (n \\log n)/S)$$<br/>通过对 $S$ 求导可知大约选取 $S = \\log n$ 时达到最优复杂度，此时的空间复杂度为 $\\Theta(n \\log \\log n)$。<br/>What a pity！我们费尽心思，却仍然不能达到线性复杂度。注意到我们的空间几乎都用在处理一堆大小为 $O(S)$ 的子问题上了。由于每个位置上可以是任意数值，所以块与块之间几乎不可能相同，这导致利用现有的算法难以将空间复杂度降下来。<br/>现在回到最开始要解决的问题，也就是求最近公共祖先。DFS 序总有一些非常好的性质，就例如之前的深度序列，不难发现这个序列上相邻两个数之差总是 $\\pm 1$。这是因为 DFS 这个过程的每一步要么往下走，要么往上走。换句话说，深度序列的差分序列1上只有 $\\pm 1$。如果原序列长度为 $S$，那么它的差分序列就只有 $2^{S-1}$ 种，这远远小于原始序列可能的种数。<br/>现在你也许可以猜到接下来要做什么了。由于差分序列种类不多，所以我们可以将差分序列做一遍前缀和处理，得到一个新的序列，第 $i$ 个位置上的值是差分序列上前 $i$ 个数的和，并且处理这个序列上的每个区间的最值。然后如果知道原始序列的第一项 $a$，那么原始序列就相当于是前缀和序列前添加一个 $0$，并且每个数都加上 $a$，所以可以轻松知道原始序列的最值。<br/>这样一来，我们就可以使得大小为 $O(S)$ 的 RMQ 问题减小总空间代价了。选定 $S = \\frac12\\log n$，一方面，这样使得差分序列的种类只有 $2^{1/2\\log n - 1} = \\Theta(\\sqrt{n})$ 种，因此我们可以简单粗暴的使用 $\\Theta(S^2)$ 的空间为每一种差分序列计算区间最值，当然，你也可以使用稀疏表；另一方面，跨越多个块的询问同样可以使用之前的分块算法，并且空间复杂度依然是 $\\Theta(n)$。综上，最近公共祖先问题可以在 $\\Theta(n)$-$\\Theta(1)$ 的复杂度解决了。<br/>在具体实现上，由于 $\\log n$ 不大，所以差分序列通常用二进制来表示（如二进制位 $1$ 表示差分序列上的 $+1$，对应的 $0$ 则表示 $-1$）。这样就只需要访问数组下标就可以知道特定差分序列的信息了。<br/>笛卡尔树<br/>虽然最近公共祖先的理论复杂度下界已经实现了，本文似乎也就没有必要继续下去了。但是之前我肯定的回答了 RMQ 能否达到理论下界，同时也为了揭示最近公共祖先和 RMQ 问题之间的一些联系，这里还是有必要说一下如何改进稀疏表的空间复杂度。<br/>为了方便，接下来都只考虑最大值。我们知道，最大值一定是序列上的一个值，那么对于序列上的每个值，有哪些区间的最大值是它自己呢？首先来找出一个最大的区间满足这个区间的最大值就是自己，假设序列是 $a_i$，现在我们要确定的是 $a_x$ 的最大区间 $[l,\\;r]$，那么可以从 $[x,\\;x]$ 开始，检查 $a_{l-1}$ 是否不超过 $a_x$，如果是，则 $l$ 可以减 $1$；同理，如果满足 $a_{r+1} \\leqslant a_x$，那么 $r$ 也可以加 $1$。当然我们需要满足 $l \\geqslant 1$ 以及 $r \\leqslant L$，其中 $L$ 是序列长度。这样做的正确性是显然的，因为这个区间不能跨过任何一个比 $a_x$ 大的位置。此外，我们容易得到所有满足最大值为 $a_x$ 的区间 $[l',\\;r']$ 满足 $l \\leqslant l' \\leqslant x \\leqslant r' \\leqslant r$。<br/>设 $l(x)$ 和 $r(x)$ 表示之前对于特定的 $x$ 所说的 $l$ 和 $r$，并且 $M(x) = [l(x),\\;r(x)]$。求出所有的 $l(x)$ 和 $r(x)$ 固然可以使用贪心算法，但是它效率不高。其实这里可以使用之前提到过的单调队列。因为向左找出 $l(x)$ 的过程就相当于不停地从队列末尾弹出元素，直到找到第一个大于 $a_x$ 的元素。而求出 $r(x)$ 就是要知道 $a_x$ 是当谁加入队列后被弹出的，如果加入 $a_y$ 导致 $a_x$ 被弹出，那么说明 $a_y$ 是 $a_x$ 向右走的第一个大于 $a_x$ 的位置。此外还需要注意，最后队列里面肯定还会剩余一些元素没有被弹出来，这则说明这些元素的 $r(x)$ 都是 $L$。这样做的话就只用 $\\Theta(n)$ 的时间复杂度了。具体的实现如下：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16// a: 长度为 L 的整型数组，表示序列<br/>Q = []  // 单调队列<br/>for i = 1 to L:<br/>    while Q is not empty and a[Q.last()] <= a[i]:<br/>        r(Q.last()) = i - 1<br/>        Q.pop_back()<br/><br/>    if Q is empty:<br/>        l(i) = 1  // 此时 a[i] 一路往左没有遇到更大的值<br/>    else:<br/>        l(i) = Q.last() + 1<br/><br/>    Q.push_back(i)<br/><br/>foreach i in Q:<br/>    r(i) = L<br/><br/><br/>现在我们来观察一个简单的例子：<br/><br/>（Fig. 10. 在序列 2 3 1 6 4 5 7 的例子）<br/>此时你就会发现所有的这些区间两两之间只有包含和分离的关系。利用这种包含关系，我们实际上就可以构造一棵树：<br/><br/>（Fig. 11. 如果 $M(x) \\subseteq M(y)$，那么 $y$ 是树上 $x$ 的祖先）<br/>这棵二叉树被称为笛卡尔树（Cartesian Tree）。对于知道 Treap 的人来说这个名词一定不陌生，这棵树相当于给每个位置 $x$ 的权值是 $a_x$ 后建立的 Treap。如果序列中没有重复的元素，那么这棵树是唯一的。回忆起所有满足最大值为 $a_x$ 的区间 $[l',\\;r']$ 满足 $l(x) \\leqslant l' \\leqslant x \\leqslant r' \\leqslant r(x)$，那么说明这个最大值 $x$ 在树上一定是 $l'$ 和 $r'$ 的公共祖先。此外，还要满足 $l' \\leqslant x \\leqslant r'$，这恰好说明 $x$ 需要是 $\\mathrm{lca}(l',\\;r')$。因为如果不是最近公共祖先就不会将 $l'$ 和 $r'$ 隔开，就比如上图中的 $[3,\\;5]$，这个区间的最大值是 $a_4$，而不是 $a_7$。<br/>如果我们能够快速的构建出笛卡尔树，就可以使用上一节讨论的 $\\Theta(n)$-$\\Theta(1)$ 的最近公共祖先算法以同样的复杂度解决静态 RMQ 问题了。幸运的是，我们只用稍微修改一下之前的单调队列算法，就可以构造出笛卡尔树。<br/>假设我们现在已经有了一棵笛卡尔树，考虑在后面加入一个新的元素 $a_x$ 时，笛卡尔树该如何变化。首先，我们还是要找出 $a_x$ 往左走的第一个比它大的元素 $a_y$，此时我们就知道 $y$ 是 $x$ 的父亲了。另外，不要忘记那些被弹出队列的点，这些的点的 $r$ 函数的值已经全部被修改为 $x - 1$ 了，所以会改变它们的父亲：<br/><br/>（Fig. 12. 新加入一个元素，其权值为 $7$，以 $6$ 为根的子树变成了新点的左儿子）<br/>经修改后的算法实现应该是这样的：<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5<br/> 6<br/> 7<br/> 8<br/> 9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19// 现在每个元素 a[i] 有三个属性 value、left 和 right，<br/>// 分别表示权值、二叉树上的左儿子和右儿子，如果没有儿子则为 null<br/>function BUILD-CARTESIAN-TREE(a):<br/>    Q = []<br/>    foreach x in a:<br/>        while Q is not empty and Q.last().value <= x.value:<br/>            Q.last().right = x.left<br/>            x.left = Q.last()<br/>            Q.pop_back()<br/><br/>        Q.push_back(x)<br/><br/>    // 最后留在队列里的点相连<br/>    while Q.size() > 1:<br/>        v = Q.last()<br/>        Q.pop_back()<br/>        Q.last().right = v<br/><br/>    return Q.first()  // 返回笛卡尔树的树根<br/><br/><br/>至此，最近公共祖先问题和区间最值问题同时都得到了优秀的解决方案。现在我们来整理一下这两者之间的联系：<br/><br/>利用 DFS 序可以将最近公共祖先问题转为区间最值问题。<br/>利用笛卡尔树可以将区间最值问题转为最近公共祖先问题。<br/><br/>注记<br/>上文中实际上只介绍了在线算法，而没有介绍离线算法，一是因为离线算法应用场景比较少，二是因为我所知道的离线算法（分治法和 Tarjan 算法）的复杂度并没有达到理论下界（Tarjan 算法是一个复杂度接近常数的 $\\Theta(n + q)$-$O(\\alpha(n))$ 算法）。所以只在这里简单提及一下。分治算法使用了一种通常称作 “整体二分” 的思想：定义过程 $\\mathrm{solve}(l,\\;r)$ 会解决最近公共祖先的深度在 $[l,\\;r]$ 的所有询问，这个过程大致执行步骤如下：<br/><br/>令 $m = (l + r) / 2$，表示我们二分的答案。<br/>将所有深度为 $m$ 的点 $u$ 的子树 $T_u$ 内深度不大于 $r$ 的点的标号设为 $u$。<br/>对于每一个询问 $u$、$v$，如果 $u$ 和 $v$ 都有标号且标号相同，则说明 $d(\\mathrm{lca}(u,\\;v)) \\geqslant m$，将这个询问交给 $\\mathrm{solve}(m,\\;r)$。否则将 $u$ 和 $v$ 都变为自己标号的父亲（如果没有标号则不变），并交给 $\\mathrm{solve}(l,\\;m-1)$。<br/>清除所有标号并且递归处理 $\\mathrm{solve}(m,\\;r)$ 和 $\\mathrm{solve}(l,\\;m-1)$。<br/><br/>分治算法本质上是实现了一个集体倍增的方法，其复杂度为 $\\Theta(n + q)$-$O(\\log h)$。Tarjan 算法则是对 DFS 序的处理，在回溯的时候将父亲与儿子利用并查集连接起来，并且在并查集上存储附加信息使得可以查询答案，实现起来比较方便。<br/>在前文中留下了一个简单的思考题，就是利用长链剖分实现 $O(n \\log h)$-$\\Theta(1)$ 的祖先查询，这个算法可以在 https://riteme.github.io/blog/2017-2-6/long-chain.html 处找到答案。<br/>RMQ 问题的实现方面，其实还有许多可以仔细思考的地方。虽然我们在理论上达到了最优，但是它付出了较大的空间代价，并且在一般情况下这种算法实际表现情况并不如想象中那么优秀。相关的讨论可以在 Wikipedia 的笛卡尔树（https://en.wikipedia.org/wiki/Cartesian_tree）的引用中找到。<br/>最后，前面所提及的算法我基本上亲自使用 C++ 实现并测试过，这些代码可以在这里找到：https://github.com/riteme/test/tree/master/oi/Code/algs/Graph/LCA<br/><br/><br/><br/><br/>长度为 $n$ 的序列 $a_i$ 经过差分可以得到一个长度为 $n - 1$ 的序列 $d_i$，其中 $d_i = a_{i + 1} - a_i$，即记录相邻两个数之差。如果知道 $a_1$，那么也可以通过 $d_i$ 推出 $a_i$。 ↩<br/><br/><br/>","tags": "最近公共祖先 区间最值问题 数据结构","url": "blog/2017-9-3/lca.html"}]};