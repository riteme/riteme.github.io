var tipuesearch = {"pages": [{"title": "$k$-SBK变换","text": "$k$-SBK变换 (ksbk.in/out/cpp)<br />时间限制: 1 s / 内存限制: 512 MB / 打开O2优化<br />题目描述<br />数学家Lunk最近发现了一种逗逼的SBK变换。在Lunk眼里，SBK变换是这样的：<br /><br />给你一个$1$至$n$的排列$A$和一个$1$至$n$的排列$P$，$P$对$A$做一次SBK变换后将得到一个新的排列$B$，其中：<br />$$ B_{P_i} = A_i \\tag{SBK Transformation}$$<br /><br />然而做一次SBK变换太过无聊，于是Lunk决定连续做多次SBK变换。即将每次变换后的结果$B$变为$A$，然后继续用$P$对$A$做SBK变换。Lunk想知道连续对$A$做$k$次SBK变换后的结果。<br />输入格式<br />第一行输入两个整数$n$和$k$，表示排列的长度和连续做SBK变换的次数。<br />第二行输入$n$个整数表示排列$A$。<br />第三行输入$n$个整数表示排列$P$。<br />输出格式<br />一行输出$n$个整数，表示$k$次SBK变换后的结果。<br />样例输入<br />1<br />2<br />35 2<br />1 2 3 4 5<br />2 3 4 5 1<br /><br /><br />样例输出<br />14 5 1 2 3<br /><br /><br />样例解释<br />做完第一次SBK变换后： 5 1 2 3 4<br />做完第二次SBK变换后： 4 5 1 2 3<br />数据范围及约定<br />共$10$个测试点，每个测试点的数据范围如下表所示：<br /><br /><br /><br />数据点<br />$n$的规模<br />$k$的规模<br /><br /><br /><br /><br />1<br />$\\le10^3$<br />$\\le10^3$<br /><br /><br />2<br />$\\le10^3$<br />$\\le10^3$<br /><br /><br />3<br />$\\le10^4$<br />$\\le10^5$<br /><br /><br />4<br />$\\le10^4$<br />$\\le2\\times10^5$<br /><br /><br />5<br />$\\le4\\times10^5$<br />$\\le2^{30}$<br /><br /><br />6<br />$\\le4\\times10^5$<br />$\\le2^{33}$<br /><br /><br />7<br />$\\le6\\times10^5$<br />$\\le2^{63}$<br /><br /><br />8<br />$\\le6\\times10^5$<br />$\\le2^{63}$<br /><br /><br />9<br />$\\le10^6$<br />$\\le2^{63}$<br /><br /><br />10<br />$\\le2.3\\times10^6$<br />$\\le2^{63}$<br /><br /><br />","tags": "Problems","url": "blog/2016-7-28/ksbk.html"},
{"title": "2-3树与红黑树","text": "2-3树与红黑树<br />概述<br />红黑树<br />红黑树1是一种平衡二叉树，其目标是为了优化二叉搜索树，防止极端情况下时间复杂度的退化。<br /><br />红黑树的背后原型其实是2-3树。因此我们将先了解什么是2-3树。<br />2-3树<br />2-3树2是一种阶为3的B树3，可以简单的理解为3叉树。2-3树最大的特点就是它一定是一棵完全3叉树，即除了叶节点外，其它的节点没有空儿子。<br /><br />接下来我们将探究2-3树的基本操作。之后再来观察2-3树与红黑树之间的联系。<br />2-3树？<br />树的表示<br />从之前给出的图中可以看出，2-3树的每个节点不一定只有一个键4，同时儿子的数量也有不同。<br />在2-3树中，共有两种节点。<br />第一种是“2-节点”：<br /><br />2-节点和普通的二叉查找树的节点没有什么不同。其左儿子表示比a小的子树，右儿子表示比a大的子树。<br />接下来是不一样的“3-节点”：<br /><br />3-节点有两个键。最左边的儿子表示比a小的子树，中间的儿子表示大于a但小于b的子树，右边的儿子表示比b大的子树。<br />虽然这是2-3树，呈现给我们看的树中是不存在“4-节点”的。但是为了保持树的平衡性，我们将会利用4-节点来在插入和删除过程中保持树的完美平衡。下面是一个4-节点：<br /><br />与3-节点类似，左边和右边的儿子分别表示小于a和大于c的子树。中间的两个儿子分别表示大于a且小于b的子树和大于b小于c的子树。<br />查询操作<br />2-3树具有和二叉查找树一样的有序性，使得查找操作和二叉查找树类似。<br />我们先来看一棵2-3树：<br /><br />使用和二叉查找树一样的方法，我们在向下递归这棵树的时候通过“打擂台”来确定查找的节点应该在哪棵子树中。<br />例如我们要查找8,首先和根节点5做比较，发现比5大，于是在其右子树中查找。<br />接下来7-9这个3-节点中，我们先和9比较，发现比9小，于是向左移一位，与7比较，发现比7大，因此查找的节点应当在中间的子树中。<br />继续深入下去，我们发现2-节点8就是我们要找的。<br />由于2-3树的完美平衡性质，因此所有查询操作均可在$ \\Theta(\\text{log}N) $的时间复杂度内完成。<br />那么问题来了，为什么2-3树具有完美平衡的性质？<br />插入操作<br />2-3树之所以完美平衡，关键在于插入时的维护。<br />我们首先来看2-节点、3-节点以及4-节点之间如何转换。<br />节点合并<br />当我们插入结点时，通常都是插入一个键，在2-3树中就是一个2-节点。<br />与二叉查找树一样，我们将会在2-3树中找到一个合适位置来插入它，这个位置一定在树的底部。<br />然而，在插入前，我们可以保证这棵2-3树是完美平衡的（空树也是如此）。在底部插入一个节点后，就会导致底部“多出”一个节点，导致2-3树不完美平衡。<br />其解决方案就是把它与上面的节点相结合。<br />与节点结合时，共有5种情况：<br /><br />在一个2-节点的左边 <br />在一个2-节点的右边 <br />在一个3-节点的左边 <br />在一个3-节点的中间 <br />在一个3-节点的右边<br /><br />嗯…这些情况很无聊，下面是它们的转换情况：<br /><br />合并的过程是很直观的，就是将2-节点放到了一个合适的地方。<br />由于2-3树中不存在4-节点，因此不需要考虑与4-节点的合并。<br />节点分裂<br />在上面的节点合并的操作中，我们发现出现了4-节点。然而4-节点是不能出现在最后的2-3树中的。<br />因此我们需要将4-节点“肢解”，以确保这是一棵2-3树。<br />通常情况下，一个4-节点可以分裂成3个2-节点：<br /><br />分裂的过程十分简单，只需要将4-叉节点从中间分开，并将中间的两个儿子分别重新接在a的右儿子和c的左儿子即可。<br />但是4-节点是在插入时出现的，并且是出现在树的底部。我们发现这样一分裂就导致高度加1，直接导致树的不平衡。为了解决这个问题，我们将a和c留在原处，把b向上传递，与父亲节点结合。这样就可以避免高度的增加了。<br />但是父亲节点可能是一个3-节点，b向上结合时又会产生4-节点！但是不必慌张，我们只需要继续分解这个新生成的4-节点即可。<br />那么问题又来了，如果父亲节点是3-节点并且它是树根呢？<br />其实非常简单，我们依然可以分解4-节点，由于根节点没有父亲，因此向上传递的节点就没必要去结合了，此时整棵树的高度加1，保证了2-3树的完美平衡性。<br />插入示例<br />下面是一个完整的插入示例，依次向一棵空的2-3树中插入1到7：<br /><br />在插入节点中，找到其正确的位置需要访问$ \\Theta(\\text{log}N) $个节点。回溯向上调整2-3树时，每个节点处的调整时间为$ \\Theta(1) $。因此，2-3树的插入操作的时间复杂度为$ \\Theta(\\text{log}N) $。<br />删除操作<br />可以看出，2-3树的插入操作是有点复杂的，然而删除操作更加麻烦。我们首先从简单的情况开始讨论。<br />首先，我们确定一点：2-3树中的节点的儿子，要么都是空儿子，要么都不是空儿子。<br />原因非常简单，我们用反证法来证明：如果存在一个节点，它既有非空儿子，又有空儿子，那么非空儿子在树中所处的深度肯定大于父节点的深度，那么以这个节点为根的子树不是完美平衡的。又因为2-3树必须是完美平衡的，因此2-3树需要它所有的子树也是完美平衡的，故这样的节点是不存在的。<br />并且可以看出，只有树的底部节点才会没有儿子。<br />由此，我们就可以方便的分情况讨论。<br />删除底部节点<br />我们先考虑底部节点是因为这些节点不需要和它的儿子们“纠缠不清”，并且它也是我们后续删除算法的一个基础。<br />首先考虑3-节点。从3-结点删除一个键非常简单，只需要将其变成一个2-节点就可以保证2-3树的完美平衡。然而删除一个2-节点就麻烦了，因为这会导致留下一个空位，而且没有合适的节点来填补它。<br />为了解决这个问题，我们考虑在删除之前能否将其变成一个3-节点。<br />答案是肯定的，我们可以通过从根节点开始的一系列变换来实现这一点。<br />为了在最后删除的时候的确是一个3-节点，我们必须确保在查找被删除的节点的路径上必须一直有3-节点。<br />假设我们在寻找待删除节点的路径上已经处于一个3-节点处，我们需要考虑如何保证下一步也是一个3-节点。首先，我们确定要向下递归的方向，如果在该方向上已经有一个3-节点，那么我们无需变换就可安全地递归向下。如果该方向上没有3-节点，我们就需要想办法变出一个3-节点。<br />如何才能变出一个3-节点呢？一个很好的想法就是当我们有很多的节点时，我们就有很大的自由来分配这些节点。因此，我们将当前的3-节点中的一个键拿出来，和它的儿子”团聚”一下，然后确定如何“发配”这些“聚在一起”的节点。如果其中一个儿子是3-节点，那么聚合后就会出现一个含有4个键的5-节点！5-节点是绝对不能出现的！但是我们可以从中取出两个键来构成一个3-节点，剩下的两个键则用于调整局部平衡。这样就既不损害2-3树的完美平衡性，又能在希望的地方创建一个3-节点了。当然，你也可以理解成公然从左儿子或右儿子中“抢来”了一个键。<br />但如果两个儿子中没有一个是3-节点，那么我们现在就只凑到了3个键，还不足以分解出3-节点。因此，我们索性将从当前节点的分离出来的键和儿子们构成一个临时的4-节点。没错，就是4-节点，在4-节点中删除一个键也是很容易的，并且如果不是从中删除键，我们也有办法在删除完指定的键之后的回溯过程中来分解这个4-节点，从而保证2-3树中不会出现不该出现的东西。<br />为了更清楚的说明上面这坨东西在讲什么，我放几张图解释一下：<br />首先是可以从旁边“抢”节点的情况：<br /><br />上图是准备向右递归之前的调整过程。首先取出e与它的儿子3-节点c-d和2-节点f结合生成了一个5-节点c-d-e-f，然后我们取出e和f在右边创建出一个3-节点，然后d代替原来3-节点b-e中e从而还原，然后被抢掉一个键的c就默默的留在原地…<br />对于向左边和中间调整都是类似的做法。只是向中间递归的调整需要先判定是左边有3-节点还是右边有3-节点，从而确定被取出的键是谁。<br />如果这个键的儿子都是2-节点，我们从这个节点中取出一个键向下合并，却只能创造出一个临时的4-节点，无法从中提取出3-节点。因此我们将其留在那里当作是3-节点。这个4-节点等到我们删除完之后再来处理。如果要删除的键就在这个节点中，我们就不需要管了。如果这个4-节点依然保留着，只需分解它即可。下面是合并的过程：<br /><br />但是，上面的做法都是在假设当前正处在一个3-节点处而做的。倘若根节点就不是3-节点，那该怎么办呢？<br />考虑到根节点的特殊性，我们可以直接将其和它的儿子合并为4-节点。<br /><br />如果根节点和它的左右儿子都是2-节点，那么我们可以直接将它和儿子们结合，变成一个3-节点。这样会导致树的局部的高度降低。然而这是在根节点处，所以这样的变化是全局性的，不会影响2-3树的完美平衡性。同时有保证向下变换时有充足的键可取。同理，这个遗留的4-节点可以日后再来将其分解掉。<br />这样，我们就能确保在删除操作必定是在3-节点内进行的了。于是我们完成了底部节点的删除操作。<br />删除中间节点<br />然而，我们不一定会去删除底部节点，而是会删除树中央的一个节点。这样似乎问题变得很棘手。<br />然而我们可以将其转换为删除底部节点。我们模仿二叉搜索树的删除方式：当要被删除的节点有两个儿子时，用该节点的前趋或者后继节点来顶替它，并且将这个前趋或者后继节点删除。<br />由于2-3树的非底部节点一定是有多个儿子的，因此，我们找到其后继节点，将这个后继节点的键和卫星数据5复制到要被删除的节点处，这样就实现了用后继节点来顶替原先节点的任务。因此我们就只需要将原来的后继节点删除即可。<br />而一个节点的后继节点是它的右子树中的最小的节点，即右子树中最靠左的节点，因此它肯定没有儿子。所以我们可以使用删除底部节点的方法来删除它。<br />删除示例<br />为了使大家想得更明白，这里给出一个删除底部节点的示例。<br />首先，下面是一棵高度为4的2-3树，我们准备删除i：<br /><br />从根节点开始，发现i在右子树中，但发现根节点自己和左右儿子都是2-节点，于是它们合并为一个4-节点：<br /><br />接下来在新的4-节点d-h-n中发现右儿子为3-节点，于是直接向下搜索。<br />在3-节点j-l中我们发现i在其左子树中，并且左儿子不是3-节点，于是我们将j向下合并：<br /><br />向下后来到4-节点i-j-k，发现目标i就在其中，我们直接将其删除：<br /><br />删除完成，我们沿着递归向下的顺序向上回溯。回溯到根节点时，我们发现是一个4-节点，于是我们将其分解：<br /><br />至此。删除操作就完成了。<br />对于所有的删除操作，2-3树需要$ \\Theta(\\text{log}N) $的时间查找节点，并且以$ \\Theta(1) $的时间在每个回溯的节点处来作出适当的调整。故2-3树的删除操作是$ \\Theta(\\text{log}N) $的。<br />2-3树到红黑树<br />上面讲了那么多关于2-3树的操作，却从不提及其具体实现，是因为2-3树在实际中很少使用。<br />由于其需要大量的节点变换（从2-节点到3-节点到4-节点甚至到5-节点…），这些变换在实际代码中是很复杂的。所以现在几乎没有2-3树的具体实现。<br />但是由于2-3树的变化十分直观，因此前人在2-3树的理论基础上发明了红黑树。<br />变化到红黑树<br />红黑树是一种平衡二叉树，只有一种节点。这种节点有两个儿子，和2-3树中的2-节点对应。<br /><br />如何表示3-节点呢？我们尝试一种特殊的边：默认情况下节点的颜色均为黑色。我们将某个节点染为红色，表示它和父亲的的链接是红色的，就像下图：<br /><br />当我们将红链接画平时…<br /><br />我们发现它和2-3树中的3-节点极为类似！<br />事实上，我们完全可以用这样的方式来表示2-3树中的3-节点。<br />下图是一棵典型的红黑树：<br /><br />如果将红链接画平，将得到一棵完美平衡的“2-3树”：<br /><br />从某种意义上来说，红黑树和2-3树是一种等同。<br />同时，为了我们的操作方便，我们对红黑树作出以下规定：<br /><br />红黑树是二叉搜索树。  <br />根节点必须为黑色。毕竟根节点没有父亲。  <br />红链接必须在左侧6。将红链接统一在一个方向是为了方便其它操作。如果不统一，3-节点就有两种情况，4-节点就有5中情况，非常不利于我们判定当前是什么节点。并且，对于右边的红链接，我们可以通过二叉搜索树的旋转操作来将其变为左链接。具体的会在之后解释。  <br />不允许两个连续的红链接。因为连续的连个红链接表示的是4-节点。当然，跟2-3树一样，插入/删除的过程中还是允许临时的4-节点。  <br />每一条树链上的黑色节点数量（称之为“黑高”）必须相等。原因非常简单，一个黑色节点就对应着2-3树中的一个2-节点或3-节点，而2-3树是完美平衡的。  <br />空节点（NULL/None）为黑色。这样方便将方便我们识别没有儿子的2-节点。<br /><br />查询操作<br />由于红黑树是二叉搜索树，因此查询操作就是二叉搜索树的查询操作。时间复杂度为$ \\Theta(\\text{log}N) $。<br />基本操作<br />在介绍红黑树的插入和删除操作前，首先介绍红黑树的一些基本操作。<br />旋转<br />红黑树的旋转只有两种：顺时针旋转和逆时针旋转7。<br />红黑树的旋转操作是为了在保证二叉搜索树和红黑树的性质的前提下，来转换红链接的位置。  <br /><br />可以看出顺时针旋转就是将节点的左儿子提上来，将自己变做它的右儿子，将左儿子的右子树接到自己的左子树中，同时转变红链接。可以将其想象成把4->2这条边顺时针旋转了一下。逆时针旋转也是类似的做法。同时顺时针旋转和逆时针旋转可以视为一对逆操作，因为一次左旋和一次右旋可以变回原来的样子。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25# 顺时针旋转<br />def cw_rotate(h):<br />    assert h is not None and h.left is red  # h是非空节点并且左儿子为红色<br /><br />    x = h.left<br />    h.left = x.right<br />    x.right = h<br />    x.color = h.color<br />    h.color = red<br /><br />    return x  # 返回被提上来的左儿子<br /><br /># 逆时针旋转<br />def ccw_rotate(h):<br />    assert h is not None and h.right is red  # h是非空节点并且左儿子为红色<br /><br />    x = h.right<br />    h.right = x.left<br />    x.left = h<br />    x.color = h.color<br />    h.color = red<br /><br />    return x  # 返回被提上来的左儿子<br /><br />h = cw_rotate(h)  # 将h顺时针旋转<br /><br /><br />反色<br />如同在2-3树中一样，红黑树要能够处理4-节点。<br />对于4-节点，我们只有两种操作：合成一个4-节点和分解一个4-节点。<br /><br />对照一下2-3树，这个操作就显而易见了。<br /><br />也许你会注意到反色操作会将两个儿子的父节点变为红色，是因为在2-3树中，中间取出来的键要向上传递并结合进去。此外，反色操作会导致出现右边的红链接，然而这没有关系，因为4-节点是临时的，我们最终会通过逆时针旋转将其变为左边的红链接或者再次反色将这个4-节点分解。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10def flip_color(h):<br />    assert h.color is different from h.children.color  # h的颜色和它的儿子相反<br /><br />    h.color = (h.color == RED ? BLACK : RED)<br />    h.left.color = (h.left.color == RED ? BLACK : RED)<br />    h.right.color = (h.right.color == RED ? BLACK : RED)<br /><br />    return h<br /><br />h = flip_color(h)  # 将h反色<br /><br /><br />插入操作<br />为了探究红黑树的插入操作，我们依然回到2-3树。在2-3树中，我们将新插入的节点与上面的节点合并，然后再做调整。为了表示合并，我们将新插入的节点均设为红色，表示与上面的节点相连接。  <br />然而插入后，新的红节点可能会违反我们的规定，因此需要在回溯的时候进行调整。<br />情况一：调整右边的红链接<br />当我们发现某个节点的左儿子是黑色但右儿子是红色时，我们要将右边的红色链接转到左边来：<br /><br />如上图，通过对b逆时针旋转，完成了对红链接位置的纠正。<br />这样做是为了方便接下来的操作。<br />情况二：分解4-节点<br />在情况一中，我们要求节点的左儿子是黑色。这是因为当左儿子和右儿子都是红色时，就代表着一个4-节点，为此我们可以直接将其反色来分解它：<br /><br />如果该操作是在根节点上，那么整棵红黑树的黑高将会加1。<br />情况三：连续的红色左儿子<br />在情况一中，我们能够把所有的右边的红色节点转到左边来，这样就好判断是否存在4-节点。除了情况二中的4-节点外，连续的两个红色左儿子也将表示一个4-节点：<br /><br />对此，我们的做法是将节点顺时针旋转，从而变为了情况二。<br />平衡操作<br />上面介绍了三种插入时的情况，实际上已经将插入的所有情况都概括到了。接下来我们将实现一个平衡操作。这个平衡操作就是通过对节点的情况进行判定并作出调整。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13def balance(h):<br />    assert h is not None  # 当然不能为非空节点<br /><br />    if h.right is red and h.left is not red:  # 情况一<br />        h = ccw_rotate(h)<br /><br />    if h.left is red and h.left.left is red:  # 情况三<br />        h =.cw_rotate(h)<br /><br />    if h.left is red and h.right is red:  # 情况二<br />        h = flip_color(h)<br /><br />    return h  # 返回调整后的h节点<br /><br /><br />有了平衡操作后，我们就能直接改动一行二叉搜索树的插入代码，就能实现红黑树的插入了：<br />1<br />2<br />3<br />4<br />5def insert(h, key, value):<br />    # 二叉搜索树的插入实现<br /><br />    # return h<br />    return balance(h)  # 插入后回溯的过程中，先平衡节点，再返回<br /><br /><br />这里需要注意一点，当所有操作完成以后，根节点可能变为红色，这是需要我们手动将根节点设置为黑色。<br />由于balance操作是$ \\Theta(1) $的时间复杂度，故红黑树的插入操作是$ \\Theta(\\text{log}N) $的时间复杂度。<br />删除操作<br />正如你所见，红黑树的插入写起来也并不是那么难。然而删除操作就未必。根据我们在2-3树中所讨论的，红黑树删除节点也要保证一路上都有一个3-节点或4-节点。<br />红节点的转移<br />由于红黑树在向下递归的过程中只有向左边和向右两个方向，因此我们再弄两个操作：红色左移和红色右移。这两个操作用于在左儿子和右儿子处创造出一个3-节点或4-节点。<br />我们先讨论红色左移的情况，毕竟红色右移也是类似的做法。<br />当我们要在左儿子处造一个3-节点时，首先肯定左儿子不是3-节点。那么按照2-3树的做法，我们要么是从右儿子借一个节点，要么就是把自己“献身”。<br />第一种情况是右儿子不是3-节点，我们直接在左儿子处创建4-节点：<br /><br />上面就是利用了反色操作。<br />另一种情况是右儿子是一个3-节点，那么操作就有点复杂了：<br /><br />和2-3树一样，我们将b合并创建出一个5-节点。然后我们发现右儿子的左儿子是红色的，即右儿子为3-节点。为此，我们通过两次旋转操作将代替节点b的节点c旋转到曾经b的位置。最后我们分裂这个5-节点，此时左儿子已经是一个3-节点。<br />这样我们就能把红色左移给写出来了：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13def move_red_to_left(h):<br />    assert h is red and h.left is not red  # 左儿子必须为黑色，同时当前必须是红色<br /><br />    h = flip_color(h)  # 与儿子节点结合<br /><br />    if h.right.left is red:  # 如果右儿子为3-节点<br />        # 通过两次旋转将替代者上移至h处<br />        h.right = cw_rotate(h.right)<br />        h = ccw_rotate(h)<br /><br />        h = flip_color(h)  # 分裂5-节点<br /><br />    return h<br /><br /><br />同样红色右移也是一样的做法。先是节点结合，然后根据情况进行调整。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11def move_red_to_left(h):<br />    assert h is red and h.right is not red<br /><br />    h = flip_color(h)<br /><br />    if h.left.left is red:<br />        h = cw_rotate(h)  # h的左儿子就是替代者<br /><br />        h = flip_color(h)<br /><br />    return h<br /><br /><br />处理根节点<br />和2-3树一样，根节点可能为2-节点。为了方便处理，我们可以把根节点也看作是一个3-节点：<br /><br />上图中，a是真正的根节点，而$ \\infty $是一个想象的节点，实际上不存在。这样根节点就变成了一个3-节点。<br />并且，对于这个3-节点，无论红色左移和红色右移都不会关系到$ \\infty $，因此这样不会导致问题。<br />实际中，我们直接将根节点设为红色即可。当删除操作完成后，再把根节点设为黑色。<br />真正的删除<br />解决了红色节点的转移的工作，删除操作也就变得清晰了。下面将介绍删除操作该如何进行。<br />红黑树的删除过程和二叉搜索树类似。首先都要在树中找到这个节点，然后再着手处理。<br />对于红黑树，它的节点也是要么都是空儿子，要么就没有空儿子。<br /><br />对于没有儿子的节点，在保证向下递归的红色节点的变换完成之后，如果它是红节点，我们可以直接将其删除。如果不是红节点，那么它的左儿子必定是红色节点，因为我们保证它会在一个3-节点或4-节点中，并且我们的红色转移操作都是创建红链接在左的节点。这样我们可以直接将其顺时针旋转，使其变为红色节点，然后直接删除。  <br />对于有儿子的节点，我们模仿二叉搜索树中的做法：在它的右子树中找到最小的节点来替代它的位置，然后在右子树中将这个节点删除即可。<br /><br />下面是红黑树的删除操作的参考实现：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40# 获取后继节点<br />def min_node(h):<br />    assert h is not None<br /><br />    if h.left is not None:  # 一直沿左链接寻找<br />        return min_node(h.left)<br />    else:<br />        return h<br /><br />def delete(h, key):<br />    assert h is not None  # 确认不是一棵空树<br /><br />    if key < h.key:  # 在左子树中<br />        if h.left is black and h.left.left is black:  # 如果左儿子不是3-节点<br />            h = move_red_to_left(h)<br /><br />        h.left = delete(h.left, key)<br />    else:  # 在右子树中或已经找到<br />        if h.left is red:<br />            h = cw_rotate(h)  # 将左边的红链接变为右边的红链接<br /><br />        if key == h.key and h.right is None:  # 如果已经查找到并且没有儿子<br />            del h  # 直接删除<br />            return None<br /><br />        if h.right is black and h.right.left is black:  # 如果右儿子不是3-节点<br />            h = move_red_to_right(h)<br /><br />        if key == h.key:  # 如果已经查找到但有儿子<br />            x = min_node(h.right)  # 找到后及节点<br /><br />            # 交换键值和卫星数据<br />            h.key = x.key<br />            h.data = x.data<br /><br />            h.right = delele(h.right, x.key)  # 在右子树中删除后继<br />        else:  # 如果没有命中，则继续往右边寻找<br />            h.right = delete(h.right, key)<br /><br />    return balance(h)  # 完成删除后平衡当前的子树<br /><br /><br /><br /><br /><br /><br />红黑树维基百科：https://zh.wikipedia.org/zh-cn/% E7% BA% A2% E9% BB% 91% E6% A0% 91 ↩<br /><br /><br />2-3树（2-3-4树）维基百科：https://zh.wikipedia.org/wiki/2-3-4% E6% A0% 91 ↩<br /><br /><br />B树维基百科：https://zh.wikipedia.org/wiki/B% E6% A0% 91 ↩<br /><br /><br />键（Key）表示节点用于索引的值，同时也是确定节点在树中的位置的依据之一。 ↩<br /><br /><br />卫星数据指存储在这个节点上的与树结构无关的数据，即这个节点的一些附加数据，例如假设每个节点表示一个人，那么性别、年龄、身高等就属于卫星数据。 ↩<br /><br /><br />这是红黑树的一种实现。网络上有其它的实现，允许右儿子为红色。 ↩<br /><br /><br />也称作左旋和右旋，但个人认为这样的名字晦涩并具有误导性，故使用顺时针旋转和逆时针旋转代替。 ↩<br /><br /><br />","tags": "2-3树 红黑树 算法 数据结构","url": "blog/2016-3-12/2-3-tree-and-red-black-tree.html"},
{"title": "All Posts","text": "所有文章<br />2016<br />2016-11<br />2016-11-29<br /><br />差分序列与Stirling数: 介绍了差分序列和两类Stirling数<br /><br />2016-11-25<br /><br />位运算卷积与FWT: 介绍了位运算卷积以及快速计算的FWT算法<br /><br />2016-11-16<br /><br />辛普森积分法: 简单介绍了辛普森积分法和自适应辛普森积分法<br /><br />2016-11-6<br /><br />RSRL开发记录（一）<br /><br />2016-10<br />2016-10-30<br /><br />收到一封奇怪的邮件<br /><br />2016-9<br />2016-9-19<br /><br />Hall定理: 一个用于判定二分图是否具有最大匹配的定理<br /><br />2016-8<br />2016-8-28<br /><br />HNSDFZ2016 #5: HNSDFZ2016第五次欢乐互测<br /><br />2016-8-22<br /><br />快速数论变换 (NTT): 快速傅立叶变换的双胞胎，用原根代替单位复数根<br /><br />2016-8-19<br /><br />二进制GCD: 在算导上发现了一个有趣的算法，有氧环境下可以拿来卡卡常.....<br /><br />2016-8-18<br /><br />莫比乌斯反演: 介绍了莫比乌斯函数和莫比乌斯反演公式<br />二项式定理及其它: 记录一下二项式定理、多项式定理和牛顿二项式定理的一些东西<br /><br />2016-8-17<br /><br />中国剩余定理 (CRT): 介绍了基本的中国剩余定理<br /><br />2016-8-15<br /><br />HNSDFZ2016 #4: HNSDFZ2016第四次欢乐互测<br /><br />2016-8-11<br /><br />凸包相关: 凸包的构造算法与动态凸包、旋转卡壳和斜率优化<br /><br />2016-7<br />2016-7-28<br /><br />平衡树套链表: 用链表加速平衡树上前趋后继的查询<br /><br />2016-7-9<br /><br />有关多项式的算法:记录一些与多项相关式算法<br /><br />2016-7-9<br /><br />HNSDFZ2016 #3: HNSDFZ2016第三次欢乐互测<br /><br />2016-6<br />2016-6-23<br /><br />极限与导数: 最近学了一些基础微积分，这里稍微记录一下<br /><br />2016-6-19<br /><br />诱导排序与SA-IS算法: 介绍一种在2009年出现的基于诱导排序思想的线性时间构建后缀数组的算法SA-IS。此算法号称是目前速度最快的后缀数组构建算法<br /><br />2016-6-3<br /><br />树状数组: 总结一下树状数组的用法<br /><br />2016-6-2<br /><br />点分四叉树 (Point Quadtree): 二维平面上的一种划分树<br /><br />2016-5-31<br /><br />HNSDFZ2016 #2: HNSDFZ2016第二次欢乐互测<br />HNSDFZ2016 #1: HNSDFZ2016第一次欢乐互测<br /><br />2016-5<br />2016-5-7<br /><br />排列与组合: 介绍了排列与组合的基础知识<br /><br />2016-4<br />2016-4-23<br /><br />伪代码规定: 规定下本博客的伪代码规范，不要想太多<br /><br />2016-4-20<br /><br />树链剖分: 介绍了树链剖分算法及其小扩展<br /><br />2016-4-16<br /><br />Graphviz: 可视化调试利器: 介绍可视化工具Graphviz的基本使用<br /><br />2016-4-12<br /><br />平面计算几何: 计算几何的基础知识和算法<br /><br />2016-4-10<br /><br />秩平衡树(Rank Balanced Tree): 利用秩进行平衡的二叉搜索树<br /><br />2016-4-6<br /><br />替罪羊树(Scapegoat Tree): 二叉平衡树替罪羊树<br /><br />2016-3<br />2016-3-21<br /><br />$x^n-1$问题: 对$x^n-1$进行因式分解<br /><br />2016-3-12<br /><br />2-3树与红黑树: 2-3树与红黑树<br /><br />2016-2<br />2016-2-5<br /><br />DevIL快速入门: 了解图片库DevIL<br /><br />2016-2-4<br /><br />正式开始编写ne2d: 启动ne2d<br />测试多说: 测试多说评论系统<br /><br />2016-2-3<br /><br />编译并使用bgfx: bgfx在Ubuntu上编译<br /><br />2016-2-2<br /><br />最小费用最大流: 增广路算法<br /><br />2016-2-1<br /><br />[POJ2135] Farm Tour: POJ2135 题解<br />[NOIP2014] 寻找道路: NOIP2014 Day2 T2 题解<br />[NOIP2015] 信息传递: NOIP2015 Day1 T2 题解<br />最近公共祖先(LCA): 朴素LCA算法，Tarjan-LCA算法，倍增法<br /><br />2016-1<br />2016-1-31<br /><br />pagegen.py的试炼: 测试pagegen.py<br /><br />临时链接<br /><br />无尽的黄金 (HNSDFZ OIER FORBIDDEN before self contest #6)<br />空袭 (HNSDFZ OIER FORBIDDEN before self contest #5)<br />$k$-SBK变换 (HNSDFZ OIER FORBIDDEN before self contest #4)<br />HNSDFZ #3<br />Lesson 16<br />","tags": "Posts","url": "posts.html"},
{"title": "BST厂长","text": "BST厂长 (bst.in/out/cpp)<br />时间限制: 1 s / 内存限制: 128 MB / 打开O2优化<br />题目描述<br /><br />二叉树真是迷人......<br /><br />随着时代的进步，二叉搜索树(Binary Search Tree)发挥着越来越大的作用。作为HNSDFZ上机部长XL，担负着为学校制造各种BST的任务。它们会用于各种用途：成绩排名、薪水发放、PY**......<br />本来学校对BST的需求并不是很大，但是自从ZY加入了上机组后，BST的需求越来越大......<br />作为XL，早已按捺不住。于是XL利用通用技术教学楼建立了一个厂房，专门制造各种BST。<br />这个厂子会收到各种各样的订单。每个订单都会是一个很长的数列，其中没有两个数是相同的。而XL要做的就是将这些数字依次插入到一棵空的BST中，然后将BST发送出去。<br />然而人工干这件事实在是太麻烦了，因此XL将ZY抓过来造BST。然而ZY更懒，把Link抓过来要它帮<br />ZY写个程序来构建BST。然而Link并不屑于写这个程序，于是这个任务莫名其妙地传到了你手上......<br />当然XL不会就这样放手不管，XL会随时来检查这棵BST是否是正确的，以防你在乱造BST。<br />输入格式<br />第一行输入一个正整数$n$，表示订单中数列的长度。<br />接下来$n$行，每行输入两个正整数$x$和$k$。表示将$x$插入到当前的BST中。初始时是空树。$k$则表示XL的检查。他会问你根节点到新插入的节点$x$的链上第$k$个节点是谁。默认从$1$开始数。<br />输出格式<br />对于每一次XL的检查，输出对应的答案。<br />样例输入<br />1<br />2<br />3<br />43<br />2 1<br />1 1<br />3 2<br /><br /><br />样例输出<br />1<br />2<br />32<br />2<br />3<br /><br /><br />提示及数据约定<br />对于第一次插入$2$，树的根节点为$2$，故答案为$2$。<br />对于第二次插入$1$，因为$1 \\lt 2$，所以$1$是$2$的左儿子。$2$到$1$的链上的第一个节点为$2$<br />对于最后一次插入$3$，因为$3 \\gt 2$，所以$3$是$2$的右儿子。$2$到$3$的链上的第二个节点是$3$。<br />对于$10\\% $的数据，$n \\le 20,000$。<br />对于$10\\% $的数据，$n \\le 90,000$。<br />对于$20\\% $的数据，$n \\le 100,000$。<br />对于另外$10\\% $的数据，数列完全随机。<br />对于$100\\% $的数据，$n \\le 200,000$，$1 \\le x \\le n$，保证每次检查的节点存在。","tags": "Problems ZY XL LinkSBK","url": "blog/2016-5-30/riteme.html"},
{"title": "DevIL快速入门","text": "DevIL快速入门<br />DevIL全名是“Developer’s Image Library”，它是一个多功能的图像库，能过很方便地载入、修改和保存图片。<br />其原名是OpenIL，后来是因为SGI的要求才改名为DevIL1。<br />本文主要介绍DevIL载入和保存图片的功能。DevIL虽然有处理图片的功能，但并不够强，不如使用Boost.GIL，<br />因此不介绍DevIL处理图片的功能。<br />特点<br />DevIL具有几个非常好的特性：<br /><br />支持包括PNG，JPG，TGA等30多种图片格式。  <br />与OpenGL类似的API风格。  <br />十分轻巧  <br />有许多辅助函数（ilut）<br /><br />安装<br />理论上安装DevIL不会很艰难。对于Ubuntu 用户而言，可以直接使用下列命令来安装：<br />1sudo apt-get install libdevil-dev<br /><br /><br />具体的下载、编译、安装的页面在此。<br />初始化<br />接下来正式介绍如何使用DevIL。首先，我们需要添加头文件：<br />1#include <IL/il.h><br /><br /><br />一般情况下，动态链接的DevIL会自动加载，不必调用特定的函数。但在某些情况下可能不会。因此，为了兼容性，我们最好手动载入：<br />1<br />2// 在程序开始的地方<br />ilInit();<br /><br /><br />仅仅一行代码，并没有什么关系。<br />加载图片<br />DevIL中使用了和OpenGL一样的对象创建方式。为了加载图片，我们首先要创建一个图片对象：<br />1<br />2<br />3ILuint image = 0;<br />ilGenImages(1, &image);<br />assert(image != 0);  // 检查是否创建成功<br /><br /><br />也许你会发现第二行非常熟悉，确实和OpenGL中创建缓冲区的调用长得非常像，因此很多使用OpenGL的开发者能很快上手。<br />当然，你如果觉得这还麻烦了，可以只创建一个：<br />1ILuint image = ilGenImage();<br /><br /><br />就像OpenGL一样，需要绑定当前的图片对象。绑定后，所有的操作都是在此图片对象上的，除非解绑：<br />1<br />2<br />3<br />4<br />5ilBindImage(image);<br /><br />// ...<br /><br />ilBingImage(0);  // 解绑图片对象<br /><br /><br />绑定好图片对象后，就可以直接使用ilLoad函数来加载图片了：<br />1ilLoad(IL_PNG, \"sample.png\");<br /><br /><br />上面的IL_PNG是指定图片格式为PNG。<br />当然，可以使用更简单的ilLoadImage：<br />1ilLoadImage(\"sample.png\");<br /><br /><br />使用ilLoadImage就不需要手动指定图片格式了，DevIL会自动检测。<br />我们可以使用ilGetError来查看错误。如果加载过程中没有出错，ilGetError会返回IL_NO_ERROR。<br />1assert(ilGetError() == IL_NO_ERROR);<br /><br /><br />注意<br />当你不需要再使用图片对象时，应及时使用ilDeleteImage删除：<br />1<br />2ilDeleteImage(image);       // 删除单个图片对象<br />ilDeleteImages(1, &image);  // 当然也可以批量删除<br /><br /><br /><br />创建材质<br />加载完图片后，还只是将数据托管在DevIL内部。为了能够将数据提供给OpenGL或DirectX来创建材质，我们使用ilGetData()。<br />同时，我们还需获取图片的相关的信息，如宽度、高度、图片存储格式等等，这些都可以使用ilGetInteger来获取。<br />下面是在OpenGL中创建材质的过程：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9ilBindImage(image);                               // 绑定当前图片对象<br />GLint    width  = ilGetInteger(IL_IMAGE_WIDTH);   // 获取图片宽度<br />GLint    height = ilGetInteger(IL_IMAGE_HEIGHT);  // 获取图片高度<br />GLenum   format = ilGetInteger(IL_IMAGE_FORMAT);  // 获取图片像素格式<br />ILubyte *ptr    = ilGetData();                    // 获取图片数据的指针<br />ilBindImage(0);<br /><br />// 创建材质<br />glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, ptr);<br /><br /><br />提示<br />DevIL中可以获取很多图片的信息，除了宽度、高度和像素格式外，还可以获取色深（IL_IMAGE_DEPTH）、<br />图片数据的大小（IL_IMAGE_SIZE_OF_DATA）、BPP（”Bytes Per Pixel“，每个像素所占字节数，IL_IMAGE_BPP或IL_IMAGE_BYTES_PER_PIXEL）、<br />Bit Per Pixel（每个像素所占位数，IL_IMAGE_BITS_PER_PIXEL）、图片格式（IL_IMAGE_TYPE）、<br />水平/竖直平移量（IL_IMAGE_OFFX和IL_IMAGE_OFFY）、图片原点（IL_IMAGE_ORIGIN）、<br />颜色通道数（IL_IMAGE_CHANNELS）等。<br /><br />提示<br />在上面的示例中，图片的像素格式被直接传到OpenGL的函数中是可以的，因为DevIL对应的值和OpenGL规定的是一样的，不会有问题。<br />对于DirectX，需要手写switch来切换。<br /><br />保存图片<br />DevIL中保存图片很简单，只需要先绑定图片对象，指定保存路径就可直接保存。DevIL会自动通过文件后缀名来确定图片格式。<br />1<br />2<br />3ilBindImage(image);<br />ilSaveImage(\"output.png\");<br />ilBindImage(0);<br /><br /><br />可是我们并没有对图片做什么处理啊，保存它有什么用？确实，我们不会去用DevIL来做什么特效。但有一个场景却很常用，就是保存截图。<br />对于OpenGL，DevIL的工具库ilut已经帮我们做到了这一点。我们可以非常简单的写出保存截图的函数：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16#define ILUT_USE_OPENGL  // 通知ilut使用OpenGL<br />#include <IL/ilut.h><br /><br />// 保存截图<br />bool TakeScreenshot(const std::string &filepath) {<br />    ILuint image = ilGenImage();    <br />    ilBindImage(image);<br /><br />    ilutGLScreen();                // 将当前OpenGL的颜色缓冲区的数据复制到image中<br />    ilSaveImage(filepath.data());  // 保存图片<br /><br />    ilBindimage(0);<br />    ilDeleteImage(image);          // 记得释放图片对象<br /><br />    return ilGetError() == IL_NO_ERROR;<br />}<br /><br /><br />没错，ilutGLScreen帮我们做了一切。只是非常可惜，截图的函数是OpenGL专属的。<br />但它是怎么工作的呢？我在GitHub上找到其源码，其过程非常简短。<br />下面是GitHub上的源码：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22//! Takes a screenshot of the current OpenGL window.<br />ILboolean ILAPIENTRY ilutGLScreen()<br />{<br />    ILuint  ViewPort[4];<br /><br />    ilutCurImage = ilGetCurImage();<br />    if (ilutCurImage == NULL) {<br />        ilSetError(ILUT_ILLEGAL_OPERATION);<br />        return IL_FALSE;<br />    }<br /><br />    glGetIntegerv(GL_VIEWPORT, (GLint*)ViewPort);<br /><br />    if (!ilTexImage(ViewPort[2], ViewPort[3], 1, 3, IL_RGB, IL_UNSIGNED_BYTE, NULL))<br />        return IL_FALSE;  // Error already set.<br />    ilutCurImage->Origin = IL_ORIGIN_LOWER_LEFT;<br /><br />    glPixelStorei(GL_PACK_ALIGNMENT, 1);<br />    glReadPixels(0, 0, ViewPort[2], ViewPort[3], GL_RGB, GL_UNSIGNED_BYTE, ilutCurImage->Data);<br /><br />    return IL_TRUE;<br />}<br /><br /><br />我们来简要分析下这个过程在干什么。<br />首先是获取当前绑定的图片对象：<br />1<br />2<br />3<br />4<br />5ilutCurImage = ilGetCurImage();<br />if (ilutCurImage == NULL) {  // 检查并报错<br />    ilSetError(ILUT_ILLEGAL_OPERATION);<br />    return IL_FALSE;<br />}<br /><br /><br />然后获取当前OpenGL视图的信息：<br />1<br />2<br />3<br />4<br />5ILuint  ViewPort[4];<br /><br />// ...<br /><br />glGetIntegerv(GL_VIEWPORT, (GLint*)ViewPort);<br /><br /><br />此时，ViewPort中存储的分别是原点的X坐标和Y坐标，以及视图的宽度和高度。<br />根据获取来的视图信息，就需要调整图片的参数：<br />1<br />2<br />3<br />4// ilTexImage分别设置的是图片的宽度、高度、BPP、颜色通道数量、像素格式和数据格式<br />// 最后一个参数是图片数据的指针，但是图片数据要在之后读取，因此这里填nullptr<br />if (!ilTexImage(ViewPort[2], ViewPort[3], 1, 3, IL_RGB, IL_UNSIGNED_BYTE, NULL))<br />    return IL_FALSE;  // 设置失败<br /><br /><br />然后是从OpenGL的颜色缓冲中读取数组：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8// 因为OpenGL的原点是在左下角，而屏幕坐标的原点却在左上角，因此此处做点调整<br />ilutCurImage->Origin = IL_ORIGIN_LOWER_LEFT;<br /><br />// 更改数据的内存对齐，避免读出来的数据格式不对<br />glPixelStorei(GL_PACK_ALIGNMENT, 1);<br /><br />// 读出数据<br />glReadPixels(0, 0, ViewPort[2], ViewPort[3], GL_RGB, GL_UNSIGNED_BYTE, ilutCurImage->Data);<br /><br /><br />那么此时截图的方法已经出来了。对于DirectX，只需先创建图片对象并重设其参数，<br />然后读出颜色数据到图片中，最后保存即可。不过我不怎么熟悉DirectX，因此这里并没有给出DirectX的截图代码了。<br />结尾<br />从上面的文章我们已经了解了DevIL库，并且能够运用到实际工程中了。<br />事实上类似的库还有很多，例如SOIL和FreeImage。<br />如果你只是专注于一种格式，也许像libpng和libjpg更适合你。<br />因此在实际中，需要我们酌情选择合适的库来提高自己的开发效率。<br /><br /><br /><br /><br />官方说法在这里 ↩<br /><br /><br />","tags": "C/C++ DevIL OpenGL","url": "blog/2016-2-5/devil-usage.html"},
{"title": "D人大厅","text": "随你D","tags": "D人","url": "blog/chat.html"},
{"title": "Graphviz: 可视化调试利器","text": "Graphviz: 可视化调试利器<br />当你的各种树出现奇奇怪怪的问题时，你是如何找到错误的呢？<br />printf？GDB？肉眼？<br />当然这些方法当然可行，然而把它画出来岂不更秒？<br />现在祭出利器：Graphviz<br />简介<br /><br />Graphviz is open source graph visualization software. Graph visualization is a way of representing structural information as diagrams of abstract graphs and networks. It has important applications in networking, bioinformatics,  software engineering, database and web design, machine learning, and in visual interfaces for other technical domains. <br /><br /><br />翻译：<br /><br />Graphviz是一个开源的图形可视化软件。图形可视化是表示诸如图表的结构化的抽象图形或网络。在网络技术、生物信息学、软件工程、数据库、网页设计、机器学习和可视化界面及其他可以领域大有用处。<br /><br />详情参见Graphviz官网。<br />安装<br />这个不是本文的重点。我只知道对于Debian/Ubuntu用户可以按照以下方式安装：<br />1sudo apt-get install graphviz<br /><br /><br />使用<br />Graphviz使用一种领域特定语言(Domain-Specific Language1)来描述一副图。这里的图就是指图论中的图。然后Graphviz通过自动布局器来绘制出这个图。由于布局不是由我们手动决定的，因此生成的图的质量依赖于布局算法。<br />大多数情况下，Graphviz的默认布局器dot可以胜任布局这一任务。下面我们将使用dot。<br />Hello, GRAPHVIZ!<br />按照惯例，总得有个Hello, world!。<br />当然不要着急，我们先创建一个dot脚本文件：<br />1touch hello-world.dot<br /><br /><br />用你喜欢的编辑器来编辑它：<br />1vim hello-world.dot<br /><br /><br />写入以下内容，保存：<br />1<br />2<br />3<br />4<br />5digraph {<br />    a -> b;<br />    b -> c;<br />    a -> c;<br />}<br /><br /><br />生成SVG图片：<br />1dot hello-world.dot -Tsvg > hello-world.svg<br /><br /><br />用你喜欢的图片查看器来看看效果：<br />1eog hello-world.svg<br /><br /><br />如果一路上不出意外，你可以看到下面的结果：<br /><br />恭喜你成功创建了一张有向图。<br />图的类型<br />在上面，我们创建了一张带有三个顶点的有向图。然而我们有时候不一定要的就是有向图。<br />如果需要无向图，将digraph换为graph，并把有向边换为无向边即可：<br />1<br />2<br />3<br />4<br />5graph {  // <-- Here<br />    a -- b;<br />    b -- c;<br />    a -- c;<br />}<br /><br /><br />此时的图是这样的：<br /><br />当然我们可以添加坑爹的平行边和自环：<br />1<br />2<br />3<br />4<br />5<br />6<br />7graph {<br />    a -- b;<br />    b -- c;<br />    a -- c;<br />    c -- c;  // 自环 x 1<br />    a -- c;  // 平行边 x 1<br />}<br /><br /><br />于是乎图长这样：<br /><br />当然，如果你不想要它们出现，你可以利用strict将这张图变为严格的图：<br />1<br />2<br />3<br />4<br />5<br />6<br />7strict graph {  // <-- strict HERE<br />    a -- b;<br />    b -- c;<br />    a -- c;<br />    c -- c;<br />    a -- c;<br />}<br /><br /><br />此时平行边已经不见了，毕竟它们的含义是一样的。但是自环还是会留下来的：<br /><br />顶点<br />个人感觉椭圆实在太难看，用来调试完全体现不出B格。<br />把它换成圆形就好看多了：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9graph {<br />    node [shape = circle];  // 所有顶点全部变成圆形<br /><br />    a -- b;<br />    b -- c;<br />    a -- c;<br />    c -- c;<br />    a -- c;<br />}<br /><br /><br />就变成这样：<br /><br /><br />啊！我想让c变成正方形！<br /><br />当然也没有问题：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10graph {<br />    node [shape = circle];  // 所有顶点全部变成圆形<br />    c [shape = square];  // 指定c变为正方形<br /><br />    a -- b;<br />    b -- c;<br />    a -- c;<br />    c -- c;<br />    a -- c;<br />}<br /><br /><br /><br /><br />不行我要三角形！<br /><br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10graph {<br />    node [shape = circle];  // 所有顶点全部变成圆形<br />    c [shape = triangle];  // 指定c变为三角形<br /><br />    a -- b;<br />    b -- c;<br />    a -- c;<br />    c -- c;<br />    a -- c;<br />}<br /><br /><br /><br />好吧如果你还要其它的图形，可以参见http://www.graphviz.org/content/node-shapes。<br />光有形状有卵用，加点颜色才好玩：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12graph {<br />    node [shape = circle];<br />    a [color = blue];  // 变蓝色<br />    b [color = red];　// 变红色<br />    c [fontcolor = green];  // 字体颜色变绿<br /><br />    a -- b;<br />    b -- c;<br />    a -- c;<br />    c -- c;<br />    a -- c;<br />}<br /><br /><br /><br />更详细的颜色名称表在此：http://www.graphviz.org/content/color-names<br />边<br />现在我们来画一棵二叉搜索树：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12digraph {<br />    node [shape = circle];<br /><br />    3 -> 2;<br />    3 -> 8;<br />    2 -> 1;<br />    8 -> 5;<br />    8 -> 9;<br />    5 -> 4;<br />    5 -> 7;<br />    7 -> 6;<br />}<br /><br /><br />得到的结果是这样的：<br /><br />似乎并不尽人意，难以分辨左儿子和右儿子。<br />因此我们可以通过顶点的方向来确定。<br />每个顶点有八个方向：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12digraph {<br />    node [shape = circle];<br /><br />    x :e -> e;<br />    x :ne -> ne;<br />    x :n-> n;<br />    x :nw -> nw;<br />    x :w -> w;<br />    x :sw -> sw;<br />    x :s -> s;<br />    x :se -> se;<br />}<br /><br /><br />下面的图片展示了顶点的八个方向2(这张图是用circo生成的，命令行参数一样)：<br /><br />这些方向和东南西北的表示是一样的。<br />刚才我们指定的是出发的方向，当然我们也可以指定进入的方向。<br />因此我们来将左右儿子的边的出发方向修改一下，左孩子出发方向为:sw，右孩子的出发方向为:se：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12digraph {<br />    node [shape = circle];<br /><br />    3:sw -> 2;<br />    3:se -> 8;<br />    2:sw -> 1;<br />    8:sw -> 5;<br />    8:se -> 9;<br />    5:sw -> 4;<br />    5:se -> 7;<br />    7:sw -> 6;<br />}<br /><br /><br /><br />虽然不是那么规整，但是足以分辨出左右儿子了。<br />对于有些树，我们会记录父亲节点，因此我们加一条指向父亲的边：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20digraph {<br />    node [shape = circle];<br /><br />    3:sw -> 2;<br />    2 -> 3;<br />    3:se -> 8;<br />    8 -> 3;<br />    2:sw -> 1;<br />    1 -> 2;<br />    8:sw -> 5;<br />    5 -> 8;<br />    8:se -> 9;<br />    9 -> 8;<br />    5:sw -> 4;<br />    4 -> 5;<br />    5:se -> 7;<br />    7 -> 5;<br />    7:sw -> 6;<br />    6 -> 7;<br />}<br /><br /><br />得到的效果是这样的：<br /><br /><br />话说我分不清哪个是指向父亲的链接了！！！<br /><br />呃…没关系，我们把左右儿子的链接加粗就分得清了：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20digraph {<br />    node [shape = circle];<br /><br />    3:sw -> 2 [style = bold];<br />    2 -> 3;<br />    3:se -> 8 [style = bold];<br />    8 -> 3;<br />    2:sw -> 1 [style = bold];<br />    1 -> 2;<br />    8:sw -> 5 [style = bold];<br />    5 -> 8;<br />    8:se -> 9 [style = bold];<br />    9 -> 8;<br />    5:sw -> 4 [style = bold];<br />    4 -> 5;<br />    5:se -> 7 [style = bold];<br />    7 -> 5;<br />    7:sw -> 6 [style = bold];<br />    6 -> 7;<br />}<br /><br /><br /><br />上面是对边进行设置，将边加粗。<br /><br />指向区别能更明显些吗？<br /><br />干脆把它做成虚的吧：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20digraph {<br />    node [shape = circle];<br /><br />    3:sw -> 2 [style = bold];<br />    2 -> 3 [style = dotted];<br />    3:se -> 8 [style = bold];<br />    8 -> 3 [style = dotted];<br />    2:sw -> 1 [style = bold];<br />    1 -> 2 [style = dotted];<br />    8:sw -> 5 [style = bold];<br />    5 -> 8 [style = dotted];<br />    8:se -> 9 [style = bold];<br />    9 -> 8 [style = dotted];<br />    5:sw -> 4 [style = bold];<br />    4 -> 5 [style = dotted];<br />    5:se -> 7 [style = bold];<br />    7 -> 5 [style = dotted];<br />    7:sw -> 6 [style = bold];<br />    6 -> 7 [style = dotted];<br />}<br /><br /><br /><br />像某些数据结构，可能会有Lazy标记之类的，我们可能需要对节点作特殊标记来标明。<br />这当然也是可以实现的，只需提前声明好即可：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23digraph {<br />    node [shape = circle];<br /><br />    3 [color = red];<br />    5 [color = red];<br /><br />    3:sw -> 2 [style = bold];<br />    2 -> 3 [style = dotted];<br />    3:se -> 8 [style = bold];<br />    8 -> 3 [style = dotted];<br />    2:sw -> 1 [style = bold];<br />    1 -> 2 [style = dotted];<br />    8:sw -> 5 [style = bold];<br />    5 -> 8 [style = dotted];<br />    8:se -> 9 [style = bold];<br />    9 -> 8 [style = dotted];<br />    5:sw -> 4 [style = bold];<br />    4 -> 5 [style = dotted];<br />    5:se -> 7 [style = bold];<br />    7 -> 5 [style = dotted];<br />    7:sw -> 6 [style = bold];<br />    6 -> 7 [style = dotted];<br />}<br /><br /><br /><br />用于调试<br />经过上面的简单介绍，Graphviz已经可以用于调试了。<br />dot脚本非常的便于程序生成，因此我们可以在程序运行中途生成脚本，然后使用dot将其处理后并展示出来。<br />处理的代码大致是这个样子：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8function SHOW(x):<br />    buffer = \"graph {\"<br /><br />    // 读取数据并生成dot脚本<br /><br />    buffer += \"}\"<br />    write buffer to a dot file<br />    SYSTEM \"dot a.dot -Tsvg > a.svg && eog a.svg\"<br /><br /><br />小结<br />Graphviz非常强大，这里只是介绍了一小部分功能，如想深入学习可以参见Graphviz官方文档或者Graphviz中文教程指南。<br />利用Graphviz我们可以将图论算法、数据结构的调试过程可视化，从而更加方便我们找到错误所在。<br />当然，可以利用Graphviz进行对算法过程的截图，从而生成整个算法的流程。<br />如果你想利用Graphviz来制作插图，那么自动布局就可能不能使你满意。此时个人推荐ProcessOn或者其它的流程图制作软件来绘制，效果更好。<br /><br /><br /><br /><br />维基页面https://en.wikipedia.org/wiki/Domain-specific_language ↩<br /><br /><br />事实上，Graphviz中可以定义更加更加精确的方向。但大多数情况下，这几个方向足矣。 ↩<br /><br /><br />","tags": "Graphviz 可视化 调试","url": "blog/2016-4-16/graphviz.html"},
{"title": "HNSDFZ #3","text": "<br />HNSDFZ第3次欢乐互测<br /><br /><br /><br /><br /><br />expression<br />unstring<br />gambler<br />starcraft<br /><br /><br /><br /><br />源文件<br />expression.cpp<br />unstring.cpp<br />gambler.cpp<br />starcraft.cpp<br /><br /><br />输入文件<br />expression.in<br />unstring.in<br />gambler.in<br />starcraft.in<br /><br /><br />输出文件<br />expression.out<br />unstring.out<br />gambler.out<br />starcraft.out<br /><br /><br />时间限制<br />$1\\text{s}$<br />$1\\text{s}$<br />$1\\text{s}$<br />$1\\text{s}$<br /><br /><br />空间限制<br />$512\\text{MB}$<br />$128\\text{MB}$<br />$128\\text{MB}$<br />$32\\text{MB}$<br /><br /><br />题目类型<br />传统型<br />传统型<br />传统型<br />传统型<br /><br /><br />出题人<br />riteme<br />Link<br />ruanxingzhi<br />Haogram<br /><br /><br /><br /><br />拒绝Pascal程序。<br />对于C\\C++程序，使用以下的编译命令：<br />1g++ source.cpp -o exec -O2 -std=c++11<br /><br /><br /><br />A. 密码锁<br />题目描述<br />dyx在家里玩耍时发现了一个神奇的密码锁。然而他早已忘记了这个锁的密码，于是他随便尝试了一下，结果锁就打开了......<br />锁的内部有一个很长的字符串，机智的dyx马上就发现这就是密码锁的核心。于是他研究了一下午，探寻这把锁的奥秘。<br />他发现这个字符串是一个表达式的形式，像下面这个样子：<br />1a|b&(!c^d)<br /><br /><br />其中，每一个由小写字母组成的单词是一个变量，对应着密码锁上的一个按钮。由于按钮只能按下或不按下，于是你可以认为每个变量是一个布尔类型的（即只有$\\text{true}$和$\\text{false}$之分）<br />其余的字符就只有&、|、^、!和左右小括号。dyx发现括号是用来优先运算的，意思是这是一个会将所有变量进行计算的表达式，并且优先计算括号中的子表达式。同时，&、|、^、!都是运算符，它们分别对应的是逻辑与、逻辑或、逻辑异或和逻辑非。其中前三者运算优先级一致，当它们在同一级出现时会从左至右运算，逻辑非的优先级比它们高。当每一个变量都有相应的值时，整个表达式就会就会进行计算，并给出一个布尔值。dyx还发现，当整个表达式的值为$\\text{true}$时，密码锁就会打开。<br />很明显，整个密码锁的输入方案共有$2^n$种，其中$n$是表达式中变量的数量。于是dyx瞬间明白为什么他一次就可以将这个密码锁解开了。然而dyx是一个勇于探究的人，他想知道到底有多少中方法可以解开一个密码锁。<br />不知为何，dyx又发现了一火车的密码锁。坚持不懈的dyx不停的计算着每一个密码锁能解开的方案数......由于密码锁的表达式越来越长并且人脑计算量是$\\Theta(1)$的，dyx不得不需要一个程序来帮助他计算这个方案数。<br />输入格式<br />每个测试数据点有多个表达式。文件以EOF结束。<br />每一个表达式占一行，且中间只有小写字母和&、|、^、!、(、)。<br />对于&、|和^运算，它们左右会各有一个变量或子表达式。其运算规则如下：<br /><br /><br /><br />$a$<br />$b$<br />$a$ & $b$ ($a \\land b$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{true}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br />$\\text{false}$<br /><br /><br />$\\text{false}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br /><br /><br /><br /><br /><br />$a$<br />$b$<br />$a$ | $b$ ($a \\lor b$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{true}$<br />$\\text{false}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br /><br /><br /><br /><br />$a$<br />$b$<br />$a$ ^ $b$ ($a \\oplus b$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{true}$<br />$\\text{false}$<br /><br /><br />$\\text{true}$<br />$\\text{false}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br /><br />对于!运算，它后面会有一个变量或子表达式。其运算规则如下：<br /><br /><br /><br />$a$<br />!$a$ ($\\lnot a$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{false}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br /><br /><br /><br />输入保证表达式是有效的，且表达式中不存在缺少参数的运算符和空的括号。<br />为了防止此题变成不可做的NP-hard问题，输入保证表达式中每一个变量名只出现一次。<br />输出格式<br />对于每一个表达式，输出能够解开它的方案总数。由于答案可能过大，因此将答案对$10^9 + 7$取模后输出。<br />一种方案即指对每一个变量给定一个值。<br />两种方案不同当且仅当至少一个变量所给定的值不同。<br />样例输入<br />1<br />2<br />3a&b<br />a|b|c<br />a|!(b|c)<br /><br /><br />样例输出<br />1<br />2<br />31<br />7<br />5<br /><br /><br />数据范围及提示<br />对于第一个表达式，只有$a = \\text{true}, b = \\text{true}$才为$\\text{true}$。<br />对于第二个表达式，只要三者有一个变量为$\\text{true}$就是$\\text{true}$。<br />对于第三个表达式，先运算b|c，然后对其取反，最后与$a$做逻辑与。<br />以下$n$表示变量数量，$T$表示测试数据组数，$L$表示表达式的总长度。<br />对于$10\\% $的数据，$n \\le 10,\\; T = 15$。<br />对于另外$10\\% $的数据，只有逻辑或运算，没有括号。<br />对于另外$10\\% $的数据，不存在逻辑非和括号。<br />对于另外$20\\% $的数据，不存在括号。<br />对于另外$20\\% $的数据，$n \\le 500$。<br />对于$100\\% $的数据，变量名长度$\\le 4$，$L \\le 10^6$，$n \\le 3\\times10^5$。<br />其中$90\\% $的数据，$T \\le 5$。<br /><br />B. UnString<br />题目描述<br />ZY很累。<br />因为最近内网的服务器地址总是改来改去。<br />然而ZY又非常想去捣乱。他必须知道内网的服务器的地址是啥。<br />但是阴险的Blue却是给地址加了个密，还TM竟然隐藏了一些字符。<br />但是ZY也是蛮机智的，他得到了一段被加密的地址<br />还有Blue傻逼丢博客的字符对照表，如果地址和博客的字符对照表相似<br />那么ZY就知道他得到的地址是对的，虽然他仍然不能知道地址是啥。<br />输入格式<br />第一行一个字符串$S$，字符串$S$是由a-b组成的字符串<br />第二行一个字符串$C$，字符串$C$是由a-b和?组成的字符串<br />输出格式<br />我们将?认为是任何字符，询问$C$是否是$S$的子串<br />输出YES或者NO<br />样例输入<br />1<br />2abc<br />a?c<br /><br /><br />样例输出<br />1YES<br /><br /><br />数据范围及提示<br />$30\\% $ $S$长度小于$2000$，$C$长度小于$20$<br />$60\\% $ $S$长度小于$100000$，$C$长度小于$500$<br />$100\\% $ $S$长度不超过$200000$,$C$长度不超过$2000$<br /><br />C. 赌徒<br />题目描述<br />HNSDFZ有一大批赌徒。他们分布在化学组、生物组、机房……这些赌场有道路相连，形成一棵树的结构。<br />赌场里的人越来越多。如果记某个赌场第$n$天的人数为$F_n$，则有$F_n=2F_{n-2}+3F_{n-1}$。每个赌场的$F_1$和$F_2$是预先知道的。当然，赌徒的数量不能太多。每个赌场都会不停地清理人员，做法是把每天的人数模$2333$。<br />现在是第$m$天，3班的某个英语老师要打击赌徒。她准备打击一条链上的所有赌徒。但是她并不知道自己最多能打到多少个赌徒，所以把你捆过来算一算。<br />输入格式<br />第一行一个正整数，$n$表示赌场个数，$m$表示在第几天动手。<br />接下来$n$行，每行两个整数$F_1,F_2$。<br />接下来$n-1$行，每行两个整数$u,v$表示$u$和$v$有边相连。<br />输出格式<br />一行，一个正整数，表示能打击到的赌徒个数。<br />样例输入<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />115 1<br />1 1<br />1 1<br />1 1<br />1 1<br />1 1<br /><br />1 2<br />1 3<br />2 4<br />2 5<br /><br /><br />样例输出<br />14<br /><br /><br /><br />数据范围及提示<br />输入数据中：<br />在第一天，所有的赌场都只有1个人。<br />在这时打击，最多能打击到4个人。这条链是$4-2-1-3$。<br />$n \\le 5 \\times 10^5$, $m \\le 2\\times 10^9$<br /><br />D. 星际争霸<br />题目描述<br />虽然二十世纪的科技和文化进步神速，但是和後世科技和文明的跳跃式进步相比起来， 也只能甘拜下风。在二十一世纪的末，人类的文明经历了巨大而且难以想像的进步。崭新的科技以难以想像的速度窜起，即使是地球上最为落後的国家也开始拥有越来越先进的电脑和资料库。在东欧共产主义解体的同时，核子武器开始变得随手可得。原来国际势力的兴衰是以资产和军事强权来作为依据，第三世界的国家却利用这个机会猛然窜起，挑战这些强权，打破国际间局势的均衡。 <br />当系统控工学、复制和基因工程变成人人皆可掌握的科技之後，激进人道主义者和狂热的宗教团体开始质疑私人公司以基因工程图利的正当性。大众开始纷纷装置由精密工学所研制出来的人工器官，其他人则开始显现出各种各样的基因突变性状，包括了较为隐性的器官变得敏锐，到明显的心灵感应。人类基因库中所产生的这些变化，让全球各地的人本主义者感到非常的恐慌。 <br />科技继续进步及扩张，人口增加的速度也开始飙升。在二十世纪结束的时候，地球上有 六十亿的人口。仅仅经过短短的三百年，人口暴增为两百三十亿。污染和自然资源、燃料的耗竭更是火上加油。各个国家莫不竭力寻找降低人口成长率的方法。在人口爆炸、基因突变横扫整个地球的同时，一般人都认为地球将因此而走向天灾地变的结局。<br />于是人类造出一艘星际巨舰，在擎天神的领导下，飞往无边的太空......<br />最後，其中一艘的航舰引擎融毁了。在经过二十八年的曲速旅行之後，这些巨大的船只重新出现在三度空间中，靠近一个可居住星系的外缘。这里距离地球六万光年之远，他们的曲速引擎全毁，生命维持的系统几乎已经耗竭。所有的船只只有进入紧急状况，准备迫降在最接近的可居住行星上。<br />每个行星的居民努力的试图在被称为『新世界』的星球上生存。他们并不知道还有其它的同类挣扎著在别的地方求生存，只能够努力的利用手边的资源活下去。<br />然而，Zerg和Protoss的兵力正进攻过来，能否活下还是个问题......<br />作为采矿的工具，空间建筑工程车 (Space Constrution Vehicle)，简称SCV，它们的多样性和无以比拟的可靠性使得它们成为一种极有价值的建筑工具。<br />采矿的流程如下，然而图不能动。<br /><br />SCV从指挥中心 (Command Center) 出发，移动至水晶矿处开采矿物，为了简化问题，设定为采矿不需要时间。采完矿后需要返回指挥中心将矿物送回，否则不能算采到了矿物。图片里既有正在采矿的也有才完了矿带着矿回指挥中心的。<br />因为地面环境复杂，所以SCV所走的路线不一定是笔直的，而是曲折的，再次你可以将其理解为以指挥中心为根的一颗有根树，而水晶矿处于该有根树的叶子节点处。有根树的每一条边都有距离，长度单位为宇宙单位。定义SCV速度为 1 宇宙单位/s。为简化问题，SCV一次采矿可以将该水晶矿采完。<br />有时会有一些宇宙生物（比如卡拉兽）会爬行至采矿路径上的一些点导致该路径不通。增加采矿难度。出于某种原因，地图会不断更新，矿物就会恢复原状，卡拉兽也会被更新至一个新的节点。<br />Zerg和Protoss的进攻已经很近了，你需要尽快采更多的资源......<br />输入格式<br />第一行有$2$个正整数$n$，$m$，表示图上有$n$个点，地图更新$m$次。<br />接下来$n-1$行，每行$3$个正整数$p$，$f$，$l$，代表描述第$p$个点，其父节点为$f$，与父节点的连边长为$l$。<br />接下来$x$行，有$2$个正整数$p$，$w$，表示第$p$号节点有$w$水晶矿。$x$为叶节点个数。<br />接下来$m$行，每行一个正整数$p$，$t$，表示地图更新后，有一只卡拉兽在$p$号节点位置上，Zerg和Protoss的进攻将在$t$秒后来临。如果$p$为$0$，表示没有卡拉兽在地图上。<br />输出格式<br />地图每次更新会将采完的矿回复原状。<br />输出共$m$行，每行对于一次地图更新，输出在进攻来临前采集到的最多矿物数量。<br />样例输入1<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />83 3<br />2 1 35<br />3 1 24<br />2 100<br />3 65<br />0 60<br />1 23<br />3 33<br /><br /><br />样例输出1<br />1<br />2<br />365<br />0<br />0<br /><br /><br /><br />样例输入2<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />189 4<br />2 1 8<br />3 1 10<br />5 2 25<br />6 2 13<br />7 3 22<br />4 1 26<br />8 4 12<br />9 4 23<br />5 78<br />6 66<br />7 48<br />8 50<br />9 80<br />0 257<br />3 200<br />2 230<br />1 500<br /><br /><br />样例输出2<br />1<br />2<br />3<br />4242<br />194<br />130<br />0<br /><br /><br />数据范围及提示<br />对于$10\\% $的数据: $n \\le 20, m \\le 5$<br />对于$20\\% $的数据: $n \\le 20, m \\le 500$<br />对于另外$20\\% $的数据，地图没有卡拉兽<br />对于另外$20\\% $的数据，$n \\le 1000, m \\le 50$<br />对于$100\\% $的数据，$n \\le 1000, m \\le 500, t \\le 50000$<br />指挥中心的编号始终为$1$，地图至多有一只卡拉兽","tags": "Contests","url": "blog/2016-7-1/hnsdfz-3.html"},
{"title": "HNSDFZ2016 #1","text": "HNSDFZ2016 #1<br />A. ZY的钻石树 (Link)<br />时间限制: 1s / 内存限制: 250MB<br />题目描述<br />ZY是一个很神的孩子，对于他来说一切都是O(1)的。 <br />ZY也是一个很喜欢玩MC的孩子。 <br />这天，ZY登陆了他的MC，他发现他家不知道被哪个熊孩子糟蹋了。 <br />他的家变成了一颗有N个节点的树，每个树都有一种钻石块(种类是1-1000000的整数表示)。 <br />奇怪的是，同种的钻石块ZY只能拿一个。 <br />更加奇怪的是，不同时刻某些钻石块还会改变自己的种类。 <br />ZY因此想知道，以某个节点为根的子树中有多少个不同的钻石块 <br />1号节点为树的根 <br />两种操作： <br />1 x 询问x节点为根的子树有多少个不同的钻石块 <br />0 x val 修改x节点的钻石块种类为val<br />输入格式<br />第一行N，代表树的节点数 第二行N个数，代表每个节点的钻石块种类 然后N-1行代表哪两个点连接 一行M代表操作数 之后M行代表操作<br />输出格式<br />对于每个询问输出其答案<br />样例输入<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />197<br />1 2 3 4 5 6 7<br />1 2 <br />1 7 <br />2 3 <br />2 6 <br />3 4 <br />3 5 <br />10<br />1 5 <br />0 7 22<br />1 2 <br />0 6 10 <br />0 4 2 <br />0 4 45 <br />1 5 <br />1 2 <br />0 2 12 <br />1 1 <br /><br /><br />样例输出<br />1<br />2<br />3<br />4<br />51<br />5<br />1<br />5<br />7<br /><br /><br />数据范围及提示<br />m,n<=100000<br />B. ZY的核电站 (riteme)<br />时间限制: 5 s / 内存限制: 256 MB / 打开O2优化<br />题目描述<br /><br />“ZY喜欢玩核电站。”<br /><br />ZY的核电站非常特殊。早在2038年，ZY就发现了高分子有机物的完全裂解可以释放大量的核能的原理（这句话纯属FP）。因此ZY的核电站反应堆里面全是高分子有机物，可惜只有一个。<br />为了使发电量尽可能大，ZY找到了一种能使有机物完全裂解的方式，使释放出来的能量最大。由于这是ZY的有机物，因此裂解方式也非常奇葩。下面是ZY在2039年的论文《论ZY对MC1核电站的巨大贡献》中的节选片段：<br /><br />......<br />我们的有机物是由$n$个各种原子构成的，原子之间通过不同的共价键相连。<br /><br />($\\text{H}$太多了，到时候这些没用的氢原子都会被ZY丢掉)<br />......<br />为了方便进行裂解，这个有机物是没有环的，这样就可以节约成本来买**V*P***......<br />......<br />每次裂解都会断开一个共价键，此时这个有机物会分为两部分。并且释放大量的能量......<br />设放出的能量为$E$，有机物裂解后的两部分的共价键的集合分别为$A$和$B$，则：、<br />$$ E = \\sum_{a\\in A} a.\\text{energy} \\cdot \\sum_{b\\in B} b.\\text{energy} \\tag{ZY's energy theorem}$$<br />其中$\\text{energy}$表示共价键的能量。<br />......<br />为了充分利用有机物中的能量，每裂解一个共价键后，我们有办法无损耗无成本的将其还原，即有机物会变得和裂解前一样。但是出于种种原因，这个共价键就不能再次进行裂解了。除非ZY发出SB之神力来使所有的共价键复活......<br />......<br />那么，一个有机物完全裂解所能放出的能量为所有共价键裂解一次后所放出的能量之和。<br />......<br /><br />(实际上，ZY的这篇论文长达$2147483647$字)<br />当然，ZY的智商理论上为$-\\infty$。因此它的核电站其实非常辣鸡。反应堆中的有机物不一定是稳定的，但是ZY利用LCT算法以$O(\\infty!)$的时间复杂度内成功地保证了有机物的结构，这样就方便ZY发出SB之神力。但是令ZY想跳楼的是，总有一个共价键的能量在维护有机物结构时会变动。然而”机智”的ZY可以发现这些变化。<br />ZY只希望能够快速算出当前的有机物通过完全裂解究竟能放出多少能量。由于ZY的数学只有学前班水平，所以每当她算到一半时，这个有机物又开始乱搞了，ZY就只能用LCT来重新维护它。<br />一年之内，ZY的核电站什么电都没有发。为了快速计算，ZY找到了你这个**。<br />ZY希望你能给出一个好方法来帮助她计算当前有机物完全裂解能放出的能量。<br />输入格式<br />第$1$行输入两个正整数$n$，$m$。$n$表示有机物中原子的数量，$m$表示ZY维护有机物结构的次数。<br />接下来$n - 1$行描述一个有机物。对于每一行输入三个整数$u$，$v$和$e$，表示第$u$号原子和第$v$号原子之间以能量为$e$的共价键相连。<br />接下来$m$行，每一行描述一个共价键的键能变化。每行输入三个整数$u$，$v$和$e$，表示第$u$号原子和第$v$号原子之间的共价键的能量变为$e$。保证第$u$号原子和第$v$号原子之间存在共价键。<br />输出格式<br />对于每次共价键能量的变动，输出一行一个整数，表示键能改变后的有机物完全裂解能放出的能量。<br />输入样例<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />127 4<br />1 2 2<br />1 7 1<br />2 3 2<br />2 6 1<br />3 4 1<br />3 5 1<br /><br />1 2 2<br />1 2 3<br />2 3 3<br />1 2 0<br /><br /><br />输出样例<br />1<br />2<br />3<br />413<br />15<br />16<br />10<br /><br /><br />数据范围及提示<br />对于第一个询问:<br />裂解$1$和$2$之间的共价键: $1 \\times (2 + 1 + 1 + 1) = 5$<br />裂解$2$和$3$之间的共价键: $(2 + 1 + 1) \\times (1 + 1) = 8$<br />其余的共价键裂解得到的能量均为$0$。<br />因此答案为$13$。<br />对于$10\\% $的数据: $n \\le 1,000, \\; m \\le 5,000$<br />对于$10\\% $的数据: $n \\le 10,000, \\; m \\le 500,000$<br />对于$10\\% $的数据: $n \\le 100,000, \\; m \\le 100$<br />对于$10\\% $的数据: $n \\le 10,000, \\; m \\le 1,000,000$<br />对于另外$20\\% $的数据: 有机物没有支链。<br />对于$100\\% $的数据: $n \\le 200,000, \\; m \\le 1,000,000, \\; e \\le 10 $<br />C. ZY的仙人掌 (blue)<br />时间限制: 2 s / 内存限制: 512 MB<br />题目描述<br />ZY是个很喜欢打MC的孩子，动态仙人掌对他来说是$O(1)$的。 <br />ZY登录MC，发现自己在一个仙人掌包围的巨大盒子里。这是$n\\times n$的巨大网格，可以走到上下左右相邻的格子，但是不能斜走。 <br />ZY认为，既然来了，就要潇洒走一回。他tp到一个网格，准备步行前往另一个网格。 <br />但是blue显然不愿意看到ZY如此悠闲。所以，每次ZY作出计划，blue都会让某个格子长出仙人掌。（ZY怎敢踏过仙人掌）<br />那么问题来了：给出ZY的计划和blue的操作，询问ZY能否完成计划。<br />输入格式<br />第一行，两个整数$n$、$m$，表示盒子是$n\\times n$的，ZY有$m$个计划。 接下来$m$行，每行三个点对：$(x_1,y_1)$表示ZY的出发点，$(x_2,y_2)$表示ZY的目标点，$(x_3,y_3)$表示blue让这个点长出仙人掌。<br />输出格式<br />输出共$m$行，描述ZY的计划能否完成。 如果能完成，输出Yes，否则输出No<br />样例输入<br />1<br />2<br />3<br />45 3<br />1 1 4 4 2 2<br />1 1 3 3 1 2<br />1 1 3 3 3 1<br /><br /><br />样例输出<br />1<br />2<br />3Yes<br />Yes<br />No<br /><br /><br />数据范围及提示<br />数据有梯度，暴力可拿分。<br />可能在同一个地点长仙人掌；也可能ZY从仙人掌出发或者到达仙人掌。如果遇到这种情况，请直接输出<br />No<br />n <= 1000 ?<br />D. ZY的三元组 (blue)<br />时间限制: 1 s / 内存限制: 233 MB<br />题目描述<br />ZY是个很神的孩子，计算勾股数对他来说是$O(1)$的。<br />对于 $a,b,c \\in Z^+$，且$a<=b<=c$ 有 $a^k+b^k=c^k$，而且$a:b:c$为最简整数比，并且$c-b$不超过3，则称三元组$(a,b,c)$为贼达k拉斯三元组。<br />给定$n$和$m$，字典序输出所有$c<=n$，$2<=k<=m$的贼达k拉斯三元组。<br />输入格式<br />一行，$n,m$<br />输出格式<br />每行一个贼达k拉斯三元组。 如果没有就不输出.<br />样例输入<br />1100 3<br /><br /><br />样例输出<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />93 4 5<br />5 12 13<br />7 24 25<br />8 15 17<br />9 40 41<br />11 60 61<br />12 35 37<br />13 84 85<br />16 63 65<br /><br /><br />数据范围及提示<br />数据范围<br />$n<=100000$，$2<=k<=1000$。<br />题解<br />A (Missing)<br />B<br />题目描述不用看，看样例就好了…<br />给你一棵无根树，每条边有边权。将一条边断开会出现两棵树，这两棵树的各自的边权之和相乘就是裂解一次的能量。完全裂解就是每一条都这样计算一下。<br />如果只要计算一次，考虑将无根树转为有根树，然后DFS一遍计算以每个节点的子树中的边权之和。根节点的这个值就是总边权之和。用对于每条边，用深度较大的节点来记录这条边上的信息$a$和$b$。$a$表示子树中的边权之和，$b$表示子树外的边权之和(当然要除去这条边)。然后在$\\Theta(n)$的时间内可以计算出答案。<br />接下来考虑维护答案。对于每条边的修改，自己的$a$和$b$不会有影响，对于从这条边到根节点的链上的每一条边的$a$值都会增加，而对于其它的边的$b$值都会增加。因此我们用$\\Delta a$和$\\Delta b$来记录每一条边的增量，这个值可以利用树链剖分+线段树来维护，链上的边直接增加，其它边先全局打上标记，然后对不需要的边打上反标记即可。<br />最后在线段树的根节点统计答案，利用求和的性质即可：<br />$$<br />\\begin{align}<br />\\sum^n_{i=1} a^,_i b^,_i & = \\sum^n_{i=1} (a_i + \\Delta a)(b_i + \\Delta b) \\\\<br />& = \\sum^n_{i=1} a_ib_i + \\Delta a\\sum^n_{i=1}b_i + \\Delta b\\sum^n_{i=1} a_i + n\\Delta a\\Delta b<br />\\end{align}<br />$$<br />从这也能看出维护三个和式和两个标记就可完成维护。总复杂度为$O(n\\log^2n)$。<br />C (Missing)<br />D (Missing)<br /><br /><br /><br /><br />ZY从不打摆。 ↩<br /><br /><br />","tags": "HNSDFZ 互测 2016","url": "blog/2016-5-31/hnsdfz2016-1.html"},
{"title": "HNSDFZ2016 #2","text": "HNSDFZ2016 #2<br />这是一场痞题大战。<br />A. 二十四点 (blue)<br />时间限制: 0.4s / 内存限制: 128MB<br />题目描述<br />给定四个数，判断能否构成二十四点。仅允许：+ - * / () [] {}这几种符号。<br />输入格式<br />第一行，一个正整数$n$，表示有$n$组数据。 接下来$n$行，每行四个正整数，表示给你的牌。 保证：这些正整数$\\in[1,13]$。<br />输出格式<br />$n$行，每行一个整数，描述是否能构成二十四点。 能则输出$Yes$，不能则输出$No$。<br />样例输入<br />1<br />2<br />32<br />5 5 5 1<br />9 9 9 9<br /><br /><br />样例输出<br />1<br />2Yes<br />No<br /><br /><br />数据范围及提示<br />最多5000组。<br />B. BST厂长 (riteme)<br />时间限制: 1 s / 内存限制: 128 MB<br />题目描述<br /><br />二叉树真是迷人......<br /><br />随着时代的进步，二叉搜索树(Binary Search Tree)发挥着越来越大的作用。作为HNSDFZ上机部长XL，担负着为学校制造各种BST的任务。它们会用于各种用途：成绩排名、薪水发放、PY**......<br />本来学校对BST的需求并不是很大，但是自从ZY加入了上机组后，BST的需求越来越大......<br />作为XL，早已按捺不住。于是XL利用通用技术教学楼建立了一个厂房，专门制造各种BST。<br />这个厂子会收到各种各样的订单。每个订单都会是一个很长的数列，其中没有两个数是相同的。而XL要做的就是将这些数字依次插入到一棵空的BST中，然后将BST发送出去。<br />然而人工干这件事实在是太麻烦了，因此XL将ZY抓过来造BST。然而ZY更懒，把Link抓过来要它帮<br />ZY写个程序来构建BST。然而Link并不屑于写这个程序，于是这个任务莫名其妙地传到了你手上......<br />当然XL不会就这样放手不管，XL会随时来检查这棵BST是否是正确的，以防你在乱造BST。<br />输入格式<br />第一行输入一个正整数$n$，表示订单中数列的长度。<br />接下来$n$行，每行输入两个正整数$x$和$k$。表示将$x$插入到当前的BST中。初始时是空树。$k$则表示XL的检查。他会问你根节点到新插入的节点$x$的链上第$k$个节点是谁。默认从$1$开始数。<br />输出格式<br />对于每一次XL的检查，输出对应的答案。<br />样例输入<br />1<br />2<br />3<br />43<br />2 1<br />1 1<br />3 2<br /><br /><br />样例输出<br />1<br />2<br />32<br />2<br />3<br /><br /><br />数据范围及提示<br />对于第一次插入$2$，树的根节点为$2$，故答案为$2$。<br />对于第二次插入$1$，因为$1 \\lt 2$，所以$1$是$2$的左儿子。$2$到$1$的链上的第一个节点为$2$<br />对于最后一次插入$3$，因为$3 \\gt 2$，所以$3$是$2$的右儿子。$2$到$3$的链上的第二个节点是$3$。<br />对于$10\\% $的数据，$n \\le 20,000$。<br />对于$10\\% $的数据，$n \\le 90,000$。<br />对于$20\\% $的数据，$n \\le 100,000$。<br />对于另外$10\\% $的数据，数列完全随机。<br />对于$100\\% $的数据，$n \\le 200,000$，$1 \\le x \\le n$，保证每次检查的节点存在。<br />C. 鱼的记忆 (Link)<br />时间限制: 3s / 内存限制: 100MB<br />题目描述<br />对于只有7秒记忆的鱼来说，他能够记住的东西太少了。 <br />但是鱼对于美的追求却不会因为他的记忆而放弃。 <br />他想知道在他的记忆中，对于每个事物有多少个事物没有这个事物美丽。 <br />每一件事物都有三个维度的评价，鱼能够很快的知道评价是多少。 <br />但是他并没有办法知道每个事物有多少个事物没有这个事物美丽。 <br />如果一个事物的三个维度都>=另外一个事物的三个维度并且这个事物被鱼看到的时间不能比其先。<br />输入格式<br />第一行一个n，表示鱼见到的事物个数 第2到n+1行分别为4个整数。 分别是前3维和时间<br />输出格式<br />输出n行，分别是有多少个事物没这个事物美丽<br />样例输入<br />1<br />2<br />3<br />43  <br />1 2 3 5  <br />2 1 1 6  <br />1 1 1 5  <br /><br /><br />样例输出<br />1<br />2<br />31  <br />1  <br />0  <br /><br /><br />数据范围及提示<br />10%  N<=1000 <br />10%  N<=30000 <br />80%  N<=100000 <br />没错，就是4维的。 <br />前面3维小于100000 <br />第4维<=7 鱼的记忆只有7秒 <br />D. ZY的铁套装 (Haogram)<br />时间限制: 1s / 内存限制: 250MB<br />题目描述<br />在附中内网MC伊始之时，RLB(排名不分先后)三侠努力地挖矿造家打脏比，每天幸福充实的生活着，MC着。<br />然而ZY突然出现，夺走了RLB所有的铁块，打造了一身时尚时尚最时尚的铁套装。<br />RLB决心攻击ZY，收回铁套装。毕竟挖矿很难。<br />于是RLB三侠拿起了武器背包，向ZY发起进攻，并决心事后封ZY的id。<br />由于ZY的铁套装十分时(qiang)尚(da)，所以必须要连击$L$次才能打败ZY。<br />RLB三侠有$N$个武器，每个武器本可以在两个时刻发动攻击，然而ZY的铁套装太强，每个武器使用一次就报废了。<br />每次攻击要从1时刻开始向ZY攻击，显然，如果RLB没有可以在1时刻攻击的武器，那就一次也不能打到ZY了。<br />输入格式<br />第一行有两个数，$N$和$L$。 接下来的$N$行，每一行有两个数$a$,$b$，表示该武器可以在$a$或$b$时刻攻击ZY。<br />输出格式<br />输出一行，如果 RLB 能攻击 ZY 至少$L$次，输出”Yes”,否则”No”。(区分大小写)。<br />样例输入<br />1<br />2<br />3<br />43 2<br />1 2<br />2 3<br />4 5<br /><br /><br />样例输出<br />1Yes<br /><br /><br />数据范围及提示<br />输出样例1 解释：<br />1时刻，RLB用1号武器攻击, 1号武器报废<br />2时刻，RLB用2号武器攻击, 2号武器报废<br />3时刻，RLB没有可以在3时刻攻击ZY的武器，攻击结束。<br />一共攻击2次，正好打败ZY！<br />数据范围：<br />对于30% 的数据，保证N <= 1000<br />对于100% 的数据，保证N <= 1000000<br />攻击ZY的时刻 0 < a,b <= 10000<br />题解<br />A<br />暴力暴力暴力......<br />B<br />用平衡树维护当前二叉树中能够被插入的节点，每次插入节点时在平衡树上二分找出新节点的范围，然后利用倍增法计算LCA来确定父亲，最后更新倍增数组的值。<br />查询时利用倍增上跳即可。<br />C<br />对于同一时间内，利用CDQ分治就可以解决(像Mokia或陌上花开一样)<br />由于有个时间轴，当时却只有7，因此进行7次CDQ分治......<br />因该要注意下细节，我并没有写......<br />Link真是脑洞大开......<br />D<br />将原问题转换为一个二分图匹配的问题，然后匈牙利算法直接跑。<br />即第$i$件武器与对应的天相连来构建二分图。<br />一群贪心100分......","tags": "HNSDFZ 互测 2016","url": "blog/2016-5-31/hnsdfz2016-2.html"},
{"title": "HNSDFZ2016 #3","text": "HNSDFZ2016 #3<br />大家都在出水题。<br />A. 密码锁 (riteme)<br />题目描述<br />dyx在家里玩耍时发现了一个神奇的密码锁。然而他早已忘记了这个锁的密码，于是他随便尝试了一下，结果锁就打开了......<br />锁的内部有一个很长的字符串，机智的dyx马上就发现这就是密码锁的核心。于是他研究了一下午，探寻这把锁的奥秘。<br />他发现这个字符串是一个表达式的形式，像下面这个样子：<br />1a|b&(!c^d)<br /><br /><br />其中，每一个由小写字母组成的单词是一个变量，对应着密码锁上的一个按钮。由于按钮只能按下或不按下，于是你可以认为每个变量是一个布尔类型的（即只有$\\text{true}$和$\\text{false}$之分）<br />其余的字符就只有&、|、^、!和左右小括号。dyx发现括号是用来优先运算的，意思是这是一个会将所有变量进行计算的表达式，并且优先计算括号中的子表达式。同时，&、|、^、!都是运算符，它们分别对应的是逻辑与、逻辑或、逻辑异或和逻辑非。其中前三者运算优先级一致，当它们在同一级出现时会从左至右运算，逻辑非的优先级比它们高。当每一个变量都有相应的值时，整个表达式就会就会进行计算，并给出一个布尔值。dyx还发现，当整个表达式的值为$\\text{true}$时，密码锁就会打开。<br />很明显，整个密码锁的输入方案共有$2^n$种，其中$n$是表达式中变量的数量。于是dyx瞬间明白为什么他一次就可以将这个密码锁解开了。然而dyx是一个勇于探究的人，他想知道到底有多少中方法可以解开一个密码锁。<br />不知为何，dyx又发现了一火车的密码锁。坚持不懈的dyx不停的计算着每一个密码锁能解开的方案数......由于密码锁的表达式越来越长并且人脑计算量是$\\Theta(1)$的，dyx不得不需要一个程序来帮助他计算这个方案数。<br />输入格式<br />每个测试数据点有多个表达式。文件以EOF结束。<br />每一个表达式占一行，且中间只有小写字母和&、|、^、!、(、)。<br />对于&、|和^运算，它们左右会各有一个变量或子表达式。其运算规则如下：<br /><br /><br /><br />$a$<br />$b$<br />$a$ & $b$ ($a \\land b$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{true}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br />$\\text{false}$<br /><br /><br />$\\text{false}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br /><br /><br /><br /><br />$a$<br />$b$<br />$a$ | $b$ ($a \\lor b$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{true}$<br />$\\text{false}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br /><br /><br /><br /><br />$a$<br />$b$<br />$a$ ^ $b$ ($a \\oplus b$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{true}$<br />$\\text{false}$<br /><br /><br />$\\text{true}$<br />$\\text{false}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br /><br />对于!运算，它后面会有一个变量或子表达式。其运算规则如下：<br /><br /><br /><br />$a$<br />!$a$ ($\\lnot a$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{false}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br /><br /><br /><br />输入保证表达式是有效的，且表达式中不存在缺少参数的运算符和空的括号。<br />为了防止此题变成不可做的NP-hard问题，输入保证表达式中每一个变量名只出现一次。<br />输出格式<br />对于每一个表达式，输出能够解开它的方案总数。由于答案可能过大，因此将答案对$10^9 + 7$取模后输出。<br />一种方案即指对每一个变量给定一个值。<br />两种方案不同当且仅当至少一个变量所给定的值不同。<br />样例输入<br />1<br />2<br />3a&b<br />a|b|c<br />a|!(b|c)<br /><br /><br />样例输出<br />1<br />2<br />31<br />7<br />5<br /><br /><br />数据范围及提示<br />对于第一个表达式，只有$a = \\text{true}, b = \\text{true}$才为$\\text{true}$。<br />对于第二个表达式，只要三者有一个变量为$\\text{true}$就是$\\text{true}$。<br />对于第三个表达式，先运算b|c，然后对其取反，最后与$a$做逻辑与。<br />以下$n$表示变量数量，$T$表示测试数据组数，$L$表示表达式的总长度。<br />对于$10\\% $的数据，$n \\le 10,\\; T = 15$。<br />对于另外$10\\% $的数据，只有逻辑或运算，没有括号。<br />对于另外$10\\% $的数据，不存在逻辑非和括号。<br />对于另外$20\\% $的数据，不存在括号。<br />对于另外$20\\% $的数据，$n \\le 500$。<br />对于$100\\% $的数据，变量名长度$\\le 4$，$L \\le 10^6$，$n \\le 3\\times10^5$。<br />其中$90\\% $的数据，$T \\le 5$。<br />B. UnString (Link)<br />题目描述<br />ZY很累。<br />因为最近内网的服务器地址总是改来改去。<br />然而ZY又非常想去捣乱。他必须知道内网的服务器的地址是啥。<br />但是阴险的Blue却是给地址加了个密，还TM竟然隐藏了一些字符。<br />但是ZY也是蛮机智的，他得到了一段被加密的地址<br />还有Blue傻逼丢博客的字符对照表，如果地址和博客的字符对照表相似<br />那么ZY就知道他得到的地址是对的，虽然他仍然不能知道地址是啥。<br />输入格式<br />第一行一个字符串$S$，字符串$S$是由a-b组成的字符串<br />第二行一个字符串$C$，字符串$C$是由a-b和?组成的字符串<br />多组数据输入 (Link这货坑爹)<br />输出格式<br />我们将?认为是任何字符，询问$C$是否是$S$的子串<br />输出YES或者NO<br />样例输入<br />1<br />2abc<br />a?c<br /><br /><br />样例输出<br />1YES<br /><br /><br />数据范围及提示<br />$30\\% $ $S$长度小于$2000$，$C$长度小于$20$<br />$60\\% $ $S$长度小于$100000$，$C$长度小于$500$<br />$100\\% $ $S$长度不超过$200000$,$C$长度不超过$2000$<br />C. 赌徒 (ruanxingzhi)<br />题目描述<br />HNSDFZ有一大批赌徒。他们分布在化学组、生物组、机房……这些赌场有道路相连，形成一棵树的结构。<br />赌场里的人越来越多。如果记某个赌场第$n$天的人数为$F_n$，则有$F_n=2F_{n-2}+3F_{n-1}$。每个赌场的$F_1$和$F_2$是预先知道的。当然，赌徒的数量不能太多。每个赌场都会不停地清理人员，做法是把每天的人数模$2333$。<br />现在是第$m$天，3班的某个英语老师要打击赌徒。她准备打击一条链上的所有赌徒。但是她并不知道自己最多能打到多少个赌徒，所以把你捆过来算一算。<br />输入格式<br />第一行一个正整数，$n$表示赌场个数，$m$表示在第几天动手。<br />接下来$n$行，每行两个整数$F_1,F_2$。<br />接下来$n-1$行，每行两个整数$u,v$表示$u$和$v$有边相连。<br />输出格式<br />一行，一个正整数，表示能打击到的赌徒个数。<br />样例输入<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />115 1<br />1 1<br />1 1<br />1 1<br />1 1<br />1 1<br /><br />1 2<br />1 3<br />2 4<br />2 5<br /><br /><br />样例输出<br />14<br /><br /><br />数据范围及提示<br />输入数据中：<br />在第一天，所有的赌场都只有1个人。<br />在这时打击，最多能打击到4个人。这条链是$4-2-1-3$。<br />$n \\le 5 \\times 10^5$, $m \\le 2\\times 10^9$<br />D. 星际争霸 (Haogram)<br />题目描述<br />虽然二十世纪的科技和文化进步神速，但是和後世科技和文明的跳跃式进步相比起来， 也只能甘拜下风。在二十一世纪的末，人类的文明经历了巨大而且难以想像的进步。崭新的科技以难以想像的速度窜起，即使是地球上最为落後的国家也开始拥有越来越先进的电脑和资料库。在东欧共产主义解体的同时，核子武器开始变得随手可得。原来国际势力的兴衰是以资产和军事强权来作为依据，第三世界的国家却利用这个机会猛然窜起，挑战这些强权，打破国际间局势的均衡。 <br />当系统控工学、复制和基因工程变成人人皆可掌握的科技之後，激进人道主义者和狂热的宗教团体开始质疑私人公司以基因工程图利的正当性。大众开始纷纷装置由精密工学所研制出来的人工器官，其他人则开始显现出各种各样的基因突变性状，包括了较为隐性的器官变得敏锐，到明显的心灵感应。人类基因库中所产生的这些变化，让全球各地的人本主义者感到非常的恐慌。 <br />科技继续进步及扩张，人口增加的速度也开始飙升。在二十世纪结束的时候，地球上有 六十亿的人口。仅仅经过短短的三百年，人口暴增为两百三十亿。污染和自然资源、燃料的耗竭更是火上加油。各个国家莫不竭力寻找降低人口成长率的方法。在人口爆炸、基因突变横扫整个地球的同时，一般人都认为地球将因此而走向天灾地变的结局。<br />于是人类造出一艘星际巨舰，在擎天神的领导下，飞往无边的太空......<br />最後，其中一艘的航舰引擎融毁了。在经过二十八年的曲速旅行之後，这些巨大的船只重新出现在三度空间中，靠近一个可居住星系的外缘。这里距离地球六万光年之远，他们的曲速引擎全毁，生命维持的系统几乎已经耗竭。所有的船只只有进入紧急状况，准备迫降在最接近的可居住行星上。<br />每个行星的居民努力的试图在被称为『新世界』的星球上生存。他们并不知道还有其它的同类挣扎著在别的地方求生存，只能够努力的利用手边的资源活下去。<br />然而，Zerg和Protoss的兵力正进攻过来，能否活下还是个问题......<br />作为采矿的工具，空间建筑工程车 (Space Constrution Vehicle)，简称SCV，它们的多样性和无以比拟的可靠性使得它们成为一种极有价值的建筑工具。<br />采矿的流程如下，然而图不能动。<br /><br />SCV从指挥中心 (Command Center) 出发，移动至水晶矿处开采矿物，为了简化问题，设定为采矿不需要时间。采完矿后需要返回指挥中心将矿物送回，否则不能算采到了矿物。图片里既有正在采矿的也有才完了矿带着矿回指挥中心的。<br />因为地面环境复杂，所以SCV所走的路线不一定是笔直的，而是曲折的，再次你可以将其理解为以指挥中心为根的一颗有根树，而水晶矿处于该有根树的叶子节点处。有根树的每一条边都有距离，长度单位为宇宙单位。定义SCV速度为 1 宇宙单位/s。为简化问题，SCV一次采矿可以将该水晶矿采完。<br />有时会有一些宇宙生物（比如卡拉兽）会爬行至采矿路径上的一些点导致该路径不通。增加采矿难度。出于某种原因，地图会不断更新，矿物就会恢复原状，卡拉兽也会被更新至一个新的节点。<br />Zerg和Protoss的进攻已经很近了，你需要尽快采更多的资源......<br />输入格式<br />第一行有$2$个正整数$n$，$m$，表示图上有$n$个点，地图更新$m$次。<br />接下来$n-1$行，每行$3$个正整数$p$，$f$，$l$，代表描述第$p$个点，其父节点为$f$，与父节点的连边长为$l$。<br />接下来$x$行，有$2$个正整数$p$，$w$，表示第$p$号节点有$w$水晶矿。$x$为叶节点个数。<br />接下来$m$行，每行一个正整数$p$，$t$，表示地图更新后，有一只卡拉兽在$p$号节点位置上，Zerg和Protoss的进攻将在$t$秒后来临。如果$p$为$0$，表示没有卡拉兽在地图上。<br />输出格式<br />地图每次更新会将采完的矿回复原状。<br />输出共$m$行，每行对于一次地图更新，输出在进攻来临前采集到的最多矿物数量。<br />样例输入1<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />83 3<br />2 1 35<br />3 1 24<br />2 100<br />3 65<br />0 60<br />1 23<br />3 33<br /><br /><br />样例输出1<br />1<br />2<br />365<br />0<br />0<br /><br /><br />样例输入2<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />189 4<br />2 1 8<br />3 1 10<br />5 2 25<br />6 2 13<br />7 3 22<br />4 1 26<br />8 4 12<br />9 4 23<br />5 78<br />6 66<br />7 48<br />8 50<br />9 80<br />0 257<br />3 200<br />2 230<br />1 500<br /><br /><br />样例输出2<br />1<br />2<br />3<br />4242<br />194<br />130<br />0<br /><br /><br />数据范围及提示<br />对于$10\\% $的数据: $n \\le 20, m \\le 5$<br />对于$20\\% $的数据: $n \\le 20, m \\le 500$<br />对于另外$20\\% $的数据，地图没有卡拉兽<br />对于另外$20\\% $的数据，$n \\le 1000, m \\le 50$<br />对于$100\\% $的数据，$n \\le 1000, m \\le 500, t \\le 50000$<br />指挥中心的编号始终为$1$，地图至多有一只卡拉兽<br />题解<br />A<br />任选一种方法建立AST，标程使用的是递归下降式解析器。<br />然后在AST上DP即可得到答案。<br />B<br />模糊字符串匹配，使用AC自动机，好像有论文什么的......<br />原来的B题被出题人弃了，于是出题人十分不负责地放裸题，数据还一大堆问题......<br />AC自动机搞法纯属暴力！<br />此题正解是FFT，不知道HJWJBSR究竟是怎么搞的。<br />正则表达式的时间复杂度未知......<br />此外还可以用bitset水过去，时间复杂度是$O({nm \\over T})$，$T$是机器的整型长度。具体做法是用所有字符到原串中匹配，匹配上就填$1$否则填$0$，得到不同的布尔数组。对于问号，就全部填$1$。目标就是按照模式串的每个字符顺序排放，找到一个斜列全是$1$即可。因此可以使用bitset，每次先左移一定的位置然后按位与。如果最后得到的bitset中有$1$则表示匹配成功。<br />最后，bitset跑得比标解FFT快很多......<br />C<br />每个点用矩阵快速计算点权，然后DFS找加权直径。<br />D<br />可以将每一个叶节点视为一个有代价有价值的物品，然后做01背包。<br />对于能够删除一些物品后再计算好像没有什么好办法，标程就是每次询问暴力......<br />坐等HJWJBSR给出牛逼搞法。<br />HJWJBSR说可以用前缀和就可以做到$O(nt)$。","tags": "HNSDFZ 互测 2016","url": "blog/2016-7-9/hnsdfz-3.html"},
{"title": "HNSDFZ2016 #4","text": "HNSDFZ2016 #4<br />A. 24点加强版 (ruanxingzhi)<br />题目描述<br />这是一道提交答案的防AK水题。<br />给定$n$个正整数,以四则运算、小括号拼出$k$。<br />自然,每个数都要用且仅用一次。<br />输入格式<br />第一行,两个正整数,表示$n$和$k$。<br />第二行,$n$个正整数,意义如题目所述。<br />输出格式<br />一行,一个四则运算的表达式。注意所有括号都是小括号,可以括号嵌套。<br />样例输入1<br />1<br />24 24<br />6 6 6 6<br /><br /><br />样例输出1<br />1()6+(6+(6)+6)<br /><br /><br />样例输入2<br />1<br />24 24<br />2 7 1 7<br /><br /><br />样例输出2<br />1(7*7-1)/2<br /><br /><br />数据范围及提示<br />对于每个输入文件k_.in,你需要提交一个输出文件k_.out.<br />共有$7$个测试点。前$4$个测试点每个$10$分,后$3$个测试点每个$20$分。<br />$k$-SBK变换 (riteme)<br />题目描述<br />数学家Lunk最近发现了一种逗逼的SBK变换。在Lunk眼里，SBK变换是这样的：<br /><br />给你一个$1$至$n$的排列$A$和一个$1$至$n$的排列$P$，$P$对$A$做一次SBK变换后将得到一个新的排列$B$，其中：<br />$$ B_{P_i} = A_i \\tag{SBK Transformation}$$<br /><br />然而做一次SBK变换太过无聊，于是Lunk决定连续做多次SBK变换。即将每次变换后的结果$B$变为$A$，然后继续用$P$对$A$做SBK变换。Lunk想知道连续对$A$做$k$次SBK变换后的结果。<br />输入格式<br />第一行输入两个整数$n$和$k$，表示排列的长度和连续做SBK变换的次数。<br />第二行输入$n$个整数表示排列$A$。<br />第三行输入$n$个整数表示排列$P$。<br />输出格式<br />一行输出$n$个整数，表示$k$次SBK变换后的结果。<br />样例输入<br />1<br />2<br />35 2<br />1 2 3 4 5<br />2 3 4 5 1<br /><br /><br />样例输出<br />14 5 1 2 3<br /><br /><br />样例解释<br />做完第一次SBK变换后： 5 1 2 3 4<br />做完第二次SBK变换后： 4 5 1 2 3<br />数据范围及约定<br />共$10$个测试点，每个测试点的数据范围如下表所示：<br /><br /><br /><br />数据点<br />$n$的规模<br />$k$的规模<br /><br /><br /><br /><br />1<br />$\\le10^3$<br />$\\le10^3$<br /><br /><br />2<br />$\\le10^3$<br />$\\le10^3$<br /><br /><br />3<br />$\\le10^4$<br />$\\le10^5$<br /><br /><br />4<br />$\\le10^4$<br />$\\le2\\times10^5$<br /><br /><br />5<br />$\\le4\\times10^5$<br />$\\le2^{30}$<br /><br /><br />6<br />$\\le4\\times10^5$<br />$\\le2^{33}$<br /><br /><br />7<br />$\\le6\\times10^5$<br />$\\le2^{63}$<br /><br /><br />8<br />$\\le6\\times10^5$<br />$\\le2^{63}$<br /><br /><br />9<br />$\\le10^6$<br />$\\le2^{63}$<br /><br /><br />10<br />$\\le2.3\\times10^6$<br />$\\le2^{63}$<br /><br /><br /><br />C. 稀奇古怪的根 (Link)<br />题目描述<br />DYX是一个很ZY的ZY,但是他不想ZY一样ZY。<br />他特别喜欢捣鼓一些无与伦比的树。<br />他也特别喜欢逆序对这种东西,因此他想把逆序对拓展到树上来。<br />DYX对于树上的逆序对的定义是这样的:<br />树上的某个点到根节点的路径上权值比他大的节点和他构成逆序对<br />换句话来说,就是指,树上某个节点能和他构成逆序对的节点是他的子树中<br />权值比他小的或者是他到根节点的路径上权值比他大的<br />聪明的DYX很快就把他推广到树上了。<br />最近DYX学会了LCT,里面的换根操作打动了他。<br />因此他在想能不能把LCT的换根拓展到他的树上<br />定义树上两个节点$X$和$Y$,且$X$是$Y$到根节点的路径上面的一个节点<br />定义$X$和$Y$构成逆序对当且仅当$X$的权值比$Y$的大<br />给你一棵树,询问以某个节点为根的时候这棵树总共有多少组逆序对<br />输入格式<br />第一行$n$和$m$表示树的节点个数和询问个数<br />第二行$n$个数表示每个节点的权值<br />然后$n-1$行两个数$X$,$Y$.表示点$X$和$Y$有一条边连接<br />然后$m$行每行$1$个数$X$,表示以$X$为根的时候树中有多少组逆序对<br />输出格式<br />输出$m$行,每行一个整数,表示以$X$为根的树中有多少组逆序对<br />样例输入<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />1610 5<br />1 2 3 4 5 6 7 8 9 10<br />1 2<br />1 3<br />3 4<br />3 5<br />3 7<br />2 9<br />2 10<br />2 6<br />2 8<br />3<br />2<br />1<br />7<br />10<br /><br /><br />样例输出<br />1<br />2<br />3<br />4<br />52<br />1<br />0<br />8<br />10<br /><br /><br />数据范围及提示<br />$30\\% $ $n,\\;m \\le 1000$<br />$50\\% $ $n,\\;m \\le20000$, 且权值不大于$20000$<br />$100\\% $ $n,\\;m \\le 100000$, 保证所有数据在int范围内<br />提供两个类:<br />LCT和主席树,要的请找出题人。<br />要了的话就­1分<br />D. 最长公共子序列 (Haogram)<br />题目描述<br />给定两个正整数序列,每个序列中元素两两不同,且范围都在$[1,\\;n^2]$。求其最长公共子序列。<br />输入格式<br />第一行一个正整数$t$, 表示数据组数。对于每组数据:<br />第一行三个数$n$, $p$, $q$, $n$, 含义如题, $p$, $q$分别为两个序列的长度。<br />接下来两行描述两个序列。<br />输出格式<br />共$t$行$t$个整数,表示答案。<br />样例输入<br />1<br />2<br />3<br />41<br />3 7 8<br />1 7 5 4 8 3 9<br />1 4 3 5 6 2 8 9<br /><br /><br />样例输出<br />14<br /><br /><br />数据范围及提示<br />对于$30\\% $的数据，$n \\le 30$<br />对于$100\\% $的数据，$2 \\le n \\le 250,\\;1 \\lt p,\\;q \\le n^2,\\;t\\le10$<br />E. ZY的金坷垃 (HJWJBSR)<br />题目描述<br /><br />Zy:金坷垃好处都有啥,谁说对了就给他<br />zy:肥料掺了金坷垃,不流失,不蒸发,零浪费<br />zY:肥料掺了金坷垃,能吸收两米下的氮磷钾<br />zy:世界肥料都涨价,肥料掺了金坷垃,一袋能顶两袋撒<br />zY:用了金坷垃,小麦亩产一千八。日本的粮食再也不向美国进口了!hhhhhhhh<br />Zy:小鬼子,真不傻!金坷垃给了他对美国农业危害大,决不能给了他!<br />Zy:非洲农业不发达,我们都要支援他。金坷垃,你们日本别想了!<br />zY:狡猾,狡猾。没有金坷垃,怎么种庄稼!金坷垃!金坷垃!(残念脸<br /><br />zy最近从小鬼子手中抢到了金坷垃。开始考虑怎么撒。他家的地可以看做一个$n\\times m$的方阵。<br />由于非洲农业不发达,zy家的地有些地方并不能够播撒。<br />并且金坷垃是全球瞩目的焦点是农业科技的前沿,所以播撒的方式也比较不一样:每次需要选择一个没被选择过的矩形<br />并均匀撒上金坷垃,且必须将所有矩形都播撒一次。<br />每次播撒的花费的金坷垃袋数是矩形包含的格子个数的平方。<br />zy想知道他要买多少金坷垃才够用。<br />输入格式<br />第一行给出两个正整数$n$和$m$代表zy家的地的长和宽。<br />下面$n$行每行一个长度$m$的01串描述了zy家地的状态。$0$代表这个地不能撒,$1$代表能撒。<br />输出格式<br />一个非负整数代表金坷垃至少要多少袋。<br />样例输入<br />1<br />2<br />3<br />4<br />5<br />65 5<br />01001<br />11000<br />00010<br />00000<br />10001<br /><br /><br />样例输出<br />115<br /><br /><br />数据范围及提示<br />对于$30\\% $的数据, 保证$n,\\;m \\le 10$。<br />对于$50\\% $的数据,保证$n,\\;m \\le 100$。<br />对于所有数据,保证$n,\\;m \\le 1000$。<br />题解<br />A<br />这道题首先需要你有1个小时。<br />然后就可以A掉了。<br />防AK什么鬼......<br />B<br /><br />20分: 模拟 ($\\Theta(nk)$)<br />80分:<br />排列矩阵快速幂 ($\\Theta(n \\log k)$，排列矩阵的乘法可以在$\\Theta(n)$的时间内计算)<br />寻找循环节，倍增找到每个值 ($O(n\\log k)$)<br /><br /><br />100分: 寻找循环节，取模找到每个值 ($\\Theta(n)$)<br /><br />C<br />首先需要计算DFS序。<br />然后用可持久化平衡树来维护它上面的值。<br />首先以$1$为根，计算每棵子树中比树根小的值有多少个，加起来就是$1$的答案。<br />然后从$1$开始DFS一遍，考虑在知道当前节点的答案的情况下，换根到自己的一个儿子处，答案的变化，可以在$\\Theta(\\log n)$的时间内计算出来。<br />然后就可以愉快的$\\Theta(1)$回答啦~~~<br />D<br />将其中一个序列的值依次重新编号，然后将另外一个序列也同步修改一下。<br />然后就转成了求另外一个序列的最长上升子序列问题。<br />这个可以在$\\Theta(n\\log n)$的时间内计算。<br />E<br />引用一段话：<br /><br />题解：<br />本来打算出了另外一道题，后来才发现正确性不太好。又不想变成只能出数据结构题的选手，就临时换了这个比较裸的题。<br />（出题好难<br />很明显如果矩形代价都是1那么肯定就是直接悬线法。<br />否则他要算这个的代价就在悬线法里面加特技：每次相当于要从一个长宽分别为n*m的矩形里面算满足特定条件的子矩形的答案。这样就不会重复。<br />相当于$\\sum_{i=y_0}^{y_1} i^2 \\times \\text{横着的答案}$。<br />横着的答案：$\\sum_{i=1}^m i^2 \\cdot (n-i+1)$。<br />然后就没了。<br />","tags": "HNSDFZ 互测 2016","url": "blog/2016-8-15/hnsdfz-4.html"},
{"title": "HNSDFZ2016 #5","text": "HNSDFZ2016 #5<br />A. 微小的数学 (ruanxingzhi)<br />题目描述<br /><br />到了附中我这三年也没有什么别的,大概三件事:一个,算出了$\\varphi(n)$了; 第二个,算出了$\\mu(n)$; 第三个,就是算出$\\varphi \\times \\mu$了。<br />如果还说有一点成绩就是科普了杜教筛......还有上周的狄利克雷卷积也是很大的。但这些都是次要的。<br />我主要干的就是三件事,很惭愧,就做了一点微小的数学。<br />$$ \\tag{——Gromah} $$<br />现在请你追随Gromah的脚步,来虐掉这个题,做一点微小的数学吧。<br />$$ \\tag{——ruanxingzhi} $$<br /><br />一句话题意:求：<br />$$<br />\\sum_{i=1}^n\\sum_{d \\mid i} \\varphi(d) \\mu(\\frac{i}d)<br />$$<br />输入格式<br />仅一行,一个正整数$n$。<br />输出格式<br />仅一行,一个正整数,表示答案。<br />样例输入1<br />113<br /><br /><br />样例输出1<br />138<br /><br /><br />样例输入2<br />1233<br /><br /><br />样例输出2<br />110138<br /><br /><br />数据范围及提示<br />对于$10\\% $的数据,有$n \\le 32$。<br />对于$30\\% $的数据,有$n \\le 1000$。<br />对于$50\\% $的数据,有$n \\le 100000$。<br />对于$100\\% $的数据,有$n \\le 50000000$<br />B. 一圈一圈 (Haogram)<br />题目描述<br /><br />“有些事,我都已忘记,但我现在还记得,啦啦啦啦啦......”<br />“一圈一圈似爪牙,似魔鬼的步伐,啦啦啦啦......”<br />传闻《我的滑板鞋》作者约瑟翰·庞麦郎即将推出新歌《一圈一圈》,并且mv中要配上鬼畜的舞蹈,于是他贴出了应聘广告,Hagram们自然不想放弃这个赚钱的好机会,毅然决然地前往应聘......<br /><br />约瑟翰·庞麦郎一共应聘了$k$个Hagram，$k$个Hagram都要参与舞蹈。Hagram们被要求在一个$n$行$m$列的矩阵上跳舞，当然一个格子只能站一个Hagram。为了保证舞蹈的鬼畜性，矩阵的第$c$个圈上必须四边都要有Hagram存在，圈数是从最外层往内数的。<br />两个舞蹈队形不同当且仅当其中一个方案的一个格子上有Hagram而另一个方案没有。<br />如果有一个Hagram在某一圈的顶点上，可以认为其既在行上，又在列上。<br />现在约瑟翰·庞麦郎想知道一共有多少种不同的方案，答案对$10^9+7$取模。<br />输入格式<br />对于每组数据，四个数：$n,\\;m,\\;k,\\;c$<br />当$n=m=k=c=0$时结束。<br />输出格式<br />对于每组数据，输出一行一个正整数表示答案。<br />样例输入<br />1<br />2<br />3<br />4<br />52 2 1 1<br />2 2 2 1<br />3 3 1 2<br />3 3 2 2<br />0 0 0 0<br /><br /><br />样例输出<br />1<br />2<br />3<br />40<br />2<br />1<br />8<br /><br /><br />数据范围及提示<br />对于$30\\% $的数据，$n,\\;m \\le 3$，$k \\le 10$。<br />对于$100\\% $的数据，$n,\\;m \\le 50$，$k \\le 3 \\times 10^3$。<br />保证$c$合法。<br />C. KFight (Link)<br />题目描述<br />Zy他是一位在异界闻名的勇士。<br />Zy在知道公主ZY被恶龙BigGayY抓走后，内心及其不平静。<br />Zy知道他走向人生巅峰，迎娶公主的时候到了。他要去找到BigGayY，然后打摆他。<br />但是，BigGayY早就知道闻名的勇士Zy会来。<br />因此倾心于他的公主SAMA找到了他的骑士们阻止Zy的到来。<br />骑士有$N$个，他们挡在了Zy去打摆恶龙的路上。Zy要想办法打败他们，但是他不能出全力。<br />不然的话，到时候没力气打摆BigGayY。因此他只能出$K$拳。<br />骑士们很逗逼，他们有些人会组成团来和Zy战斗，有些人分开和Zy战斗。<br />作为勇士的Zy很强，他每次一拳都可以打死一个人或者一团人。<br />但是骑士团里面还有其他的ZY，作为Zy，他不能够去打败这些ZY，这些ZY也不会去阻止他。  <br />作为异界王者的国王，很想知道Zy不能够救出公主的概率是多少，他并不想让Zy找到公主。<br />因此他找到了你，想知道Zy不能救出公主的概率是多少。<br />输入格式<br />第一行一个T表示有T波骑士来阻挡了Zy。<br />第二行三个数$N,\\;K,\\;Q$，分别表示每一波有$N$个骑士来袭，Zy只能打$K$拳，然后这一波骑士里面有$Q$个ZY。<br />输出格式<br />对于每一波骑士，输出Zy打不过的概率，保留$10$位小数。<br />样例输入<br />1<br />21<br />3 1 0<br /><br /><br />样例输出<br />10.8000000000<br /><br /><br />数据范围及提示<br />注意精度,由于取的小数位很多，注意精度问题。<br />对于$30\\% $的数据有$K \\le N \\le 4,\\;Q = 0,\\;T \\le 10$。<br />对于$60\\% $的数据有$K \\le N \\le 20,\\;Q \\le 10,\\;T \\le 2000$。<br />对于$100\\% $的数据有$K \\le N \\le 30,\\;Q \\le 20,\\;T \\le 2000$。<br />D. 空袭 (riteme)<br />题目描述<br />这是一道交互题。<br />注意本交互库不提供Pascal支持。只支持C\\C++。<br />统计学家Lunk所居住的城市遭到的软斯兰国的空袭，弄得Lunk心神不定。<br />然而伟大的统计学家怎么会就因为空袭而四处避难呢？Lunk决定弄出个大新闻。<br />由于各种原因，Lunk所居住的城市的市区的形状十分奇怪。Lunk将其大致的轮廓画在地图上，形成了一个多边形的形状。软斯兰国的飞机每丢下一枚炸弹，Lunk就会马上观测到炸弹的位置，并将其画在地图上。但是，他所想要统计的只是智障的软斯兰国有多少枚炸弹攻击到了市区。<br />于是Lunk放弃了在地图上画下每一个炸弹的位置，而是转而在地下室里直接统计。<br />现在它所需要的就是一个能帮他统计的程序。他希望能在你们写的程序中选出一个精确度高并且跑得比香港记者还快的程序来帮助它完成这个任务。<br />我该如何编写这个程序<br />选手目录下将会下发interface.h这个文件。<br />你需要实现interface.h中的接口。<br />你需要在同一目录下新建一个文件airstrike.cpp，其中包含以下内容：<br />1<br />2<br />3#include \"interface.h\"<br /><br />// 实现部分<br /><br /><br />你需要实现的接口在头文件中有简要说明。这里做详细说明。<br />1void initialize(const double *x, const double *y, const size_t n, const int id);<br /><br /><br />是载入程序的入口。在进行查询之前，会调用这个函数。<br />载入所用的时间不会计入你的程序用时。但是载入时间不能超过$3\\text{s}$。<br />x和y是两个数组，给出的是市区的轮廓，即Lunk绘制的多边形的顶点，按照逆时针顺序给出。<br />n是多边形的顶点数量。<br />id是当前数据点的标号，在下文会有解释。<br />1bool query(const double dx, const double dy);<br /><br /><br />是Lunk的操作，每次调用即查询炸弹是否炸在市区内。如果炸在市区内则返回true，否则返回false。<br />dx和dy是炸弹炸到的坐标。<br />该函数的用时会被计入程序用时。<br />1void finalize();<br /><br /><br />是结束程序。这个函数将在所有查询任务完成后调用。<br />用于释放你的程序所用的资源。<br />该函数的用时不会计入程序用时，但是其运行时间不能超过$3\\text{s}$。<br />注意，请不要使用delete[]删除掉之前initialize参数中给你的顶点数组，否则后果自负。<br />我该如何测试这个程序<br />选手目录下将会下发main.cpp这个文件。<br />首先你需要有输入的数据，其格式将在下文给出。<br />假设你的程序文件是airstrike.cpp，那么使用以下命令来编译：<br />1g++ main.cpp airstrike.cpp -std=c++11 -o main<br /><br /><br />或者你需要调试：<br />1g++ main.cpp airstrike.cpp -std=c++11 -o main -g<br /><br /><br />打开-O2优化：<br />1g++ main.cpp airstrike.cpp -std=c++11 -o main -O2<br /><br /><br />对于C语言，将main.cpp改名为main.c，使用gcc，并且将-std=c++11改为-std=c11即可。<br />然后使用：<br />1./main<br /><br /><br />来运行程序。<br />如果需要使用文件输入输出，你可以使用管道，也可以修改main.cpp，将其中的两行带有注释的freopen取消注释，然后重新编译即可。<br />注意，该程序不会测试你的用时并给你评分。并且与最终评测时的运行程序不同。<br />输入格式<br />此处的输入格式是根据上面的测试程序所说的。<br />第一行输入两个整数$n$和$d$，表示顶点数量和数据编号。<br />下面$n$行描述市区，每一行给出一个整点$(x,\\;y)$，表示一个顶点。<br />之后给出若干行，一直到文件尾，每行给出一个整点$(x_q,\\;y_q)$，表示炸弹的位置。<br />输出格式<br />对于每一个Lunk的询问，输出对应的信息 (YES或NO)。<br />样例输入1<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />93 1<br />0 0<br />6 1<br />8 7<br /><br />6 5<br />2 7<br />8 1<br />3 1<br /><br /><br />样例输出1<br />1<br />2<br />3<br />4YES<br />NO<br />NO<br />YES<br /><br /><br />样例解释1<br />样例输入1如下图所示：<br /><br />样例输入2<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />157 1<br />1 1<br />7 1<br />4 2<br />3 4<br />7 5<br />5 6<br />1 6<br /><br />0 4<br />2 4<br />4 4<br />5 3<br />5 5<br />3 1<br /><br /><br />样例输出2<br />1<br />2<br />3<br />4<br />5<br />6NO<br />YES<br />NO<br />NO<br />YES<br />YES<br /><br /><br />样例解释2<br />样例输入2如下图所示：<br /><br />数据限制<br />共$7$个数据测试点，限制如下：<br /><br /><br /><br />数据编号<br />$n$的规模<br />特殊限制<br /><br /><br /><br /><br />$1$<br />$\\le 10$<br />无<br /><br /><br />$2$<br />$\\le 10^3$<br />无<br /><br /><br />$3$<br />$\\le 10^5$<br />无<br /><br /><br />$4$<br />$\\le 2 \\times 10^5$<br />无<br /><br /><br />$5$<br />$\\le 10^6$<br />左右的边与$y$轴平行，下边与$x$轴平行，上边顶点$x$递增，均高于下边，输入数据从左下角开始。<br /><br /><br />$6$<br />$\\le 10^6$<br />凸多边形<br /><br /><br />$7$<br />$\\le 10^3$<br />$0 \\le x,\\;y \\le 10^3$<br /><br /><br /><br />对于$100\\% $的数据，满足$3 \\le n \\le 10^6,\\;|x|,\\;|y|,\\;|x_q|,\\;|y_q| \\le 10^9$。<br />顶点按照逆时针顺序输入，没有两个顶点一样，并且为简单多边形。<br />评分标准<br />对于不同的数据点，分值和时间限制如下表所示：<br /><br /><br /><br />数据编号<br />分值<br />时间限制<br /><br /><br /><br /><br />$1$<br />$5$<br />$0.1\\text{s}$<br /><br /><br />$2$<br />$10$<br />$1\\text{s}$<br /><br /><br />$3$<br />$15$<br />$1\\text{s}$<br /><br /><br />$4$<br />$30$<br />$1\\text{s}$<br /><br /><br />$5$<br />$10$<br />$1\\text{s}$<br /><br /><br />$6$<br />$15$<br />$1\\text{s}$<br /><br /><br />$7$<br />$15$<br />$1\\text{s}$<br /><br /><br /><br />在时间限制内，如果程序不出意外 (如运行时错误)，将会不断的给出询问。设你的程序完成的询问个数为$x$。对于每一个点的评分标准如下：<br /><br /><br /><br />数据编号<br />$20\\% $<br />$40\\% $<br />$60\\% $<br />$80\\% $<br />$100\\% $<br /><br /><br /><br /><br />$1$<br />$\\ge 10^5$<br />$\\ge 2\\times 10^5$<br />$\\ge 3 \\times 10^5$<br />$\\ge 4 \\times 10^5$<br />$\\ge 5 \\times 10^5$<br /><br /><br />$2$<br />$\\ge 5 \\times 10^4$<br />$\\ge 10^5$<br />$\\ge 2 \\times 10^6$<br />$\\ge 3 \\times 10^6$<br />$\\ge 4 \\times 10^6$<br /><br /><br />$3$<br />$\\ge 5 \\times 10^2$<br />$\\ge 10^3$<br />$\\ge 2 \\times 10^5$<br />$\\ge 4 \\times 10^5$<br />$\\ge  5 \\times 10^5$<br /><br /><br />$4$<br />$\\ge 10^3$<br />$\\ge 1 \\times 10^5$<br />$\\ge 2 \\times 10^5$<br />$\\ge 3 \\times 10^5$<br />$\\ge 4 \\times 10^5$<br /><br /><br />$5$<br />$\\ge 10^3$<br />$\\ge 8 \\times 10^5$<br />$\\ge 10^6$<br />$\\ge 1.2 \\times 10^6$<br />$\\ge 1.4 \\times 10^6$<br /><br /><br />$6$<br />$\\ge 5 \\times 10^2$<br />$\\ge 8 \\times 10^5$<br />$\\ge 10^6$<br />$\\ge 1.2 \\times 10^6$<br />$\\ge 1.4 \\times 10^6$<br /><br /><br />$7$<br />$\\ge 10^6$<br />$\\ge 2 \\times 10^6$<br />$\\ge 3 \\times 10^6$<br />$\\ge 4 \\times 10^6$<br />$\\ge 10^7$<br /><br /><br /><br />你的$x$需要达到对应的要求才能得到对应的百分比。评测程序将选取你能达到的最高的百分比。<br />其中百分比是将该点总分乘上该百分比并向下取整，作为你该点的分数。<br />如果询问回答错误，将每回答错误一次扣除$1$分，扣分到$0$分为止，分数不会变为负数。<br />如果发生运行时错误，或者运行严重超时，将导致该点得$0$分。<br />如果你的initialize或finalize超时，该点得$0$分。<br />关于评测机<br />出于一些原因，GCC编译出来的评测器并不是很稳定，可能出现成绩波动的情况，所以评测时最好采用Clang进行编译，得到的结果会稳定一些。<br />如果你对你的算法十分自信，然而在评测时却没有得到满分，可以进行重测。<br />温馨提示<br />评测时限很长，请不要恶意卡评测，谢谢合作！<br />部分题解<br />A<br />raunxingzhi总是喜欢出这种题目，莫名其妙。<br />首先是$O(n \\ln n)$的做法，令：<br />$$<br />f(n) = \\sum_{d \\mid n} \\varphi(d) \\mu(\\frac{n}d)<br />$$<br />对其进行逆反演，可以得到：<br />$$<br />\\varphi(n) = \\sum_{d \\mid n} f(d)<br />$$<br />所以：<br />$$<br />f(n) = \\varphi(n) - \\sum_{d \\mid n,\\;d \\lt n} f(d)<br />$$<br />所以欧拉函数可以$\\Theta(n)$预处理，而后面的部分可以按照贡献计算，做到$O(n \\ln n)$。<br />mdzz，$O(n \\ln n)$怎敢过......<br />其次是两种更快算法。<br />第一种是乱搞算法，是一个分块打表。<br />由于我们计算一个$\\sum_{d \\mid n} \\varphi(d) \\mu(\\frac{n}d)$就需要$\\Theta(\\sqrt{n})$的时间，考虑提前将一些答案计算出来。<br />设每隔$T$个打一个表，那么总共会打$n / T$个表，每次询问的时间为$O(T\\sqrt{n})$。因此，只要你的文件存得下，$T$越小这个速度越快。<br />第二种是$\\Theta(n)$的算法。首先考虑将式子变形，改变枚举顺序：<br />$$<br />\\sum_{i=1}^n \\sum_{d \\mid i} \\varphi(d) \\mu(\\frac{i}d) \\Longrightarrow \\sum_{d = 1}^n \\varphi(d) \\sum_{k = 1}^{\\left\\lfloor \\frac{n}d \\right\\rfloor} \\mu(dk)<br />$$<br />变成了先枚举因子，然后枚举因子的倍数。于是就变成了欧拉函数和莫比乌斯函数的前缀和之积。<br />注意不要写出以下代码：<br />1typedef int int64;<br /><br /><br />否则会挂得很惨。<br />B<br />Haogram的题似乎有很多做法，我都不太记得了，这里瞎BB一下：<br />我的做法是生成函数。一个最原始的想法是枚举环上四条边有多少个人，这样将四条边上的答案相乘并且乘上站在环外的方案数就是当前答案。<br />这样纯枚举是$\\Theta(n^4)$的。这个过程非常类似于多项式乘法，换成生成函数的观点，就是将答案组合起来。<br />于是设四个生成函数，分别表示一条边上站$0,\\;1,\\;2,\\;\\dots$个人的方案数，实际上就是一个组合数，然后暴力将多项式乘起来 (因为$n$很小)，可以做到$\\Theta(n^2)$的复杂度。<br />如果$n$很大可以换成FFT或NTT。注意使用NTT时，因为题目中已经有了一个模数，所以这两个模数或多或少会有一些冲突，需要注意一下。<br />然后就是留下四个角的特殊情况。之前我们需要在边上的人不能站在角上。现在来钦定这四个角上有没有人。最后你一共要手动枚举$7$中情况orzorz......<br />注意其中一条边退化为$1$的情况。<br />标解是使用容斥原理。因为不考虑那个莫名其妙的要求，直接计数是很简单的。然后就需要考虑去掉不合法的情况。基础情况自然是一条边上没有人。<br />运用容斥原理乱搞就好了~~只有$4$个条件所以速度很快。<br />C<br />你们自己问Link吧，我也不会......<br />D<br />原来只要出交互题就可以做到全场爆$\\color{red}{0}$，曾经有人出过提答题，结果全场AC......<br />60分不写就算了，40分智障分也不写你们好劲啊！一颗赛艇啊！<br />首先百度一下和谷歌一下的第一版的算法基本上就$10$到$20$左右吧。射线法和角度判别法都是$\\Theta(n)$的算法。<br />然后后面$40$分是些智障数据点。第$5$个点是上边会上下起伏，我们可以二分找出对应的边，然后叉积判断即可。<br />第$6$个点凸多边形可以直接进行三角剖分，然后利用角度二分找到对应的三角形，就可以愉快地判定了。这些过程均可用叉积。<br />第$7$个点直接在initialize里面全部预处理就OK了。注意查询的点可能不在那个范围内，需要特判一下。<br />接下来是标准解法。<br />首先考虑一个离线算法，这个算法我是从梯形化三角剖分里借鉴到的。首先将所有边建立两个事件，左端点插入和右端点删除，然后排序。查询也要排序。<br />然后做一条从左至右的竖直扫描线，用一棵平衡树来维护当前穿过扫描线的边。<br />很明显的一点就是平衡树中的边不会相交，这样我们可以方便地确定两条边之间的比较关系。<br />首先如果一条边的两个端点都在另一条边所在的直线下面，那么这条边肯定在在另一条边下面。<br />利用这一点就可确定大小关系。但是需要注意一种特殊情况：<br /><br />此时$A$显然在$B$下面，然而如果用$A$去判定$B$就会得到错误的结果 (因为$B$有一个点在$A$所在直线下方)。<br />我们所要做的就是，当发现这种情况时，交换$A$和$B$，就可以避免处理这种情况。<br />这样我们每扫描完一个$x$，就可以逐个回答当前的询问了。在平衡树上二分找到上下边，然后判定这个点是否在这两条边所表示的半平面交的范围内。<br />由于是交互题，被强制在线了。为了能够在线，我们需要每一个$x$处的平衡树来在线回答。这个东西可以利用可持久化平衡树高效地存下来。","tags": "HNSDFZ 互测 2016","url": "blog/2016-8-28/hnsdfz-5.html"},
{"title": "Hall定理","text": "Hall定理<br />基本形式<br />Hall定理是一个用于判定二分图是否具有最大匹配的定理。<br />首先对于二分图$G = (X \\cup Y, E)$，点集被分为了$X$和$Y$两部分。<br />是否具有最大匹配，首先一个最基本的条件就是$|X| = |Y|$。<br />Hall定理则在此基础上给出了一个更强的条件。<br />首先对于一个点集$T \\subseteq X$，定义$\\Gamma(T)$如下：<br />$$<br />\\Gamma(T) = \\{v \\mid u \\rightarrow v \\in E,\\; u \\in T,\\; v \\in Y\\}<br />$$<br />即表示$T$中所有点能够直接到达的$Y$中的点的集合。<br /><br />上图中，$\\Gamma(\\{1,\\;3\\}) = \\{4,\\;5,\\;6\\}$。<br />那么Hall条件则用于判断一个二分图是否存在最大匹配。Hall条件如下：<br />对于任意的点集$T \\subseteq X$，均存在：<br />$$<br />|T| \\le |\\Gamma(T)|<br />$$<br />那么此二分图必定存在最大匹配。<br />证明<br />这个定理看起来很显然，证明起来也不是很难。<br />首先我们令$n = |X|$，那么，当$n$等于$0$或$1$时，可以验证是正确的。<br />我们尝试进行逆向归纳。对于一个$n > 1$的二分图，考虑以下两种情况：<br /><br />如果对于任意的$T \\subseteq X$均满足以下条件：<br />$$ |\\Gamma(T)| \\ge |T| + 1 $$<br />那么我们可以删除图中任意一条边作为匹配。由于每个子集均满足以上条件，那么从$X$和$Y$中各删除一个点不会导致违反Hall条件，所以此操作可以使归纳继续并且使$n$减小。<br />如果存在一个最大的$T \\subset X$，满足以下条件：<br />$$ |\\Gamma(T)| = |T| $$<br />那么我们可以明确两点：第一，在$T$中我们可以找到一个关于$T$的最大匹配；第二，将这个匹配从图中删去，剩下的图依然满足Hall条件。因为根据Hall条件易知每一个$X$中的点必定至少与一个$Y$中的点有连边关系。同时Hall条件还表明，不存在一个不属于$T$的点，只与$\\Gamma(T)$中的点有边相连。故删除它们不会造成有点的出度变为$0$，从而满足了Hall条件。<br /><br />因此可以通过归纳证明Hall定理。<br />简单运用<br />Hall定理一般没有什么优化算法复杂度上的用途，但是可以作为一个比较好的思维工具。<br />例如下面这个问题：<br />[Russian Code Cup 2016 - Finals] A. Closing ceremony<br />大意是有一个$n\\times m$的网格和$n \\times m$个人，每个人都要走到一个网格上的一点，每个点只能装下一个人。<br />同时定义两个点之间的距离为曼哈顿距离，每个人有自己行走的路程上限。<br />现在这$n \\times m$个人分成两批，从$(0,\\;0)$和$(0,\\;m+1)$出发，问你是否存在一种安排每个人的最终位置的方案，来满足每个人走到对应位置时的路程不超过自己的上限。<br />令点$A$为$(0,\\;0)$，点$B$为$(0,\\;m+1)$。并且设$f(i,\\;j)$表示离$A$距离至少为$i$，离$B$距离至少为$j$的格子的个数。<br />设$S_A(i)$表示在$A$最远距离至少为$i$的人数，同理，$S_B(i)$表示在$B$处最远距离至少为$i$的人数。由于每个人和一个位置形成了一个一一对应的关系，由此我们可以构建一个二分图，并且我们所要做的就是判定这个二分图是否具有最大匹配。<br />事实上由于存在单调性，利用Hall定理可以知道，我们只用判定是否对于所有的$f(i,\\;j)$均不大于$S_A(i) + S_B(j)$，如果满足这个条件，那么这个二分图就有最大匹配。<br />那么现在的问题就是求得$f$。由于曼哈顿距离为$i$的等距线实际上是一条斜率为$1$或$-1$的直线，所以$f(i,\\;j)$就是两条直线在网格中围成的面积。<br />并且注意到它可以递归计算：<br />$$<br />f(i,\\;j) = f(i+1,\\;j) + f(i,\\;j+1) - f(i+1,\\;j+1)<br />$$<br />并且需要考虑这两条直线的交点是否会占用一个格子。所以我们的做法就是枚举交点，确定是那两条直线相交，并且赋给对应的$f$去，然后对$f$计算后缀和就是我们想要的东西啦～","tags": "图论 二分图 Hall定理","url": "blog/2016-9-19/hall-theorem.html"},
{"title": "Home Page","text": "欢迎来到riteme’s site！<br />这是riteme的个人主页。<br />这个博客已经开始成天乱说话了，大家不要乱D QAQ。<br />博客更新比较缓慢，可能会长期不更......<br />博客里大多关于编程与OI，大家随意翻阅~~<br />我的GitHub: https://github.com/riteme<br />我的知乎: https://www.zhihu.com/people/riteme<br />PS: 多说评论居然是在线更新的！<br />–>辣鸡聊天室<–<br />最近文章<br />差分序列与Stirling数介绍了差分序列和两类Stirling数READ MORE…位运算卷积与FWT介绍了位运算卷积以及快速计算的FWT算法READ MORE…辛普森积分法简单介绍了辛普森积分法和自适应辛普森积分法READ MORE…RSRL开发记录（一）READ MORE…收到一封奇怪的邮件READ MORE…Hall定理一个用于判定二分图是否具有最大匹配的定理READ MORE…HNSDFZ2016 #5HNSDFZ2016第五次欢乐互测READ MORE…快速数论变换 (NTT)快速傅立叶变换的双胞胎，用原根代替单位复数根READ MORE…二进制GCD在算导上发现了一个有趣的算法，有氧环境下可以拿来卡卡常.....READ MORE…莫比乌斯反演介绍了莫比乌斯函数和莫比乌斯反演公式READ MORE…查看全部…","tags": "Home","url": "index.html"},
{"title": "Int 2048","text": "Int 2048<br />时间限制：$1 \\mathrm{s}$<br />空间限制：$1024 \\mathrm{MB}$<br />题目描述<br />这是一道交互题。<br />注意本交互库不提供Pascal\\C支持，只支持C++。<br />L语言之父Lunk最近声称用该语言编写计数问题不要取模，因为Lunk发明了$256 \\mathrm{\\ Byte}$的int2048_t，并且已经内置到L语言中。<br />然而屁民们并不相信，因为Lunk的int2048_t还不支持Xntel公司的CSB指令 (Count Set Bits，计数被设置的位的数量)，于是众人D之。Lunk为了挽回自己的脸面，决定实现一个CSB命令来教训一下这群智障。<br />CSB指令是一个这样的指令：它用于计数一个整型的二进制表示中的$1$的个数。例如下面的整型中：<br />$$01001101$$<br />其执行CSB的结果是$4$。<br />Lunk不想再搞个新东西来支持这个垃圾玩意，他只准备利用现有的功能来实现它。目前int2048_t所支持的功能如下表所示：<br /><br /><br /><br />符号<br />说明<br />示例<br />代价<br />实际复杂度<br /><br /><br /><br /><br />(constructor)<br />构造一个int2048_t<br />int2048_t<br />$0$<br />$\\Theta(n)$<br /><br /><br />(constructor)<br />从一个字符串构造一个int2048_t<br />int2048_t(\"110\")<br />$0$<br />$\\Theta(n)$<br /><br /><br />+<br />加法<br />0011 = 0010 + 0001<br />$1$<br />$\\Theta(n)$<br /><br /><br />-<br />取负数 (计算其补码)<br />1111 = -0001<br />$1$<br />$\\Theta(n)$<br /><br /><br />-<br />减法 (需要执行一个取负数和加法)<br />1101 = 1111 - 0010<br />$2$<br />$\\Theta(n)$<br /><br /><br />~<br />将各位取反<br />1010 = ~0101<br />$1$<br />$\\Theta(n)$<br /><br /><br />&<br />按位与<br />0010 = 1011 & 0110<br />$1$<br />$\\Theta(n)$<br /><br /><br />|<br />按位或<br />1111 = 1011 | 0110<br />$1$<br />$\\Theta(n)$<br /><br /><br />^<br />按位异或<br />1101 = 1011 ^ 0110<br />$1$<br />$\\Theta(n)$<br /><br /><br /><<<br />左移<br />1100 = 1011 << 2<br />$1$<br />$O(n)$<br /><br /><br />>><br />右移<br />0010 = 1011 >> 2<br />$1$<br />$O(n)$<br /><br /><br />==<br />判断是否相等<br />0010 == 0010<br />$1$<br />$\\Theta(n)$<br /><br /><br />!=<br />判断是否不等<br />0010 != 1010<br />$1$<br />$\\Theta(n)$<br /><br /><br /><<br />小于<br />0010 < 0100<br />$1$<br />$O(n)$<br /><br /><br />><br />大于<br />0110 > 0100<br />$1$<br />$O(n)$<br /><br /><br /><=<br />小于等于<br />0100 <= 0100<br />$1$<br />$O(n)$<br /><br /><br />>=<br />大于等于<br />0010 >= 0010<br />$1$<br />$O(n)$<br /><br /><br />(bool)<br />转为bool类型 (如果为$0$则为$\\mathrm{false}$，否则为$\\mathrm{true}$)<br />if (a)<br />$1$<br />$O(n)$<br /><br /><br /><br />在上表中，代价是智障们评定运行快慢的标准，实际复杂度是在实际运行 (即你的程序) 中的时间复杂度，其中$n$表示int2048_t的二进制位数，即$2048$。<br />智障屁民们将会给出一堆的测试，如果Lunk的CSB指令写挂了，那么它们将会打$0$分。如果Lunk的CSB指令太慢，它们就又不高兴。于是Lunk请你帮他编写一个快速的CSB指令的实现。<br />实现<br />选手目录下将会下发int2048_t.hpp和int.h两个文件。<br />int2048_t.hpp是Lunk的int2048_t的实现，已经被int.h包含，选手不用自行包含。<br />选手需要实现一个evaluate函数，表示CSB指令。其函数原型如下：<br />1int evaluate(const int2048_t &num);<br /><br /><br />当交互库运行时，会将测试数据通过num传入，而该函数的目的就是返回CSB指令在num上的结果。<br />样例交互库<br />选手目录下将会下发implementer.cpp这个文件。<br />假设你的实现的源文件是int.cpp，那么使用下面的编译命令来编译：<br />1g++ int.cpp implementer.cpp -std=c++11 -o exec<br /><br /><br />然后将会得到可执行文件exec。<br />输入格式<br />此处的输入格式值针对样例交互库而言的。<br />输入只有一行，表示测试的整形，以二进制形式给出。请确保输入不超过2048位，否则将导致不正常结果。<br />由于int2048_t是有符号整型，出于一些原因，最终测试数据的输入的最高位都是$0$。<br />输出格式<br />此处的输出格式是针对样例交互库而言的。<br />样例交互库将会从输入得知答案，并将输入转为int2048_t，然后执行evaluate得到你的答案。如果两者答案一致，将会输出你所使用的代价总和。否则将输出Wrong answer，并给出正确答案和你的答案。<br />样例输入<br />101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111<br /><br /><br />样例答案<br />12047<br /><br /><br />评分标准<br />此题共$10$个数据点，每个数据点$10$分。<br />对于每一个数据点而言，如果你的答案不正确，那么将记$0$分。<br />否则，记$a$为你的evaluate执行的代价总和，$v_{\\min}$和$v_{\\max}$是每个数据点的特定的参数，那么你的得分将是：<br />$$<br />\\left\\lfloor \\max\\left\\{ 10 \\cdot\\min\\left\\{ 1, \\; { v_{\\max} - a \\over v_{\\max} - v_{\\min} } \\right\\}, \\; 0 \\right\\} \\right\\rfloor<br />$$<br />数据限制<br />对于每一个数据点，其限制如下表所示 (其中$x$表示答案)：<br /><br /><br /><br />数据点编号<br />$x$<br />$v_{\\min}$<br />$v_{\\max}$<br /><br /><br /><br /><br />$1$，$2$，$3$<br />$ \\leqslant 400 $<br />$6140$<br />$6144$<br /><br /><br />$4$，$5$，$6$<br />$ \\leqslant 200 $<br />$801$<br />$1201$<br /><br /><br />$7$，$8$，$9$，$10$<br />$ \\leqslant 2047 $<br />$76$<br />$120$<br /><br /><br /><br />提示<br />一个整型的原码就是其二进制表示：<br />$$<br />13 \\rightarrow 00001101<br />$$<br />其反码就是将除了符号位 (即最高位) 的所有取反：<br />$$<br />00001101 \\rightarrow 01110010<br />$$<br />对于负数，其符号位为$1$：<br />$$<br />01110010 \\rightarrow 11110010<br />$$<br />二进制数的补码就是将其反码加上$1$，同时对于溢出的位直接丢弃，符号位也参与计算：<br />$$<br />-13 \\rightarrow 11110011 \\\\<br />-0 \\rightarrow 11111111 + 1 \\rightarrow 100000000 \\rightarrow 00000000<br />$$<br />因此采用补码存储负数，原码存储自然数，这样减法可以变为加法：<br />$$<br />1 - 13 = 1 + (-13) \\rightarrow 00000001 + 11110011 = 11110100 \\rightarrow -12<br />$$<br />所以减法需要花费$2$的代价。","tags": "Problems","url": "blog/2016-11-24/int.html"},
{"title": "Lesson 16","text": "Lesson 16: Mary had a little lamb (玛丽有一头小羔羊)<br />Mary and her husband Dimitri lived in the tiny village of Perachora in southern Greece. One of Mary’s prize possessions was a little white lamb which her husband had given her. She kept it tied to a tree in a field during the day and went to fetch it every evening. One evening, however, the lamb was missing. The rope had been cut, so it was obvious that the lamb had been stolen.  When Dimitri came in from the fields,His wife told him what had happened.Dimitri at once set out to find the thief. He knew it would not prove difficult in such a small village. After telling several of his friends about the theft, Dimitri found out that his neighbour, Aleko, had suddenly acquired a new lamb. Dimitri immediately went to Aleko’s house and angrily accused him of stealing the lamb. He told him he had better return it or he would call the police. Aleko denied taking it and led Dimitri into his back-yard. It was true that he had just bought a lamb, he explained, but his lamb was black. Ashamed of having acted so rashly, Dimitri apologized to Aleko for having accused him. While they were talking it began to rain and Dimitri stayed in Aleko’s house until the rain stopped. When he went outside half an hour later, he was astonished to find that the little black lamb was almost white. Its wool, which had been dyed black, had been washed clean by the rain!","tags": "English","url": "blog/english/16.html"},
{"title": "NOIP2014 寻找道路题解","text": "[NOIP2014] 寻找道路<br />原题题意<br />给你一张$ n(n \\le 1000) $个点和$ m(m\\le200000) $条边权为1的无向边的图，找出一条符合下列要求的路径：<br />1. 路径上的所有点的出边所指向的点都直接或间接与终点连通。<br />2. 在满足条件 1 的情况下使路径最短。<br />做法<br />既然路径上的所有点都要满足要求1,于是我们先求出这张有向图中哪些点满足要求。<br />我们使用一个valid数组来存储某个点是否直接或间接地到终点的布尔值，故最暴力的方法就是每个点DFS。其实只需要一次DFS即可，因为只要任意一个与某个点的出边相连接的点能够到达终点，那么这个点也可以到达终点，否则不行。这样在写的过程中，比较麻烦，因此我们在读入图的时候同时构造一张反向图，即每条边与原图方向相反，然后从终点BFS，将每个可以便利到的点打上标记。<br />做完这个处理后，只需要从起点BFS就能求出答案。","tags": "NOIP BFS 图论","url": "blog/2016-2-1/find-path.html"},
{"title": "NOIP2015 信息传递题解","text": "[NOIP2015] 信息传递<br />原题题意<br />给你一张$ n \\; (n \\le 200000) $个点的有向图，请你找出其中最短的有向环，输出此环的长度。<br />做法<br />使用DFS将图遍历，找出有向环统计最小。<br />遍历是对节点进行标记，如果遍历中发现已经被标记的节点，则表示找到了一个环。<br />需要注意几点：<br /><br />一次DFS不一定能将整张图遍历，因此需要检查每个点，多次DFS。  <br />注意DFS的起点而导致的冲突。<br />   为了说明这个问题，我放一张图解释一下。<br />   下面是一张有向图：<br /><br />   假如我们第一次从2出发，DFS完后将2之后的点都打上了标记。<br />   然后从1出发继续寻找，发现2被打上了标记，会误认为是一个环，导致错误的结果。<br />   解决方法很简单，我们给每次DFS一个不同的编号，通常从1开始。<br />   我们默认如果点的标记为0表示还没有访问过。<br />   如果还没有访问，做的标记就是本次DFS的编号。因此，只要发现被标记的点是自己打上的，才说明发现了环。<br />   如果发现了别的DFS打上的标记，就不必继续搜索了。<br />有向环的长度计算。<br />   这个很好办，DFS中我们维护一个$dist$数组，表示到本次搜索起点的距离。<br />   当发现有向环时，可以利用此数组算出来。<br />递归优化。<br />   这个DFS由于不需要回溯之类的操作，并且题目中给出每个人只会将信息传给一个人，<br />   那么说明每个点的出度为1，因此我们可以将DFS改成递推的形式：<br /><br />1<br />2<br />3<br />4def dfs(s):<br />    while next(s) is not marked:<br />        # 处理s<br />        s = next(s)<br /><br />","tags": "NOIP DFS 图论","url": "blog/2016-2-1/message.html"},
{"title": "POJ2135 Farm Tour","text": "[POJ2135] Farm Tour<br />原题题意<br />FJ老爷爷带着他的朋友到他的开心农场装B。FJ的农场是一张有$n(n\\le1000)$个点，$m(m\\le10000)$条边的无向图，每个点从$1$开始编号，每条边有一个边权。现在他想从$1$走到$n$，然后又从$n$走到$1$，他希望走的路最短且每条路不走两遍。<br />做法<br />看到要使走的路最短，就肯定要动用最短路了。然而他还需要两条，且这两条路径的每一条边都不同，用单纯的最短路难以办到。<br />不妨运用最大流的思想，将每条边拆成两个有向管道，且容量为1。那么，在增广时，只要是走过的边就会没有流量了，保证只有一条路径经过。<br />将最短路和最大流结合起来，就是最小费用最大流，这里我们将流网络的每条弧增加一个属性cost表示费用（注意不是单位费用），对应的就是原图中的边权。每次增广时选取费用最小的来进行增广，就能确保找到的增广路是原图中的最短路。<br />最后一个问题就是要找两条，这个其实很好办。我们利用源点和汇点来控制。首先建立一个源点，与$1$相连，容量为2,当然费用为0，这样不会最短路的结果。同样的方法，将汇点与$n$连接。这样，每次只能增广1的流，就能确保最多只有2条增广路。<br />需注意的是，在残留网络中，方向边的边权要为-cost，这样才能让增广正常进行。因此，Dijkstra算法并不适合。","tags": "POJ 网络流 最小费用流 图论","url": "blog/2016-2-1/farm-tour.html"},
{"title": "RSRL开发记录（一）","text": "RSRL开发记录（一）<br />深觉自己姿势水平还是太低，许多东西并没有学到家就准备搞东西，ne2d就是一个典型的例子吧。虽然以后可能还会继续，但是现在先写个软渲染器来熟悉一些基础知识。<br />项目开在了GitHub和Git@OSC上，欢迎围观：<br />GitHub: https://github.com/riteme/RSRL<br />Git@OSC: http://git.oschina.net/riteme/RSRL<br />所谓乎开发记录，就是记录一点有点价值的东西，各位随意看看。<br />颜色运算<br />Color.h & Color.cpp<br />常见的屏幕颜色有四个分量：红($\\mathrm{R}$)、绿($\\mathrm{G}$)、蓝($\\mathrm{B}$)和透明度($\\mathrm{A}$)。通常这四个分量用uint8_t来记录，范围就是$0$至$255$。在计算机图形学中为了方便插值，通常都是用浮点数来存储的，范围为$0.0$至$1.0$。<br />计算一个颜色的反色可以用以下公式：<br />$$<br />\\mathrm{R}^\\prime = 1 - \\mathrm{R} \\\\<br />\\mathrm{G}^\\prime = 1 - \\mathrm{G} \\\\<br />\\mathrm{B}^\\prime = 1 - \\mathrm{B}<br />$$<br />这里我们不考虑透明度。<br />另一个比较重要的就是Alpha混合，就是将两个颜色按照透明度混合，通常是这样计算的：<br />$$<br />\\mathrm{R}^\\prime = \\mathrm{R}_1 \\cdot \\mathrm{A}_1 + \\mathrm{R}_2 \\cdot \\mathrm{A}_2 \\cdot (1 - \\mathrm{A}_1) \\\\<br />\\mathrm{G}^\\prime = \\mathrm{G}_1 \\cdot \\mathrm{A}_1 + \\mathrm{G}_2 \\cdot \\mathrm{A}_2 \\cdot (1 - \\mathrm{A}_1) \\\\<br />\\mathrm{B}^\\prime = \\mathrm{B}_1 \\cdot \\mathrm{A}_1 + \\mathrm{B}_2 \\cdot \\mathrm{A}_2 \\cdot (1 - \\mathrm{A}_1) \\\\<br />\\mathrm{A}^\\prime = 1 - (1 - \\mathrm{A}_1) \\cdot (1 - \\mathrm{A}_2)<br />$$<br />其中$\\{\\mathrm{R}_1,\\;\\mathrm{G}_1,\\;\\mathrm{B}_1,\\;\\mathrm{A}_1\\}$是前景色，$\\{\\mathrm{R}_1,\\;\\mathrm{G}_1,\\;\\mathrm{B}_1,\\;\\mathrm{A}_1\\}$是后景色。<br />同时，这个公式可以实现颜色的叠加顺序不同，最终的结果也会有所不同。<br />向量与矩阵<br />Math.h & Math.cpp<br />这里不在介绍什么是向量和矩阵了，这里至介绍一下为什么要使用矩阵。<br />首先我们的可能需要缩放一个向量，这可以使用矩阵来表示：<br />$$<br />\\left[<br />\\begin{matrix}<br />S_X & 0 & 0 \\\\<br />0 & S_Y & 0 \\\\<br />0 & 0 & S_Z<br />\\end{matrix}<br />\\right]<br />\\cdot<br />\\left(<br />\\begin{matrix}<br />X \\\\<br />Y \\\\<br />Z<br />\\end{matrix}<br />\\right)<br />$$<br />如果是旋转，那么这样也可以（下面示例的是绕Z轴旋转）：<br />$$<br />\\left[<br />\\begin{matrix}<br />\\cos\\alpha & -\\sin\\alpha & 0 \\\\<br />\\sin\\alpha & \\cos\\alpha & 0 \\\\<br />0 & 0 & 1<br />\\end{matrix}<br />\\right]<br />\\cdot<br />\\left(<br />\\begin{matrix}<br />X \\\\<br />Y \\\\<br />Z<br />\\end{matrix}<br />\\right)<br />$$<br />对于绕X轴和绕Y轴的旋转可以类似的构造。<br />很多其它的线性变换都可以用矩阵来表示。当我们想进行多个变换的时候，我们可以使用矩阵乘法来变为一个矩阵，这样就加速了复杂的变换。<br />但是平移向量出了一点意外，因为3维的矩阵无法表示平移变化。<br />为了统一它们，平移变化被加上了一维，使用四维矩阵来表示之：<br />$$<br />\\left[<br />\\begin{matrix}<br />1 & 0 & 0 & D_X \\\\<br />0 & 1 & 0 & D_Y \\\\<br />0 & 0 & 1 & D_Z \\\\<br />0 & 0 & 0 & 1<br />\\end{matrix}<br />\\right] \\cdot<br />\\left(<br />\\begin{matrix}<br />X \\\\<br />Y \\\\<br />Z \\\\<br />1<br />\\end{matrix}<br />\\right)<br />$$<br />是不是非常巧妙？虽然向量和矩阵都变成了四维，但是这样我们就可以将所有的线性变换都用矩阵表示，并且可以利用矩阵乘法来加速变换。这也就是为什么矩阵在计算机图形学中十分重要的原因之一了。","tags": "RSRL","url": "blog/2016-11-6/rsrl-1.html"},
{"title": "ZY的核电站","text": "ZY的核电站 (nuclear.in/out/cpp)<br />时间限制: 5 s / 内存限制: 256 MB / 打开O2优化<br />题目描述<br /><br />“ZY喜欢玩核电站。”<br /><br />ZY的核电站非常特殊。早在2038年，ZY就发现了高分子有机物的完全裂解可以释放大量的核能的原理（这句话纯属FP）。因此ZY的核电站反应堆里面全是高分子有机物，可惜只有一个。<br />为了使发电量尽可能大，ZY找到了一种能使有机物完全裂解的方式，使释放出来的能量最大。由于这是ZY的有机物，因此裂解方式也非常奇葩。下面是ZY在2039年的论文《论ZY对MC1核电站的巨大贡献》中的节选片段：<br /><br />......<br />我们的有机物是由$n$个各种原子构成的，原子之间通过不同的共价键相连。<br /><br />($\\text{H}$太多了，到时候这些没用的氢原子都会被ZY丢掉)<br />......<br />为了方便进行裂解，这个有机物是没有环的，这样就可以节约成本来买**V*P***......<br />......<br />每次裂解都会断开一个共价键，此时这个有机物会分为两部分。并且释放大量的能量......<br />设放出的能量为$E$，有机物裂解后的两部分的共价键的集合分别为$A$和$B$，则：、<br />$$ E = \\sum_{a\\in A} a.\\text{energy} \\cdot \\sum_{b\\in B} b.\\text{energy} \\tag{ZY's energy theorem}$$<br />其中$\\text{energy}$表示共价键的能量。<br />......<br />为了充分利用有机物中的能量，每裂解一个共价键后，我们有办法无损耗无成本的将其还原，即有机物会变得和裂解前一样。但是出于种种原因，这个共价键就不能再次进行裂解了。除非ZY发出SB之神力来使所有的共价键复活......<br />......<br />那么，一个有机物完全裂解所能放出的能量为所有共价键裂解一次后所放出的能量之和。<br />......<br /><br />(实际上，ZY的这篇论文长达$2147483647$字)<br />当然，ZY的智商理论上为$-\\infty$。因此它的核电站其实非常辣鸡。反应堆中的有机物不一定是稳定的，但是ZY利用LCT算法以$O(\\infty!)$的时间复杂度内成功地保证了有机物的结构，这样就方便ZY发出SB之神力。但是令ZY想跳楼的是，总有一个共价键的能量在维护有机物结构时会变动。然而”机智”的ZY可以发现这些变化。<br />ZY只希望能够快速算出当前的有机物通过完全裂解究竟能放出多少能量。由于ZY的数学只有学前班水平，所以每当她算到一半时，这个有机物又开始乱搞了，ZY就只能用LCT来重新维护它。<br />一年之内，ZY的核电站什么电都没有发。为了快速计算，ZY找到了你这个**。<br />ZY希望你能给出一个好方法来帮助她计算当前有机物完全裂解能放出的能量。<br />输入格式<br />第$1$行输入两个正整数$n$，$m$。$n$表示有机物中原子的数量，$m$表示ZY维护有机物结构的次数。<br />接下来$n - 1$行描述一个有机物。对于每一行输入三个整数$u$，$v$和$e$，表示第$u$号原子和第$v$号原子之间以能量为$e$的共价键相连。<br />接下来$m$行，每一行描述一个共价键的键能变化。每行输入三个整数$u$，$v$和$e$，表示第$u$号原子和第$v$号原子之间的共价键的能量变为$e$。保证第$u$号原子和第$v$号原子之间存在共价键。<br />输出格式<br />对于每次共价键能量的变动，输出一行一个整数，表示键能改变后的有机物完全裂解能放出的能量。<br />输入样例<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />127 4<br />1 2 2<br />1 7 1<br />2 3 2<br />2 6 1<br />3 4 1<br />3 5 1<br /><br />1 2 2<br />1 2 3<br />2 3 3<br />1 2 0<br /><br /><br />输出样例<br />1<br />2<br />3<br />413<br />15<br />16<br />10<br /><br /><br />数据范围及提示<br />对于第一个询问:<br />裂解$1$和$2$之间的共价键: $1 \\times (2 + 1 + 1 + 1) = 5$<br />裂解$2$和$3$之间的共价键: $(2 + 1 + 1) \\times (1 + 1) = 8$<br />其余的共价键裂解得到的能量均为$0$。<br />因此答案为$13$。<br />对于$10\\% $的数据: $n \\le 1,000, \\; m \\le 5,000$<br />对于$10\\% $的数据: $n \\le 10,000, \\; m \\le 500,000$<br />对于$10\\% $的数据: $n \\le 100,000, \\; m \\le 100$<br />对于$10\\% $的数据: $n \\le 10,000, \\; m \\le 1,000,000$<br />对于另外$20\\% $的数据: 有机物没有支链。<br />对于$100\\% $的数据: $n \\le 200,000, \\; m \\le 1,000,000, \\; e \\le 10 $<br /><br /><br /><br /><br />ZY从不打摆。 ↩<br /><br /><br />","tags": "Problems ZY","url": "blog/2016-5-26/riteme.html"},
{"title": "x^n-1问题","text": "$x^n-1$问题<br />问题描述<br />请对下面的多项式$ A_n(x) $进行因式分解：<br />$$ A_n(x) = x^n - 1 \\tag{1}$$<br />其中，$ n \\in \\text{N}^* $。<br />分析<br />对于$ n = 1$的情况，我们无需分解。对于$n = 2 $的情况，我们可以分解为$ (x - 1)(x + 1) $。<br />如果次数更高，这个问题就比较棘手。<br />对于这个问题，我们有如下的定理：<br />$$ m \\mid n \\Longrightarrow (x^m - 1) \\mid (x^n - 1) \\tag{2}$$<br />这个定理可以用多项式除法来验证。<br />因此，我们为了分解$(1)$式，首先用$\\Theta(\\sqrt{n})$的时间对$n$进行分解质因数，从而能找到$(1)$的几个因式，然后原始就可以表示成几个形如$(x^a - 1)(x^b - 1) \\cdots (x^z - 1)$的形式，从而能够递归的继续分解。<br />然而我们需要注意一点：以$n=6$为例，$6$的因子有$1$、$2$、$3$和$6$。我们发现选择了$(x^6 - 1)$作为因式跟没选一样。然而选择其它的因子时发现更严重的问题：<br />$$ (x - 1) \\mid (x^3 - 1) \\Longrightarrow (x - 1) \\nmid {x^6 - 1 \\over x^3 - 1} $$<br />这样导致几个因子间会有冲突，因此我们无法直接选择因式。<br />为了解决这个问题，我们定义一系列的多项式$ p_n(x) $：<br />$$ p_n(x) = { x^n - 1 \\over \\prod_{i \\mid n}p_i(x)} \\; (i \\neq n) \\tag{3}$$<br />实际上，这些多项式只是将原本$ x^n - 1 $中的非本身因式去掉了，这样使得：<br />$$ (x - 1) \\mid {x^6 - 1 \\over p_3(x) } $$<br />因为<br />$$<br />{x^6 - 1 \\over p_3(x) } = {x^6 - 1 \\over {(x^3 - 1) / (x - 1)}} = (x - 1) \\cdot {x^6 - 1 \\over x^3 - 1}<br />$$<br />这样，我们可以将任意的$ A_n(x) $表示为如下形式：<br />$$ A_n(x) = \\prod_{i \\mid n} p_i(x) \\tag{4}$$<br />根据$(3)$式和$(4)$式，递推完$ p_n(x) $后，我们就可以将$ A_n(x) $中的每一项都求解出来。如果多项式除法的时间复杂度为$ \\Theta(g(n)) $，那么我们可以在$ \\Theta(n\\sqrt{n} \\cdot g(n)) + \\Theta(\\sqrt{n}) = \\Theta(n\\sqrt{n} \\cdot g(n))$的时间内对$ A_n(x) $进行因式分解。","tags": "数学 多项式","url": "blog/2016-3-21/x-2-1.html"},
{"title": "中国剩余定理 (CRT)","text": "中国剩余定理 (CRT)<br />玩一玩<br />找出所有$a$，使得满足下列关系式：<br />$$<br />\\begin{align}<br />a & \\equiv 3\\;(\\text{mod}\\;5) \\\\<br />a & \\equiv 2\\;(\\text{mod}\\;7)<br />\\end{align}<br />$$<br />通过暴力枚举，我们可以得知答案：<br />$$<br />a = 23 + 35k\\;(k \\in Z)<br />$$<br />简单形式<br />现在来考虑一个问题：<br /><br />证明：一定存在一个$a$，满足<br />$$a \\equiv a_1\\;(\\text{mod}\\;m) \\\\a \\equiv a_2\\;(\\text{mod}\\;n)$$<br />其中$m \\bot n$<br /><br />我们使用鸽巢原理来证明。<br />设有$n$个数模$m$等于$a_1$，这$n$个数是：<br />$$<br />a_1,\\;m + a_1,\\;2m + a_1,\\;\\dots,\\;(n - 1)m + a_1<br />$$<br />即设其中有两个数模$n$意义下同余，设它们为$im + a_1$和$jm + a_1$ ($i < j$)。<br />那么意味着：<br />$$<br />jm + a_1 = pn + r \\\\<br />im + a_1 = qn + r<br />$$<br />两式相减可得：<br />$$<br />(j - i)m = (p - q)n<br />$$<br />因为$p - q \\in Z$，所以$n \\mid (j - i)m$。<br />但是$m \\bot n$，且$0 \\lt j - i \\le n - 1$，所以$n \\not\\mid (j - i)m$，与之前的假设相矛盾。<br />故之前选出的$n$个数里面没有两个数在模$n$意义下同余。<br />那么这里面必定存在一个数模$n$余$a_2$。<br />中国剩余定理<br /><br />证明：存在一个数$x$，满足<br />$$x \\equiv a_1 \\; (\\text{mod}\\;m_1) \\\\x \\equiv a_2 \\; (\\text{mod}\\;m_2) \\\\\\dots \\\\x \\equiv a_k \\; (\\text{mod}\\;m_k)$$<br />其中$m_1,\\;m_2,\\;\\dots,\\;m_k$两两互质<br /><br />当然可以考虑两两合并的方式，并使用之前鸽巢原理的证法来证明。<br />当然我们考虑一种更具有价值的证法。<br />既然要证明其存在，不如直接构造一个答案：<br />首先设：<br />$$<br />M = \\prod_{j=1}^k m_j \\tag{2.1}<br />$$<br />是所有模数之积。<br />$$<br />M_i = {M \\over m_i} \\tag{2.2}<br />$$<br />是剔除掉某一个模数的积。<br />$$<br />C_i = M_i(M_i^{-1}\\;\\text{mod}\\;m_i) \\tag{2.3}<br />$$<br />则是一个神奇的数字。<br />由于$M_i$肯定与$m_i$互质，所以这个逆元是肯定能求出来的。<br />那么：<br />$$<br />x \\equiv \\sum_{i=1}^k a_iC_i \\; (\\text{mod}\\;M)<br />$$<br />接下来就是要证明这个数同时满足上面的方程。<br />首先注意到：<br />$$<br />m_i \\mid C_j \\Longrightarrow C_i \\equiv 0 \\; (\\text{mod}\\;m_i) \\;\\;\\; (i \\neq j)<br />$$<br />同时：<br />$$<br />C_i \\equiv M_i\\cdot M_i^{-1} \\equiv 1 \\; (\\text{mod}\\;m_i)<br />$$<br />于是：<br />$$<br />x \\equiv a_i \\; (\\text{mod} \\; m_i)<br />$$<br />因此这个数是满足要求的。<br />同时我们获得了中国剩余定理 (CRT) 的公式：<br />$$<br />x = \\sum_{i=1}^k a_i M_i(M_i^{-1}\\;\\text{mod}\\;m_i) \\tag{2.4}<br />$$<br />借助欧几里德算法，可以在$O(n\\log n)$的时间内计算答案。<br />应用<br />中国剩余定理一个最大的应用就是计算一些数在模一个合数下的取值。<br />例如，求大组合数取模：<br />$$<br />{n \\choose m} \\;\\text{mod}\\; p<br />$$<br />对于这个问题，如果$p$是质数且比较小，我们可以采用Lucas定理求解。<br />然而现在是合数。<br />我们考虑一种方案，将合数$p$进行质因数分解，这样就可以分解成多个质数，对于每一个质数，我们都有方法求解答案。这样对于每一个质数计算答案之后，我们得到了一个模线性方程组。<br />这样就变成了我们之前所讨论的问题。对于此，使用中国剩余定理，就可以合并答案。","tags": "数学 数论 中国剩余定理","url": "blog/2016-8-17/crt.html"},
{"title": "二进制GCD","text": "二进制GCD<br />在算导上发现了一个有趣的算法，有氧环境下可以拿来卡卡常.....<br />算法原理<br />下面将考虑计算$\\gcd(a,\\;b)$，假定$a \\ge b$：<br /><br />如果$a$、$b$都是偶数，那么易知：<br />$$<br />\\gcd(a,\\;b) = 2\\gcd(a / 2,\\;b / 2)<br />$$<br />如果$a$是偶数，$b$是奇数，那么有：<br />$$<br />\\gcd(a,\\;b) = \\gcd(a / 2, b)<br />$$<br />如果$a$是奇数，$b$是偶数，那么有：<br />$$<br />\\gcd(a,\\;b) = \\gcd(a,\\;b / 2)<br />$$<br />如果$a$、$b$都是奇数，那么有：<br />$$<br />\\gcd(a,\\;b) = \\gcd((a - b) / 2, b)<br />$$<br /><br />这些结论都是比较容易证明的，这里就略去了。<br />由于减法的速度比取模快 (减法速度基本与加法一致)，同时除以$2$和乘以$2$可以使用位运算来代替，并且每次折半可以保证复杂度，所以理论上这个算法是非常快的。<br />但是需要注意，欧几里德算法是上界$O(\\log(\\min\\{a,\\;b\\}))$，而此算法类似于快速幂，是上下界$\\Theta(\\log(\\min\\{a,\\;b\\}))$。<br />但这并不影响它的效率。在我的机子上 (使用Clang 3.6.0) 实测，在编译器打开-O2优化下比欧几里德算法快。<br />但是在没有开-O2优化时，因为常数问题速度变慢许多。<br />算法实现<br />下面展示一个基本实现：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15function BINARY-GCD(a, b):<br />    if a < b:  # 要保证 a >= b<br />        SWAP(a, b)<br />    if b == 0:<br />        return a<br />    if a & 1:<br />        if b & 1:<br />            return BINARY-GCD((a - b) >> 1, b)<br />        else:<br />            return BINARY-GCD(a, b >> 1)<br />    else:<br />        if b & 1:<br />            return BINARY-GCD(a >> 1, b)<br />        else:<br />            return BINARY-GCD(a >> 1, b >> 1) << 1<br /><br /><br />注意到欧几里德算法里面是尾递归，编译器可以依此做优化。<br />而上面给出的代码里面并不是这种形式。<br />但是我们可以稍微修改一下，就可以将其改为尾递归形式：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15function TAIL-BINARY-GCD(a, b, shift = 0):  # 记录一个shift表示答案乘了几个2<br />    if a < b:<br />        SWAP(a, b)<br />    if b == 0:<br />        return a << shift  # 将shift的记录的2算入答案<br />    if a & 1:<br />        if b & 1:<br />            return TAIL-BINARY-GCD((a - b) >> 1, b, shift)<br />        else:<br />            return TAIL-BINARY-GCD(a, b >> 1, shift)<br />    else:<br />        if b & 1:<br />            return TAIL-BINARY-GCD(a >> 1, b, shift)<br />        else:<br />            return TAIL-BINARY-GCD(a >> 1, b >> 1, shift + 1)  # 计数器加1<br /><br /><br />在编译器优化的帮助下，这份代码跑得更快。<br />此外，二进制GCD另一个巨大的优势就是在需要高精度的场合下，不但降低时间复杂度也减低了编程难度 (毕竟不需要高精度取模)，所以在这种情况下是一个非常好的算法。","tags": "数学 GCD","url": "blog/2016-8-19/binary-gcd.html"},
{"title": "二项式定理及其它","text": "二项式定理及其它<br />二项式定理<br />基本定理<br />二项式定理是用于展开两数相加的幂次的公式：<br />$$<br />(x + y)^n = \\sum_{k=0}^n {n \\choose k} x^k y^{n-k} \\tag{1.1}<br />$$<br />我们可以考虑使用组合证明。由于我们可以从$n$个括号中任意选取$k$个来组成$x^k$的项，这个方案数恰好是${n \\choose k}$，剩下的$y$也是同理。因此对应的项的系数就是${n \\choose k}$或${n \\choose n - k}$。<br />下面使用归纳法证明：<br />当$n = 1$的时候：<br />$$<br />(x + y)^1 = x + y = \\sum_{k=0}^1 {1 \\choose k} x^ky^{1-k}<br />$$<br />结论显然成立。<br />假设对$n$成立，求证对$n + 1$成立：<br />$$<br />\\begin{align}<br />(x + y)^{n+1} & = (x + y)(x + y)^n \\\\<br />& = (x + y)\\sum_{k=0}^n {n \\choose k} x^ky^{n-k} \\\\<br />& = \\sum_{k=0}^n {n \\choose k} x^{k+1}y^{n-k} + \\sum_{k=0}^n {n \\choose k} x^ky^{n-k+1} \\\\<br />& = x^{n+1} + y^{n+1} + \\sum_{k=0}^{n-1} {n \\choose k} x^{k+1}y^{n-k} + \\sum_{k=1}^n {n \\choose k} x^ky^{n-k+1} \\\\<br />& = x^{n+1} + y^{n+1} + \\sum_{k=1}^{n} {n \\choose k - 1} x^{k}y^{n-k+1} + \\sum_{k=1}^n {n \\choose k} x^ky^{n-k+1} \\\\<br />& = x^{n+1} + y^{n+1} + \\sum_{k=1}^n \\left[{n \\choose k - 1}+{n \\choose k}\\right] x^ky^{n-k+1} \\\\<br />& = x^{n+1} + y^{n+1} + \\sum_{k=1}^n {n+1 \\choose k} x^ky^{n-k+1} \\\\<br />& = \\sum_{k=0}^{n+1} {n+1 \\choose k} x^ky^{n-k+1} \\\\<br />\\end{align}<br />$$<br />这样就完成了我们的证明。<br />简单运用<br />组合恒等式<br />将$y = 1$，我们将得到一个很常用的式子：<br />$$<br />(1 + x)^n = \\sum_{k=0}^n {n \\choose k} x^k \\tag{1.2}<br />$$<br />令$x = 1$:<br />$$<br />\\sum_{k=0}^n {n \\choose k} = (1 + 1)^n = 2^n \\tag{1.3}<br />$$<br />得到了组合数之和，<br />令$x = -1$:<br />$$<br />\\sum_{k=0}^n (-1)^k {n \\choose k} = 0 \\tag{1.4}<br />$$<br />得到了组合数的交错和。<br />通过移项可以得到更进一步的结论：:<br />$$<br />{n \\choose 0} + {n \\choose 2} + \\dots = {n \\choose 1} + {n \\choose 3} + \\dots \\tag{1.5}<br />$$<br />结合$(1.3)$可知：<br />$$<br />{n \\choose 0} + {n \\choose 2} + \\dots = {n \\choose 1} + {n \\choose 3} + \\dots = 2^{n-1} \\tag{1.6}<br />$$<br />导数<br />现在我们重新考虑这个式子：<br />$$<br />(1 + x)^n = \\sum_{k=0}^n {n \\choose k} x^k \\tag{1.2}<br />$$<br />两边同时关于$x$求导：<br />$$<br />n(1 + x)^{n-1} = \\sum_{k=0}^n {n \\choose k} \\cdot kx^{k-1} \\tag{1.7}<br />$$<br />令$x = 1$：<br />$$<br />n2^{n-1} = \\sum_{k=0}^n k{n \\choose k} \\tag{1.8}<br />$$<br />这样我们得到了一个非常有意思的式子。<br />运用这个式子，我们可以算出：<br />$$<br />\\sum_{k=0}^n (2k+1){n \\choose k} = (n+1)2^n<br />$$<br />事实上，你还可以对$(1.8)$进一步求导，从而得到$k^2$的公式。<br />组合数的平方和<br />$$<br />\\sum_{k=0}^n {n \\choose k}^2 = {2n \\choose n} \\tag{1.9}<br />$$<br />对于这个结论，我们考虑下面的式子：<br />$$<br />(1 + x)^n(1+x)^n = (1+x)^{2n}<br />$$<br />运用二项式定理展开可得：<br />$$<br />\\begin{align}<br />\\sum_{i=0}^n {n\\choose i} x^i \\cdot \\sum_{j=0}^n {n\\choose j} x^j & = \\sum_{i=0}^n\\sum_{j=0}^n {n \\choose i}{n \\choose j} x^ix^j \\\\<br />& = \\sum_{k=0}^{2n} {2n \\choose k} x^k<br />\\end{align}<br />$$<br />考虑等号两边系数同为$k$的项，一定满足下面的等式：<br />$$<br />\\sum_{i=0}^n {n \\choose i}{n \\choose k - i} = {2n \\choose k} \\tag{1.10}<br />$$<br />当$k = n$时：<br />$$<br />\\begin{align}<br />\\sum_{i=0}^n {n \\choose i}{n \\choose n - i} & = \\sum_{i=0}^n {n \\choose i}{n \\choose i} \\\\<br />& = \\sum_{i=0}^n {n \\choose i}^2 \\\\<br />& = {2n \\choose n}<br />\\end{align}<br />$$<br />这样就证明了组合数的平方和的结论。<br />二项式定理与$\\text{e}$<br />根据泰勒展开，我们可以知道：<br />$$<br />\\text{e}^x = \\sum_{n=0}^\\infty \\frac{x^n}{n!} \\tag{1.11}<br />$$<br />令$x = 1$就可以得到$\\text{e}$的无穷展开形式：<br />$$<br />\\text{e} = \\sum_{k=0}^\\infty \\frac1{k!} \\tag{1.12}<br />$$<br />而我们平常所熟知的$\\text{e}$的定义是这样的：<br />$$<br />\\text{e} = \\lim_{n \\rightarrow \\infty} \\left(1 + \\frac1n\\right)^n \\tag{1.13}<br />$$<br />运用二项式定理可以证明泰勒展开的结果与上面的定义等价：<br />$$<br />\\begin{align}<br />\\text{e} & = \\lim_{n\\rightarrow\\infty} \\left(1 + \\frac1n\\right)^n \\\\<br />& = \\lim_{n\\rightarrow\\infty} \\sum_{k=0}^n {n \\choose k} \\frac1{n^k} \\\\<br />& = \\lim_{n\\rightarrow\\infty} \\sum_{k=0}^n \\frac1{k!} \\frac{\\prod_{i=n-k+1}^n i}{n^k}<br />\\end{align}<br />$$<br />由于：<br />$$<br />\\lim_{n \\rightarrow \\infty} \\frac{\\prod_{i=n-k+1}^n i}{n^k} = 1<br />$$<br />所以这一项可以去掉。于是就得到了泰勒展开的结果。<br />多项式定理<br />与二项式定理，这个定理并不怎么常用。<br />可能是形式比较复杂，不便于理论分析。<br />多项式定理是二项式定理的扩展：<br />$$<br />(x_1 + x_2 + \\dots + x_m)^n = \\sum_{k_1 + k_2 + \\dots + k_m = n} {n \\choose k_1\\;k_2\\;\\dots\\;k_m} x_1^{k_1}x_2^{k_2}\\cdots x_m^{k_m} \\tag{2.1}<br />$$<br />其中：<br />$$<br />{n \\choose k_1\\;k_2\\;\\dots\\;k_m} = {n! \\over k_1!k_2!\\cdots k_m!}<br />$$<br />是多项式系数，同时也是多重集合的全排列数量。<br />组合证明方法与二项式定理类似。同时也可以从二项式定理归纳法而来。<br />牛顿二项式定理<br />牛顿二项式定理又称为广义二项式定理：<br />$$<br />(x + y)^\\alpha = \\sum_{k=0}^\\infty {\\alpha \\choose k} x^ky^{\\alpha - k} \\;\\;\\; (\\alpha \\in R,\\;\\color{red}{0 \\le \\;\\mid x\\mid\\; \\lt \\;\\mid y\\mid}) \\tag{3.1}<br />$$<br />注意红色的字，这是非常重要的限制。<br />其中：<br />$$<br />{\\alpha \\choose k} = {\\prod_{i=\\alpha - k +1}^\\alpha i \\over k!}<br />$$<br />是在实数域的二项式系数。<br />不会那么高深的高数知识，不会证......<br />基本用途<br />这种形式并不常用，而另外一种形式很常用：<br />令$z = x/y$，那么$\\color{red}{\\mid z\\mid \\;\\lt 1}$：<br />$$<br />(x + y)^\\alpha = y^\\alpha(z + 1)^\\alpha<br />$$<br />所以：<br />$$<br />\\begin{align}<br />(z + 1)^\\alpha & = \\sum_{k=0}^\\alpha {\\alpha \\choose k} {x^ky^{\\alpha-k} \\over y^\\alpha} \\\\<br />& = \\sum_{k=0}^\\alpha {\\alpha \\choose k} {x^k \\over y^k}\\cdot{y^{\\alpha-k} \\over y^{\\alpha-k}} \\\\<br />& = \\sum_{k=0}^\\alpha {\\alpha \\choose k} z^k \\\\<br />& = (1 + z)^\\alpha<br />\\end{align}<br />\\tag{3.2}<br />$$<br />几何级数<br />令$\\alpha = -n \\; (n \\in Z)$：<br />$$<br />{\\alpha \\choose k} = {-n \\choose k} = (-1)^k{n + k - 1 \\choose k}<br />$$<br />所以：<br />$$<br />\\frac1{(1+z)^n} = \\sum_{k=0}^\\infty (-1)^k{n + k - 1 \\choose k} z^k<br />$$<br />令$z = -z$：<br />$$<br />\\frac1{(1-z)^n} = \\sum_{k=0}^\\infty {n+k-1 \\choose k}z^k<br />$$<br />妙啊！讨厌的$-1$不见了！<br />令$n=1$：<br />$$<br />\\frac1{1-z} = \\sum_{k=0}^\\infty z^k<br />$$<br />正是收敛几何级数。<br />这东西在生成函数里面很常见。<br />看生成函数之前一定要学好牛顿二项式定理和泰勒展开QAQ。<br />现在我们来求一下有限几何级数的公式。<br />注意$\\mid z \\mid \\;\\lt 1$：<br />$$<br />\\begin{align}<br />\\sum_{k=0}^n z^k & = \\sum_{k=0}^\\infty z^k - \\sum_{k=n+1}^\\infty z^k \\\\<br />& = \\sum_{k=0}^\\infty z^k - z^{n+1}\\sum_{k=0}^\\infty z^k \\\\<br />& = (1 - z^{n+1}) \\sum_{k=0}^\\infty z^k \\\\<br />& = {1 - z^{n+1} \\over 1-z}<br />\\end{align}<br />\\tag{3.3}<br />$$<br />开根运算<br />之前取$\\alpha = -n$，从而解决了几何级数的问题。<br />现在取$\\alpha = 1/2$，就可以将求平方根变成一个迭代的形式。<br />并且可以求任意幂次、任意精度的结果。<br />由于$z$有限制，因此需要提项，如：<br />$$<br />\\sqrt{20} = \\sqrt{16+4} = 4\\sqrt{1 + 0.25}<br />$$<br />这样我们就获得了一个求根号的好方法。","tags": "数学 组合数学 二项式定理 多项式定理 牛顿二项式定理","url": "blog/2016-8-18/binomial.html"},
{"title": "伪代码规定","text": "伪代码规定<br />最近博客上的伪代码越写越乱了，是时候好好定一下了。<br />参考了《算法导论》的伪代码风格，杂揉一些Python的写法。<br />注释<br />//后的所有内容都是注释。<br />1// 这是注释<br /><br /><br />变量<br />以单个字符为主，小写字母可以有多个，大写字母最好只有1个。<br />变量的属性用.操作符来访问。<br />这里的变量实际上都是对实体的一个引用，类似于C++中的指针。<br />1<br />2<br />3<br />4<br />5<br />6<br />7a = 1  // 第一次声明a<br />b = 2  // 第一次声明b<br />a = b  // a绑定到b上，即a和b指向同一实体<br />a = COPY(b)  // 将b的值复制到a<br />a = DEEPCOPY(b)  // 深度复制，将b中所有的引用全部复制。<br />a.name = \"233\"  // 属性的设定<br />b.name = a.name  // 属性的访问与设定<br /><br /><br />函数<br />函数的声明以function开始。<br />函数名称最好全部大写，如果有多个词语用-分开。<br />函数名后面带一个元组，表示参数。<br />return语句用来返回函数值。如果没有return，那么实际返回nil。<br />1<br />2<br />3<br />4function ADD-TWO-NUMBERS(a, b):<br />    return a + b<br /><br />c = ADD-TWO-NUMBERS(1, 2)  // c = 3<br /><br /><br />操作符<br />=: 赋值，在if中表示判断是否相等<br /><: 小于<br />>: 大于<br /><=: 不大于<br />>=: 不小于<br />+: 加号<br />-: 减号<br />*: 乘号<br />**: 幂运算<br />/: 除号<br />mod: 取模<br />~: 按位取反<br />&: 按位与<br />|: 按位或<br />^: 按位异或<br /><<: 按位左移<br />>>: 按位右移<br />not: 逻辑反<br />and: 逻辑且<br />or: 逻辑或<br />xor: 逻辑异或<br />条件控制语句<br />if<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8if statement:<br />    // 如果为真<br />else if statement2:<br />    // ...<br />else if statement3:<br />    // ...<br />else:<br />    // ...<br /><br /><br />while<br />1<br />2while condition:<br />    // ...<br /><br /><br />for<br />for的形式可以多样。条件可以用陈述句。<br />1<br />2for i = 0 to 100 step 2:  // i从0到100，每次加2。<br />    // ...<br /><br /><br />foreach可以以不定的顺序遍历集合内的所有元素。<br />1<br />2foreach a in A:<br />    // ...<br /><br /><br />对于诸如1到100的遍历，可以使用定义域。<br />1<br />2foreach i in [1, 100]:<br />    // ...<br /><br /><br />内置类型<br />nil: 表示不存在的值<br />Number: 表示实数<br />String: 表示字符串，用\"\"表示<br />Boolean: 表示布尔值，只有true和false<br />Byte: 表示一个字节(通常为8bit)，允许使用16进制和2进制，16进制以#开始。<br />Set: 表示集合，用{}表示。<br />所有的类型后加上[]表示该类型的数组类型。<br />对于元组，使用()来表示。<br />内置函数或语句<br />ASSERT statement: 断言，如果不为真则报错。<br />SWAP(a, b): 交换两者的引用。<br />delete a: 删除a这一引用<br />以及各种数学函数<br />元组<br />使用小括号来声明元组。<br />1<br />2(a, )  // 如果只有一个元素，则需要带上一个额外的逗号。<br />(a, b, c)  // 三元组<br /><br /><br />元组可以裂解。<br />1a, b = (1, 2)  // a = 1, b = 2<br /><br /><br />构成元组的方式也可以随意。<br />1a, b = b, a  // 此乃SWAP的实现<br /><br /><br />如果遇到极端情况…<br />如果上面的规定不能满足表达算法的需要，那么有两种解决方法：<br /><br />从其它的语言借点语法过来，别人看得懂就行。<br />使用陈述句。<br /><br />记住，如果解决不了时，就用陈述句。","tags": "伪代码","url": "blog/2016-4-23/fake-code.html"},
{"title": "位运算卷积与FWT","text": "位运算卷积与FWT<br />几行代码里隐藏数学真是高深莫测，只有勇者才能够发现这绝妙的规律。<br />位运算卷积<br />普通的卷积 (即多项式乘法) 是这个样子：<br />$$<br />C_i = \\sum_{j + k = i} A_j \\cdot B_k \\;\\;\\;\\;\\forall \\; j, k \\in [0, n)<br />\\tag{1.1}<br />$$<br />而位运算卷积就是将加号变为了二元位运算，就是这样：<br />$$<br />C_i = \\sum_{j \\oplus k = i} A_j \\cdot B_k \\;\\;\\;\\;\\forall \\; j, k \\in [0, n)<br />\\tag{1.2}<br />$$<br />其中$\\oplus$指代任意二元位运算符号，如异或 (就是记做$\\oplus$)、与运算 ($\\land$) 和或运算 ($\\lor$) 等等。<br />注意到，在多项式乘法中，如果两个多项式的界为$A$和$B$，那么答案的界就是$A + B - 1$。而在位运算卷积中，却是$2^{\\left\\lceil\\log_2\\max\\{A,B\\}\\right\\rceil}$。而且对于两个输入向量而言，末尾添加几个$0$是不会对答案产生影响的1。因此，像在快速傅里叶变换中一样，假定输入的向量大小一致且均为$2$的幂，设这个大小为$n$。<br />特殊情况<br />为了探寻规律，我们以异或为例，手动计算一下$n$很小时的情况。<br />$n = 2^0$<br />当输入两个数时，结果会是一个数。由于$0 \\oplus 0 = 0$，所以：<br />$$<br />C_0 = A_0 \\cdot B_0<br />\\tag{2.1}<br />$$<br />So easy, 也没什么意思。<br />$n = 2^1$<br />输入两个二元组$A = (a_0, a_1)$和$B = (b_0, b_1)$。得到的结果$C$是：<br />$$<br />C = (a_0 b_0 + a_1 b_1, a_0 b_1 + a_1 b_0)<br />\\tag{2.2}<br />$$<br />不如大胆的尝试一下，能否通过某种变换，从而能够使用更简单的点积来计算呢，就像下面这个样子：<br />$$<br />TA \\cdot TB = TC<br />\\tag{2.3}<br />$$<br />这里$T$表示变换，同时他还需要一个逆变换从而使得我们能够得到$C$。我们可以从线性代数的角度来考虑这个问题，那么我们希望$T$能够是一个线性变换，这样我们就可以用矩阵来表示之。<br />那么意味着我们要找到一个矩阵$T$，满足：<br />$$<br />T<br />\\left[<br />\\begin{matrix}<br />a_0 \\\\<br />a_1<br />\\end{matrix}<br />\\right]<br />\\cdot<br />T<br />\\left[<br />\\begin{matrix}<br />b_0 \\\\<br />b_1<br />\\end{matrix}<br />\\right]<br />=<br />T<br />\\left[<br />\\begin{matrix}<br />a_0 b_0 + a_1 b_1 \\\\<br />a_0 b_1 + a_1 b_0<br />\\end{matrix}<br />\\right]<br />\\tag{2.4}<br />$$<br />首先这个线性变换只在二维向量空间上进行的，所以$T$应该是一个$2 \\times 2$的矩阵，于是设：<br />$$<br />T =<br />\\left[<br />\\begin{matrix}<br />m & n \\\\<br />p & q<br />\\end{matrix}<br />\\right]<br />\\tag{2.5}<br />$$<br />那么之前是一个两个向量的点积式，于是我们可以列出两个方程来表示：<br />$$<br />\\begin{cases}<br />\\begin{aligned}<br />(ma_0 + na_1)(mb_0 + nb_1) & = m(a_0 b_0 + a_1 b_1) + n(a_0 b_1 + a_1 b_0) \\\\<br />(pa_0 + qa_1)(pb_0 + qb_1) & = p(a_0 b_0 + a_1 b_1) + q(a_0 b_1 + a_1 b_0)<br />\\end{aligned}<br />\\end{cases}<br />\\tag{2.6}<br />$$<br />于是你发现第一个方程和第二方程没有区别......好吧，那就只研究第一个方程，将其暴力拆开是这样的：<br />$$<br />m^2a_0 b_0 + mna_0 b_1 + mna_1 b_0 + n^2a_1 b_1 = ma_0 b_0 + na_0 b_1 + na_1 b_0 + ma_1 b_1<br />\\tag{2.7}<br />$$<br />一个二元一次方程，有很多解了啦，但是我们只需要一个。最简单的解法2就是对应的项的系数相同。<br />也就是说：<br />$$<br />m^2 = m \\Longrightarrow m = 1<br />\\tag{2.8}<br />$$<br />然后就是：<br />$$<br />n^2 = 1 \\Longrightarrow n = \\pm 1<br />\\tag{2.9}<br />$$<br />然后发现$n$的这两个取值都可以满足$mn = n$。那么对于$p$和$q$是同理的，因此$T$的一种形式是这样的：<br />$$<br />\\left[<br />\\begin{matrix}<br />1 & \\pm 1 \\\\<br />1 & \\pm 1 \\\\<br />\\end{matrix}<br />\\right]<br />\\tag{2.10}<br />$$<br />不过我们不能够全部填$1$，因为我们在一开始的要求是$T$要有逆变换，但是全是$n = q$的矩阵不满秩，所以没有逆矩阵。因此，我们只有两种选择。<br />对于其逆矩阵，我在这里帮你们算出来了：<br />$$<br />\\left[<br />\\begin{matrix}<br />1 & -1 \\\\<br />1 & 1 \\\\<br />\\end{matrix}<br />\\right]^{-1}<br />=<br />\\left[<br />\\begin{matrix}<br />0.5 & 0.5 \\\\<br />-0.5 & 0.5 \\\\<br />\\end{matrix}<br />\\right] \\\\<br />\\left[<br />\\begin{matrix}<br />1 & 1 \\\\<br />1 & -1 \\\\<br />\\end{matrix}<br />\\right]^{-1}<br />=<br />\\left[<br />\\begin{matrix}<br />0.5 & 0.5 \\\\<br />0.5 & -0.5 \\\\<br />\\end{matrix}<br />\\right]<br />\\tag{2.11}<br />$$<br />实在记不住就爆枚一下矩阵吧，这样的$\\pm 1$矩阵没几个，试一试就好......<br />$n = 2^m \\;\\; (m \\geqslant 2)$<br />现在来考虑更复杂的情况。<br />跟前面一样的思想，我们企图找到$T_m$，满足：<br />$$<br />T_mA \\cdot T_mB = T_mC<br />\\tag{2.12}<br />$$<br />我们已经知道$T_0 = 1$并且求出了$T_1$。<br />基于这样一个事实：<br />$$<br />a \\oplus b = c \\Longrightarrow<br />a[i] \\oplus b[i] = c[i]<br />\\tag{2.13}<br />$$<br />这里$a[i]$表示$a$的二进制表示中的第$i$位。这说明二进制运算有一个重要的性质就是其每一位可以分开运算。<br />这有什么好处呢？我们先考虑最高位，这样将输入向量分为两部分：<br />$$<br />A = (A_0, A_1) \\\\<br />B = (B_0, B_1)<br />\\tag{2.14}<br />$$<br />下标为$0$的表示最高位为$0$，下标为$1$的表示最高位为$1$。实际上，就是将向量切成了两半。<br />对于结果$C = (C_0, C_1)$而言，在不考虑最高位的情况下，$A_0$、$A_1$、$B_0$和$B_1$任意求卷积都是可以对$C_0$和$C_1$有贡献的 (卷积后一个向量加法累计贡献)。但是此处我们需要考虑最高位，那么就会有一定的限制，也就是下标的运算结果的限制。<br />不难发现，这实际上退化为了$n = 2$的情况，这里用之前的方法来表示：<br />$$<br />T_1<br />\\left[<br />\\begin{matrix}<br />T_{m-1} A_0 \\\\<br />T_{m-1} A_1<br />\\end{matrix}<br />\\right]<br />\\cdot<br />T_1<br />\\left[<br />\\begin{matrix}<br />T_{m-1}B_0 \\\\<br />T_{m-1}B_1<br />\\end{matrix}<br />\\right]<br />=<br />T_1<br />\\left[<br />\\begin{matrix}<br />T_{m-1}C_0 \\\\<br />T_{m-1}C_1<br />\\end{matrix}<br />\\right]<br />\\tag{2.15}<br />$$<br />对于逆变换也是一样。<br />于是可以得知：<br />$$<br />T_m = T_1<br />\\left[<br />\\begin{matrix}<br />T_{m-1} \\\\<br />T_{m-1}<br />\\end{matrix}<br />\\right]<br />\\tag{2.16}<br />$$<br />但实际上已经没有意义啦！因为$(2.15)$就是一个分治计算的过程，并且它的复杂度是：<br />$$<br />T(n) = 2T(n / 2) + \\Theta(n) = \\Theta(n\\log n)<br />\\tag{2.17}<br />$$<br />于是我们获得了FWT算法！<br />FWT算法<br />前面BB了一大段，现在来梳理一下：<br /><br />我们计算$TA$和$TB$。<br />然后答案就是$T^{-1}(TA \\cdot TB)$。<br /><br />如何计算$TA$和$T^{-1}A$？根据$(2.15)$式，我们先要按最高位分成两个向量，对于每一个子向量，递归计算其经过变换后的结果。然后根据$T_1$来合并结果。<br />以异或运算为例，假设我们钦定了使用这个矩阵作为我们的变换：<br />$$<br />T = <br />\\left[<br />\\begin{matrix}<br />1 & 1 \\\\<br />1 & -1 \\\\<br />\\end{matrix}<br />\\right]<br />\\tag{3.1}<br />$$<br />那么合并的过程就是这样3：<br />$$<br />A = (TA_0 + TA_1, TA_0 - TA_1)<br />\\tag{3.2}<br />$$<br />你只用按照矩阵的形式来计算就可以了。<br />对于逆变换，就是这样合并：<br />$$<br />A = \\left({TA_0 + TA_1 \\over 2}, {TA_0 - TA_1 \\over 2}\\right)<br />\\tag{3.3}<br />$$<br />具体实现<br />为了方便理解，在这里给出用Python编写的FWT算法，依然是异或的例子。<br />递归形式<br />递归形式简单粗暴，容易编写。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43import numpy<br /><br />def fwt(X):<br />    \"\"\"正变换，返回TX<br />    X: 输入向量<br />    \"\"\"<br /><br />    if len(X) == 1:<br />        return X<br /><br />    m = len(X) // 2<br />    A0 = fwt(X[:m])<br />    A1 = fwt(X[m:])<br />    return numpy.array(*(A0 + A1), *(A0 - A1))<br /><br />def rfwt(X):<br />    \"\"\"逆变换，返回T^{-1}X<br />    X: 输入向量<br />    \"\"\"<br /><br />    if len(X) == 1:<br />        return X<br /><br />    m = len(X) // 2<br />    A0 = rfwt(X[:m])<br />    A1 = rfwt(X[m:])<br />    return numpy.array(*((A0 + A1) / 2), *((A0 - A1) / 2))<br /><br />def product(A, B):<br />    \"\"\"计算卷积<br />    A, B: 输入向量<br />    \"\"\"<br /><br />    TA = fwt(A)<br />    TB = fwt(B)<br />    TC = TA * TB<br />    return rfwt(TC)<br /><br /># 调用<br />print(product(<br />    numpy.array([1, 2, 3, 4]),<br />    numpy.array([2, 3, 3, 3])<br />))  # [29, 28, 27, 26]<br /><br /><br />迭代形式<br />与快速傅里叶变换类似，FWT也可以改写为迭代的版本，具体的原理可以参见快速傅里叶变换的实现：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28import copy<br />import numpy<br /><br />def iterative_fwt(X):<br />    A = copy.deepcopy(X)<br />    s = 2<br />    while s <= len(X):<br />        for i in range(0, len(X), s):<br />            for j in range(0, s // 2):<br />                tmp = A[i + j]<br />                A[i + j] += A[i + j + s // 2]<br />                A[i + j + s // 2] = tmp - A[i + j + s // 2]<br />        s *= 2<br /><br />    return A<br /><br />def iterative_rfwt(X):<br />    A = copy.deepcopy(X)<br />    s = 2<br />    while s <= len(X):<br />        for i in range(0, len(X), s):<br />            for j in range(0, s // 2):<br />                tmp = A[i + j]<br />                A[i + j] = (A[i + j] + A[i + j + s // 2]) / 2<br />                A[i + j + s // 2] = (tmp - A[i + j + s // 2]) / 2<br />        s *= 2<br /><br />    return A<br /><br /><br />当然这里给出版本不是常数上效率最高的，大家可以根据实际情况改写代码。<br />其他的位运算<br />之前一直在讨论异或，没有关注与运算和或运算。因为它们的推导过程是一样的。这里就不重复其过程了。<br />对于与运算而言：<br />$$<br />T = <br />\\left[<br />\\begin{matrix}<br />1 & 0 \\\\<br />1 & 1 \\\\<br />\\end{matrix}<br />\\right] \\\\<br />T^{-1} = <br />\\left[<br />\\begin{matrix}<br />1 & 0 \\\\<br />-1 & 1 \\\\<br />\\end{matrix}<br />\\right]<br />\\tag{5.1}<br />$$<br />对于或运算而言：<br />$$<br />T = <br />\\left[<br />\\begin{matrix}<br />1 & 1 \\\\<br />0 & 1 \\\\<br />\\end{matrix}<br />\\right] \\\\<br />T^{-1} = <br />\\left[<br />\\begin{matrix}<br />1 & -1 \\\\<br />0 & 1 \\\\<br />\\end{matrix}<br />\\right]<br />\\tag{5.2}<br />$$<br />实现它们的位运算卷积就只用修改合并的过程即可。<br /><br /><br /><br /><br />当然需要保证添加完$0$后结果的界不变。数值上不会有影响。 ↩<br /><br /><br />为什么不直接将$m$和$n$设为$0$？因为那样太naive了，你得到的$T$是零矩阵。 ↩<br /><br /><br />由于我们已经得到了矩阵，所以这个变换是线性变换，你可以有其它的写法。 ↩<br /><br /><br />","tags": "位运算卷积 FWT","url": "blog/2016-11-25/fwt.html"},
{"title": "凸包相关","text": "凸包相关<br />定义<br />通常说的凸包是指一个点集的凸包，并且是指在二维平面上1。这种凸包本身是一个凸多边形，由点集中的点构成，并且要求凸包上的点尽可能少。下面是一个凸包的示例：<br /><br />对于其它的图形，也可以有凸包，如线段的凸包：<br /><br />实际上线段的凸包就是所有线段的端点的凸包。更一般的，多边形的凸包就是所有多边形的顶点的凸包。<br />而曲线图形的凸包则没有这么简单，从圆的凸包就可见一窥：<br /><br />下面的文章将不讨论与曲线相关的凸包。<br />特别的，当点集里只有两个点时，凸包退化为一条线段。只有一个点时，退化为一个点。<br />同时需要注意多点共线和多点重合而导致的凸包退化现象。<br />构造算法<br />在计算几何里面，计算凸包就跟排序一样十分经典，至今已经研究出了许多算法。它们中的绝大部分可以在维基百科上看到，这里只介绍Javis步进法、水平扫描线法和Graham扫描法。<br />Jarvis步进法 (Gift Wrapping)<br />Jarvis步进法可以看作是给点集包上包装纸，最后算出凸包的。算法过程非常简单：<br /><br />找出最左下和最右上的两个点，记为$p_1$、$p_2$，它们一定是凸包上的点。<br />设$p_1$为当前点，每次从剩下的点中找出以当前点为原点极角最小的点，将其加入凸包，并设为当前点。重复这一步骤，直到遇到$p_2$。这样完成了凸包右边的构造。<br />与第二步相似，构造凸包的左边（每一步寻找极角最大的点）。<br /><br />以下面的点集为例：<br /><br />首先找到左下和右上两个点：<br /><br />构建右凸包：<br /><br /><br />构建左凸包：<br /><br /><br /><br />至此，凸包构建完毕。<br />由于Jarvis步进法中凸包每一个点都需要对剩下的点进行处理，所以该算法的时间复杂度为$\\Theta(nh)$，其中$h$是凸包的规模。最坏情况下为$\\Theta(n^2)$。由于当点在一个有限矩形内随机分布时凸包的期望规模为$O(\\log n)$，所以在这种情况下，该算法的时间复杂度为$O(n\\log n)$。<br />下面是其伪代码：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45<br />46<br />47<br />48function JARVIS(Q):  # Q是点集<br />    if |Q| <= 3:  # 点数不大于3<br />        return Q<br /><br />    p1, p2 = nil<br />    for p in Q:<br />        if p1 == nil or ( p.y < p1.y or p.y == p1.y and p.x < p1.x ):<br />            p1 = p<br />        if p2 == nil or ( p.y > p2.y or p.y == p2.y and p.x < p2.x ):<br />            p2 = p<br /><br />    # 使用叉积来比较极角大小<br />    CH = [p1, p2]  # 凸包<br />    Q.pop(p1, p2)  # 删除p1, p2<br /><br />    # 右凸包<br />    x = p1<br />    while true:<br />        y = Q[0]<br />        for p in Q[1:]:<br />            if cross(y - x, p - x) < 0 or<br />               cross(y - x, p - x) == 0 and |y - x| < |p - x|:  # 共线<br />                y = p<br /><br />        if y == p2:<br />            break<br /><br />        CH.append(y)<br />        Q.pop(y)<br />        x = y<br /><br />    # 左凸包<br />    x = p1<br />    while true:<br />        y = Q[0]<br />        for p in Q[1:]:<br />            if cross(y - x, p - x) > 0 or<br />               cross(y - x, p - x) == 0 and |y - x| < |p - x|:  # 共线<br />                y = p<br /><br />        if y == p2:<br />            break<br /><br />        CH.append(y)<br />        Q.pop(y)<br />        x = y<br /><br />    return CH<br /><br /><br />水平扫描线法<br />计算几何中，扫描线是一种常用的方法。我们也可以使用扫描线来计算凸包。<br />我们可以从左至右扫描每一个点来更新凸包。可以确定，最左边和最右边的点都是凸包上的点。因此利用扫描线来分别计算上下凸包。<br />算法步骤如下：<br /><br />将所有点按照$x$排序。<br />对于每一组$x$相同的点，仅保留$y$值最大和最小的点。<br />取出最左和最右作为基点，用于判断其它的点是在上凸包还是下凸包。<br />从左至右扫描每一个点，根据基点利用叉积计算该点是应插入上凸包还下凸包，将其插入对应的凸包中。然后从这个点开始向前访问，如果和之前的点形成内凹的形状（可以利用叉积判断），就将之前的点删除。直到不存在这样的形状为止。<br /><br />下面展示了一个水平扫描线的示例：<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />开始从上凸包中删除点：<br /><br /><br /><br /><br /><br />由于每个点只会被访问1次，点在栈中只会被弹出一次，所以扫描线的部分是$\\Theta(n)$的。但排序需要$O(n\\log n)$的时间，所以总复杂度是$O(n\\log n)$的。是一个非常不错的算法。<br />伪代码如下：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28function SCANLINE(Q):<br />    if |Q| <= 3:<br />        return Q<br /><br />    sort Q by order of x<br />    foreach x keeps the highest and lowest points<br /><br />    p1, p2 = Q[0], Q[-1]<br />    CH1 = []<br />    CH2 = []<br />    for p in Q:<br />        if p == p1:  # 起点<br />            CH1.append(p)<br />            CH2.append(p)<br />            continue<br />        if p == p2 or  # 终点<br />           cross(p2 - p1, p - p1) >= 0:  # 在上凸包<br />            while |CH1| > 1 and cross(CH1[-1] - CH1[-2], p - CH1[-2]) >= 0:<br />                CH1.pop()<br />            CH1.append(p)<br />        if p == p2 or<br />           cross(p2 - p1, p - p1) < 0:  # 在下凸包<br />            while |CH2| > 1 and cross(CH2[-1] - CH2[-1], p - CH2[-2]) <= 0:<br />                CH2.pop()<br />            CH2.append(p)<br /><br />    merge CH1, CH2 into CH<br />    return CH<br /><br /><br />Graham扫描法<br />计算凸包的另外一种算法就是Graham扫描法，也可以视为是旋转扫描线的运用。类似于Jarvis步进法这种不断包裹形成凸包的方法，Graham扫描法首先选出一个肯定在凸包上的点作为基点，然后将其它点进行极角排序，按照极角序的顺序来扫描。并且按照水平扫描线算法中删除先前的点的方法来不断更新凸包。<br />Graham算法有一个好处，就是最终得到的凸包还是按照极角序排列的，不需要再次排序，方便后续的处理。<br />算法步骤如下：<br /><br />选出最左下的点作为基点<br />以基点为原点，其它点按照极角逆时针排序。对于极角相同的点，保留与基点距离最远的点。<br />维护一个栈，依次访问每一个点，检查之前的点是否与其形成了凹陷的形状（利用叉积判断），如果有就从栈中退掉一个点。否则将该点压入栈中。<br />最后栈中元素就是凸包<br /><br />下面给出了一个示例：<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />图上依次连接的线表示栈中的元素。<br />对于Graham扫描法的时间复杂度，与水平扫描线的分析一致，关键在于排序的时间复杂度。<br />该算法总体复杂度为$O(n\\log n)$。<br />下面是该算法的伪代码：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17function GRAHAM-SCAN(Q):<br />    if |Q| <= 3:<br />        return Q<br /><br />    select the base point p1<br /><br />    sort Q by polar angle order, when meets the same polar angle,<br />    keep the furthest one.<br /><br />    CH = []<br />    for p in Q[1:]:<br />        while |Q| > 1 and<br />              cross(Q[-1] - Q[-2], p - Q[-2]) <= 0:<br />            CH.pop()<br />        CH.append(p)<br /><br />    return CH<br /><br /><br />小结<br />上面介绍了三种凸包构造算法，其中水平扫描线法和Graham扫描法是最为常用和高效的算法。<br />这两种算法中的扫描线方法可以被单独拿出来使用，因而可以做进一步扩展（如下面将提到的动态凸包问题）<br />扩展与应用<br />动态凸包<br />动态凸包是指要求实现动态插入点并维护点集凸包的问题，目前好像还没有支持在线2删除点的高效算法。<br />目前流行的两种动态凸包算法来源于之前的两种凸包算法：水平扫描线法和Graham扫描法。<br />水平序<br />第一种是来源于水平扫描线的算法。我们用两棵平衡树来维护上下两个凸包，均按照$x$排序。<br />每次插入点之前，先要判断点是否在凸包内部。首先二分出该点所在的上凸包或下凸包的左右两个点，然后利用叉积来判断是否在凸包外。注意这里有几个边界情况：<br /><br />点超出了凸包的最左边和最右边时要单独处理。<br />点的$x$与最左边或最右边相同时需要考虑一下。<br /><br />如果点在凸包内，那么凸包将不会被更新。否则就要考虑更新凸包。<br />按照同样的方法，在平衡树上查找出该点在凸包上左边和右边的点，然后向左向右检查是否有违反凸包性质的凹陷形状，如果有，则删除对应的点。直到凸包性质得到维护。然后将该点插入即可。<br />类似的，对于之前判断点是否在凸包内的边界情况，在这里就需要更加注意。<br />由于有上下两个凸包，所以相似的代码需要写两遍......<br />极角序<br />第二种是来源于Graham扫描法的算法，这个算法与水平序相比边界更简单，代码也更短。<br />该算法要求得到一个初始的凸包（至少两个点），并以这些点的中心作为原点，按照极角序3插入到平衡树中。<br />与水平序类似，首先要查询点是否在凸包内部。同样，我们在平衡树中查找极角左右的点，并利用叉积判断是否在凸包内。注意我们期望这些点会按照一个环的方式存入，然而平衡树是链状数据结构。因此在边界处需要到另外一边寻找答案。<br />如果查询的点与原点一样，就没有极角可言了，因此我们需要判断该点是否与原点一样。由于我们的原点必定在凸包内，所以可以直接判定。<br />之后的插入与水平序一致，二分出左右点，并维护凸包性质即可。<br />注意这里没有超出左右边界的情况，这就是极角序的一大优势。同时，极角序也只用维护一棵平衡树。<br />具体实现<br />[Codeforces 70D] Professor’s task<br />这道题是非常良心的模板题，如果想实现动态凸包，可以到这里来测试。<br />本人的代码由于是手写的向量和平衡树，所以代码相当长，就不在此以代码框的形式放出。有兴趣的可以点开下面的链接来看：<br />水平序<br />极角序<br />旋转卡壳<br />旋转卡壳是一类应用于凸多边形上的算法。由于凸包也是凸多边形，所以也可以用在凸包上。<br />为了解释什么是旋转卡壳，首先来看一个经典的问题：<br /><br />给你一个点集$Q$，求这个点集中最远4的两个点的距离。<br /><br />该问题最为直接的方法是枚举这两个点对，然后计算距离。这样做的时间复杂度为$\\Theta(n^2)$。<br />有没有一种更快的算法呢？首先可以注意到，最远的两个点一定在凸包上，因为如果它们不在凸包上，那么凸包实际上可以被扩大。<br />这样我们就只用考虑凸包上的点了。对于凸包上的一个点，很直观的想法就是找到凸包另一边最远的点。<br />这是就要用到旋转卡壳，我们用一对平行线”夹紧”这个凸包，这样被两条直线所压住的点之间就可能有最远点对。<br /><br />由于当前所卡中的不一定就是最远点对，所以还需要继续寻找。<br />而对每一条凸包上的边而言，都只有最远的点对其有效。<br />所以可以想象其中一条直线不断的沿着凸包上的边进行旋转，而另一条直线则不断更新与之最远的点。<br /><br />第一条直线的事情好办，关键在于第二条。由于凸包上的点到第一条直线的距离具有单调性，所以第二条直线可以沿着一个方向移动，从而到达合适的位置。<br />当然需要注意一种边界情况：如果有两条平行的边，那么第二条直线可能卡中两个点5，这样就需要多枚举一些情况。<br />按照这样的方法旋转一周，就可以对所有可能的点对完成枚举，极大地减少了枚举量。<br />对于凸多边形的每一条边我们都要计算一次答案。如果计算答案的复杂度为$O(g(n))$，那么旋转卡壳的复杂度就是$O(ng(n))$。对于最远点对问题，我们可以在$\\Theta(n)$的时间内解决。<br />旋转卡壳还有许多有趣的应用，很多情况下是用于解决点集和凸多边形上的问题。<br />斜率优化<br />斜率优化是一类应用在递推优化上的算法，它巧妙在于将看似没有规律的递推关系转为了二维平面上的线性规划问题。下面举一个简单的例子：<br /><br />给你一个数组$A[1\\dots n]$和$B[1\\dots n]$　$(A[i],\\;B[i] > 0,\\;i\\in[1.\\;n])$，并给出$f(1)$和$f(2)$，已知$f$具有以下递推关系：<br />$$ f(x) = \\max\\{A[x]f(i) + B[x]f(i - 1) \\mid i \\in [2,\\;x)\\} $$<br />求$\\sum_{i=1}^nf(i)$。<br /><br />首先，直接枚举的时间复杂度为$\\Theta(n^2)$，并不是很优。<br />如果单纯是取最大值，这个问题就可以用线段树来解决。然而$\\max$中的东西简直莫名其妙，令人摸不着头脑。<br />不妨从另外一个角度来考虑问题。对于当前的$x$而言，考虑之前的两个位置$j,\\;k \\in [2,\\;x)$ (假定$j \\lt k$)，什么时候$j$会比$k$更优（即可能取到最大值）。<br />我们发现。只有下面的不等式成立时，$j$会比$k$更优：<br />$$ A[x]f(j) + B[x]f(j - 1) \\gt A[x]f(k) + B[x]f(k - 1) $$<br />由于$f(x)$是递增的，所以我们可以尝试对上式进行一些等价变形：<br />$$ A[x](f(j) - f(k)) \\gt B[x](f(k - 1) - f(j - 1)) $$<br />$$ {f(j) - f(k) \\over f(k-1) - f(j-1)} \\gt {B[x] \\over A[x]} \\tag{1} $$<br />$$ {f(j) - f(k) \\over f(j-1) - f(k-1)} \\lt -{B[x] \\over A[x]} \\tag{2} $$<br />回想一下直线斜率的计算公式，不难发现$(2)$式左边是一个计算斜率的形式，而右边是一个常量（对特定的$x$而言）。<br />因此$(2)$式左边可以视为是两个点$(f(j-1),\\;f(j))$和$(f(k-1),\\;f(k))$的直线的斜率与$-B[x] / A[x]$的关系。<br /><br />如上图所示，这个时候：<br />$$ {f(j) - f(k) \\over f(j-1) - f(k-1)} \\gt -{B[x] \\over A[x]} $$<br />故此时$j$不比$k$更优。<br />可以注意到，对于这个问题，查询的斜率都是负数，所以只要两点间的斜率大于$0$，就可以有更优的调整。<br />因此所有非上凸包的点都不比上凸包的点更优。<br />于是我们就只用考虑上凸包的点了。<br />由于上凸包的相邻两点间斜率是递减的，而我们的目标是查找到第一个小于$-B[x] / A[x]$的边，所以我们可以采用二分的方法！<br />到此整个算法已经很妙了，只剩下一个问题，就是这些点并不是一开始就知道的。<br />所以我们需要动态插入点并维护凸包，这就需要之前所提及的动态凸包。<br />由于只需要上凸包，所以这里最好选用水平序，并且只需要维护一棵平衡树。<br />这样这个问题我们就做到的$O(n\\log n)$的时间复杂度。<br />事实上，机智的人可能发现这个问题并不需要这种高级的方法，然而这里只是为了解释什么是斜率优化。在真正复杂的地方，斜率优化还是有很大用处，并且形式也多变。<br /><br /><br /><br /><br />凸包的定义可以扩展至高维。 ↩<br /><br /><br />如果只需要删除且允许离线，则可以进行”时光倒流”，从后往前处理，这样就变成了插入。 ↩<br /><br /><br />最好采用先象限后极角的方法，避免一些边界情况。 ↩<br /><br /><br />最近点对问题的解决方法与之完全不同，通常是采用分治法。 ↩<br /><br /><br />由于凸包上不允许出现同一条直线上出现多于两个点（因为要使凸包上的点尽可能少），所以不会同时卡中三个以上的点。 ↩<br /><br /><br />","tags": "凸包 计算几何 数据结构 斜率优化 旋转卡壳","url": "blog/2016-8-11/convex-hull.html"},
{"title": "密码锁","text": "密码锁 (expression.cpp/in/out)<br />时间限制: 1 s / 内存限制: 512 MB / 打开O2优化<br />题目描述<br />dyx在家里玩耍时发现了一个神奇的密码锁。然而他早已忘记了这个锁的密码，于是他随便尝试了一下，结果锁就打开了......<br />锁的内部有一个很长的字符串，机智的dyx马上就发现这就是密码锁的核心。于是他研究了一下午，探寻这把锁的奥秘。<br />他发现这个字符串是一个表达式的形式，像下面这个样子：<br />1a|b&(!c^d)<br /><br /><br />其中，每一个由小写字母组成的单词是一个变量，对应着密码锁上的一个按钮。由于按钮只能按下或不按下，于是你可以认为每个变量是一个布尔类型的（即只有$\\text{true}$和$\\text{false}$之分）<br />其余的字符就只有&、|、^、!和左右小括号。dyx发现括号是用来优先运算的，意思是这是一个会将所有变量进行计算的表达式，并且优先计算括号中的子表达式。同时，&、|、^、!都是运算符，它们分别对应的是逻辑与、逻辑或、逻辑异或和逻辑非。其中前三者运算优先级一致，当它们在同一级出现时会从左至右运算，逻辑非的优先级比它们高。当每一个变量都有相应的值时，整个表达式就会就会进行计算，并给出一个布尔值。dyx还发现，当整个表达式的值为$\\text{true}$时，密码锁就会打开。<br />很明显，整个密码锁的输入方案共有$2^n$种，其中$n$是表达式中变量的数量。于是dyx瞬间明白为什么他一次就可以将这个密码锁解开了。然而dyx是一个勇于探究的人，他想知道到底有多少中方法可以解开一个密码锁。<br />不知为何，dyx又发现了一火车的密码锁。坚持不懈的dyx不停的计算着每一个密码锁能解开的方案数......由于密码锁的表达式越来越长并且人脑计算量是$\\Theta(1)$的，dyx不得不需要一个程序来帮助他计算这个方案数。<br />输入格式<br />每个测试数据点有多个表达式。文件以EOF结束。<br />每一个表达式占一行，且中间只有小写字母和&、|、^、!、(、)。<br />对于&、|和^运算，它们左右会各有一个变量或子表达式。其运算规则如下：<br /><br /><br /><br />$a$<br />$b$<br />$a$ & $b$ ($a \\land b$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{true}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br />$\\text{false}$<br /><br /><br />$\\text{false}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br /><br /><br /><br /><br />$a$<br />$b$<br />$a$ | $b$ ($a \\lor b$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{true}$<br />$\\text{false}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br /><br /><br /><br /><br />$a$<br />$b$<br />$a$ ^ $b$ ($a \\oplus b$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{true}$<br />$\\text{fasle}$<br /><br /><br />$\\text{true}$<br />$\\text{false}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br />$\\text{true}$<br /><br /><br />$\\text{false}$<br />$\\text{false}$<br />$\\text{false}$<br /><br /><br /><br />对于!运算，它后面会有一个变量或子表达式。其运算规则如下：<br /><br /><br /><br />$a$<br />!$a$ ($\\lnot a$)<br /><br /><br /><br /><br />$\\text{true}$<br />$\\text{false}$<br /><br /><br />$\\text{false}$<br />$\\text{true}$<br /><br /><br /><br />输入保证表达式是有效的，且表达式中不存在缺少参数的运算符和空的括号。<br />为了防止此题变成不可做的NP-hard问题，输入保证表达式中每一个变量名只出现一次。<br />输出格式<br />对于每一个表达式，输出能够解开它的方案总数。由于答案可能过大，因此将答案对$10^9 + 7$取模后输出。<br />一种方案即指对每一个变量给定一个值。<br />两种方案不同当且仅当至少一个变量所给定的值不同。<br />输入样例<br />1<br />2<br />3a&b<br />a|b|c<br />a|!(b|c)<br /><br /><br />输出样例<br />1<br />2<br />31<br />7<br />5<br /><br /><br />数据范围及提示<br />对于第一个表达式，只有$a = \\text{true}, b = \\text{true}$才为$\\text{true}$。<br />对于第二个表达式，只要三者有一个变量为$\\text{true}$就是$\\text{true}$。<br />对于第三个表达式，先运算b|c，然后对其取反，最后与$a$做逻辑与。<br />以下$n$表示变量数量，$T$表示测试数据组数，$L$表示表达式的总长度。<br />对于$10\\% $的数据，$n \\le 10,\\; T = 15$。<br />对于另外$10\\% $的数据，只有逻辑或运算，没有括号。<br />对于另外$10\\% $的数据，不存在逻辑非和括号。<br />对于另外$20\\% $的数据，不存在括号。<br />对于另外$20\\% $的数据，$n \\le 500$。<br />对于$100\\% $的数据，变量名长度$\\le 4$，$L \\le 10^6$，$n \\le 3\\times10^5$。<br />其中$90\\% $的数据，$T \\le 5$。","tags": "Problems","url": "blog/2016-6-30/expression.html"},
{"title": "差分序列与Stirling数","text": "差分序列与Stirling数<br />刚看完《组合数学》的这一节，写一点笔记。<br />差分序列<br />定义<br />设一个序列：<br />$$<br />h(0), h(1), h(2), h(3), h(4), \\dots<br />$$<br />的一阶差分序列为：<br />$$<br />\\Delta h(0), \\Delta h(1), \\Delta h(2), \\Delta h(3), \\dots<br />$$<br />其中：<br />$$<br />\\Delta h(n) = h(n + 1) - h(n)<br />$$<br />同样，将差分出来的序列再次进行差分，可以得到二阶差分序列。因此，我们定义零阶差分序列就是原序列，$p$阶差分序列为：<br />$$<br />\\Delta^{(p)} h(n) = \\Delta^{(p - 1)} h(n + 1) - \\Delta^{(p - 1)} h(n) \\;\\;\\;\\; (p \\gt 0)<br />$$<br />差分序列有一种求导的意味。<br />多项式的差分序列<br />多项式$h(n) = 2n^3 + 2n^2 - 4n + 233$的差分序列如下：<br />$$<br />233, 233, 249, 293, 377, 513, \\dots \\\\<br />0, \\;16, \\;44, \\;84, \\;136, \\dots \\\\<br />16, \\;28, \\;40, \\;96, \\dots \\\\<br />12, \\;12, \\;12, \\dots \\\\<br />0, \\;\\;0, \\dots \\\\<br />\\dots<br />$$<br />我们发现$h(n)$是个$3$次多项式，而它的序列经过$3$次差分就变成了全是$0$的序列。<br />可以证明，一个$p$次多项式的序列最多经过$p$次差分就会变为全$0$序列。<br />首先考虑$0$次多项式，它的序列值是一个常数，所以至多经过一次差分就可以变为$0$。<br />现在进行归纳假设：假设对于$p$次多项式的序列最多经过$p$次差分就会得到全$0$序列，那么现在证明对于$p + 1$次多项式最多差分$p + 1$就可以得到全$0$序列。<br />观察最高次数的项，在每一次差分中的变化：<br />$$<br />\\begin{align}<br />\\Delta^{(c)} h(n) & = \\Delta^{(c-1)} h(n + 1) - \\Delta^{(c-1)}h(n) \\\\<br />& = (n + 1)^{p} + \\cdots - n^p - \\cdots \\\\<br />& = \\sum_{k = 0}^p {p \\choose k} n^k + \\cdots - n^p - \\cdots<br />\\end{align}<br />$$<br />由于${p \\choose p} = 1$，所以最高次数的项在一次差分中被减去了，所以差分后的序列是一个至多$p - 1$次的多项式的序列。因此，根据归纳假设，$p + 1$次的多项式最多进行$p + 1$次差分就可以对到全$0$序列。<br />差分的线性性<br />如果：<br />$$<br />h(n) = af(n) + bg(n)<br />$$<br />那么：<br />$$<br />\\begin{align}<br />\\Delta h(n) & = \\Delta (af(n) + bg(n)) \\\\<br />& = a(f(n + 1) - f(n)) + b(g(n + 1) - g(n)) \\\\<br />& = a\\Delta f(n) + b\\Delta g(n)<br />\\end{align}<br />$$<br />由此我们证明了差分是一个线性变换。这称为差分的线性性。<br />特殊差分表<br />在差分表中：<br />$$<br />233, 233, 249, 293, 377, 513, \\dots \\\\<br />0, \\;16, \\;44, \\;84, \\;136, \\dots \\\\<br />16, \\;28, \\;40, \\;96, \\dots \\\\<br />12, \\;12, \\;12, \\dots \\\\<br />0, \\;\\;0, \\dots \\\\<br />\\dots<br />$$<br />称第一横行为第$0$行，表示原数列，如上面的$233, 233, 249, 293, 377, 513, \\dots$。而左边的第一斜列为第$0$条对角线，如上面的$233,0,16,12,0,\\dots$。显然知道了这两个中的任意一个就可以确定整个差分表。<br />考虑一下由下面的对角线构成的差分表会是怎样的数列构成的：<br />$$<br />0, 0, 0, 0, 1, 0, 0\\dots<br />$$<br />首先，这个差分表后面全部变成了$0$，所以这肯定是一个$4$次多项式的差分表。同时我们可以确定这个多项式有$4$个零点，所以我们可以写出：<br />$$<br />f(n) = cn(n-1)(n-2)(n-3)<br />$$<br />其中$c$还是待确定的。<br />同时，我们注意到$f(4) =  1$，所以：<br />$$<br />c \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1 = 1 \\Longrightarrow c = \\frac1{4!}<br />$$<br />换言之：<br />$$<br />f(n) = {n! \\over 4!(n - 4)!} = {n \\choose 4}<br />$$<br />是不是感觉很神奇？这一结论可以推广到任意位置的$1$的差分表。同时，利用差分表的线性性，我们可以得到更加神奇的东西：<br /><br />如果$\\Delta f(n)$的第$0$条对角线为$c_0, c_1, c_2, c_3, \\dots, c_p, 0, 0, \\dots$，那么：<br />$$ f(n) = \\sum_{k=0}^p c_k{n \\choose k}$$<br /><br />此时你也许会想问这东西有什么用？由于它是对于一个多项式的差分分析得到的结论，因此，我们对于一个多项式，如果知道了第$0$条对角线，那么我们可以直接计算这个多项式。<br />并且，根据Pascal公式，我们可以知道：<br />$$<br />\\sum_{k=0}^p {n \\choose k} = {n + 1 \\choose p}<br />$$<br />所以：<br />$$<br />\\sum_{k = 0}^n f(k) = \\sum_{k = 0}^p c_k {n + 1 \\choose k}<br />$$<br />所以，当我们拥有了这个结论之后，我们就可以以同样的代价来计算它的前缀和。<br />现在来考虑一个具体一点并且不是很复杂的问题，但是可能当场并不能解决它：<br /><br />给你$T$次询问，每次给出$n$和$p$，要求你计算：<br />$$ \\sum_{a = 1}^n a^p \\pmod{10^9 + 7}$$<br />$1 \\leqslant T \\leqslant 5000$，$1 \\leqslant p \\leqslant 5000$，$1 \\leqslant n \\leqslant 10^{18}$。<br /><br />如果采用直接计算$c_0, c_1, c_2, \\dots$的话，总的复杂度为$\\Theta(q^3 + Tq)$。这里出现的问题就是系数的预处理代价太高，因此我们需要寻找一种更快速的计算方法。<br />对此，我们设$f_p(n) = n^p$，同时设它的系数为：<br />$$<br />c(p, 0), c(p, 1), c(p, 2), \\dots, c(p, p)<br />$$<br />那么答案就是：<br />$$<br />\\sum_{k = 0}^p c(p, k){n + 1 \\choose k}<br />$$<br />第二类Stirling数<br />定义<br />有第二类Stirling数就有第一类Stirling数，但是由于第二类Stirling数可以帮助我们解决之前的问题，所以先介绍它。<br />第二类Stirling数的用途是使用下降幂来表示数的幂。下降幂是这样的一种东西：<br />$$<br />x^{\\underline{n}} = {x! \\over (x - n)!}<br />$$<br />回到前面的问题，可以发现：<br />$$<br />\\begin{aligned}<br />n^p & = \\sum_{k = 0}^p c(p, k){n \\choose k} \\\\<br />& = \\sum_{k = 0}^p \\frac{c(p, k)}{k!} n^{\\underline{k}}<br />\\end{aligned}<br />$$<br />所以设：<br />$$<br />S(p, k) = {c(p, k) \\over k!}<br />$$<br />为第二类Stirling数。并且满足：<br />$$<br />n^p = \\sum_{k = 0}^p S(p, k)n^{\\underline{k}}<br />$$<br />同时注意一下它的边界值：<br />$$<br />S(n, n) = 1 \\;\\;\\;\\; \\forall n \\in N \\\\<br />S(n, 0) = 0 \\;\\;\\;\\; \\forall n \\in N_+<br />$$<br />不妨来考虑一下：<br />$$<br />\\begin{aligned}<br />n^{p-1} & = \\sum_{k = 0}^{p-1} S(p-1, k)n^{\\underline{k}} \\\\<br />n^p = n \\cdot n^{p-1} & = n\\sum_{k = 0}^{p-1} S(p-1, k)n^{\\underline{k}} \\\\<br />& = \\sum_{k = 0}^{p-1} S(p-1, k) \\cdot n \\cdot n^{\\underline{k}} \\\\<br />& = \\sum_{k = 0}^{p-1} S(p-1, k) \\cdot (n - k + k) \\cdot n^{\\underline{k}} \\\\<br />& = \\sum_{k = 0}^{p-1} S(p-1, k) n^{\\underline{k + 1}} + \\sum_{k = 0}^{p-1} kS(p-1, k) n^{\\underline{k}} \\\\<br />& = \\sum_{k = 1}^{p} S(p-1, k - 1) n^{\\underline{k}} + \\sum_{k = 0}^{p-1} kS(p-1, k) n^{\\underline{k}}<br />\\end{aligned}<br />$$<br />通过比较同一项的系数，我们可以得知下面的递推式：<br />$$<br />S(p, k) = kS(p - 1, k) + S(p - 1, k - 1)<br />$$<br />解决之前的问题<br />在之前的问题中，我们知道：<br />$$<br />\\begin{aligned}<br />\\sum_{a = 1}^n a^p & = \\sum_{k = 0}^p c(p, k){n + 1 \\choose k} \\\\<br />& = \\sum_{k = 0}^p S(p, k)(n + 1)^{\\underline{k}}<br />\\end{aligned}<br />$$<br />对于后面的式子，我们发现可以通过递推算出$(n + 1)^{\\underline{0}}$至$(n + 1)^{\\underline{p}}$的值，同时，我们有了之前的递推式，我们可以在$\\Theta(p^2)$的时间内预处理出第二类Stirling数。所以这个问题我们可以以$\\Theta(p^2 + Tp)$的时间复杂度解决这个问题。<br />其实，根据第二类Stirling数的递推公式，我们也可以类似的推出$c(p, k)$的递推公式：<br />$$<br />c(p, k) = k(c(p - 1, k - 1) + c(p - 1, k))<br />$$<br />读者可以自己试一试。<br />但是这还不是这个问题的最优解法。使用伯努利数和快速傅里叶变换，我们可以得到更好的复杂度。这里就没有介绍了。<br />组合意义<br />现在来考虑一下这个简单问题：<br /><br />求$p$个人，放入$k$个相同的房子 (房子不可以为空) 的方案数。<br /><br />不难我们可以想出一个递推：设$f(p, k)$为$p$个人放入$k$个相同的房子的方案数，那么它满足：<br />$$<br />f(p, k) = kf(p - 1, k) + f(p - 1, k - 1)<br />$$<br />对于其正确性，考虑两点：<br /><br />如果第$p$个人单独进入一个房间，那么方案数为$f(p - 1, k - 1)$。<br />如果第$p$个人进入之前的房间，那么它可以挑选之前的$k$个房间的任意一间，即方案数为$kf(p - 1, k)$。<br /><br />同时我们注意到：<br />$$<br />f(n, n) = 1<br />$$<br />并且：<br />$$<br />f(n, 0) = 0 \\;\\;\\;\\; \\forall n \\in N_+<br />$$<br />也就是$f$和第二类Stirling数满足一样的初始条件和递推公式，那么意味着$f(p, k)$和$S(p, k)$是一样的。所以这个问题的答案就是$S(p, k)$。这也正是第二类Stirling数的组合意义。<br />对于这个问题，我们可以从容斥原理的角度来获得另外一个不同的公式。设$A_1,\\; A_2, \\;A_3,\\dots,A_k$为第$1$到第$k$个房间为空的方案集合，那么我们的答案就是：<br />$$<br />S(p, k) = \\frac1{k!}\\left|\\overline{A}_1 \\cup \\overline{A}_2 \\cup \\cdots \\cup \\overline{A}_k\\right|<br />$$<br />注意在之前的推到里面我们区分了这$k$个房间，而第二类Stirling数是没有区分的，所以要乘以$1/k!$。<br />考虑到如果有$t$个房间为空，那么对于每一个人而言，就只有$k - t$个选择，所以对于此的方案数的就是$(k - t)^p$。所以我们可以知道：<br />$$<br />S(p, k) = \\frac1{k!}\\sum_{t = 0}^k (-1)^t{k \\choose t}(k - t)^p<br />$$<br />这也就是计算单个第二类Stirling数的公式。<br />第一类Stirling数<br />定义<br />现在来介绍第一类Stirling数。与第二类Stirling数类似，第一类Stirling数是使用数的幂来表示下降幂。<br />现在来观察一下规律：<br />$$<br />\\begin{aligned}<br />& n^{\\underline{0}} = 1 \\\\<br />& n^{\\underline{1}} = n \\\\<br />& n^{\\underline{2}} = n(n - 1) = n^2 - n \\\\<br />& n^{\\underline{3}} = n(n - 1)(n - 2) = n^3 - 3n^2 + 2n \\\\<br />& n^{\\underline{4}} = n(n - 1)(n - 2)(n - 3) = n^4 - 6n^3 + 11n^2 - 6n \\\\<br />& \\dots<br />\\end{aligned}<br />$$<br />可以发现，下降幂展开以后是一个系数正负号交替的多项式。与在第二类Stirling数中类似的，我们设$s(p, k)$为第一类Stirling数，并且满足：<br />$$<br />n^{\\underline{p}} = \\sum_{k = 0}^p (-1)^{p - k}s(p, k)n^k<br />$$<br />以及边界值：<br />$$<br />s(n, n) = 1 \\;\\;\\;\\; \\forall n \\in N \\\\<br />s(n, 0) = 0 \\;\\;\\;\\; \\forall n \\in N_+<br />$$<br />类似的，我们可以据此推出第二类Stirling数的递推公式：<br />$$<br />\\begin{aligned}<br />n^{\\underline{p - 1}} & = \\sum_{k = 0}^{p-1} (-1)^{p - k - 1}s(p - 1, k)n^k \\\\<br />n^{\\underline{p}} & = (n - p + 1)\\sum_{k = 0}^{p-1} (-1)^{p - k - 1}s(p - 1, k)n^k \\\\<br />& = \\sum_{k = 0}^{p-1} (-1)^{p - k - 1}s(p - 1, k)n^{k+1} + \\sum_{k = 0}^{p-1} (-1)^{p - k}(p - 1)s(p - 1, k)n^k \\\\<br />& = \\sum_{k = 1}^{p} (-1)^{p - k}s(p - 1, k - 1)n^{k} + \\sum_{k = 0}^{p-1} (-1)^{p - k}(p - 1)s(p - 1, k)n^k<br />\\end{aligned}<br />$$<br />通过比较同次项的系数可以得知：<br />$$<br />s(p, k) + (p - 1)s(p - 1, k) + s(p - 1, k - 1)<br />$$<br />组合意义<br />同样的，第一类Stirling数也具有其组合意义。通过考虑下面的问题就可以证明：<br /><br />求$p$个人围成$k$个圈 (圈不能为空) 的方案数。<br />注意这里的圈中的人的顺序不同也会视为圈不同。<br /><br />对于这个问题，我们证明其答案$f(p, k)$满足下面的递推关系：<br />$$<br />f(p, k) = (p - 1)f(p - 1, k) + f(p - 1, k - 1)<br />$$<br />证明：<br /><br />如果第$p$个人独自站成一个圈，那么共有$f(p - 1, k - 1)$种方案。<br />如果第$p$个人与之前的人站在一起，那么他有$p - 1$种方案站在一个人的右边，所以共有$(p - 1)f(p - 1, k)$中方案。<br /><br />不难验证这个问题的初始条件与第一类Stirling数一致，所以$f(p, k)$和$s(p, k)$就是一样的啦～","tags": "差分 Stirling数","url": "blog/2016-11-29/delta-and-stirling.html"},
{"title": "平衡树套链表","text": "平衡树套链表<br />前言<br /><br />这是一个闲得卵疼的产物<br /><br />有时候我们希望能够在一个序列上快速遍历，然而这个序列却又是动态的，因此会考虑到平衡树来维护序列。<br />然而普通平衡树查找前趋后继是比较麻烦的，除了Splay有一个很简单直观的方法1，其它平衡树都要与父亲节点纠缠一番。<br />然而最关键的是，它们查询前趋后继还不是$\\Theta(1)$的时间，最坏情况下是$O(\\log n)$的。<br />因此考虑将链表”挂载”在平衡树上，可以将查找前趋后继的时间复杂度降为$\\Theta(1)$，并且只需要在插入和删除时每个节点付出$\\Theta(1)$的代价。同时顺序遍历节点的代码将与普通链表一样。这样在动态维护凸包等一些复杂的平衡树应用中做到一些优化。<br />想必强者2看完前言已经脑补出这玩意了。<br />插入<br />实际上我们就是需要在插入节点时同时记录一个节点的前趋和后继。<br />由于新插入的节点一定是在树的底部，因此我们需要考虑的情况很少。<br />这时有两种情况，一种是插入到左儿子：<br /><br />那么新插入的节点必定是其父亲的前趋。这个过程可以看作是往链表中插入一个元素。<br />同样，对于插入到右儿子，情况也是类似的：<br /><br />因此，对于每个新插入的节点，只需要花费$\\Theta(1)$的时间来记录前趋后继。<br />旋转<br />许多平衡树 (Treap、Splay等) 都是以旋转操作来进行平衡的。然而平衡的时候是否要维护链表信息呢？<br />实际上根本不需要，因为旋转操作不会影响平衡树的有序性，所以对于每个节点而言，它的前趋后继是不会变化的，所以没有必要改动信息。<br />删除<br />有了前面的基础，删除操作其实很自然了。实际上就是最后要真正删除节点时，将链表上的指针重设。如果你写过链表的删除 (这东西很简单)，在平衡树上也就是一样的了。<br />应用<br />这个东西实际上只是一个小技巧，它可以用来简便一些代码，尤其是维护动态凸包这种要不停地向左向右访问节点的东西。如果我们使用的是循环链表，就可从任意一个节点开始循环遍历每一个节点。<br /><br /><br /><br /><br />将当前节点Splay至根，然后就不用讨论父亲节点了。 ↩<br /><br /><br />LinkSBK ↩<br /><br /><br />","tags": "数据结构 平衡树 链表","url": "blog/2016-7-28/bst-with-list.html"},
{"title": "平面计算几何","text": "平面计算几何<br />1 线段<br />下图中展示了一条无向线段$AB$。<br /><br />一般来说，我们所见的线段都是不定方向的。但在计算几何中，我们会借助向量这一强大的工具，因此我们需要将线段表示成有向线段(Directed Segment)的形式。如下图所示：<br /><br />事实上，有向线段就是一个向量。在上面，线段$AB$被向量$\\vec{AB}$所替代。<br />同样，我们也可以用相反的向量$\\vec{BA}$来表示$AB$。<br />2 叉积<br />2.1 定义<br />对于两个向量$p_1$和$p_2$，它们的叉积(Cross Product)$p_1 \\times p_2$的定义如下：<br />$$<br />p_1 \\times p_2 = <br />\\begin{vmatrix}<br />x_1 & x_2 \\\\<br />y_1 & y_2<br />\\end{vmatrix} = <br />x_1y_2 - x_2y_1<br />\\tag{2.1}<br />$$<br />上面的定义使用了行列式，初学者可能感到迷糊。好在叉积有着很好的几何解释。<br />2.2 几何解释<br />下图中，向量$p_1$和向量$p_2$的叉积$p_1 \\times p_2$就是它们和与$p_1$平行的向量$p_3$和与$p_2$平行的向量$p_4$所围成的平行四边形$ABCD$的有向面积。<br /><br />为什么会是有向面积呢？你可以自己造个数据来算一下，你会发现$p_1 \\times p_2 = -p_2 \\times p_1$。<br />我们发现，叉积结果的符号与$p_1$和$p_2$的相对位置关系有很大联系：<br /><br />当$p_2$在$p_1$的顺时针方向时，$ p_1 \\times p_2 \\lt 0$。  <br />当$p_2$在$p_1$的逆时针方向时，$ p_1 \\times p_2 \\gt 0$。  <br />当$p_2$与$p_1$共线（方向相同或相反）时，$ p_1 \\times p_2 = 0$。<br /><br />利用这些性质，我们可以完成许多有趣的事情。<br />同时，利用上面的图像，我们可以探究出叉积公式的另外一种形式：<br /><br />在前面的基础上，我们作$ BE \\bot p_2 $，那么平行四边形$ABCD$的面积又可以表示为：<br />$$ S_{ABCD} = |p_2| \\cdot |BE| $$<br />又因为：<br />$$ |BE| = |p_1| \\sin \\alpha $$<br />因此：<br />$$ p_1 \\times p_2 = |p_1|\\cdot|p_2|\\sin \\alpha \\tag{2.2} $$<br />但是显然这样的公式对于计算机而言需要大量的浮点数运算，所以用这个公式计算叉积精度可能不高。<br />但是这个公式可以改为下面的形式：<br />$$ \\alpha = \\sin^{-1}\\left({p_1 \\times p_2 \\over |p_1| \\cdot |p_2|}\\right) \\tag{2.3}$$<br />这样我们可以利用这个公式来计算两个向量间的夹角。<br />如果两个向量的起点都不在原点时，该怎么计算这个有向面积呢？<br />这其实相当简单，我们将两个向量的公共起点作为原点，然后运用向量减法来计算相对向量，然后就可以计算了。<br />2.3 计算面积<br />下面我们将利用叉积来计算简单多边形的面积。<br />首先，简单多边形时多边形中没有边相交的多边形。注意包括凸多边形以及令人讨厌的凹多边形。<br />首先从平行四边形入手。<br /><br />这是之前的图。虽然向量的叉积算出来时有向面积，但是我们只用取绝对值，就是平行四边形的面积了。<br />对于三角形，通过对称的方法可以构造出平行四边形。因此三角形就是叉积的绝对值的一半。<br />先来看一下正方形：<br /><br />显然，它的面积是$1$。<br />但现在要你用向量的方法来计算，该怎么办?<br />我们的正方形是用一组向量来表示的($\\vec{AB}$、$\\vec{BC}$、$\\vec{CD}$和$\\vec{DA}$)，并且按照逆时针排列，这样就指定了顶点的顺序。<br />然后我们按照下面的流程来计算面积：<br /><br />在平面内任选一点作为原点。  <br />按照有向边的顺序依次计算叉积并累积求和，最后的结果除以$2$就是多边形的面积。<br /><br />现在我们来演示一次：<br /><br />选定原点，平面内任意一个点都可以。这里选择的是$O$点。<br /><br />计算叉积，首先是$\\vec{AB}$，我们计算的是$\\vec{OA} \\times \\vec{OB} = -1 $。<br /><br />然后是$\\vec{BC}$，$\\vec{OB} \\times \\vec{OC} = 2$。<br /><br />之后是$\\vec{CD}$，$\\vec{OC} \\times \\vec{OD} = 2$。<br /><br />最后是$\\vec{DA}$，$\\vec{OD} \\times \\vec{OA} = -1$。<br />将叉积结果累加起来并除以$2$，得到$ S_{ABCD} = 1$。<br />算法得到了正确结果。<br />事实上，这个算法就是简单多边形的面积算法。那么，为什么这样计算是正确的呢？<br />我们首先来考虑$\\vec{AB}$和$\\vec{BC}$。<br /><br />这两个向量从$O$的角度来看，它们是相反的方向，并且它们叉积出来的结果是异号的。<br />我们可以发现，${\\vec{OA} \\times \\vec{OB} \\over 2}$就是$-S_{\\triangle OBA}$，${\\vec{OB} \\times \\vec{OC} \\over 2}$就是$S_{\\triangle OBC}$，$S_{\\triangle OBC}-S_{\\triangle OBA} = S_{\\triangle ABC}$。因此这一对边就可以计算出这个正方形一半的面积。对于另一半，也是如此。<br />因此，我们发现，这个算法时先计算这个多边形与选定的原点构成的更大的多边形的面积：<br /><br />上图就是线计算了$S_{OCDEFG}$。这几条边的叉积之和为正数。<br />然后计算不属于多边形的部分：<br /><br />上图中就是计算$S_{OCBAG}$，而这几条边的叉积之和是负数。因此相加后就只剩下多边形的面积了。<br />又因为叉积计算的是平行四边形的面积，所以最后要除以$2$。","tags": "数学 计算几何","url": "blog/2016-4-12/geometry.html"},
{"title": "快速数论变换 (NTT)","text": "快速数论变换 (NTT)<br />之前写了一篇关于多项式算法的博客，提到了快速傅立叶变换 (FFT)。<br />快速傅立叶变换中使用了单位复数根来进行采样与插值，快速数论变换和这是类似的，只不过使用的是原根。<br />原根的性质<br />为了方便，我们设：<br />$$<br />g_n = g^{(p-1) / n}<br />$$<br />其中$p$是素数并且$n \\mid (p-1)$，另外$g$是模$p$意义下的原根。<br />考虑下单位复数根为什能做到$\\Theta(n \\log n)$的时间复杂度，是因为它具有下面的性质：<br /><br />$$ \\omega_n^n = 1 \\tag{1}$$<br /><br />对原根而言：<br />$$<br />g_n^n = g^{n(p-1) / n} = g^{p-1} = g^{\\varphi(p)} = 1<br />$$<br /><br />$$ \\omega_{dn}^{dk} = \\omega_n^k \\tag{2}$$<br /><br />原根也可以：<br />$$<br />g_{dn}^{dk} = g^{dk(p-1) / dn} = g^{k(p-1) / n} = g_n^k<br />$$<br /><br />(折半引理)<br />$$ \\{(\\omega_n^k)^2\\} = \\{\\omega_{n/2}^k\\} \\tag{3} $$<br /><br />原根依然可以。<br />根据上面的结论，我们有：<br />$$<br />(g_n^{k})^2 = g_{n}^{2k} = g_{n/2}^k \\\\<br />(g_n^{k+n/2})^2 = g_n^{2k+n} = g_n^{2k} = g_{n/2}^k<br />$$<br />因此，单位复数根该有的性质原根居然都有！<br />NTT算法<br />从上面的讨论中我们知道，将你的FFT代码中的单位复数根换成$g_n^k$，就是NTT。注意到处取模。<br />逆FFT变换时需要除以$n$，在模$p$意义下记住是使用逆元。<br />NTT的总复杂度与FFT一致，是$\\Theta(n \\log n)$。<br />最后还剩下一个问题：$p$和$g$该怎么办。<br />在FFT中，为了方便处理，$n$一般都是选定了一个$2$的幂。因此，对于$p$，我们只需要选出一个$p-1$中含有$2$的幂的因子的素数，并且这个$2$的幂要大于$n$。通常选择形如$a\\cdot 2^k + 1$的素数。注意你必须保证这个素数有原根！<br />为了方便，通常选定：<br />$$<br />p = 1004535809 = 479 \\times 2^{21} + 1<br />$$<br />它的原根之一是$3$。<br />使用快速数论变换的好处就是避免了浮点数精度误差。当输入系数都是整型的时候最好优先考虑NTT。<br />但是出于一些常数上的原因，你写出来的NTT未必会比你的FFT快。","tags": "FFT NTT","url": "blog/2016-8-22/ntt.html"},
{"title": "排列与组合","text": "排列与组合<br />排列与组合是组合数学中最基础的东西了。在此做一点记录。<br />阶乘<br />在组合数学中，阶乘随处可见，它极大的简化了公式的形式。<br />我们将$n!$记作$n$的阶乘，其定义如下：<br />$$ n! = \\prod^n_{i=1} i \\tag{1.1} $$<br />特别的，$0! = 1$。之所以$0$的阶乘这样定义，是为了使后面的公式更具有普遍性。<br />我们来看一下阶乘函数的增长：<br /><br />上图中，红色的阶乘函数$ f(x) = x! $，蓝色的是$g(x) = x^2 $，而绿色的是$ h(x) = x^3 $。<br />由此可见阶乘函数的增长比平方快。与三次方相比，阶乘函数在之后也将赶超。<br />因此如果时间复杂度里面出现了阶乘，那将是一件可怕的事情。<br />排列<br />对于一个集合$S$，其排列是$S$中的元素的有序放置。<br />例如集合$S = \\{ a, b, c \\}$，它的1排列为：<br />$$ a, b, c $$<br />其2排列为：<br />$$ ab, ac, ba, bc, ca, cb $$<br />3排列为：<br />$$ abc, acb, bac, bca, cab, cba $$<br />由于$|S| < 4$，所以$S$没有4排列。<br />为了方便计数，我们将一个含有$n$个元素的集合的$r$排列个数记为$ P(n, r) $1。<br />如：$P(3,1)=3, \\; P(3,2)=P(3,3)=6 $。<br />特别的，我们定义$P(n,0)=1$。<br />如何计算这个值呢？当然我们是有公式的：<br />定理 对于任意的$n, r \\in N_+$，并且$ r \\le n$，有：<br />$$ P(n, r) = {n! \\over (n-r)!} \\tag{2.1} $$<br />证明 我们有$r$个空位来摆放元素。在第一个空位我们有$n$种选择，在第二个空位我们有$n - 1$中选择......由此可以得知：<br />$$ P(n, r) = \\prod^n_{i=n-r+1} i = {n! \\over (n-r)!} $$<br />现在我们来运用一下排列。<br />首先来计数由$1$至$9$的数构成的每一位均不同的$7$位数有多少个。<br />这个非常简单，就是$P(9, 7) = 181440$。<br />如果现在要求$5$和$6$不能连续出现，那么这样的数又有多少个？<br />我们考虑将连续出现的数给计数出来，这样就可以得到答案。<br />我们发现，通过向一个$5$位数中插入两个数就可以得到一个$7$位数，因此我们来考虑将$5$和$6$连续的插入一个$5$位数中。我们只会插入$56$或$65$，它们在一个$5$位数中一共有$6$个位置可以插入。因此$5$和$6$连续出现的数共有$ 2 \\times 6 \\times P(7, 5) = 30240 $个。<br />因此最终的答案为$ 181440 - 30240 = 151200 $。<br />组合<br />与排列相对，一个集合的组合2是其元素的无序放置。<br />其含义就是从集合中”选取”出几个元素。由于不考虑位置关系，所以像$abc$和$bac$3是等价的。<br />组合这一概念在整个组合数学中用处十分巨大。接下来我们先看到如何计数它。<br />首先我们将组合数记为${n \\choose r}$4，表示一个大小为$n$的集合的$r$组合的个数。例如，一个大小为$4$的集合$ S = \\{ a,b,c,d\\}$的3组合为：<br />$$ \\{a,b,c\\}, \\{a,b,d\\}, \\{a,c,d\\}, \\{b,c,d\\} $$<br />因此${4 \\choose 3} = 4$。<br />同样，为了能够更加方便的计数它，我们当然也是有公式的。<br />我们发现，任意一个$r$组合，都会有$P(r,r) = r! $种排列。而每一种排列，都会对应到一个组合。因此，一个集合的$r$组合与排列之间存在以下关系：<br />$$ {n \\choose r}r! = P(n,r) \\tag{3.1} $$<br />将排列数展开，我们可以得到下面的公式：<br />$$ {n \\choose r} = {n! \\over (n-r)!r! } \\tag{3.2} $$<br />其中，$n,r \\in N_+$，且$r\\le n$。<br />组合数的基本性质<br />组合数有着许多非常有用的性质。首先一个非常基本的等式就是：<br />$$ {n \\choose r} = {n \\choose n-r} \\tag{4.1} $$<br />直接利用组合数的公式可以得证这一性质。<br />通过对组合数进行求和，我们可以得知一个集合的子集数量：<br />$$ \\sum^n_{i=0} {n\\choose i} = 2^n \\tag{4.2} $$<br />这个等式当然可以用求和来得出。我们可以换个角度来考量它。一个集合的子集中，某些元素要么没有出现，要么就出现了。因此对于每个元素一共有两种选择，因此子集的总数为$2^n$个。<br />接下来是比较重要的帕斯卡公式：<br />定理 对于所有的$ 1 \\le k \\le n-1$的整数$n$和$k$：<br />$$ {n\\choose k} = {n-1\\choose k} + {n-1\\choose k-1} \\tag{4.3} $$<br />证明 尝试将右式化为左式即可。<br />$$<br />\\begin{align}<br />{n-1\\choose k} + {n-1\\choose k-1} &= {(n-1)! \\over k!(n-k-1)!} + {(n-1)! \\over (k-1)!(n-k)!} \\\\<br />&= {(n-1)!(n-k) \\over k!(n-k)!} + {(n-1)!k \\over k!(n-k)!} \\\\<br />&= {(n-1)!n \\over k!(n-k)!} \\\\<br />&= {n! \\over k!(n-k)!} \\\\<br />&= {n \\choose k}<br />\\end{align}<br />$$<br />这样就完成了证明。注意，在上面的证明中，利用到了阶乘的性质：$(n-1)!\\cdot n=n!$。<br />不难发现，帕斯卡公式实际上是组合数的一个递推公式。<br /><br />上图是由帕斯卡公式得到的一个递推的关系图，这里以${4 \\choose 3}$为例。其中灰色的节点是无效的值。为了方便，直接将其设为$0$。除了${1 \\choose 0} = {1 \\choose 1} = 1$为初始值外，其它的值都是由其所指向的节点的值求和而来。<br />上面的步骤就是动态规划中的状态转移的过程。利用这个公式，我们可以在$\\Theta(nr)$的时间来计算大量的组合数。因此可以将此作为一个预处理。<br />在具体实现的时候只需注意一些无效的特殊情况，其中包括$ r > n $和$n < 0$或$r < 0$。这些情况下的值均设为$0$。然后通过${1 \\choose 0}$和${1 \\choose 1}$这两个初始值就可以完成递推。<br /><br /><br /><br /><br />当然也可记作$_nP_r$或$P^n_r$。 ↩<br /><br /><br />《组合数学》中称之为”子集”，也许更为恰当。 ↩<br /><br /><br />下面将使用集合的方式表示组合，如$\\{a,b,c\\}$。 ↩<br /><br /><br />也可记作$_nC_r$或$C(n,r)$或$C^n_r$。 ↩<br /><br /><br />","tags": "组合数学","url": "blog/2016-5-7/permutation-and-combination.html"},
{"title": "收到一封奇怪的邮件","text": "收到一封奇怪的邮件<br />今天翻垃圾箱时发现了一封邮件，内容如下：<br /><br />My beloved friend,<br />I sent this mail praying for it to reach you in good health, since I myself are in a very critical health condition in which I sleep every night without knowing if I may be alive next day. My name is Mrs. Sarah Al moubi, a widow suffering from long time illness. I have some funds I inherited from my late husband, which I will need the help of a person like you to assist for this desired project, as my Doctor told me recently that I would not last due to the illness. Having known my condition, I decided to donate this fund to a good person that will utilize it the way I am going to instruct herein. I need a very honest and God fearing person who can use it for Charity works, for orphanages, widows and also build schools for less privilege that will be named after my late husband if possible.<br />The sum is currently deposited in an existing bank. Your role will be to:<br />[1]. Receive the funds into a business/private bank account.<br />[2]. Invest/donate the funds to any orphanage home.<br />[3]. Value of funds: (USD) $10.5 Million.<br />I accept this decision because I do not have any child who will inherit this money after me.<br />Please I want your sincerely and urgent answer to know if you will be available for this project, and I will give you more information on how the fund will be transferred to you. And everything will be done legally to ensure that the funds are transferred to you.<br />I am waiting for your reply.<br />Thank you,<br />Mrs. Sarah Al moubi.<br /><br />并不知道是我的哪个邮箱收到的，所以猜不出是什么网站上得到的邮箱。<br />我到底该不该相信呢？","tags": "Email","url": "blog/2016-10-30/strange-email.html"},
{"title": "无尽的黄金","text": "无尽的黄金 (gold.cpp/in/out)<br />时间限制：3s / 空间限制：512MB / 打开-O2优化<br />题目描述<br />探险家Lunk发现了一个藏在大山深处的洞穴。经过五天五夜的探索，Lunk在洞中发现了一个非常神奇的地方。这里有一个不断生成黄金的小口，每分钟可以取出一个黄金，不然这个黄金就会马上消失。取出的黄金自然会变成Lunk的了。贪婪的资本家绝对不会错过这个发财的大好时机，Lunk想要取走大量的黄金。<br />然而在这旁边却立着一个牌子，上面写着：<br /><br />Hello, Lunk,<br />恭喜你，你非常机智地发现了这个奇妙的地方，我早已知道你到底想干什么。不如我们来玩个游戏，你可随意取走黄金，但是任意连续的$K$分钟内，你不可以取走过多的黄金，否则，你将找不到出去的路。<br />Best wishes<br />——XL<br /><br />这让Lunk感到十分害怕，它担心自己一不留神就会触犯的这个可怕的规则。但是贪婪的资本家是不会放弃的，Lunk想知道究竟有多少种取走黄金的方法（可以全都不取），使得自己不会葬身于山洞之中。<br />Lunk现在还有一些时间，希望你能够快速给出答案。<br />输入格式<br />每个数据仅一行，包含三个整数$T$，$K$和$C$。<br />$T$表示Lunk还剩下的时间，单位为分钟。<br />$K$和$C$表示Lunk在任意连续的$K$分钟内可以取走少于$C$个黄金。<br />输出格式<br />输出一行一个整数，表示Lunk取走黄金的方案数。由于答案可能非常大，所以请将答案对$1073741824$取模。<br />样例输入<br />12 2 2<br /><br /><br />样例输出<br />13<br /><br /><br />样例解释<br />只要Lunk不把所有黄金取走就好了，共有三种取法。<br />数据限制<br />本题采用捆绑测试，共$6$个子任务。<br />每个子任务和数据点约定如下：<br /><br /><br /><br />子任务 (分值)<br />$T$的限制<br />$K$的限制<br />$C$的限制<br /><br /><br /><br /><br />$1$ ($10\\% $)<br />$\\le 10^3$<br />$= 2$<br />$= 2$<br /><br /><br />$2$ ($10\\% $)<br />$\\le 10^3$<br />$= 3$<br />$= 2$<br /><br /><br />$3$ ($10\\% $)<br />$\\le 10^3$<br />$\\le 9$<br />$\\le K$<br /><br /><br />$4$ ($20\\% $)<br />$\\le 10^5$<br />$\\le 9$<br />$\\le K$<br /><br /><br />$5$ ($20\\% $)<br />$\\le 2 \\times 10^7$<br />$\\le 6$<br />$\\le K$<br /><br /><br />$6$ ($30\\% $)<br />$\\le 2 \\times 10^7$<br />$\\le 9$<br />$\\le K$<br /><br /><br /><br />对于$100\\% $的数据，均保证$1 \\le T \\le 2 \\times 10^7$，$1 \\le K \\le 9$，$0 \\le C \\le K$。<br />时间限制：$2\\text{s}$<br />空间限制：$512\\text{MB}$","tags": "Problems","url": "blog/2016-10-3/gold.html"},
{"title": "替罪羊树(Scapegoat Tree)","text": "替罪羊树(Scapegoat Tree)<br />热身：线性时间建树<br />问题 给定有序排好的元素序列，现在要你在$ \\Theta(n) $的时间内建立一棵平衡的二叉搜索树。<br />最朴素的做法就是将元素逐一插入，由于许多平衡树的插入是$O(\\log n)$的，因此总时间复杂度为$O(n\\log n)$的。<br />考虑到元素已经是排好序的，我们可以在这里做点优化。<br />众所周知，二叉搜索树是有序的，即它的中序遍历是有序的。那么在它的中序遍历中，假设一个节点所处的位置为$i$，那么$i-1$就是它的左子树的大小，$n-i$就是右子树的大小。<br />现在我们希望建一棵平衡二叉树，所以左右子树的大小应当相近。最优的情况为左右子树大小一致，此时该节点在中序遍历的最中间。<br />于是我们得到了一个较好的算法，就是选取中间的元素作为根节点，将序列切为两部分，递归的建立左右子树即可。对于每个元素需要花费$\\Theta(1)$的时间来建立，总共有$\\Theta(n)$个节点。因此该算法的时间复杂度为$\\Theta(n)$。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14def build(s):<br />    return build(s, 1, len(s))<br /><br />def build(s, left, right):<br />    if right < left:<br />        return None<br /><br />    mid = (left + right) / 2<br />    node = new Node()                      # 新建节点<br />    node.left = build(s, left, mid - 1)    # 递归建立左子树<br />    node.right = build(s, mid + 1, right)  # 递归建立右子树<br />    node.update()                          # 对该节点做必要的更新<br /><br />    return node<br /><br /><br />α权重平衡<br />上面的热身非常简单。下面要讲的替罪羊树其实也很简单。在介绍替罪羊树之前，我们先了解下它的一个基本理论：α权重平衡(α-weight-balanced)。下文所述的平衡均为α权重平衡。<br />我们认为一棵树$x$是平衡的当且仅当它每一棵子树满足下列条件：<br />$$<br />\\begin{align}<br />\\text{size}(x.\\text{left}) &\\le \\alpha \\cdot \\text{size}(x) \\\\<br />\\text{size}(x.\\text{right}) &\\le \\alpha \\cdot \\text{size}(x)<br />\\end{align}<br />$$<br />其中，$ \\alpha \\in [0.5, 1] $。<br />这个$\\alpha$可能会令人非常疑惑。我们首先来思考一下两个极值：$1$和$0.5$。<br />当$a = 1$时，无论什么二叉树都会被视为平衡的，因为左右子树的大小不会超过这棵树的大小。这正对应着普通的二叉搜索树。<br />而当$ a = 0.5$时，这时的要求将非常严格，左右子树的大小都必须是这棵树的大小的一半，此时只有完全二叉树能满足平衡要求。AVL树就是尝试保持这种平衡。<br />我们都知道，二叉搜索树极易退化，而AVL树又为了平衡导致常数相当大，并且代码又臭又长，几乎没有人写。<br />作为AVL树的改进，红黑树并不追求完美的平衡。通过放宽一些严格的平衡限制，保证了$ \\alpha = 0.666\\dots $的平衡，同时降低了常数，有着优良的性能。现在绝大多数语言的标准库都有它的身影。然而，红黑树对于OI竞赛而言代码量太大，不适合现场发挥。<br />较为常用的Treap和Splay树则对$ \\alpha$没有强制的限定，它们利用随机化的思想来使树尽可能平衡，即它们会尽量使$\\alpha$值降低。我粗略测定了Treap、非旋转式Treap和Splay的$\\alpha$。结果如下：<br /><br /><br /><br />BST \\ 测试<br />1<br />2<br />3<br />4<br />5<br />平均<br /><br /><br /><br /><br />Splay(5个不同数据）<br />0.758<br />0.588<br />0.582<br />0.612<br />0.759<br />0.659<br /><br /><br />Treap（同一个数据）<br />0.766<br />0.578<br />0.601<br />0.587<br />0.781<br />0.662<br /><br /><br />非旋转式Treap（同一个数据）<br />0.914<br />0.860<br />0.613<br />0.678<br />0.803<br />0.773<br /><br /><br /><br />以上的结果仅供参考。可见一般的BST都能够使$\\alpha$维持在$0.6$到$0.7$之间。  <br />替罪羊树<br />替罪羊树是一种平衡二叉树，它有一个很大的特点，就是它可以人为设定一个$\\alpha$值，并且它会在操作中来维护指定的平衡。个人感觉替罪羊树“又懒又暴力”，但经过实测，它的速度完全不亚于上面提及的BST。<br />暴力重构<br />替罪羊树之所以能维持平衡，就是因为它把不平衡的树都暴力重构成一棵完全二叉树！<br />但是这样一来时间复杂度就会暴涨。因此替罪羊树应当设置一个合适的$\\alpha$值，避免过多的重构，从而均摊时间复杂度。可以证明，只要$\\alpha$设置合理，替罪羊树的所有操作都是$O(\\log n)$的。<br />首先考虑如何重构。在之前线性时间建树的基础上，我们先将树的中序遍历给复制出来，然后就可以直接在这个基础上重建。<br />查询<br />替罪羊树的查询和二叉搜索树一模一样，毕竟查找不会导致树的不平衡，那么它也没有必要进行重构。<br />插入<br />替罪羊树的插入操作和二叉搜索树是差不多的，只是最后要检查回溯时的树链上有哪棵子树违反了平衡。然后直接将其重构即可。<br />在重构时你可能会考虑到一条树链上可能有多个子树违反了平衡。对此，你只需要将最大的那棵子树重构即可。但是这样在实际代码中会略显复杂。如果你想偷懒，就只在回溯时找到了第一棵不平衡的树重构也是可以的。因为在替罪羊树中，同时出现几个不平衡的子树的情况也不是很多。在实际测试中，偷懒的写法在上千万的数据量下性能差距小于1s。<br />删除<br />替罪羊树的删除操作很好的体现了Lazy思想。它在删除节点时，并不是真正的删除，而是将其标记。此后所有的操作都将其无视，重构就直接丢弃，除非有插入操作将其恢复。当然我们不能无止尽地进行标记。如果被标记的节点数超过了整棵树大小的一半，我们就直接将整棵树重构，同时清除删除的节点。<br />实现细节及其时间复杂度<br />节点定义<br />除了存储键值外，我们还需要存储树的大小和删除标记。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25struct Node<KeyType, ValueType>:<br />    key:     KeyType    # 键<br />    value:   ValueType  # 值<br />    size:    int        # 树的大小<br />    deleted: bool       # 删除标记<br />    left:    Node       # 左子树<br />    right:   Node       # 右子树<br /><br />    def update(self):<br />        self.size = self.left.size + self.right.size<br /><br />        if not self.deleted:  # 如果自己不是被删除的节点<br />            self.size += 1<br /><br /># 空结点<br />struct NoneNode<*, *>:<br />    key     = None<br />    value   = None<br />    size    = 0<br />    deleted = True<br />    left    = NodeNode()<br />    right   = NodeNode()<br /><br />    def update(self):<br />        pass<br /><br /><br />选定α<br />替罪羊树的好处在于我们有了更好的调控能力。$\\alpha$这个值可以选取$0.5$到$1$中的任意一个值。一般情况下选取$0.7$到$0.8$最佳。我们可以根据实际需要来作出适当调整。$\\alpha$越大插入速度就越快，而访问和删除速度就会降低。反之则插入变慢。这里我们选择$0.75$：<br />1ALPHA = 0.75<br /><br /><br />重构<br />重构操作十分简单，只需要中序遍历一遍就可以重建树了。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21# 中序遍历<br />def travel(h, s):<br />    if h is NoneNode:<br />        return<br /><br />    travel(h.left, s)<br />    if h is not deleted:  # 忽略删除的节点<br />        s.append(h)<br />    travel(h.right, s)<br /><br />    if h is deleted:<br />        del h<br /><br />def refact(h):<br />    assert h is not NoneNode<br /><br />    s = []<br />    travel(h, s)<br /><br />    # 重建<br />    return build(s)<br /><br /><br />插入<br />插入操作与二叉搜索树一致，只是在最后要重新从顶向下检查一遍是否有不平衡的子树。如果有就重构。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12def check(h, key):<br />    if h is NoneNode:<br />        return NoneNode()<br />    elif max(h.left.size, h.right.size) > ALPHA * h.size:<br />        return refact(h)<br />    elif key < h.key:<br />        h.left = check(h.left, key)<br />    elif key > h.key:<br />        h.right = check(h.right, key)<br /><br />    h.update()<br />    return h<br /><br /><br />删除<br />当我们命中删除的节点时，直接将其作删除标记，然后退回。删除结束后，检查整棵树中被删除的节点数是否超过了总结点数的一半，如果超过就整体重构。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12# 命中时<br />h.deleted = True<br />h.update()<br />deleted_count += 1<br /><br /># ...<br /><br /># 删除完后<br />if deleted_count > size / 2:<br />    tree = refact(tree)<br />    size -= deleted_count<br />    deleted_count = 0<br /><br /><br />时间复杂度<br />替罪羊树的所有操作均摊复杂度为$O(\\log n)$。<br /><br /><br /><br />操作<br />时间复杂度（均摊）<br /><br /><br /><br /><br />查询<br />$O(\\log n)$<br /><br /><br />插入<br />$O(\\log n)$<br /><br /><br />删除<br />$O(\\log n)$<br /><br /><br /><br />对于查询操作，因为替罪羊树是保持了$\\alpha$平衡的.只要$\\alpha$值是合理的，那么这棵树就能保持比较平衡的状态，故插入是$O(\\log n)$的。<br />对于插入操作，我们假设一个刚好重构过的子树的大小为$x$。在最坏情况下，我们可以向它的一侧不停的插入节点。假设当向一侧插入了$k$个节点时恰好破坏了平衡，那么此时$k$将满足：<br />$$ \\left\\lfloor\\frac{x}{2}\\right\\rfloor + k \\gt \\alpha \\cdot (x + k) $$<br />即<br />$$ k > {\\alpha - \\frac{1}{2} \\over 1 - \\alpha}x $$<br />因此每${\\alpha - \\frac{1}{2} \\over 1 - \\alpha}x $次就会进行一次重构。重构的时间复杂度为$\\Theta(x)$。我们均摊它的时间复杂度：<br />$$ {\\Theta(x) \\over (\\alpha - \\frac{1}{2}) / (1 - \\alpha) \\cdot x} = \\Omega(1) \\; (\\alpha = 0.75) $$<br />因此最好情况下我们可以均摊到$\\Omega(1)$。由于树能保持$\\alpha$平衡，因此插入操作的时间复杂度为$O(\\log n)$。<br />同时我们可见，$\\alpha$越大，均摊的常数就会越低。<br />对于删除操作，我们假设我们进行了$\\frac{n}{2}$次删除，并且为此触发了重构。由于每次删除的时间复杂度为$O(\\log n)$的，因此总的时间复杂度为：<br />$$ \\sum_1^{\\frac{n}{2}} O(\\log n) + \\Theta(n) = \\frac{n}{2}O(\\log n) + \\Theta(n) $$<br />我们将其均摊到$\\frac{n}{2}$次操作上：<br />$$ {\\frac{n}{2}O(\\log n) + \\Theta(n) \\over \\frac{n}{2}} = O(\\log n) + \\Theta(1) = O(\\log n) $$<br />最终的时间复杂度为$ O(\\log n) $。<br />更多操作<br />替罪羊树作为一种“又懒又暴力”的平衡二叉树，代码简单易于实现，并且性能十分不错。当然我们会想拓展更多的操作。当然，由于替罪羊树只会定时重构，不依赖其它的操作，因此可以扩展许多操作。下面列举一些：<br /><br />rank取排名：记录了子树的大小就可$O(\\log n)$求出了。  <br />第k大：记录了size可以$O(\\log n)$求出。  <br />split拆分：非旋转式Treap的搞法即可，$O(\\log n)$。  <br />merge合并按照可合并堆的搞法即可，$O(\\log n)$。  <br />slice提取区间Splay乱搞，$O(\\log n)$。  <br />各种区间操作，乱套各种树…$O(\\log n)$、$O(\\log n)$、$O(\\log n)$…  <br />…  <br />（当然有些时候何苦来乱搞）<br />","tags": "算法 数据结构 替罪羊树","url": "blog/2016-4-6/scapegoat.html"},
{"title": "最小费用最大流","text": "最小费用最大流<br />之前一直想不明白最小费用流，今天翻了很多资料才理解了，在此做点记录。<br />最小费用流<br />我们首先定义流$f$的费用$w(f)$为：<br />$$<br />w(f) = \\sum_{(u,v)\\in f} w(u,v)f(u,v)<br />$$<br />那么最小费用（可行）流就是指一个在所有同流量的流中费用最小的流。<br />最小费用最大流问题<br />在给定的流网络$G$中，若$(u,v)\\in E$，则$c(u,v)$表示其容量，$w(u,v)$表示其单位流费用。设$f$为其中的可行流，最小费用最大流问题就是要求在使$f$为最大流的情况下，其总费用$w(f)$最小。<br />增广路算法<br />本文中我们只讨论增广路算法。最小费用流还有消圈法和神奇的ZKW算法。<br />增广路算法有一个贪心的基本思想：已知一个最小费用流$f$，在流网络中找出一条费用最小的增广路对其增广得到$f^,$，那么$f^,$也是最小费用流。<br />这个结论是显而易见的，因为原流费用最小，增广出来的新流费用也最小，那么总费用也是最小的。<br />因此，寻找最小费用最大流的思路就出来了：<br /><br />初始化零流$f$ <br />寻找费用最小的增广路，如果没有则表明$f$已为最大流  <br />增广流$f$，跳至第二步<br /><br />在上面的步骤中，第二步是关键。<br />我们首先要确定费用最小的衡量标准。首先考虑一条增广路会对流增加多少的费用。<br />假设$p$是一条增广路，其瓶颈边（即剩余容量最小的边）的容量为$c_{min}$，那么增加的费用就是所有边所产生的费用之和：<br />$$w(p) = \\sum_{(u,v)\\in p} w(u,v)c_{min} = c_{min}\\sum_{(u,v)\\in p} w(u,v)$$<br />由于我们要保证每一步都是最小费用流，而流的大小并不在意，因为最后肯定能达到最大流。<br />故我们不在乎每次流的增量$c_{min}$，而只要使单位费用之和最小即可。<br />因此我们把每条弧的单位费用作为其边权，然后寻找一条从源点到汇点的最短路，这样就能使单位费用之和最小。<br />实现细节<br />现在我们来尝试实现增广路算法，首先我们定义边的结构体：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8# 表示有向边<br />class DirectedEdge(object):<br />    u:int                      # 出发点<br />    v:int                      # 进入点<br />    capacity:int               # 容量<br />    flow:int                   # 现有流量<br />    cost:int                   # 单位流费用<br />    reverse_edge:DirectedEdge  # 表示其在残留网络中的反向边<br /><br /><br />我们添加一个函数，计算边的的剩余流量：<br />1<br />2def r(edge:DirectedEdge):<br />    return edge.capacity - edge.flow<br /><br /><br />在残留网络中，如果剩余容量为0,它就已经不存在了。<br />我们使G为一个有向边链表的数组，表示从某个点出发的边集合。<br />现在思考下残留网络中反向边的费用。反向边本意是为了最大流算法能重新调整整个流，让算法能够“反悔”，<br />因此我们给反向边的费用为-cost，能够与之前的选择抵消。这样导致出现了负边，因此找最短路不能使用Dijkstra算法，<br />为了方便，我们添加一个add_edge函数来添加边：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10def add_edge(u:int, v:int, capacity:int, cost:int):<br />    e  = DirectedEdge(u, v, capacity,  cost, flow=0)         # 初始为零流<br />    re = DirectedEdge(v, u, capacity, -cost, flow=capacity)  # 注意是反向边<br /><br />    # 设置反向边<br />    e.reverse_edge = re<br />    re.reverse_edge = e<br /><br />    G[u].append(e)<br />    G[v].append(re)<br /><br /><br />这样就可方便的添加边<br />最好采用Bellman Ford算法，这里使用其改进版SPFA算法：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23dist:int[]             = [INFTY...]  # 距离数组<br />edge_to:DirectedEdge[] = [None...]   # 前趋边数组<br /><br />def SPFA(s:int, t:int):<br />    q:queue<br />    q.push(s)<br />    dist[s] = 0<br /><br />    while q not empty:<br />        u:int = q.pop()<br /><br />        for edge in G[u]:<br />            if r(edge) == 0:  # 如果剩余容量为0,这条边就不存在<br />                continue<br /><br />            # 松弛操作<br />            v:int = edge.v<br />            if dist[v] > dist[u] + edge.cost:<br />                dist[v]    = dist[u] + edge.cost<br />                edge_to[v] = edge  # 更新前趋边<br /><br />                if v not in q:<br />                    q.push(v)<br /><br /><br />接下来就可以写最小费用最大流算法了：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33s:int  # 源点<br />t:int  # 汇点<br /><br />def compute_maxflow():<br />    answer:int = 0<br /><br />    while True:<br />        SPFA(s, t)  # 寻找增广路<br /><br />        if dist[t] == INFTY:  # 如果没有增广路，s到t的距离就不会更新<br />            return<br /><br />        minflow:int = INFTY  # 瓶颈边容量<br /><br />        # 寻找瓶颈边<br />        x:int = t<br />        while edge_to[x] is not None:<br />            minflow = min(minflow, r(edge_to[x]))<br /><br />            x = edge_to[x].u<br /><br />        # 增广<br />        x = t<br />        while edge_to[x] is not None:<br />            DirectedEdge e = edge_to[x]<br /><br />            answer += minflow * e.cost  # 更新总费用<br />            e.flow += minflow<br />            e.reverse_edge.flow -= minflow<br /><br />            x = edge_to[x].u<br /><br />    return answer<br /><br /><br />至此，增广路算法就结束了。现在总结下其中涉及到的关键：<br />1. 贪心选择：每次寻找费用最少的增广路<br />2. 反向边边权：是相反的<br />3. SPFA: 寻找最短路","tags": "算法 网络流 最小费用流 图论","url": "blog/2016-2-2/mincost-maxflow.html"},
{"title": "最近公共祖先(LCA)","text": "最近公共祖先(LCA)<br />1 概述<br />1.1 什么是LCA？<br />下面是一棵有根树，注意不一定是二叉树。<br /><br />我们先定义深度函数$ d(u): u \\text{到根的最短距离} $。<br />例如，在上图中$ d(1)=0,\\,d(3)=1,\\,d(9)=3$<br />我们再定义一个函数$ LCA(u, v) $表示节点$ u $和$ v $的最小公共祖先。<br />其定义为：<br />$$ LCA(u,v):u和v的所有祖先p中,d(p)最大 $$<br />举个例子：$ LCA(5,6)=3,\\,LCA(7,6)=3,\\,LCA(1,8)=1 $<br />应该很简单吧。<br />1.2 有什么卵用？<br />一个简单的例子，计算完LCA后，可以在$ \\Theta (1) $的时间内算出任意两点的距离。<br />还是下面这个图解释：<br /><br />上面的树边上带了权重，两点之间的距离就是两点间的简单路径上的边权之和。<br />例如$ distance(1,1)=0,\\,distance(2,3)=3,\\,distance(7,6)=6$<br />如果用DFS或BFS来计算的话，需要$ O(n) $的时间复杂度。<br />如果先预处理LCA，就只需$ \\Theta (1) $的时间。<br />先不考虑是如何算出LCA的，先讲下如何快速求距离。<br />上图中，dist数组表示节点到树根的距离，在图中已经计算出来。<br />这个数组很好计算，根据下面的公式直接将树BFS一遍即可，其中$ u $是$ v $的父节点，$w[u, v]$表示$ u $到$ v $的边权。<br />$$ dist[v] = dist[u] + w[u,v] \\tag{1.1}$$<br />那么两点之间的距离$ distance(u,v) $的计算非常简单：<br />$$ distance(u,v) = dist[u] + dist[v] - 2 \\times dist[LCA(u, v)] \\tag{1.2} $$<br />可以想象成是Link这个人从$ u $先走到根节点，再从根节点走到$ v $。由于从根节点到$ LCA(u,v) $走了两遍，因此Link走的总路程，减去这一段来回走的即可。<br />1.3 预备知识<br />因为LCA的算法中会用到并查集，但我们还没学，因此并查集的实现不会过多纠结，我们只需知道并查集提供的几个函数即可。<br />并查集提供查询和连接操作：<br />1<br />2def find(u) -> int<br />def union(u, v) -> void<br /><br /><br /><br /><br />find函数会返回节点u所在的集合编号，如果find(a) == find(b)则表示a和b处在一个集合中。<br /><br /><br />union函数会将u和v所在的集合并起来，即使u和v处在一个集合中。<br /><br /><br />后面会提到在线和离线的概念，只要知道离线是先将所有操作读入后再作处理就行了。<br />2 LCA算法<br />计算LCA的算法有很多，这里介绍三个。<br />2.1 朴素算法<br />朴素算法是最简单的了，按照国际惯例，先放图：<br /><br />朴素算法的做法如下：<br /><br /><br />先将两个结点调为同一深度<br />将两个结点同时上调，直到这两个结点到达同一位置时，此时即为LCA<br /><br /><br />伪代码如下：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14def Plain_LCA(u, v):<br />    if d(u) < d(v):<br />        swap(u, v)  # 始终保持u所处的深度较深<br /><br />    while d(u) != d(v):<br />        u = father(u)  # 将u上调<br /><br />    # 将u和v同时上调<br />    while u != v:<br />        u = father(u)<br />        v = father(v)<br /><br />    # 最后会使u == v，即他们到达了LCA<br />    return u<br /><br /><br />2.2 离线算法：Tarjan-LCA<br />朴素算法很简单，大多数情况下能很快算出LCA。<br />然而在计算$ LCA(4,6) $时，需要从树的底部走到根节点。<br />因此朴素算法的时间复杂度为$ O(n) $，很容易TLE。<br />因此我们的前人想出了机智的Tarjan-LCA算法！<br />Tarjan-LCA算法比较难理解，最好的理解方法是手动模拟一下。<br />先放出伪代码：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18def Tarjan_LCA(u):<br />    # ancestor数组表示一个集合的公共祖先<br />    # 如anscestor[i]表示标号为i的集合中所有结点的公共祖先。<br />    # marked数组表示结点是否被处理过<br /><br />    anscestor[find(u)] = u<br /><br />    for v in u.children:  # 遍历u的儿子节点<br />        Tarjan_LCA(v)<br />        union(u, v)<br />        anscestor[find(u)] = u<br /><br />    marked[u] = true<br /><br />    # query数组表示查询操作，保存的是(x, y)，表示要计算LCA(x, y)<br />    for (x, y) in query:<br />        if y == u and marked[x] == True:<br />            LCA(x, y) = LCA(y, x) = anscestor[x]<br /><br /><br />这个算法的进行类似于DFS，是个递归调用的过程。<br />因为DFS总是先将小的子树遍历完，因此anscestor数组中的祖先都是尽可能小的。<br />拿一棵较小的子树作为示例：<br /><br />一开始先DFS到7处。<br /><br />处理到7时还并没有什么结点被处理过，只好默默的回到5。<br /><br />5处将7和自己相连，形成集合{5, 7}，5是这个集合的公共祖先。<br /><br />现在DFS到9。<br /><br />假设我们询问了$ LCA(7,9) $，那么在处理9时，会发现7被处理过了，7所在的集合的公共祖先为5。<br />而9是从5递归下来的，因此9与7的公共祖先中有5。<br />又因为DFS会尽可能的处理较小的子树，因此5将会是$ LCA(7, 9) $。<br />剩下的步骤都是一样的，大家可以自己手推一下。<br />为了方便理解，大家可以将Tarjan-LCA算法换个说法：<br /><br />一个熊孩子Link从一棵有根树的最左边最底下的结点灌岩浆，Link表示很讨厌这种倒着长的树。<br />岩浆会不断的注入，直到注满整个树…<br />如果岩浆灌满了一棵子树，Link发现树的另一边有一棵更深的子树，Link会先去将那棵子树灌满。<br />岩浆只有在迫不得已的情况下才会向上升高，找到一个新的子树继续注入。<br />机(yu)智(chun)的Link发现了找LCA的好方法，即如果两个结点都被岩浆烧掉时，他们的LCA即为那棵子树上岩浆最高的位置。<br /><br />Tarjan-LCA算法能在$ \\Theta (n + q) $时间内计算出所有询问的LCA，其中$ q $为询问总数。<br />这得益于并查集的高效。<br />同样我们也能以此算出所有点对的LCA。<br />2.3 在线算法：倍增法<br />Tarjan-LCA算法速度很快，效果也很好，但有一个致命的问题…<br />就是内存占用。<br />首先它需要离线操作，如果空间比较紧且操作较多时，显然不合适。<br />另外，如果要处理任意结点对的LCA，就需要一个巨大的二维数组来存储，这意味着如果$ n > 10000 $此算法将报废。<br />但如果用朴素算法，就又太慢了…<br />这时，倍增法就来拯救世界了。<br />倍增法能以$ \\Theta (\\log n) $的时间复杂度和$ \\Theta (n \\log n) $的空间复杂度内完成LCA的计算。<br />相比与Tarjan-LCA的$ \\Theta (n^2) $的空间复杂度，能节省更多的空间。<br />并且它是在线算法，弥补了LCA算法的不足。<br />倍增法运用了动态规划的思想，并利用二进制达到了$ \\Theta (\\log n) $的时间复杂度。<br />2.3.1 预处理<br />倍增法首先需要计算一个f数组，其含义为：<br />$$ f[i, j] : 离节点i相距2^j的父节点 $$<br />换言之<br />$$ distance(i, f[i, j]) = 2^j \\tag{2.1} $$<br /><br />又是这个图。我们将树上的每一条边的长度都视为1，那么$ f[7, 0] = 5,\\,f[7, 1] = 3 ... $，<br />因此节点$ 5 $到$ 7 $的距离为$ 1 = 2^0 $，节点$ 3 $到$ 7 $的距离为$ 2 = 2^1 $。<br />由此我们可以观察到f数组的一个特点：$ f[i, 0] $就是$ i $的父节点。<br />为了算出f数组，我们有如下的状态转移方程：<br />$$ f[i,j] = f[f[i, j - 1], j - 1] \\tag{2.2} $$<br />如何理解这个转移方程呢？<br />我么设$ u = f[i,j],\\,v=f[i, j-1] $，<br />那么，根据$ (2.1) $式可得：<br />$$<br />\\begin{align}<br />distance(i, v) & = 2^{j-1} \\\\<br />distance(i, u) & = 2^j \\\\<br />distance(v, u) & = distance(i, u) - distance(i, v) \\\\<br />&                = 2^j-2^{j-1} \\\\<br />&                = 2^{j-1} \\times 2 - 2^{j-1} \\times 1 \\\\<br />&                = 2^{j-1} \\\\<br />&                \\Rightarrow u = f[v, j - 1] \\\\<br />&                \\Rightarrow u = f[f[i, j-1],j-1]<br />\\end{align}<br />$$<br />即证明$ (2.2) $式。<br />利用得到的状态转移方程，我们可以在$ \\Theta (n \\log n) $的时间内推出f数组。<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8# 初始化f[i, 0]<br />for i in [1, n]:<br />    f[i, 0] = father(i)<br /><br /># 计算整个f数组<br />for j in [1, log(n)]:<br />    for i in [1, n]:<br />        f[i, j] = f[f[i, j - 1], j - 1]<br /><br /><br />2.3.2 在线算法<br />得到了f数组后，倍增法也就完成了50% 了，剩下的任务就是计算LCA。<br />事实上，倍增法计算LCA的过程与朴素算法一样，也是要先调制同一深度，再同时上调。<br />而巧妙的是倍增法利用算出的f数组来加速提升的过程，使得节点的上升的距离可以达到$ 2^j $，而不是一格一格往上调。<br />思路已经很清晰了，然而难在如何运用f数组。<br />下面的伪代码展示了倍增法求LCA的过程：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21def Double_LCA(u, v):<br />    if d(u) < d(v):<br />        swap(u, v)  # 始终保持u所处的深度较深<br /><br />    # 将u上调dist个距离<br />    dist = d(u) - d(v)<br />    for i in [0, log(n)]:<br />        if (1 << i) & dist  # KEY #1<br />            u = f[u, i]<br /><br />    if u == v:<br />        return u  # 特判此时u, v是否在同一位置，如果是，u和v都站在LCA上<br /><br />    # 将u和v同时上调<br />    for i from log(n) to 0:<br />        if f[u, i] != f[v, i]:  # KEY #2<br />            u = f[u, i]<br />            v = f[v, i]<br /><br />    # 最后会使u和v成为LCA的子节点<br />    return f[u, 0]<br /><br /><br />在代码中有两处比较奇特的地方，被注释打上了KEY。<br />先看KEY #1，这里的代码是尝试将$ u $与$ v $调制统一高度，而这里出现的位运算令人十分费解。<br />首先我们思考一下二进制：<br />对于一个二进制数$ k $，设其从右往左数的第$ i $位为$ k_i $，则当$ k_i = 1 $时，$ k - 2^i $的第$ i $位为$ 0 $。<br />例如，对于二进制数$ 110010_{(2)} $，第$ 2 $位为$ 1 $，$ 2^2 = 10_{(2)} $，$ 110010_{(2)} - 10_{(2)} = 110000_{(2)} $，我们发现这个二进制数的第$ 2 $位变成了$ 1 $。<br />利用这个特性，我们可以逐位将一个二进制数减成$ 0 $。<br />在上面的代码中，就这样逐步上调节点$ u $，并使最后的深度差dist变为$ 0 $。<br />下面有一张样例：<br /><br />再来看KEY #2，此时$ u $和$ v $处在同一深度上，$ j $从大到小逐一测试。<br />我们试图使$ u $和$ v $尽可能靠近LCA，但又不直接到达LCA。<br />如果说$ 2^j $的距离上，$ u $和$ v $的父节点相同，则这个父节点是它们的公共祖先，如果跳上去就有可能超过LCA了，因此忽略。<br />如果说$ 2^j $的距离上，$ u $和$ v $的父节点不同，则$ f[u, j] $和$ f[v, j] $的LCA也是$ u $和$ v $的LCA，因此可以将$ u $和$ v $上移至该位置，不影响结果。<br />因为这两个节点到LCA的深度差可以被分解成多个$ 2 $的幂之和，因此我们有办法逐步将它们上移至LCA的位置。<br />但是为了方便判断是否跳的太远，我们不让它们最后跳到LCA的位置，而是跳到LCA的儿子节点处。<br />此时其父节点就是LCA。<br />下面有一张样例：<br /><br />至此，倍增法就结束了。<br />以上三种算法是比较常见的求LCA的算法。似乎二叉树还有一种分治的LCA算法，我没有做过多了解了。","tags": "算法 LCA","url": "blog/2016-2-1/lca.html"},
{"title": "有关多项式的算法","text": "有关多项式的算法<br />多项式<br />一个度数为$n$的多项式为最高项的次数为$n - 1$的多个$x$的幂次与对应系数之积的和，通常用大写字母表示多项式。<br />如，下式是一个度数为$4$的多项式。将$x^2$的系数设为$0$就可消除这一项。<br />$$ A(x) = 3x^3 + 2x + 1 $$<br />用$\\text{degree}(A)$来表示一个多项式的度数。一个多项式中会含有$\\text{degree}(A)$项。<br />通常有两种表示多项式的方法：系数表达和点值表达。<br />系数表达即按照从低次项到高次项1的顺序将每个项的系数放入一个向量中。如上面的多项式$A(x)$还可以表示成这样：<br />$$ \\hat A(x) = (1,\\;0,\\;2,\\;3) $$<br />点值表达，顾名思义就是给定一些点，计算出多项式在这些点的值。<br />计算多项式在一个点$x_0$处的值可以用秦九韶算法2:<br />$$ A(x_0) = a_0 + x_0(a_1 + x_0(a_2 + \\dots + x_0(a_{n-2} + x_0a_{n-1})\\dots)) \\tag{1.1}$$<br />这样可以在$\\Theta(\\text{degree}(A))$的时间内计算一个点处的值。<br />计算$n$个不同的点$x_0,\\;x_1,\\dots,\\;x_{n-1}$处的值$y_0,\\;y_1,\\dots,\\;y_{n-1}$，于是可以将多项式表示成$n$个二元组，二元组的第一项是选取的点$x_i$，第二项是该点计算出的值$y_i$。<br />因此之前的多项式可以表示成以下的形式：<br />$$ \\hat A(x) = \\{(0,\\;1),\\;(1,\\;6),\\;(2,\\;29),\\;(3,\\;88)\\} $$<br />可以证明，如果选择的求值点互不相同，那么一个含有$n$个元素点值表达会有唯一的度数为$n$的多项式。<br />因为点值表达可以用下面的矩阵方程表示出来：<br />$$<br />\\left[<br />\\begin{matrix}<br />1 & x_0 & x_0^2 & \\cdots & x_0^{n-1} \\\\<br />1 & x_1 & x_1^2 & \\cdots & x_1^{n-1} \\\\<br />\\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\<br />1 & x_{n-1} & x_{n-1}^2 & \\cdots & x_{n-1}^{n-1} \\\\<br />\\end{matrix}<br />\\right]<br />\\left(<br />\\begin{matrix}<br />a_0 \\\\<br />a_1 \\\\<br />\\vdots \\\\<br />a_{n-1}<br />\\end{matrix}<br />\\right)<br />=\\left(<br />\\begin{matrix}<br />y_0 \\\\<br />y_1 \\\\<br />\\vdots \\\\<br />y_{n-1}<br />\\end{matrix}<br />\\right)<br />\\tag{1.2}<br />$$<br />方程左边的矩阵是一个范德蒙德矩阵，其行列式的值为：<br />$$<br />\\prod_{0 \\le i < j < n} (x_j - x_i)<br />$$<br />因此只要$x_0,\\;x_1,\\;\\dots,\\;x_{n-1}$中没有相同的值，该矩阵的行列式就不会为$0$。<br />这意味着它一定会有一个逆矩阵，从而可以将方程右边的列向量乘以逆矩阵，就可以得到原多项式的系数向量。<br />多项式加法<br />多项式加法是很简单的，只需要将对应次数的项的系数相加即可。<br />如果是点值表达，则需要两个多项式的采样点是一样的，然后对应点的值才可以直接相加减，最后得到的是新的多项式的点值表达。<br />两个多项式$A(x)$和$B(x)$的加法可以在$\\Theta(\\max\\{\\text{degree}(A),\\;\\text{degree}(B)\\})$的时间内完成。<br />多项式乘法<br />如果采用系数表达，我们可以暴力地将多项式乘开然后合并同类项，这样可以在$O(\\text{degree}(A) \\cdot \\text{degree}(B))$的时间内完成。然而这个复杂度并不妙。<br />相反，如果采用点值表达，则只需要$\\Theta(\\max\\{\\text{degree}(A),\\;\\text{degree}(B)\\})$的时间，因为我们只要将对应采样点的值相乘就会得到新多项式的点值表达。<br />然而，点值表达方式并没有系数表达更有用。考虑能否利用点值表达的多项式乘法线性时间来加快系数表达的多项式乘法。<br />一个直接的方法就是先对原多项式在$\\text{degree}(A) + \\text{degree}(B)$个点3处采样，然后做完点值表达的乘法之后，又进行插值操作，这样就可以得到系数表达的结果了。<br />然而并没有什么很快的采样/插值算法，但是使用快速傅立叶变换可以在$\\Theta(n\\log n)$的时间内完成采样和插值。<br />复数<br />快速傅立叶变换是用于快速计算离散傅立叶变换 (DFT)的结果的算法。由于DFT涉及到复数的运算，因此这里先扯一点复数的基本知识。<br />首先定义单位复数根$i = \\sqrt{-1}$，可以将其想象成是垂直于实数轴的一个单位向量，因此所有的复数都是由$a + bi$这种形式给出的，其中$a$是实部，$b$是虚部。<br />单位复数根与自然对数的底数$\\text{e}$有着相当密切的关系，下面的公式就是欧拉公式：<br />$$ \\text{e}^{xi} = \\cos x + i\\sin x \\tag{3.1.1}$$<br />为了证明这个等式，首先考虑一下$i$的幂次的规律：<br />$$<br />\\begin{align}<br />& i^0 = 1,\\; i^1 = i,\\; i^2 = -1,\\; i^3 = -i \\\\<br />& i^4 = 1,\\; i^5 = i,\\; i^6 = -1,\\; i^7 = -i \\\\<br />& \\dots<br />\\end{align}<br />$$<br />我们注意到$i$的幂次是一个长度为$4$的循环节。考虑$\\text{e}$的无限展开式：<br />$$<br />\\begin{align}<br />\\text{e}^{xi} & = \\sum_{n=0}^{\\infty} {x^ni^n \\over n!} \\\\<br />& = 1 + xi - \\frac{x^2}{2} - \\frac{x^3}{6}i + \\dots \\\\<br />& = \\sum_{n = 2k,\\;k \\in \\mathbf{N}}^{\\infty} (-1)^k{x^n \\over n!} + i\\sum_{n = 2k + 1,\\;k \\in \\mathbf{N}}^{\\infty} (-1)^k{x^n \\over n!}<br />\\end{align}<br />$$<br />和式左边就是$\\cos x$的无限展开形式，而右边就是$\\sin x$形式。<br />因此：<br />$$ \\text{e}^{xi} = \\cos x + i\\sin x $$<br />为了方便之后的公式书写，这里定义$n$次单位复数根为：<br />$$<br />\\omega_n = \\text{e}^{2\\pi i/n}<br />\\tag{3.1.2}<br />$$<br />从几何的角度来讲，相当于将一个周角均分成$n$份，从每一个角度发出一个单位长度的向量。<br />$\\omega_8$的每一个幂次在平面上的情况如下图，注意$\\omega_8^0 = 1$。<br /><br />DFT<br />接下来介绍DFT。标准的DFT是作用在一个长度为$n$复数序列$\\{x_0,\\;x_1,\\;x_2,\\;\\dots,\\;x_{n-1}\\}$，将其变换为另一个复数序列$\\{X_0,\\;X_1,\\;X_2,\\;\\dots,\\;X_{n-1}\\}$，其定义如下：<br />$$<br />X_k = \\sum_{j=0}^{n-1} x_j\\omega_n^{-jk}<br />\\tag{3.2.1}<br />$$<br />我们当然可以从$\\{X_0,\\;X_1,\\;X_2,\\;\\dots,\\;X_{n-1}\\}$得到$\\{x_0,\\;x_1,\\;x_2,\\;\\dots,\\;x_{n-1}\\}$，即逆DFT：<br />$$<br />x_k = \\frac1n\\sum_{j=0}^{n-1}X_j\\omega_n^{jk}<br />\\tag{3.2.2}<br />$$<br />如何可以得到这个逆DFT公式呢？可以将DFT的过程视为一次矩阵乘法：<br />$$<br />\\left[<br />\\begin{matrix}<br />1 & 1 & 1 & \\cdots & 1 \\\\<br />1 & \\omega_n & \\omega_n^2 & \\cdots & \\omega_n^{n-1} \\\\<br />1 & \\omega_n^2 & \\omega_n^4 & \\cdots & \\omega_n^{2(n-1)} \\\\<br />\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\<br />1 & \\omega_n^{n-1} & \\omega_n^{2(n-1)} & \\cdots & \\omega_n^{(n-1)(n-1)}<br />\\end{matrix}<br />\\right]<br />\\left(<br />\\begin{matrix}<br />x_0 \\\\<br />x_1 \\\\<br />x_2 \\\\<br />\\vdots \\\\<br />x_{n-1}<br />\\end{matrix}<br />\\right)<br />= \\left(<br />\\begin{matrix}<br />X_0 \\\\<br />X_1 \\\\<br />X_2 \\\\<br />\\vdots \\\\<br />X_{n-1}<br />\\end{matrix}<br />\\right)<br />\\tag{3.2.3}<br />$$<br />设等式左边的矩阵为$V$，下面将证明其逆矩阵$V^{-1}$的元素$[V^{-1}]_{jk} = \\omega_n^{-jk} / n$：<br />因为<br />$$<br />[VV^{-1}]_{jk} = \\sum_{c=0}^{n-1}(\\omega_n^{jc})({\\omega_n^{-ck} \\over n}) = \\frac1n\\sum_{c=0}^{n-1}(\\omega_n^{j-k})^c<br />\\tag{3.2.4}<br />$$<br />由于几何级数的求和对复数也适用，所以：<br />$$<br />\\begin{align}<br />\\sum_{j=0}^{n-1}(\\omega_n^k)^j & = {(\\omega_n^k)^n - 1 \\over \\omega_n^k - 1} \\\\<br />& = {(\\omega_n^n)^k - 1 \\over \\omega_n^k - 1} \\\\<br />& = 0<br />\\end{align}<br />$$<br />注意，只有在$n \\not\\mid k$时上式成立。当$n \\mid k$时，$\\omega_n^k = 1$。<br />于是$V \\cdot V^{-1}$中只有$j = k$的位置为$1$，其余元素均为$0$，即单位矩阵。所以$V^{-1}$确实是$V$的逆矩阵。<br />FFT<br />如果根据DFT的定义来计算，需要$\\Theta(n^2)$的时间。可以利用复数的一些特殊性质，我们可以在$\\Theta(n\\log n)$的时间内计算DFT及逆DFT，这就是快速傅立叶变换 (FFT)。<br />下面为了讨论方便，假设所有的给FFT处理的序列长度都是$2$的某次幂。<br />快速傅立叶变换是基于分治思想的。算法首先将序列分为两部分，一部分的元素的下标为偶数，另一部分为奇数：<br />$$<br />\\begin{align}<br />A & = \\{x_0,\\;x_1,\\;x_2,\\;x_3,\\;x_4,\\;x_5,\\;x_6,\\;x_7\\} \\\\<br />A^{[0]} & = \\{x_0,\\;x_2,\\;x_4,\\;x_6\\} \\\\<br />A^{[1]} & = \\{x_1,\\;x_3,\\;x_5,\\;x_7\\}<br />\\end{align}<br />$$<br />可以注意到，下标为偶数就是下标的二进制表示的最后一位为$0$ (它们放入$A^{[0]}$)，奇数就是为$1$ (放入$A^{[1]}$)。<br />分成两部分后，对于每一部分递归求解。然后尝试将这两部分合并，得到原序列的DFT。<br />考虑假设我们获得了变换后的$A^{\\prime[0]}$和$A^{\\prime[1]}$。<br />$$<br />\\begin{align}<br />A^{\\prime[0]}(x) &= \\sum_{j=0}^{n/2-1}A^{[0]}_jx^j \\\\<br />A^{\\prime[1]}(x) &= \\sum_{j=0}^{n/2-1}A^{[1]}_jx^j<br />\\end{align}<br />$$<br />因此：<br />$$<br />A(x) = A^{\\prime[0]}(x^2) + xA^{\\prime[1]}(x^2) \\tag{4.3.1}<br />$$<br />将单位复数根带入：<br />$$<br />\\begin{align}<br />A^{\\prime[0]}(\\omega_n^{2k}) + \\omega_n^kA^{\\prime[1]}(\\omega_n^{2k}) &= A(\\omega_n^k) \\\\<br />A^{\\prime[0]}(\\omega_n^{2k}) - \\omega_n^kA^{\\prime[1]}(\\omega_n^{2k}) &= A^{\\prime[0]}(\\omega_n^{2k}) + \\omega_n^{k + n/2}A^{\\prime[1]}(\\omega_n^{2k}) \\\\<br />&= A^{\\prime[0]}(\\omega_n^{2k + n}) + \\omega_n^{k + n/2}A^{\\prime[1]}(\\omega_n^{2k + n}) \\\\<br />&= A(\\omega_n^{k+(n/2)})<br />\\end{align}<br />$$<br />由此我们获得了如何将两部分合并为一部分的方法。<br />对于逆变换，可以使用同样的方法，只是单位复数根的次数的符号恰好相反，并且最后需要对每一个数除以$n$。<br />FFT实现<br />递归式FFT<br />递归实现FFT的过程非常简单，首先判断序列长度是否为$1$，如果为$1$则直接返回。<br />否则按照下标的奇偶性分为两部分，然后递归求解。<br />最后合并这两部分的结果。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21function RECURSIVE-FFT(x, reverse = False):<br />    if x.length == 1:  # 如果长度为1<br />        return x<br /><br />    将序列分为a[0]和a[1]<br />    a'[0] = RECURSIVE-FFT(a[0])<br />    a'[1] = RECURSIVE-FFT(a[1])<br /><br />    X = [0..x.length - 1]<br />    if reverse:  # 如果是逆变换<br />        w_n = exp(0 + (-2 * pi / n)i)<br />    else:<br />        w_n = exp(0 + (2 * pi / n)i)<br />    w = 1<br />    for k in [0, x.length / 2 - 1]:<br />        t = w * a'[1][k]<br />        X[k] = a'[0] + t<br />        X[x.length / 2 + k] = a'[0] - t<br />        w *= w_n<br /><br />    return X<br /><br /><br />迭代式FFT<br />与递归式FFT相比，效率更高的是无需递归的迭代式。<br />首先考虑求值的顺序。对于一个下标而言，它的二进制表示实际上已经决定了它将要移动的路径。<br />即从低位开始，如果是$0$则向左运动，否则向右运动，然后检查其高位。<br />更进一步，观察划分完之后的序列，把每一个下标所对应的二进制翻转过来，这恰好是递增的顺序。<br />因此我们可以实现一个从高位到低位的加法器，从而计算下一个元素该是谁。<br />这个算法被称作雷德算法 (Rader’s algorithm)。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15function RADER(x):<br />    n = x.length<br /><br />    X = [0..n - 1]<br />    X[0] = x[0]<br />    rev = 0<br />    for i in [1, n - 1]:<br />        k = n / 2<br />        while k < rev:<br />            rev -= k<br />            k /= 2<br />        rev += k<br />        X[rev] = x[k]<br /><br />    return X<br /><br /><br />这样就可以按照顺序进行合并，第一次每$2$个进行合并，然后每$4$个进行合并， …，最后就是整体进行合并。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23function ITERATIVE-FFT(x):<br />    x = RADER(x)<br /><br />    n = x.length<br />    s = 2<br />    while s <= n:<br />        if reverse:  # 如果是逆变换<br />            w_n = exp(0 + (-2 * pi / n)i)<br />        else:<br />            w_n = exp(0 + (2 * pi / n)i)<br />        for i in [0, n] by s:<br />            left = i<br />            right = i + s - 1<br />            mid = (left + right) / 2<br />            w = 1<br />            for k in [0, mid - 1]:<br />                t = w * x[mid + k]<br />                x[mid + k] = x[left + k] - t<br />                x[left + k] = x[left + k] + t<br />                w *= w_n<br />        s *= 2<br /><br />    return x<br /><br /><br />多项式乘法<br />前面讲了那么多DFT，那多项式乘法与DFT有什么关系呢？<br />事实上，在多项式上采样实际上就是一次DFT的过程。<br />获得了点值表达之后，就可以在$\\Theta(n)$的时间内完成乘法。<br />最后进行一遍逆DFT可以得到结果！<br />时间复杂是$\\Theta(n\\log n)$的，$n$是两个多项式的度数和。<br />需要注意的是，上面的FFT需要序列长度为$2$的幂，解决方式就是将补$0$来完成。<br />实际实现中，需要注意$\\text{e}$的复数幂，即单位复数根的计算十分缓慢，因此对于递归式的FFT，需要先预处理每一层的单位复数根。<br /><br /><br /><br /><br />当然也可以从高次到低次，视情况选择方便的表示方法。 ↩<br /><br /><br />也称作霍纳法则。 ↩<br /><br /><br />因为新的多项式的度数为$\\text{degree}(A) + \\text{degree}(B)$。 ↩<br /><br /><br />","tags": "多项式 FFT","url": "blog/2016-7-21/fft.html"},
{"title": "极限与导数","text": "极限与导数<br />最近学了一些基础微积分，这里稍微记录一下。<br />极限<br />极限可以当做是一个函数$f(x)$的$x$无限趋近于某一个常数或无穷远处时，函数数值所逼近的一个值。<br />例如，对于函数$f(x) = {2x \\over x + 1}$，当$x$趋近于无穷大时，$f(x)$无限趋近于$2$。我们将此记成这样子：<br />$$<br />\\lim_{x \\rightarrow \\infty} f(x) = <br />\\lim_{x \\rightarrow \\infty} {2x \\over x + 1} = <br />2<br />$$<br />求极限需要会一点代数技巧，我反正是老是求不出......<br />极限有一些方便的性质：<br />当然，这些等式的左边都是存在极限的。<br />$$ \\lim_{x \\rightarrow c} a \\cdot f(x) = a \\cdot \\lim_{x \\rightarrow c} f(x) $$<br />对于两个函数$f(x)$和$g(x)$之间极限的关系：（当然$f(x)$和$g(x)$都要存在极限）<br />$$ \\lim_{x \\rightarrow c} [f(x) + g(x)] = \\lim_{x \\rightarrow c} f(x) + \\lim_{x \\rightarrow c} g(x) $$<br />$$ \\lim_{x \\rightarrow c} [f(x) - g(x)] = \\lim_{x \\rightarrow c} f(x) - \\lim_{x \\rightarrow c} g(x) $$<br />$$ \\lim_{x \\rightarrow c} f(x) \\cdot g(x) = \\lim_{x \\rightarrow c} f(x) \\cdot \\lim_{x \\rightarrow c} g(x) $$<br />$$ \\lim_{x \\rightarrow c} {f(x) \\over g(x)} = {\\lim_{x \\rightarrow c} f(x) \\over \\lim_{x \\rightarrow c} g(x)} \\; (\\lim_{x \\rightarrow c} g(x) \\neq 0)$$<br />简而言之，极限这东西可以加减乘除。<br />导数<br />对于函数$f(x)$而言，它在$x_0$处的导数是这么定义的：<br />$$ \\lim_{\\Delta x \\rightarrow 0} {f(x_0 + \\Delta x) - f(x_0) \\over \\Delta x} $$<br />从几何意义上讲，这个值可以视为是$f(x)$的图像在$x_0$处的切线的斜率。<br />当然不是所有的函数都是可以求导数的，只有在那一段上是连续的函数时，才会有导数。<br />连续的函数$f(x)$在其定义域内的每一点上都可以计算导数，意味着每一个$x$都会对应一个导数，这样就形成了一个函数关系。我们将这个函数叫作导函数，记作$f^\\prime(x)$。<br />如何求导函数呢？根据导数的定义，我们将$x_0$换为$x$，然后求极限就好了。然而说的轻巧，实际上很多都比较难以求出，因此早有先人为我们把各种导函数算好了。<br />举一个典型的例子$f(x) = x^2$。按照求导数的方法：<br />$$<br />\\begin{align}<br />f^\\prime(x) &= \\lim_{\\Delta x \\rightarrow 0} {f(x + \\Delta x) - f(x) \\over \\Delta x} \\\\<br />&= \\lim_{\\Delta x \\rightarrow 0} {(x + \\Delta x)^2 - x^2 \\over \\Delta x} \\\\<br />&= \\lim_{\\Delta x \\rightarrow 0} {\\Delta x^2 + 2x\\Delta x \\over \\Delta x} \\\\<br />&= \\lim_{\\Delta x \\rightarrow 0} (\\Delta x + 2x) \\\\<br />&= 2x<br />\\end{align}<br />$$<br />事实上，对于幂函数$f(x) = x^\\alpha$，其导函数为$f^\\prime(x) = \\alpha x^{\\alpha - 1}$。<br />导数与导数之间存在运算关系，有了这些运算关系，我们就可以方便地进行求导。<br />类似于线性的性质：<br />$$ [a \\cdot f(x) + b \\cdot g(x)]^\\prime = a \\cdot f^\\prime(x) + b \\cdot g^\\prime(x) $$<br />两个导数相乘：<br />$$ [f(x)g(x)]^\\prime = f^\\prime(x)g(x) + f(x)g^\\prime(x) $$<br />两个导数相除：<br />$$ \\left[{f(x) \\over g(x)} \\right]^\\prime = {f^\\prime(x)g(x) - f(x)g^\\prime(x) \\over g^2(x)} \\; (g(x) \\neq 0) $$<br />复合函数：<br />$$ [f(g(x))]^\\prime = f^\\prime(g(x)) \\cdot g^\\prime(x) $$<br />一些基本函数的导函数就放这里了，当我们要求一个特定函数的导函数时，可以利用上面的规则，然后根据导函数表来计算。下面只有$x$是变量。<br />$$ c^\\prime = 0 $$<br />$$ x^\\prime = 1 $$<br />$$ (x^\\alpha)^\\prime = \\alpha x^{\\alpha - 1} $$<br />$$ (\\text{e}^x)^\\prime = e^x $$<br />$$ (a^x)^\\prime = a^x\\ln a $$<br />$$ (\\ln x)^\\prime = \\frac1x $$<br />$$ (\\log_a x)^\\prime = \\frac1{x\\ln a} $$<br />$$ \\sin^\\prime x = \\cos x $$<br />$$ \\cos^\\prime x = -\\sin x $$<br />$$ \\tan^\\prime x = \\frac1{\\cos^2 x} $$<br />$$ \\cot^\\prime x = -\\frac1{\\sin^2 x} $$<br />对数求导法<br />上面的求导公式已经能够应对大部分基本函数的求导了，但是对于下面的函数：<br />$$ f(x) = x^{1/x} $$<br />该如何求导呢？<br />这就要用到对数来进行求导。<br />我们知道，对于一个函数$f(x)$：<br />$$ [\\ln f(x)]^\\prime = \\ln^\\prime f(x) \\cdot f^\\prime(x) $$<br />换言之：<br />$$ f^\\prime(x) = {[\\ln f(x)]^\\prime \\over \\ln^\\prime f(x)} \\tag{1}$$<br />利用这一点，我们就可以对$f(x) = x^{1/x}$求导。<br />首先，为了方便我们设：<br />$$ y = x^{1/x} $$<br />由于两者相等，所以两者的对数也应相等：<br />$$ \\ln y = \\ln x^{1/x} = \\frac1x\\ln x $$<br />将两边对$x$求导。注意按照$(1)$式，左式需要乘上$y^\\prime$两者才能相等。<br />$$ {y^\\prime \\over y} = {\\ln x - 1 \\over x^2} $$<br />于是我们可以得到：<br />$$ y^\\prime = {\\ln x - 1 \\over x^2}y = {\\ln x - 1 \\over x^2}x^x = f^\\prime(x) $$<br />这样我们就完成了求导。<br />既然都对这个函数求过导了，我们来验证一下它的一个性质。<br />将$\\text{e}$代入导函数：<br />$$<br />\\begin{align}<br />f^\\prime(\\text{e}) & = {\\ln \\text{e} - 1 \\over \\text{e}^2}\\text{e}^{1/\\text{e}} \\\\<br />& = {1 - 1 \\over \\text{e}^2} \\\\<br />& = 0<br />\\end{align}<br />$$<br />因此我们发现$x = \\text{e}$是这个函数的极值点。<br />但究竟是极大值还是极小值呢。设$h > \\text{e}$，则：<br />$$<br />f^\\prime(\\text{e} + h) = {\\ln (\\text{e} + h) - 1 \\over (\\text{e} + h)^2}(\\text{e} + h)^{1/(\\text{e} + h)}<br />$$<br />因为$(\\text{e} + h)^2$和$(\\text{e} + h)^{1/(\\text{e} + h)}$都大于$0$，因此只要看分子的符号。<br />由于自然对数函数是单调递增的，易知分子是大于$0$的。故$f^\\prime(\\text{e} + h) > 0$。同理，当$0 < h < \\text{e}$时，$f^\\prime(\\text{e} - h) < 0$。<br />这样我们就证明了这是一个极大值点。<br />事实上，我们可以证明这个导函数的单调性，从而得知这是最大值。<br />后记<br />有关微积分的教材这里我推荐一本：Ron Larson的Calculus。<br />这本教材的比较像我们的数学教科书，不是像某些教科书一样不停的放出各种定理......<br />用于自学是非常适合的~~~","tags": "数学 极限 导数","url": "blog/2016-6-23/limit-and-derivative.html"},
{"title": "树状数组","text": "树状数组<br />树状数组是一种快速统计前缀和的简单数据结构。<br />基本问题<br />很多情况下，我们需要查询区间内的和，通常万能的做法就是线段。写过线段树的都知道，它其实并不简单，当然也不太难。而有了树状数组后，就可以以比线段树少很多代码，来统计区间和。<br />区间求和的问题一般是这样的：<br /><br />给你一个长度为$n$的数列，然后每次给你一个区间询问，询问这段区间内数的总和。<br /><br />求区间和可以通过求前缀和而得。即查询$S[l, r]$可以转变为$S[1, R] - S[1, L - 1]$。其中$S$表示区间和。<br />点修改区间查询<br />我们将先看到几个特化过的区间求和问题。树状数组的最基本用场就是点修改 + 区间查询了。它要求支持两个操作：<br /><br /><br />修改某一位置上的数<br />查询某一位置前缀和<br /><br /><br /><br />树状数组是套在原数组上的一层2，用来进行一些维护。上图中的树状数组被画成了它该有的样子，实际上就是一个数组。<br />对于数组中的每一个元素，其箭头所指向的元素(包括他自己)都被它所维护。<br />对于任意一个元素，其往前的一个区间距离和到它父亲的距离是相同的，即一个被称为$\\text{lowbit}$的东西。这个东西定义如下：<br />1<br />2function LOWBIT(x):<br />    return x & (-x)<br /><br /><br />这里面用到一个很玄乎的位运算，至于为什么是这样，这里就不多说了。<br />对于LOWBIT有一个需要注意的地方，就是LOWBIT(0) = 0。即树状数组不能处理下标为$0$的情况1。如果不注意，就很容易出现死循环。<br />对于每次单点的更新，我们都要将它的父亲给更新，因为它是被其父亲所管辖的。<br />而查询可以向前进行统计，这样就可统计前缀和。<br />下面用fenwick表示树状数组，n表示其长度。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18// 修改单点<br />function MODIFY(x, delta):<br />    if x < 1:<br />        return<br /><br />    while x <= n:<br />        fenwick[x] += delta<br />        x += LOWBIT(x)<br /><br />// 查询前缀和<br />function QUERY(right):<br />    answer = 0<br /><br />    while right > 0:<br />        answer += fenwick[right]<br />        right -= LOWBIT(right)<br /><br />    return answer<br /><br /><br />对于每个操作，其中的循环只要进行$\\Theta(\\log n)$次，故它们的时间复杂度为$\\Theta(\\log n)$的。<br />区间修改点查询<br />对于区间修改 + 点查询的问题通常要支持一下两种操作：<br /><br /><br />修改一段前缀和<br />查询某一个位置上数的大小<br /><br /><br /><br />考虑到能够影响到一个点的值的，只有其父亲。因此每次修改前缀和时，只需要修改它们的某一个父亲即可。查询单点时，也只需要访问其每一个父亲，从而可以得知自己被加上了多少。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18// 修改<br />function MODIFY(right, delta):<br />    while right > 0:<br />        fenwick[right] += delta<br />        right -= LOWBIT(right)<br /><br />// 查询<br />function QUERY(x):<br />    if x < 1:<br />        return 0<br /><br />    answer = 0<br /><br />    while x <= n:<br />        answer += fenwick[x]<br />        x += LOWBIT(x)<br /><br />    return answer<br /><br /><br />与前面一样，这两个操作的时间复杂度也是$\\Theta(\\log n)$。<br />区间修改区间查询<br />事实上，上面两种特化版本并不是太常见，最常见的因该是完整的区间和问题。对于这个问题，我们只要实现一下两种操作：<br /><br /><br />修改一段前缀和<br />查询一段前缀和<br /><br /><br />由于树状数组的一些特殊性，它的查询不是从所谓的根节点开始的，因此在父亲信息都会丢失掉。然而要将他们统计回来时，却需要很高的代价。因此一个树状数组不好解决这个问题。<br />所以我们同时使用两个树状数组，一个用于查询其儿子们的信息，另外一个则用于查询父亲的信息。<br />具体实现时，我们使用fenwick1来记录其父亲的信息，fenwick1[x]表示的是前x个数每个都被加上的数。使用fenwick2来记录儿子的信息，fenwick2[x]表示的是第x个元素所管辖的范围内的元素之和。这样对两个数组都查询一次，就可以得到完整的信息。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32// 修改<br />function MODIFY(right, delta):<br />    if right < 1:<br />        return<br /><br />    i = right<br />    while i > 0:<br />        fenwick1[i] += delta<br />        i -= LOWBIT(i)<br />    i = right<br />    while i <= n:<br />        fenwick2[i] += delta * right  // 注意是区间每一个数都加上了delta<br />        i += LOWBIT(i)<br /><br />function QUERY(right):<br />    if right < 1:<br />        return 0<br /><br />    answer = 0<br /><br />    i = right<br />    while i <= n:  // 统计父亲上的信息<br />        answer += fenwick1[i]<br />        i += LOWBIT(i)<br />    answer *= right  // 因为是每个数所加上的数，所以要乘以个数<br /><br />    i = right - 1<br />    while i > 0:  // 统计儿子信息<br />        answer += fenwick2[i]<br />        i -= LOWBIT(i)<br /><br />    return answer<br /><br /><br />按照国际惯例，时间复杂度依然保持在$\\Theta(\\log n)$。<br />更高维度<br />有时候我们需要对二维或三维上进行求和，线段树当然可以做，只是代码量将以$O(2^k)$的复杂度暴涨，并且巨大的常数也难以接受。但此时树状数组却可以很好的因对。<br />那是因为每一个树状数组的的最后一个元素实际管辖的是整个数列的和，因此我们可以将它单独挑出来代表这一个数列。当我们有很多个数列时，我们将这些代表也用一个树状数组来维护。这样就实现了树状数组向高维度的扩展。<br />具体实现方面就是在每个操作中多了几层循环，用于在每一个维度中的统计。最后要得知一段区间中的和时，利用容斥原理即可。<br />由于在每一维上都需要花费$\\Theta(\\log n)$的时间，因此对于$k$为空间的操作的复杂度一般都是$\\Theta(\\log^k n)$。<br />优势与缺点<br />树状数组有着很多的优点：<br /><br />代码短小，常数小<br />易于调试<br />容易扩展到高维度的数据<br /><br />也正因为如此，树状数组也有着许多的局限性：<br /><br />只能用于求和3，不能求最大/小值<br />不能动态插入，面多多维数据时空间压力大<br />不能可持久化<br /><br />因此，在树状数组与线段树中进行抉择时，是需要小心的。树状数组虽好，但不是万能的。要根据实际情况来确定。<br /><br /><br /><br /><br />如果下标一定要为$0$，可以考虑将其全部加$1$。 ↩<br /><br /><br />当然也可以直接替代原数组。 ↩<br /><br /><br />或者说具有区间减法性质的数据。 ↩<br /><br /><br />","tags": "树状数组 数据结构","url": "blog/2016-6-3/fenwick.html"},
{"title": "树链剖分","text": "树链剖分<br />用途<br />问题: 给你一棵无根树，每条边有边权，请你实现以下操作：<br /><br />查询$u$到$v$的路径上边权之和。<br />查询$u$到$v$的路径上边权最大值。<br />修改$u$到$v$的路径上每条边的边权。<br />…<br /><br />这些操作利用树链剖分，都可以在$O(\\log n)$的时间内解决。<br />无根树与有根树<br />一般来说，无根树是很不好处理的，因此将其转为有根树就会好处理些。<br />我们只要选定一个节点为根，然后进行DFS即可转化为有根树。<br />转换的时候，我们需要额外记录以下信息：<br /><br />$x.\\text{father}$: $x$的父亲节点。<br />$x.\\text{children}$: $x$的所有孩子。<br />$x.\\text{size}$: 以$x$为根的这一棵子树的大小。<br />$x.\\text{depth}$: $x$在树中的深度，即$x$到树根的距离$+1$。<br /><br /><br />这是一棵以$1$为根的树。为了解释更加清楚，这里举几个例子：<br /><br />$10.\\text{father} = 5,\\; 1.\\text{father} = nil$<br />$1.\\text{children} = \\{2, 5, 6\\},\\;7.\\text{children} = \\varnothing$<br />$1.\\text{size} = 17,\\;6.\\text{size} = 8,\\;3.\\text{size} = 1$<br />$1.\\text{depth} = 1,\\;10.\\text{depth} = 3,\\;14.\\text{depth} = 4$<br /><br />为了进行树链剖分，我们在立树的过程中需要计算一个重儿子，记作$x.\\text{next}$：<br />$$ x.\\text{next} = u: u \\in x.\\text{children},\\;u.\\text{size}\\text{最大} $$<br />即所有儿子中大小最大的一个，就记为重儿子，其它的儿子就是轻儿子。同时称与重儿子相连的边为重边，与轻儿子相连的边为轻边。<br />下面的伪代码是建立有根树的过程(假设我们输入的是无根树$G$，这是一张无向图，其中与$u$相连的顶点集合为$G[u].\\text{neighbors}$)：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24function MAKE-ROOT(G, u):  // 以u为树根<br />    u.visited = true  // u已经访问过了<br />    u.father = nil // u没有父亲<br />    u.depth = 1<br /><br />    REAL-MAKE-ROOT(G, u)<br /><br />function REAL-MAKE-ROOT(G, u):  // DFS过程<br />    u.size = 1<br />    u.next = nil<br /><br />    foreach v in G[u].neighbors:<br />        if not v.visited:  // 如果还未访问<br />            v.visited = true<br />            u.children += v  // 添加儿子节点<br />            v.father = u<br />            v.depth = u.depth + 1<br /><br />            REAL-MAKE-ROOT(G, v)  // 递归向下<br /><br />            u.size += v.size  // 更新子树大小<br /><br />            if u.next = nil || v.size > u.next.size:  // 更新重儿子<br />                u.next = v<br /><br /><br />剖分<br />在介绍树链剖分的算法之前，我们先来看看剖分后的树是个什么样子：<br /><br />剖分后的树信息量一下子大了很多。我将会逐条解释上面都画了些什么。<br /><br />树链(重链): 所有红色的边所连成的一条链都是剖分后的结果。某些树链没有边，就只有一个节点，这个节点是红色的。在上面，1-6-8-11-13-17是剖分出来的最长的树链，而3独自一个节点形成了树链。<br />树链起点: 红色的节点是每一条树链的起点。<br />重儿子: 蓝色的节点是重儿子。<br />编号: 每一条边上的数字为剖分后的编号。<br /><br />可以看出，树中的每一个节点都会在一条树链中。因此我们需要对树链也进行编号。我们以树链顶端的节点作为树链的编号，并记为$x.\\text{top}$。例如，$8.\\text{top} = 1,\\;16.\\text{top} = 16$。<br />如果两个节点$u$和$v$在同一树链中，当且仅当$u.\\text{top} = v.\\text{top}$。<br />对于边$u \\rightarrow v$的编号，我们记边为二元组$(u, v)$，那么记编号为$(u,v).\\text{id}$。<br />但是这样不方便在程序中储存，因此我们将边的编号放到节点里面。在上面的写法中，如果$u$是$v$的父亲，那么我们将边$(u,v)$的编号放到$v$中，即$v.\\text{id}$。这样表示$v$与其父亲相连的边$(u,v)$的编号为$v.\\text{id}$。<br />边的编号是树剖的关键，给边赋予编号后，就可以实现很多操作了。<br />我们首先来看这些编号有什么特点：<br /><br />每个边的编号都不一样。<br />同一条的树链的边的编号从高处向低处编号递增。这样做的好处就是同一条链上面的数据可以用一些数据结构(如线段树、Splay等)来维护。<br />对于节点$u$，其重边的编号是$u$与所有儿子的连边中最小的。<br /><br />估计你已经猜到计算$\\text{top}$和$\\text{id}$的用处了。但不要着急，下面就将计算这些值。<br />计算的过程也是一遍DFS。这次的DFS是在第一次建立好的有根树上进行的。<br />当我们处理到节点$u$时，我们将$u$和$u.\\text{next}$相连来形成树链。之所以选取重儿子，是因为重儿子的大小最大，因此所生成的树链将尽可能长1。那么其它的儿子将自己成为新的树链。<br />此时来考虑编号。因为同一条树链上的边的编号是递增的，因此要优先对重儿子进行DFS。由于轻儿子是新创建的树链，因此DFS的顺序并不重要。<br />至此，树链剖分的算法就结束了。当算法完成时，每个节点就会有正确的$\\text{top}$和$\\text{id}$。<br />下面是树链剖分的伪代码：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23count = 0  // 已编号的数量<br /><br />function TREE-SPLIT(x):  // 剖分子树u<br />    x.id = 0  // 根节点没有父亲<br />    x.top = x  // 根节点是第一条链<br /><br />    REAL-TREE-SPLIT(x)<br /><br />function REAL-TREE-SPLIT(x):  // DFS过程<br />    if x.next != nil:  // 如果有重儿子<br />        count += 1<br />        x.next.id = count<br />        x.next.top = x.top<br /><br />        REAL-TREE-SPLIT(x.next)  // 优先重儿子<br /><br />    foreach v in x.children:  // 对于轻儿子则新创一条链<br />        if v != x.next:  // 检查是不是重儿子<br />            count += 1<br />            v.id = count<br />            v.top = v<br /><br />            REAL-TREE-SPLIT(v)<br /><br /><br />基础操作<br />树链剖分完有什么用呢？<br />就像一开场所说的：<br /><br /><br />查询$u$到$v$的路径上边权之和。<br />查询$u$到$v$的路径上边权最大值。<br />修改$u$到$v$的路径上每条边的边权。<br />…<br /><br /><br />下面将介绍如何进行路径边权之和的查询和修改路径边权这两个操作。其它的操作可以在此思想上扩展。<br />查询<br />假如我们要查询$u$到$v$的路径上的权值之和，那么就会有两种情况：<br /><br />$u$和$v$在同一条树链上。<br />$u$和$v$不在同一条树链上。<br /><br />对于第一种情况，非常好解决。我们可以用线段树来维护每一条边的权值，直接按照编号来排列。由于同一条链上的编号是递增的，如果$u.\\text{depth} < v.\\text{depth}$，则可以直接查询$[u.\\text{next}.\\text{id}, v.\\text{id}]$的和。如果$u.\\text{depth} = v.\\text{depth}$，由于$u$和$v$是在同一条树链上的，也就是意味着$u = v$，那么就不需要统计。<br />对于第二种情况，我们考虑使它们不断逼近到同一条链上来，从而就转为了第一种情况。但是，在其中一个节点变化到另一条树链上时，要将经过的树链的值进行统计。<br />我们按照一下步骤来处理：<br /><br />如果$u.\\text{top}.\\text{depth} < v.\\text{top}.\\text{depth}$，那么交换$u$和$v$，使$u$所在的树链为所处位置较深的一个。<br />计算$[u.\\text{top}.\\text{id},u.\\text{id}]$的值并累加。<br />令$u = u.\\text{top}.\\text{father}$。<br />如果$u.\\text{top} = v.\\text{top}$，则转化为第一种情况。否则跳转第一步。<br /><br />上面步骤的思想就是将上升期间的每一条树链的和统计出来，这样实则就是统计了这条路径上的和。<br />第一步的操作是为了方便后续的处理。第二步是计算这一条链上的和，包括这条链上面的一条轻边，因为在第三步中要走这条轻边到达上面一条树链。最后一步是检查是否成为了第一种情况。<br />下面是上面步骤的参考伪代码：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18function QUERY-SUM(u, v):<br />    sum = 0<br /><br />    // 如果不在同一条树链<br />    while u.top != v.top:<br />        if u.top.depth < v.top.depth:<br />            SWAP(u, v)  // 交换u和v<br /><br />        sum += QUERY(u.top.id, u.id)  // 利用线段树等数据结构来求和<br />        u = u.top.father  // 走轻边进入上面的树链<br /><br />    if u == v:  // 如果处在相同位置<br />        return sum<br /><br />    if u.depth > v.depth:  // 使u成为深度较小的节点<br />        SWAP(u, v)<br /><br />    return QUERY(u.next.id, v.id) + sum<br /><br /><br />如果不能理解，这里给出一个示例：<br /><br />假设我们查询$16$到$17$：<br />首先会发现它们不在同一条链上，由于$16$所处的链的深度较大，为$5$，因此将$16$进行上移，上移至$14$，并统计$[13, 13]$的和。<br />然后$14$和$17$依然不在同一条链中，由于$14$所处的链的深度为$2$，因此将$14$上移。上移至$1$，并统计$[9, 11]$的和。<br />最后发现$1$和$17$已经在同一条链中了，直接统计$[1, 5]$的和即可。<br />修改<br />事实上，修改操作和查询几乎是一模一样的，只是将求和的地方变成了相应的数据结构的修改操作。这里就不再多说了。<br />时间复杂度<br />每当学习了一个新算法，我们最关切的就是它的时间复杂度了。<br />如果树链剖分的时间复杂度高到爆，我们写的时候估计得虚死。<br />但是可以证明，树链剖分后的树，从根节点到任意一个叶节点的路径只会与$O(\\log n)$条树链相交。这意味着将两个节点逼近到同一条链上时，只需经过$O(\\log n)$次跳转。<br />即基于树剖的其它操作的时间复杂度为$\\Omega(\\log n)$(注意是下界，具体的上界取决于操作本身的附加的复杂度)。<br />为什么会只有$O(\\log n)$条呢？<br />我们来考虑树链剖分时最坏的情况：<br /><br />想象这是树剖是最坏的情况(因为实际上并不会这样)。因为树剖总是尝试将最长的剖分出来，因此树链都是向右的。如果最左链再加一个节点，树链就会向左剖分了。<br />为了达到这样的效果，这棵有根树是接近平衡的，即树高为$\\Theta(\\log n)$。<br />因此最坏的情况下，当查询最左边的节点时，只需要使用$O(\\log n)$次跳转就可完成。<br />当然上面并不是严格的证明，只是一个形象的说明罢了。我们只需要知道树链剖分能保证很好的时间复杂度即可。<br />正确的证明思路因该是这样的：<br />可以考虑一棵树中轻边的数量。由于从某一个节点开始，每走一条轻边，子树的大小都会减小一倍。因此任意一条树链上只有$O(\\log n)$条轻边，即意味着只有$O(\\log n)$。<br />树链剖分计算LCA<br />LCA即最近公共祖先。计算LCA的算法可以说是各种各样，有暴力的爬山法，炸空间的Tarjan算法，开挂的倍增法，莫名高大上的ST跳表的搞法，还有不知所云的转成RMQ问题......在与树相关的操作中，经常需要一些求LCA的操作。其中最常用的就是倍增法，它能在$O(\\log n)$的时间内求出LCA，并且其空间复杂度为$\\Theta(n \\log n)$。<br />当我们树剖后的操作需要借助到LCA时，是不是就要写个LCA的算法呢？<br />其实并不需要，我们可以直接利用树剖的结果来计算LCA。<br />然而，求LCA的过程和之前查询也是差不多的：在同一条链上的时候，深度值较小的就是LCA。如果不在同一条链上，就不断往上跳即可。这样可以在$O(\\log n)$时间内求出LCA。并且仅使用了$\\Theta(n)$的空间复杂度，优势十分显著。<br />当然，单纯拿树链剖分来求LCA也煞是浪费。既然树剖有能求LCA的能力，因此在面对需要LCA的时候就不必求助于其它的算法了。<br />树链剖分与DFS序<br />【NOI2015】软件包管理器<br />当我们既需要维护链上信息，又需要维护子树信息时，就有点棘手了。<br />维护子树信息的通常做法是DFS序。为了能够将树链剖分与DFS序结合起来，目标就是将树链剖分的编号与DFS序统一起来。<br />考虑到DFS序实际上不是唯一的，因此在树链剖分的过程中可以先对重儿子进行DFS，这样就可以保证一条重链上的DFS序也是递增的了。于是，我们可以继续按照DFS序维护子树的方法，同时树链剖分的信息也会被同时更新。<br /><br /><br /><br /><br />实际上，按照子树大小来剖分不一定能剖分出最长的树链，但这并不影响最终的操作的效率。如果要剖分出的链真正最长，应当选择秩最大的儿子作为重儿子。 ↩<br /><br /><br />","tags": "数据结构 树链剖分 LCA","url": "blog/2016-4-20/tree-split.html"},
{"title": "正式开始编写ne2d","text": "正式开始编写ne2d<br /><br />一直想找个好点的2D渲染引擎，但看了很多似乎都不合胃口，也许有点挑剔。之前看到的bgfx似乎也有点操蛋，毕竟操作上还是麻烦了点。<br />因此，趁着时间还多，多造点轮子，学点东西。索性开始自己做个适合的2D渲染引擎。<br />之前这个自制的渲染引擎ne2d一直处于极其不稳定状态，动辄几千行代码的改动。<br />今天总算有个大致框架了。目前计划做成一个单纯的2D渲染引擎，不打算管平台相关的代码。<br />只要能够提供OpenGL上下文就能使其工作。<br />目前这个工程才刚刚起步，暂时还没法使用。<br />这里记录下目前的想法和进度：<br />基本功能：  <br /><br /> OpenGL 3.3 core profile  <br /> Alpha支持<br /> Layer抽象，支持图层深度<br /> RenderObject，所有渲染对象实例化<br /> Sprite绘制材质<br /> 矩阵变换（使用glm）<br /> TrueType字体（SDL_ttf or raw Freetype?）<br /><br />计划中的功能：  <br /><br /> 动画<br /> *.layout文件载入图层（JSON or XML?）<br /> 自定Shader<br /> 粒子系统<br /><br />至于不处理平台相关的代码，因为我觉得SDL做得比我好，我个人也是很喜欢SDL的接口风格的（只是SDL在渲染方面似乎并不怎么样…）。<br />所以所有的窗口创建、OpenGL上下文创建、事件管理......这些东西都交给SDL吧！当然你喜欢glfw也是可以的。<br />最后把GitHub repo放一下吧：<br /><br />ne2d: 理论上是稳定版  <br />ne2d/develop: 理论上是最新版  <br />ne2d/unstable: 激进版<br /><br />另外，欢迎有兴趣的同志一起开发！","tags": "C/C++ ne2d 图形","url": "blog/2016-2-4/ne2d-1.html"},
{"title": "测试","text": "pagegen.py的试炼<br />希望pagegen.py能正确工作。  <br />常规Markdown测试<br />h1<br />h2<br />h3<br />h4<br />h5<br />h6<br />上面是六级标题。  <br /><br />上面是六级标题。<br />这是一段引用  <br /><br />很好，inline-code和Hello, world：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9#include <iostream><br /><br />using namespace std;<br /><br />int main(int argc, char *argv[]) {<br />    cout << \"Hello, world!\" << endl;<br /><br />    return 0;<br />}<br /><br /><br />别忘了Python：<br />1<br />2<br />3<br />4#!/usr/bin/env python3<br /><br />if __name__ == \"__main__\":<br />    print(\"Hello, world!\")<br /><br /><br />1<br />2Tab也可以直接代码<br />Yeah!!!<br /><br /><br />重要的话说三遍<br />重要的话说三遍<br />重要的话说三遍<br />下划线是什么鬼<br />打表A题：<br /><br /><br /><br />NOI<br />A<br />B<br />A + B<br /><br /><br /><br /><br />1<br />1<br />2<br />3<br /><br /><br />2<br />2<br />2<br />4<br /><br /><br />3<br />5<br />5<br />10<br /><br /><br />4<br />3<br />4<br />7<br /><br /><br /><br /><br /><br /><br />列1<br />列2<br />列3<br /><br /><br /><br /><br />233333333333333<br />23333333<br />233<br /><br /><br /><br />我的GitHub: https://github.com/riteme<br />GitHub<br />我的E-mail: riteme@qq.com<br />脚注1？  <br />GFM breaks!<br />应该不在一行!<br />应该不在一行!!<br />应该不在一行!!!!!<br />deleted<br />inserted<br />–smartpants—<br />“a“‘b‘“c“‘d‘“e”“’<br />Mathjax测试: $e^{ix} = \\cos x + i\\sin x$<br />这个应该不得出问题......<br />$$ \\sum_{i = 1}^{\\infty} i = - {1 \\over 12} \\tag{1.1} $$<br />$$ a^2 + b^2 = c^2 \\Rightarrow \\triangle ABC\\text{是直角三角形} \\tag{1.2} $$<br />$$<br />\\begin{align}<br />X_k & = \\sum^{n - 1}_{j = 0} x_ke^{-2\\pi ijk/n} \\\\<br />    & = \\sum^{n - 1}_{j = 0} x_kw_n^{-jk}<br />\\end{align}<br />$$<br />$$<br />\\begin{align}<br />x_k & = \\frac1n\\sum^{n - 1}_{j = 0} X_ke^{2\\pi ijk/n} \\\\<br />    & = \\frac1n\\sum^{n - 1}_{j = 0} X_kw_n^{jk}<br />\\end{align}<br />$$<br />$$ $$$$ $ $<br />行内公式inline-math在此$ 233 \\neq 244 $233333<br />特殊语法测试<br />FBI Warning<br />肯定有BUG<br /><br />Markdown in it<br />STRONG, inline-code.<br /><br />中文<br />Not Supported…<br />乱搞<br />233444<br /><br />233<br /><br />Goodbye!<br /><br /><br /><br /><br />真的行吗...... ↩<br /><br /><br />","tags": "test","url": "blog/2016-1-31/test.html"},
{"title": "测试多说","text": "测试多说<br />欢迎大家在下面按照基本法放肆评论，我看看我pagegen.py写对没有。<br />打个广告吧： 多说","tags": "test","url": "blog/2016-2-4/comments.html"},
{"title": "点分四叉树 (Point Quadtree)","text": "点分四叉树 (Point Quadtree)<br />点分四叉树是一种二维平面上的划分树，可以用于快速统计平面上的点的信息。<br />下图展现了一棵四叉树。其中箭头表示树中的边，矩形表示一个点所管辖的范围。<br /><br />原理<br />考虑下面的问题：<br /><br />给你平面上$n$个点，然后不断的询问一个矩形范围内有多少个点。<br /><br />通常大家会想到用二维线段树或是各种奇怪的分治算法。这当然是可以的。<br />这个问题恰好是为四叉树设计的。<br />基本的思路就是将平面切分，当然这里不是二分1，而是将四分。我们每次以一个点作为平面的中心来将平面划分。这样利用分治的思想可以快速维护一些点上的信息。<br />建树<br />从上面的图可以看出，我们每次会选择一个点来划分，同时我们以这个点为根节点，然后将其它的点分发到四个子平面内。然后对四个子平面进行递归处理。这样就可建立一棵四叉树。<br />当然，我们选择的这个点要尽可能使四个子平面中点数接近。这样就防止树过高。直接判断哪个点使四个子平面的点数最接近并没有比较好的算法。通常的做法就是将点按照一维进行排序后取中。可以证明，这样选择后的四叉树的期望树高为$O(\\log n)$。<br />当然，对点的排序可以在建树前完成，因为在建树的过程中，分发点是不会打乱顺序的。<br />为了方便统计信息，我们需要知道一个节点所管辖的真正的范围。通过将所有的点扫描一遍就可以得出这个范围。<br />由此我们可以得到建树的基本流程：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44// 对于每个树节点x，x.point是其表示的点，x.rectangle是其实际管辖的范围<br />// x.NE、x.NW、x.SE、x.SW表示四个方位的子平面<br />// 建树前先对点集排序<br /><br />function BUILD-QUADTREE(P):  // P是点集<br />    if |P| = 0:  // 如果没有点<br />        return nil<br /><br />    x = allocate a new node<br />    if |P| = 1:<br />        x.point = P[0]<br />        x.rectangle = { x.point.x, x.point.x, x.point.y, x.point.y }<br /><br />        return x<br /><br />    p = P[|P| / 2]  // 选取最中间的点<br />    midx = p.x, midy = p.y  // 切分线<br />    minx = INFTY, max = -INFTY, miny = INFTY, maxy = -INFTY  // 实际管辖的边界<br />    let Q1, Q2, Q3, Q4 be empty sets  // 四个子平面的点集<br />    for u in P:<br />        minx = min(minx, u.x)<br />        maxx = max(maxx, u.x)<br />        miny = min(miny, u.y)<br />        maxy = max(maxy, u.y)<br /><br />        if u != p:  // 分发点至四个子平面<br />            if u in Q1.rectangle:  // 在第一个子平面中<br />                Q1.append(u)<br />            else if u in Q2.rectangle:<br />                Q2.append(u)<br />            else if u in Q3.rectangle:<br />                Q3.append(u)<br />            else<br />                Q4.append(u)<br /><br />    // 更新树节点<br />    x.point = p<br />    x.rectangle = { minx, maxx, miny, maxy }<br />    x.NE = BUILD-QUADTREE(Q1)<br />    x.NW = BUILD-QUADTREE(Q2)<br />    x.SE = BUILD-QUADTREE(Q3)<br />    x.SW = BUILD-QUADTREE(Q4)<br /><br />    return x<br /><br /><br />建树的总时间复杂度为$O(n\\log n)$。因为树高是$O(\\log n)$的。<br />你也许会好奇作为四叉树却不是$O(\\log_4 n)$，那是因为可能存在所有点的某一维全部相同的情况。<br />如果有所有点都一样的情况，会导致树的退化。解决办法就是剔除重复点，从而保证树高。<br />经过对随机分布的点的测试，四叉树的树高保持在$O(\\log n)$：<br /><br />同时可以得知四叉树的空间复杂度为$\\Theta(n)$，因为每个点都会被用一次。<br />查询与修改<br />在建立完树以后，进行查询或修改就十分简单了。许多操作可以借鉴线段树，因为每个节点都管理了一段区间。<br />这里以我们开始问题为例：我们需要查询一个矩形内有多少个点。<br />对于此，在考虑时只要判断三种情况：<br /><br />查询的矩形与所管辖矩形相离：对答案没有贡献<br />所管辖矩形在查询的矩形之中：该所管辖的矩形内的点都会被算上<br />查询的矩形与所管辖矩形相交：首先计算自己在不在矩形中，然后分治到四个子平面，最中会变为第一和第二中情况<br /><br />因此我们对于每个节点，只需统计其管辖范围内有多少个点即可。这一任务可以$\\Theta(1)$完成，我们将其存入x.count。<br />整个算法的流程是十分清晰的。下面是查询的伪代码：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14function QUERY(x, rect):  // x表示当前的节点，rect是查询的矩形<br />    if x =  nil:<br />        return 0<br />    if x.rectangle is out of rect:  // 在矩形外<br />        return 0<br />    if x.rectangle is in rect:  // 在矩形内<br />        return x.count<br />    else:  // 相交<br />        answer = QUERY(x.NE, rect) + QUERY(x.NW, rect) + QUERY(x.SE, rect) + QUERY(x.SW, rect)  // 分治<br /><br />        if x.point in rect:  // 判断自己在不在矩形内<br />            return answer + 1<br />        else:<br />            return answer<br /><br /><br />实际上，我们不仅可以查询矩形中的点数，还可以计算各种范围内的点数！我们只需要修改所管辖的矩形与范围的关系的函数即可。<br />对于修改操作，也是一样的思路，只是将考虑贡献变为考虑影响即可。这里就不给出具体的做法了。<br />动态插入与删除<br />当然我们会希望能够动态插入点。事实上你可以离线所有的操作来预处理出将要插入的所有的点，然后建树，这样就避免的了动态操作的烦恼。<br />当然如果被强制在线了，我们也有解决办法，那就是利用替罪羊树2的思想。制定一个子树不平衡的标准，然后在不平衡的子树处利用BUILD-QUADTREE来重建。需要注意的是BUILD-QUADTREE的时间复杂度为$O(n\\log n)$的，而不是$\\Theta(n)$。因此均摊时间复杂度一般是$O(\\log^2 n)$的。<br />扩展至高维<br />作为平面上的划分树，它是需要四叉的。如果想利用同样的思想来应用到三维中，就会需要八叉树3。<br />当然不足之处就是代码量会大幅度增加。因此这种树不太适合高维度的操作。<br />当然利用一些离线操作方法可以使数据的维度降低。我们可以通过排序使一维有序，同时也可以利用一类按时间分治的思想来对一维分治，这样就成功的降下两维。至此，在允许离线的情况下，四叉树可以轻松对付四维的数据。<br /><br /><br /><br /><br />当然有进行二分的树，具体参见$k$-d tree ↩<br /><br /><br />替罪羊树 ↩<br /><br /><br />具体参见Octree ↩<br /><br /><br />","tags": "四叉树 划分树 数据结构","url": "blog/2016-6-2/quadtree.html"},
{"title": "秩平衡树(Rank Balanced Tree)","text": "秩平衡树(Rank Balanced Tree)<br /><br />riteme: “这是并查集和Treap的杂交品种。”<br />tplink: “贼式二叉树！”<br />ruanxz: “ZY！”<br /><br />1 秩<br />1.1 树的秩高<br />这里先介绍“秩”的概念。我们定义一棵二叉树的秩为从为从根节点开始到其叶节点中最长的一条树链上结点的个数。<br />对于空结点$nil$，它的秩为$0$。<br />$$ nil.\\text{rank} = 0 \\tag{1.1} $$<br />那么对于任意非空节点$x$，它的秩可以如下定义：<br />$$ x.\\text{rank} = \\max\\{x.\\text{left}.\\text{rank}, x.\\text{right}.\\text{rank}\\} + 1 \\tag{1.2}$$<br />树的秩我们使用UPDATE函数来维护：<br />1<br />2function UPDATE(h):<br />    h.rank = max(h.left.rank, h.right.rank) + 1<br /><br /><br />现在我们来看一棵二叉搜索树。<br /><br />上图中，a的秩为$1$，e的秩为$2$，c的秩为$3$，根节点j的秩为$6$。<br />1.2 按秩合并<br />在并查集的优化方法中有一个是启发式按秩合并。做法是将秩小的树接在秩大的树下面，这样就可以尽可能避免树的高度的暴涨。同样，在秩平衡树中，也要利用到这种思想。<br />2 旋转<br />众所周知，二叉搜索树的旋转操作可以保持树的有序性，同时可以通过旋转的组合来实现许多操作。因此我们先实现左旋(LEFT-ROATE)和右旋(RIGHT-ROTATE)。<br />左旋是将左子树旋转上来顶替自己的位置，右旋类似。<br />旋转时要确保左子树或右子树不是$nil$。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23function LEFT-ROTATE(h):<br />    ASSERT h.left != nil<br /><br />    x = h.left<br />    h.left = x.right<br />    x.right = h<br /><br />    UPDATE(h)<br />    UPDATE(x)<br /><br />    return x  // 使用左子树来替代原来的节点<br /><br />function RIGHT-ROTATE(h):<br />    ASSERT h.right != nil<br /><br />    x = h.right<br />    h.right = x.left<br />    x.left = h<br /><br />    UPDATE(h)<br />    UPDATE(x)<br /><br />    return x  // 使用右子树来替代原来的节点<br /><br /><br />例如，要对节点x进行左旋转时，我们这样调用：<br />1x = LEFT-ROTATE(x)<br /><br /><br />3 普通秩平衡树<br /><br />P: 并查集 x Treap<br />-> F1: “贼式二叉树”<br /><br />秩平衡树的样子与二叉搜索树并没有什么区别。<br />普通的秩平衡树的实现非常简单。它将利用秩的信息来使树保持平衡。<br />3.1 查询<br />查询中没有对树的形状的修改，因此什么特殊的操作都不要。<br />故查询操作和普通的二叉搜索树是一样的。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10function QUERY(h, key):<br />    if h = nil:<br />        return nil  // 没有查找到<br /><br />    if key < h.key:<br />        return QUERY(h.left, key)  // 结果在左子树中<br />    else if key > h.key:<br />        return QUERY(h.right, key)  // 结果在右子树中<br />    else:<br />        return h  // 命中节点<br /><br /><br />3.2 平衡<br />准确的说，这个操作并不能维护平衡，而只是能使树向平衡的方向发展。<br />进行平衡的依据就是树的秩。当左右子树的秩差距太大，我们就要采取行动来使其减小差距。<br />首先我们设定一个秩的差距的最大容忍值$t$。这个值是一个正整数，并且值选取的愈小树就会变得愈平衡。当$t=1$时，秩平衡树大多数情况下就是完全平衡的二叉树。<br />在普通的秩平衡树中，我们一般选定为$1$：<br />1TOLERANCE = 1<br /><br /><br />设定这个值的意义在于定义了平衡的触发标准。如果左右子树的秩的差距大于$t$，那么就要减小差距。<br />减小差距的方法就是将树根通过旋转的方式进入秩较小的子树中，这样使得秩较小的子树的秩增加，秩较大的子树的秩减小。<br />于是我们得到了一个大致的平衡代码：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10function BALANCE(h):<br />    if h.left.rank > h.right.rank and<br />       h.left.rank - h.right.rank > TOLERANCE:   // 左子树的秩过大<br />        h = LEFT-ROTATE(h)<br />    else if h.left.rank < h.right.rank and<br />            h.right.rank - h.left.rank > TOLERANCE:   // 右子树的秩过大<br />        h = RIGHT-ROTATE(h)<br /><br />    UPDATE(h)  // 更新节点<br />    return h  // 返回调整后的节点<br /><br /><br />实际上，这样还不足够。<br />考虑下面的情况：<br /><br />现在我们要平衡b节点。左子树的秩比右子树大。倘若按照上面的方法进行调整，将会得到下面的结果：<br /><br />呃…你会发现并没有什么变化。<br />其原因在于左子树的右儿子的秩太大，导致旋转过去之后没有太大效果。<br />这样导致中间的子树的深度下移一位。加之它本来就秩比较大，如此一来这个平衡就毫无作用。<br />然而，如果左子树的连个儿子如果秩是一样的，就不会有太大的影响，因为这样就只会导致秩的差距为$1$。倘若右儿子的秩更小，就不会有这样的问题。<br />为了解决这个问题，我们考虑使左子树右儿子的秩减小，这样就不会因为中间的子树而导致无用的平衡。<br />首先我们将左子树的右儿子通过右旋上移，这样使得右儿子的秩减小：<br /><br />然后再进行左旋操作，完成平衡：<br /><br />这时左右子树的秩的差距就减小了。<br />同样，对于右子树的平衡操作也是类似的处理方法。这里就不再多说。具体的可以参考实现伪代码。<br />完整的平衡代码如下：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17function BALANCE(h):<br />    if h.left.rank > h.right.rank and<br />       h.left.rank - h.right.rank > TOLERANCE:   // 左子树的秩较大<br />        if h.left.right.rank > h.left.left.rank:  // 如果左子树的右儿子的秩较大<br />            h.left = RIGHT-ROTATE(h.left)<br /><br />        h = LEFT-ROTATE(h)<br />    else<br />    if h.left.rank < h.right.rank and<br />       h.right.rank - h.left.rank > TOLERANCE:   // 右子树的秩较大<br />        if h.right.left.rank > h.right.right.rank:  // 如果右子树的左儿子的秩较大<br />            h.right = LEFT-ROTATE(h.right)<br /><br />        h = RIGHT-ROTATE(h)<br /><br />    UPDATE(h)  // 更新节点<br />    return h  // 返回调整后的节点<br /><br /><br />这个平衡操作运用到了类似于并查集中“路径压缩”的思想。在并查集中可以直接全部接在根节点处，从而极大的提高了效率。但限于二叉树的性质，平衡操作只能使每个节点的秩尽可能的小。<br />3.3 插入<br />插入与普通的二叉搜索树差不多，只是在最后回溯的时候维护树的平衡。<br />因此我们可以很快的写出插入操作：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10function INSERT(h, key):<br />    if h = nil:<br />        return new node with key<br /><br />    if key < h.key:<br />        h.left = INSERT(h.left, key)<br />    else if key > h.key:<br />        h.right = INSERT(h.right, key)<br /><br />    return BALANCE(h)  // 最后要进行平衡<br /><br /><br />3.4 删除<br />与插入类似，删除的代码和二叉搜索树的保持一致，只要最后记得进行平衡即可。<br />这里我们采用将被删除节点下沉的方法来进行删除：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34function REAL-REMOVE(h):  // 删除指定的节点<br />    if h.left != nil and h.right != nil:<br />        // 如果有两个非空子树就继续下沉<br />        // 尽量往秩小的子树中下沉，同时将另一棵子树的秩尽量减小<br />        // 从而达到平衡的目的<br />        if h.left.rank > h.right.rank:<br />            h = LEFT-ROTATE(h)<br />            h.right = REAL-REMOVE(h->right)<br />        else:<br />            h = RIGHT-ROTATE(h)<br />            h.left = REAL-REMOVE(h->left)<br />    else:<br />        // 如果只有一个子树，就可以直接删除，将唯一的子树顶替自己的位置<br />        // 如果没有子树，说明是叶节点，返回nil<br />        next = nil<br />        if h.left != nil:<br />            next = h.left<br />        else:<br />            next = h.right<br /><br />        delete h  // 删除<br />        return next<br /><br />    return BALANCE(h)<br /><br />function REMOVE(h, key):<br />    if key < h.key:<br />        h.left = REMOVE(h.left, key)<br />    else if key > h.key:<br />        h.right = REMOVE(h.right, key)<br />    else:<br />        return REAL-REMOVE(h)  // 找到指定的节点后进行删除<br /><br />    return BALANCE(h)<br /><br /><br />3.5 时间复杂度<br />如果$t$选取得当，秩平衡树将是非常平衡的。因此操作都是$O(\\log n)$的：<br /><br /><br /><br />操作<br />时间复杂度<br /><br /><br /><br /><br />平衡<br />$\\Theta(1)$<br /><br /><br />查询<br />$O(\\log n)$<br /><br /><br />插入<br />$O(\\log n)$<br /><br /><br />删除<br />$O(\\log n)$<br /><br /><br /><br />在实际效率上，秩平衡树比Treap略快，与伸展树相比常数稍大一些。在查询操作很多的时候，秩平衡树比较占优势。<br />4 可合并秩平衡树<br /><br />F1: “贼式二叉树” x 可持久化Treap<br />-> F2: “可合并秩平衡树”<br /><br />如果只是一棵单纯BST，未免太过无聊......<br />现在各种BST都玩出花出来了，然而在这之中支持区间操作的BST却非常少。据我所知还只有可持久化Treap和伸展树。<br />那秩平衡树能不能也支持区间操作呢？<br />一种思路是类似于伸展树的做法：将区间变为开区间，然后将区间的两个端点上浮，然后就可以截取区间了。秩平衡树可以进行上浮，上浮时不考虑树的平衡。当区间用完后，再将上浮的顶点依次下沉，同时维护平衡，这样就可以实现区间操作。<br />事实上，如果这样进行处理，有着诸多的缺点：<br /><br />又要增加上浮和下沉操作，并且这两个操作并不简单，代码量急剧增长。  <br />如果有懒惰标记之类的东西，难以正确处理。  <br />常数变大，尽管理论上时间复杂度都是$O(\\log n)$。<br /><br />但是…又不是不能写，毕竟我是写过的，所以我才会知道这些。<br />这样写出来的秩平衡树能比可持久化Treap快，但与伸展树相比差距较大。<br />另一种思路就是类似于可持久化Treap的做法：将树从第$k$小的位置拆开，然后又合并......<br />可合并秩平衡树就是这种做法。<br />接下来我们会继续用到秩平衡树的BALANCE操作，同时将增加两个基本操作：SPLIT和MERGE，表示拆分和合并。以及一个辅助操作RANK1来查找第$k$小的节点，这样我们就可以利用这些操作来实现各种各样的操作。<br />4.1 拆分<br />拆分操作是将树从第$k$小的节点处拆成$[1, k]$和$[k+1, n]$的两棵子树。<br />因为需要计算排名，所以每个节点都要记录一个$\\text{size}$，表示子树中节点的个数，即子树的大小。同样，空节点的大小为$0$：<br />$$ nil.\\text{size} = 0 \\tag{4.1} $$<br />对于每个节点$x$，它的大小定义如下：<br />$$ x.\\text{size} = x.\\text{left}.\\text{size} + x.\\text{right}.\\text{size} + 1 \\tag{4.2} $$<br />此时我们将在UPDATE函数中维护树的大小：<br />1<br />2<br />3function UPDATE(h):<br />    h.size = h.left.size + h.right.size + 1<br />    h.rank = max(h.left.rank, h.right.rank) + 1<br /><br /><br />拆分操作时先沿着寻找第$k$小的树链不断的将树切开，然后在回溯的时候进行拼装。这是一个递归的过程。<br />假设我们在对子树$x$进行拆分，我们考虑下面两种情况：<br /><br />如果$k \\le x.\\text{left}.\\text{size}$，那么说明第$k$小的节点在左子树中，因此只需要将左子树拆开，拆开后的左边是$[1, k]$的子树，右边是大于$k$的子树。  <br />如果$k \\ge x.\\text{left}.\\text{size}$，那么说明左子树完全小于$k$，子树的根必定不大于$k$，因此可以确定左子树和树根都在$[1,k]$的范围内。但我们不确定右子树中是否有在这个范围内的。如果有，则它在右子树中的排名为$k-x.\\text{left}.\\text{size} - 1$，因此我们将右子树按照这个值进行拆分，那么拆开的左边属于$[1,k]$。<br /><br />这个过程非常简单，代码实现也是如此：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16function SPLIT(h, k):<br />    if h = nil:<br />        return (nil, nil)  // 如果是空树，那么不需要拆分<br /><br />    if k <= h.left.size:  // 情况1<br />        a, b = SPLIT(h.left, k)  // 拆分左子树<br />        h.left = b               // b不属于[1, k]<br />        UPDATE(h)<br /><br />        return (a, h)<br />    else:                 // 情况2<br />        a, b = SPLIT(h.right, k - h.left.size - 1)  // 拆分右子树<br />        h.right = a                                 // a属于[1, k]<br />        UPDATE(h)<br /><br />        return (h, b)<br /><br /><br />4.2 合并<br />之前我们把树给拆开了，用完了当然还要还回去，因此我们必然需要合并操作。<br />同时我们注意到，拆分时我们并没有维护平衡，因此平衡的重任就交给了合并。<br />进行合并时，我们必须保证合并的左子树必须完全小于合并的右子树，即左子树的最大值必须小于右子树的最小值。<br />合并时要遵循按秩合并的思想，始终选取秩较大的子树作为树根。然后将另一棵子树与树根的对应儿子继续进行合并。<br />这是一个递归向下的过程。在回溯的时候，使用BALANCE操作进行平衡。<br />如果我们在合并两棵子树$a$和$b$，其中$a$完全小于$b$。由于二叉搜索树的有序性，合并只会出现两种情况：<br /><br />$a$作为树根，$a.\\text{right}$与$b$继续合并。  <br />$b$作为树根，$a$和$b.\\text{left}$继续合并。<br /><br />作为特例，如果$a$和$b$中有一个是空树，那么就没有必要合并了。<br />合并的伪代码如下：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17function MERGE(a, b):<br />    if a = nil:<br />        return b<br />    if b = nil:<br />        return a<br /><br />    ASSERT max(a) < min(b)  // a < b<br />    if a.rank > b.rank:  // 按秩合并<br />        a.right = MERGE(a.right, b)<br />        UPDATE(a)<br /><br />        return BALANCE(a)  // 最后进行平衡<br />    else:<br />        b.left = MERGE(a, b.left)<br />        UPDATE(b)<br /><br />        return BALANCE(b)<br /><br /><br />4.3 排名<br />由于SPLIT操作需要排名$k$，而一般的调用是给定节点的键，因此我们需要一个能将节点在树中的排名计算出来的算法。<br />因此RANK操作也成为了非常重要的操作之一。<br />利用节点储存的子树大小值，我们可以快速算出一个节点的排名。<br />这个操作也是一个递归操作的过程：<br /><br />如果指定的节点在左子树，我们直接在左子树中继续查询。  <br />如果指定的节点在右子树，我们查询它在右子树中的排名，然后加上左子树和树根的大小。  <br />如果直接命中，那么直接计算排名，其排名为左子树的大小加$1$。  <br />对于没有命中的空节点，排名的意义在于查询一个新节点插入树后的排名。为此，对于空节点，我们视为它的排名为$1$。<br /><br />根据上面的讨论，我们可以写出查询排名的操作：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10function RANK(h, key):<br />    if h = nil:<br />        return 1<br /><br />    if key < h.key:<br />        return RANK(h.left, key)<br />    else if key > h.key:<br />        return RANK(h.right, key) + h.left.size + 1<br />    else:<br />        return h.left.size + 1<br /><br /><br />当然，我们希望这个操作越快越好。现代绝大部分的语言的编译器/解释器…都能够对尾递归进行优化。上面的RANK操作可以被我们改为尾递归，从而充分利用优化的优势：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10function RANK(h, key, offest = 0):  // 利用offest进行尾递归优化<br />    if h = nil:<br />        return 1 + offest<br /><br />    if key < h.key:<br />        return RANK(h.left, key, offest)<br />    else if key > h.key:<br />        return RANK(h.right, key, offest + h.left.size + 1)<br />    else:<br />        return h.left.size + 1 + offest<br /><br /><br />如果没有优化，也没有关系，因为能尾递归的函数，基本上都可以写成迭代的形式：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13function RANK(h, key):<br />    offest = 0<br /><br />    while h != nil:                          // 向左走<br />        if key < h.key:<br />            h = h.left<br />        else if key > h.key:                 // 向右走<br />            offest += h.left.size + 1<br />            h = h.right<br />        else:<br />            return h.left.size + 1 + offest  // 直接命中<br /><br />    return offest + 1  // 最后没有命中<br /><br /><br />4.4 时间复杂度<br />显然时间复杂度是我们最关心的。通过BALANCE操作，秩平衡树在合并过程中能够维持很好的平衡。<br />因此对于所有的操作，递归深度不会超过$O(\\log n)$。因此时间复杂度都是$O(\\log n)$的。<br /><br /><br /><br />操作<br />时间复杂度<br /><br /><br /><br /><br />拆分<br />$O(\\log n)$<br /><br /><br />合并<br />$O(\\log n)$<br /><br /><br />排名<br />$O(\\log n)$<br /><br /><br /><br />4.5 衍生操作<br />有了SPLIT、MERGE和RANK三大利器，我们就可以随心所欲的进行各种操作了。下面将对一些操作进行说明，大家可以在此基础上开发更多操作。<br />4.5.1 查询<br />这个实际上没有必要动用拆分和合并，直接查就好。<br />4.5.2 插入<br />设要插入的节点的排名为$k$，那么先将树拆分为$[1, k-1]$和$[k, n]$两部分，然后依次合并。<br />1<br />2<br />3<br />4<br />5<br />6<br />7function INSERT(h, key):<br />    x = new node with key<br /><br />    k = RANK(h, key)<br />    a, b = SPLIT(h, k - 1)<br /><br />    return MERGE(MERGE(a, x), b)<br /><br /><br />4.5.3 删除<br />设要删除的节点的排名为$k$，那么将树拆分为$[1,k-1]$、$[k+1,n]$和被删除的节点三部分，然后只将左右合并即可。<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8function REMOVE(h, key):<br />    k = RANK(h, key)<br />    a1, a2 = SPLIT(h, k - 1)<br />    b1, b2 = SPLIT(a2, 1)<br /><br />    delete b1  // 删除节点<br /><br />    return MERGE(a1, b2)<br /><br /><br />4.5.4 第k小<br />直接拆就好了。<br />1<br />2<br />3<br />4<br />5<br />6function KTH(h, k):<br />    a1, a2 = SPLIT(h, k - 1)<br />    b1, b2 = SPLIT(a2, 1)<br /><br />    MERGE(a1, MERGE(b1, b2))<br />    return b1<br /><br /><br />4.5.5 截取区间<br />这才是区间操作的关键吧…<br />但是我们只要拆拆合合就搞定了…<br />最后要记得合并就好了。<br />1<br />2<br />3<br />4<br />5function SLICE(h, left, right):<br />    a1, a2 = SPLIT(h, left - 1)<br />    b1, b2 = SPLIT(a2, right - left + 1)<br /><br />    return b1<br /><br /><br />4.6 总结<br />在实际的测试中，秩平衡树的表现非常不错，比可持久化Treap快了很多，并且在区间操作上能和伸展树不相上下。<br />但是，与可持久化Treap相比，因为依赖于BALANCE操作，所以就无法进行可持久化了。<br />最后我们重新来考虑$t$这个容忍值的选取。在之前普通的秩平衡树中，我们认为$1$是最好的。而现在就未必。如果数据完全随机，我们其实并不需要平衡。但这样在极端数据的情况下，不平衡容易退化为一条链。但是过多的平衡会影响常数。因此，$t$可以稍微取大一点，但不能太大。一般情况下，最好选择$2$到$6$中的值。<br /><br /><br /><br /><br />这里的英文解释为“排名”，不是秩。 ↩<br /><br /><br />","tags": "数据结构 平衡二叉树 Rank-Tree Treap Splay 并查集 贼爷我真的错了","url": "blog/2016-4-10/rank-tree.html"},
{"title": "空袭","text": "空袭 (airstrike.c/cpp)<br />时间限制：N/A / 内存限制：1024 MB / 打开-O2优化 / 支持C11\\C++11<br />题目描述<br />这是一道交互题。<br />注意本交互库不提供Pascal支持。只支持C\\C++。<br />统计学家Lunk所居住的城市遭到的软斯兰国的空袭，弄得Lunk心神不定。<br />然而伟大的统计学家怎么会就因为空袭而四处避难呢？Lunk决定弄出个大新闻。<br />由于各种原因，Lunk所居住的城市的市区的形状十分奇怪。Lunk将其大致的轮廓画在地图上，形成了一个多边形的形状。软斯兰国的飞机每丢下一枚炸弹，Lunk就会马上观测到炸弹的位置，并将其画在地图上。但是，他所想要统计的只是智障的软斯兰国有多少枚炸弹攻击到了市区。<br />于是Lunk放弃了在地图上画下每一个炸弹的位置，而是转而在地下室里直接统计。<br />现在它所需要的就是一个能帮他统计的程序。他希望能在你们写的程序中选出一个精确度高并且跑得比香港记者还快的程序来帮助它完成这个任务。<br />我该如何编写这个程序<br />选手目录下将会下发interface.h这个文件。<br />你需要实现interface.h中的接口。<br />你需要在同一目录下新建一个文件airstrike.cpp，其中包含以下内容：<br />1<br />2<br />3#include \"interface.h\"<br /><br />// 实现部分<br /><br /><br />你需要实现的接口在头文件中有简要说明。这里做详细说明。<br />1void initialize(const double *x, const double *y, const size_t n, const int id);<br /><br /><br />是载入程序的入口。在进行查询之前，会调用这个函数。<br />载入所用的时间不会计入你的程序用时。但是载入时间不能超过$3\\text{s}$。<br />x和y是两个数组，给出的是市区的轮廓，即Lunk绘制的多边形的顶点，按照逆时针顺序给出。<br />n是多边形的顶点数量。<br />id是当前数据点的标号，在下文会有解释。<br />1bool query(const double dx, const double dy);<br /><br /><br />是Lunk的操作，每次调用即查询炸弹是否炸在市区内。如果炸在市区内则返回true，否则返回false。<br />dx和dy是炸弹炸到的坐标。<br />该函数的用时会被计入程序用时。<br />1void finalize();<br /><br /><br />是结束程序。这个函数将在所有查询任务完成后调用。<br />用于释放你的程序所用的资源。<br />该函数的用时不会计入程序用时，但是其运行时间不能超过$3\\text{s}$。<br />注意，请不要使用delete[]删除掉之前initialize参数中给你的顶点数组，否则后果自负。<br />我该如何测试这个程序<br />选手目录下将会下发main.cpp这个文件。<br />首先你需要有输入的数据，其格式将在下文给出。<br />假设你的程序文件是airstrike.cpp，那么使用以下命令来编译：<br />1g++ main.cpp airstrike.cpp -std=c++11 -o main<br /><br /><br />或者你需要调试：<br />1g++ main.cpp airstrike.cpp -std=c++11 -o main -g<br /><br /><br />打开-O2优化：<br />1g++ main.cpp airstrike.cpp -std=c++11 -o main -O2<br /><br /><br />对于C语言，将main.cpp改名为main.c，使用gcc，并且将-std=c++11改为-std=c11即可。<br />然后使用：<br />1./main<br /><br /><br />来运行程序。<br />如果需要使用文件输入输出，你可以使用管道，也可以修改main.cpp，将其中的两行带有注释的freopen取消注释，然后重新编译即可。<br />注意，该程序不会测试你的用时并给你评分。并且与最终评测时的运行程序不同。<br />输入格式<br />此处的输入格式是根据上面的测试程序所说的。<br />第一行输入两个整数$n$和$d$，表示顶点数量和数据编号。<br />下面$n$行描述市区，每一行给出一个整点$(x,\\;y)$，表示一个顶点。<br />之后给出若干行，一直到文件尾，每行给出一个整点$(x_q,\\;y_q)$，表示炸弹的位置。<br />输出格式<br />对于每一个Lunk的询问，输出对应的信息 (YES或NO)。<br />样例输入1<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />93 1<br />0 0<br />6 1<br />8 7<br /><br />6 5<br />2 7<br />8 1<br />3 1<br /><br /><br />样例输出1<br />1<br />2<br />3<br />4YES<br />NO<br />NO<br />YES<br /><br /><br />样例解释1<br />样例输入1如下图所示：<br /><br />样例输入2<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />157 1<br />1 1<br />7 1<br />4 2<br />3 4<br />7 5<br />5 6<br />1 6<br /><br />0 4<br />2 4<br />4 4<br />5 3<br />5 5<br />3 1<br /><br /><br />样例输出2<br />1<br />2<br />3<br />4<br />5<br />6NO<br />YES<br />NO<br />NO<br />YES<br />YES<br /><br /><br />样例解释2<br />样例输入2如下图所示：<br /><br />数据限制<br />共$7$个数据测试点，限制如下：<br /><br /><br /><br />数据编号<br />$n$的规模<br />特殊限制<br /><br /><br /><br /><br />$1$<br />$\\le 10$<br />无<br /><br /><br />$2$<br />$\\le 10^3$<br />无<br /><br /><br />$3$<br />$\\le 10^5$<br />无<br /><br /><br />$4$<br />$\\le 2 \\times 10^5$<br />无<br /><br /><br />$5$<br />$\\le 10^6$<br />左右的边与$y$轴平行，下边与$x$轴平行，上边顶点$x$递增，均高于下边，输入数据从左下角开始。<br /><br /><br />$6$<br />$\\le 10^6$<br />凸多边形<br /><br /><br />$7$<br />$\\le 10^3$<br />$0 \\le x,\\;y \\le 10^3$<br /><br /><br /><br />对于$100\\% $的数据，满足$3 \\le n \\le 10^6,\\;|x|,\\;|y|,\\;|x_q|,\\;|y_q| \\le 10^9$。<br />顶点按照逆时针顺序输入，没有两个顶点一样，并且为简单多边形。<br />评分标准<br />对于不同的数据点，分值和时间限制如下表所示：<br /><br /><br /><br />数据编号<br />分值<br />时间限制<br /><br /><br /><br /><br />$1$<br />$5$<br />$0.1\\text{s}$<br /><br /><br />$2$<br />$10$<br />$1\\text{s}$<br /><br /><br />$3$<br />$15$<br />$1\\text{s}$<br /><br /><br />$4$<br />$30$<br />$1\\text{s}$<br /><br /><br />$5$<br />$10$<br />$1\\text{s}$<br /><br /><br />$6$<br />$15$<br />$1\\text{s}$<br /><br /><br />$7$<br />$15$<br />$1\\text{s}$<br /><br /><br /><br />在时间限制内，如果程序不出意外 (如运行时错误)，将会不断的给出询问。设你的程序完成的询问个数为$x$。对于每一个点的评分标准如下：<br /><br /><br /><br />数据编号<br />$20\\% $<br />$40\\% $<br />$60\\% $<br />$80\\% $<br />$100\\% $<br /><br /><br /><br /><br />$1$<br />$\\ge 10^5$<br />$\\ge 2\\times 10^5$<br />$\\ge 3 \\times 10^5$<br />$\\ge 4 \\times 10^5$<br />$\\ge 5 \\times 10^5$<br /><br /><br />$2$<br />$\\ge 5 \\times 10^4$<br />$\\ge 10^5$<br />$\\ge 2 \\times 10^6$<br />$\\ge 3 \\times 10^6$<br />$\\ge 4 \\times 10^6$<br /><br /><br />$3$<br />$\\ge 5 \\times 10^2$<br />$\\ge 10^3$<br />$\\ge 2 \\times 10^5$<br />$\\ge 4 \\times 10^5$<br />$\\ge  5 \\times 10^5$<br /><br /><br />$4$<br />$\\ge 10^3$<br />$\\ge 1 \\times 10^5$<br />$\\ge 2 \\times 10^5$<br />$\\ge 3 \\times 10^5$<br />$\\ge 4 \\times 10^5$<br /><br /><br />$5$<br />$\\ge 10^3$<br />$\\ge 8 \\times 10^5$<br />$\\ge 10^6$<br />$\\ge 1.2 \\times 10^6$<br />$\\ge 1.4 \\times 10^6$<br /><br /><br />$6$<br />$\\ge 5 \\times 10^2$<br />$\\ge 8 \\times 10^5$<br />$\\ge 10^6$<br />$\\ge 1.2 \\times 10^6$<br />$\\ge 1.4 \\times 10^6$<br /><br /><br />$7$<br />$\\ge 10^6$<br />$\\ge 2 \\times 10^6$<br />$\\ge 3 \\times 10^6$<br />$\\ge 4 \\times 10^6$<br />$\\ge 10^7$<br /><br /><br /><br />你的$x$需要达到对应的要求才能得到对应的百分比。评测程序将选取你能达到的最高的百分比。<br />其中百分比是将该点总分乘上该百分比并向下取整，作为你该点的分数。<br />如果询问回答错误，将每回答错误一次扣除$1$分，扣分到$0$分为止，分数不会变为负数。<br />如果发生运行时错误，或者运行严重超时，将导致该点得$0$分。<br />如果你的initialize或finalize超时，该点得$0$分。<br />关于评测机<br />出于一些原因，GCC编译出来的评测器并不是很稳定，可能出现成绩波动的情况，所以评测时最好采用Clang进行编译，得到的结果会稳定一些。<br />如果你对你的算法十分自信，然而在评测时却没有得到满分，可以进行重测。<br />温馨提示<br />评测时限很长，请不要恶意卡评测，谢谢合作！<br />后记<br />Lunk的孙子Lnk完成了这个大新闻。<br />无奖竞猜：Lnk是谁？<br /><br />第一次出交互题，祝你们早日AC这个智障题！QAQ<br />","tags": "Problems","url": "blog/2016-8-25/airstrike.html"},
{"title": "编译并使用bgfx","text": "编译并使用bgfx<br />最近发现了一个似乎很好的图形引擎bgfx。<br />它是使用C++进行编写的，也有C99的接口，功能还比较丰富，支持DirectX 9/11和OpenGL 2.1+。<br />这是一个跨平台的库，我在Ubuntu 14.04上编译了成功了。<br />编译过程十分简单。本文就介绍Linux下的编译过程。<br />编译<br />这里我只写了Linux的编译过程，其他平台我还没试过，具体参见bgfx’s document。<br />首先需要编译器支持，确保你的编译器满足下列要求：<br /><br />Clang 3.3及以上  <br />GCC 4.6及以上<br /><br />同时准备依赖库：<br />1sudo apt-get install libgl1-mesa-dev x11proto-core-dev libx11-dev<br /><br /><br />然后从GitHub上下载源码。因为bgfx依赖于bx，因此我们还要下载bx：<br />1<br />2<br />3<br />4cd ~/Downloads  # 下载到Downloads目录<br />git clone git://github.com/bkaradzic/bx.git<br />git clone git://github.com/bkaradzic/bgfx.git<br />cd bgfx  # 进入源码目录，准备编译<br /><br /><br />使用make生成工程：<br />1make<br /><br /><br />接下来进行编译：<br />1make linux-release64<br /><br /><br />提示<br />使用make还可以生成其他版本的，其格式是：<br />1make [平台]-[release/debug][32/64]<br /><br /><br />例如，如果要生成32位的bgfx，使用以下命令：<br />1make linux-release32<br /><br /><br /><br />如果编译过程中没有报错，那么在.build/文件夹下会有对应的编译后的文件。<br />运行样例<br />bgfx提供了很多样例，编译后的样例在.build/对应的文件夹下(我的就在.build/linux64_gcc/bin/下），在目前bgfx没有什么教程的情况下是很好的学习资料。<br />由于样例需要很多资源文件（如着色器、材质之类的），而它们都在exmaples/runtime目录下，<br />因此需要在exmaples/runtime目录下用相对路径来运行。<br />首先我们切换到样例的目录。对我而言，使用以下命令：<br />1cd .build/linux64_gcc/bin/<br /><br /><br />如果你编译的是32位，将上面的64改成32即可。<br />然后使用ls命令查看样例，可以看到目前有28个样例（包括Hello, world!）：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17example-00-helloworldRelease         example-17-drawstressRelease<br />example-01-cubesRelease              example-18-iblRelease<br />example-02-metaballsRelease          example-19-oitRelease<br />example-03-raymarchRelease           example-20-nanovgRelease<br />example-04-meshRelease               example-21-deferredRelease<br />example-05-instancingRelease         example-22-windowsRelease<br />example-06-bumpRelease               example-23-vectordisplayRelease<br />example-07-callbackRelease           example-24-nbodyRelease<br />example-08-updateRelease             example-25-c99Release<br />example-09-hdrRelease                example-26-occlusionRelease<br />example-10-fontRelease               example-27-terrainRelease<br />example-11-fontsdfRelease            geometrycRelease<br />example-12-lodRelease                libbgfxRelease.a<br />example-13-stencilRelease            libbgfx-shared-libRelease.so<br />example-14-shadowvolumesRelease      libexample-commonRelease.a<br />example-15-shadowmaps-simpleRelease  shadercRelease<br />example-16-shadowmapsRelease         texturecRelease<br /><br /><br />可以看到每个样例都十分具有代表性，今后的学习就从它们开始。<br />同时注意到，有两个.a的静态库和一个.so的动态库，我们可以用它们来编译程序。<br />然而并不是在这里运行样例，我们要回到runtime目录来运行：<br />1cd ../../../examples/runtime<br /><br /><br />假如要运行00-helloworld，使用以下命令：<br />1../../.build/linux64_gcc/bin/example-00-helloworldRelease<br /><br /><br />如果不出意外，能看到以下窗口（图片来自bgfx document）：<br /><br />bgfx的文档也给出了样例的列表。<br />编译我们自己的bgfx程序<br />为了通用性，这里使用最基础的终端编译的方法，我们直接用g++进行编译。<br />首先，我们创建一个目录来存放我们的程序：<br />1<br />2mkdir my-first-bgfx<br />cd my-first-bgfx<br /><br /><br />然后将bgfx的静态库复制过来：<br />1cp [bgfx的目录]/.build/linux64_gcc/bin/*.a .<br /><br /><br />这时目录下会多出两个.a文件： libbgfxRelease.a和libexample-commonRelease.a<br />静态库 vs 动态库<br />我们在这里选用了静态库，而不是动态库，是考虑了用户的原因。<br />因为bgfx没有什么很方便的安装方法，使用静态库就可以避免安装的过程，尽可能少的对用户的系统进行修改。<br />当然，使用静态库会增大程序体积。静态链接后，我们的bgfx程序会有3MB多…<br /><br />然后需要将bgfx及其依赖库的bx的头文件给复制进来。为了方便，我们还将bgfx用于样例的common库也复制进来：<br />1<br />2<br />3cp -rf [bgfx的目录]/include/* .         # bgfx<br />cp -rf [bgfx的目录]/examples/common/ .  # bgfx-common<br />cp -rf [bx的目录]/include/* .           # bx<br /><br /><br />下面我们来照着bgfx的hello, world来写第一个程序。我们将会在窗口的左上角打出Hello, world!的字样：<br />创建程序main.cpp：<br />1<br />2touch main.cpp<br />[使用你的编辑器] main.cpp<br /><br /><br />首先添加头文件：<br />1<br />2<br />3<br />4#include <cstdint>  // uint32_t<br /><br />#include \"bgfx/bgfx.h\"      // bgfx<br />#include \"common/common.h\"  // bgfx-common<br /><br /><br />然后添加_main_函数。注意之所以是_main_而不是main，是因为bgfx的common库为了更好的处理以已经将main实现了，<br />于是设置_main_作为程序入口。<br />1<br />2<br />3int _main_(int argc, char *argv[]) {<br />    /* 代码 */<br />}<br /><br /><br />在_main_函数内，我们先做一些设定：<br />1<br />2<br />3<br />4uint32_t width  = 1280;              // 窗口宽度<br />uint32_t height = 720;               // 窗口高度<br />uint32_t debug  = BGFX_DEBUG_TEXT;   // debug模式开启，可以直接在窗口输出文字<br />uint32_t reset  = BGFX_RESET_VSYNC;  // 设置垂直同步<br /><br /><br />注意<br />似乎width和height的设置是没有用的，似乎无论设为多少，打开后都会变成1280x720，我也不知道是为什么…<br />如果你也出现了这种情况，不要惊慌，不要害怕…<br /><br />下面是加载bgfx：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10bgfx::init();                             // 载入<br />bgfx::reset(width, height, reset);        // 设置<br />bgfx::setDebug(debug);                    // 启用调试<br />bgfx::setViewClear(                       // 设置清空的状态<br />    0,                                    // bgfx中有View的概念，默认情况下是View 0<br />    BGFX_CLEAR_COLOR | BGFX_CLEAR_DEPTH,  // 表示要清空颜色缓冲和深度缓冲<br />    0xFFFFFFFF,                           // 颜色缓冲的清空值，0xFFFFFFFF是白色<br />    1.0f,                                 // 深度缓冲的清空值，默认为1.0f<br />    0                                     // 模板缓冲的清空值，默认为0<br />);<br /><br /><br />接下来就是渲染了，我们使用一个循环同时处理事件和渲染：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15// entry::processEvents是common库一个很方便的函数<br />// 它能帮我们处理几乎所有的窗口事件。<br />// 如果窗口大小有变化，width和height的值就会变化<br />// 如果窗口被关闭，就会返回true<br />while (not entry::processEvents(width, height, debug, reset)) {<br />    bgfx::setViewRect(0, 0, 0, width, height);  // 由于窗口大小会变化，因此这里要重新设置<br /><br />    bgfx::touch(0);  // 切换到View 0<br /><br />    bgfx::dbgTextClear();                                                      // 清空调试输出的文字<br />    bgfx::dbgTextPrintf(0, 0, 0x4F, \"Hello, world!\");                          // 打印\"Hello, world!\"<br />    bgfx::dbgTextPrintf(0, 1, 0x4F, \"width = % d, height = % d\", width, height); // 输出窗口大小<br /><br />    bgfx::frame();  // 提交所有的渲染操作，准备切换到下一帧<br />}<br /><br /><br />注意<br />在函数bgfx::dbgTextPrintf中，第三个参数是设置文字的前景色和背景色。<br />其中，bgfx用0-F作为颜色的标记。在上面两位的十六进制数中，第一个指定背景色，第二个制定前景色。<br />这里将这些颜色标记列出来：<br />0: 无色<br />1: 暗红色  2: 暗绿色  3: 黄色，<br />4: 蓝色，  5: 紫色，  6: 深蓝色<br />7: 灰色，  8: 深灰色  9: 红色，<br />A: 嫩绿色  B: 米黄色  C: 浅蓝色<br />D: 浅紫色  E: 天蓝色  F: 白色<br /><br />最后，当窗口关闭时，entry::processEvents就会返回true，于是退出循环，最后要退出bgfx：<br />1bgfx::shutdown();<br /><br /><br />现在来编译main.cpp：<br />1g++ -std=c++11 main.cpp -o exec -L. -lbgfxRelease -lexample-commonRelease -lpthread -lGL -lX11<br /><br /><br />注意编译器要打开C++11支持，如果你的编译器不支持C++11，那我很好奇你是怎么把bgfx编译成功的。<br />-lpthread、-lGL和-lX11是bgfx依赖的库，分别是POSIX线程库、OpenGL库和X11库。<br />如果没有错误报出，运行exec就能看到以下窗口：<br />1./exec<br /><br /><br /><br />如果你出现了什么意外，下面贴出了完整的程序用于对照：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36#include <cstdint>  // uint32_t<br /><br />#include \"bgfx/bgfx.h\"<br />#include \"common/common.h\"<br /><br />int _main_(int argc, char *argv[]) {<br />    uint32_t width = 1280;<br />    uint32_t height = 720;<br />    uint32_t debug = BGFX_DEBUG_TEXT;<br />    uint32_t reset = BGFX_RESET_VSYNC;<br /><br />    bgfx::init();<br />    bgfx::reset(width, height, reset);<br />    bgfx::setDebug(debug);<br />    bgfx::setViewClear(<br />        0,<br />        BGFX_CLEAR_COLOR | BGFX_CLEAR_DEPTH,<br />        0xFFFFFFFF,<br />        1.0f,<br />        0<br />    );<br /><br />    while (not entry::processEvents(width, height, debug, reset)) {<br />        bgfx::setViewRect(0, 0, 0, width, height);<br /><br />        bgfx::touch(0);<br /><br />        bgfx::dbgTextClear();<br />        bgfx::dbgTextPrintf(0, 0, 0x4F, \"Hello, world!\");<br />        bgfx::dbgTextPrintf(0, 1, 0x4F, \"width = % d, height = % d\", width, height);<br /><br />        bgfx::frame();<br />    }<br /><br />    bgfx::shutdown();<br />}<br /><br /><br />至此，我们的第一个bgfx程序就完成了。解决了编译的问题，就可以继续学习使用bgfx了。","tags": "C/C++ 图形 引擎 bgfx","url": "blog/2016-2-3/learn-bgfx-1.html"},
{"title": "莫比乌斯反演","text": "莫比乌斯反演<br /><br />我把《组合数学》抄了一遍，免得我记不住......<br /><br />偏序集<br />这里的莫比乌斯反演是从关联代数的角度来介绍的。首先介绍一个基础的概念：偏序集。<br />它通常写作$(X_n,\\;\\le)$，其中$X_n$是一个有限或者无限的集合，$\\le$是代指偏序关系，而不是特指小于等于符号。<br />所谓偏序关系，就是指$a,\\;b,\\;c \\in X_n$并且$a \\le b,\\;b \\le c$，有$a \\le c$的性质的关系。<br />这种偏序关系一般是比较符$\\le$、集合的$\\subseteq$符号和整除$\\;\\mid\\;$。<br />卷积<br />对于定义在偏序集$(X_n,\\;\\le)$上的二元函数$f(x,\\;y)$，我们假定当$x \\not\\le y$时，$f(x,\\;y)$均为$0$，这样是为了方便我们之后的讨论。<br />考虑偏序集$(X_n, \\le)$上的二元函数$f(x,\\;y)$和$g(x,\\;y)$，定义它们的卷积为：<br />$$<br />(f \\times g)(x,\\;y) = \\sum_{x \\le z \\le y} f(x,\\;z)g(z,\\;y) \\tag{2.1}<br />$$<br />这个卷积满足结合律：<br />$$<br />(f \\times g) \\times h = f \\times (g \\times h) \\tag{2.2}<br />$$<br />注意，这个卷积不一定1满足交换律。<br />以及三种强行定义的莫名其妙的函数：<br />$\\delta$ (delta) 函数：<br />$$<br />\\delta(x,\\;y) = [x = y] \\tag{2.3}<br />$$<br />任意函数卷$\\delta$函数均会得到原函数。<br />$\\zeta$ (zeta) 函数：<br />$$<br />\\zeta(x,\\;y) = [x \\le y] \\tag{2.4}<br />$$<br />以及莫比乌斯$\\mu$函数是定义为$\\zeta$函数的逆函数，即：<br />$$<br />\\mu \\times \\zeta = \\zeta \\times \\mu = \\delta \\tag{2.5}<br />$$<br />展开卷积可得：<br />$$<br />\\begin{align}<br />\\delta = \\mu \\times \\zeta \\Longrightarrow \\delta(x,\\;y) & = \\sum_{x \\le z \\le y} \\mu(x,\\;z)\\zeta(z,\\;y) \\\\<br />& = \\sum_{x \\le z \\le y} \\mu(x,\\;z)<br />\\end{align}<br />$$<br />因此，当$x \\neq y$时：<br />$$<br />\\mu(x,\\;y) = - \\sum_{x \\le z \\lt y} \\mu(x,\\;z) \\tag{2.6}<br />$$<br />莫比乌斯反演公式<br /><br />(莫比乌斯反演公式)<br />对于有限偏序集$(X_n,\\;\\le)$上的两个函数$F(x,\\;y)$和$G(x,\\;y)$，如果：<br />$$ G(x,\\;y) = \\sum_{x \\le z \\le y} F(x,\\;z) \\tag{3.1}$$<br />那么：<br />$$F(x,\\;y) = \\sum_{x \\le z \\le y} G(x,\\;z)\\mu(z,\\;y)  = (G \\times \\mu)(x,\\;y) \\tag{3.2}$$<br /><br />证明 首先将式子展开：<br />$$<br />\\begin{align}<br />F(x,\\;y) & = \\sum_{x \\le z \\le y} G(x,\\;z)\\mu(z,\\;y) \\\\<br />& = \\sum_{x \\le z \\le y} \\mu(z,\\;y) \\sum_{x \\le m \\le z} F(x,\\;m)<br />\\end{align}<br />$$<br />我们使用$\\zeta$函数来表示上下界，于是式子改写为以下形式：<br />$$<br />\\sum_{x \\le z \\le y} \\mu(z,\\;y) \\sum_{m \\in X_n} F(x,\\;m)\\zeta(x,\\;m)\\zeta(m,\\;z)<br />$$<br />改变求和的枚举顺序，先枚举$m$，其值依然不变：<br />$$<br />\\sum_{m \\in X_n} \\sum_{x \\le z \\le y} \\zeta(m,\\;z)\\mu(z,\\;y)\\zeta(x,\\;m)F(x,\\;m)<br />$$<br />由于当$m \\lt x$的时候$\\zeta(x,\\;m)$为$0$，因此只用考虑$m \\ge x$。<br />并且当$m \\ge x$时，$z \\ge m$必需成立。<br />因此可以改写下界：<br />$$<br />\\sum_{m \\in X_n} \\sum_{m \\le z \\le y} \\zeta(m,\\;z)\\mu(z,\\;y)F(x,\\;m)<br />$$<br />然后变成了卷积的形式：<br />$$<br />\\begin{align}<br />\\sum_{m \\in X_n} F(x,\\;m) \\sum_{m \\le z \\le y} \\zeta(m,\\;z)\\mu(z,\\;y) & = \\sum_{m \\in X_n} F(x,\\;m) \\delta(m,\\;y) \\\\<br />& = F(x,\\;y)<br />\\end{align}<br />$$<br />当$m = y$时，$\\delta(m,\\;y)$才为$1$，所以综上所述：<br />$$<br />F(x,\\;y) = \\sum_{x \\le z \\le y} G(x,\\;z)\\mu(z,\\;y) \\tag{3.2}<br />$$<br />偏序集直积<br />对于两个偏序集$(A,\\;\\le_1)$和$(B,\\;\\le_2)$，它们的直积$C = A \\times B = (A \\times B,\\;\\le)$也是偏序集，其中的元素为$(x,\\;y)\\;\\;(x \\in A,\\;y \\in B)$。其关系$\\le$的定义如下：<br />$$<br />(x_1,\\;y_1) \\le (x_2,\\;y_2) \\Longleftrightarrow x_1 \\le_1 x_2 \\land y_1 \\le_2 y_2<br />$$<br />对于偏序集的直积，我们有以下定理：<br /><br />设$A$和$B$的莫比乌斯函数分别为$\\mu_1$和$\\mu_2$，那么$C$的莫比乌斯函数满足：<br />$$\\mu((x_1,\\;y_1),\\;(x_2,\\;y_2)) = \\mu_1(x_1,\\;x_2)\\mu(y_1,\\;y_2) \\tag{4.1}$$<br /><br />证明 对于$(x_1,\\;y_1) \\not\\le (x_2,\\;y_2)$和$(x_1,\\;y_1) = (x_2,\\;y_2)$的情况，上式显然成立。<br />假设对于满足$(x_1,\\;y_1) \\le (u,\\;v) \\lt (x_2,\\;y_2)$的二元组均满足，那么有：<br />$$<br />\\begin{align}<br />\\mu((x_1,\\;y_1),\\;(x_2,\\;y_2)) & = - \\sum_{(x_1,\\;y_1) \\le (u,\\;v) \\lt (x_2,\\;y_2)} \\mu((x_1,\\;y_1),\\;(u,\\;v)) \\\\<br />& = - \\sum_{(x_1,\\;y_1) \\le (u,\\;v) \\lt (x_2,\\;y_2)} \\mu_1(x_1,\\;u)\\mu_2(y_1,\\;v) & (\\text{根据归纳假设}) \\\\<br />& = - \\sum_{x_1 \\le_1 u \\lt_1 x_2} \\sum_{y_1 \\le_2 v \\lt_2 y_2} \\mu_1(x_1,\\;u)\\mu_2(y_1,\\;v) & (\\text{分别枚举}) \\\\<br />& =  - \\sum_{x_1 \\le_1 u \\le_1 x_2} \\sum_{y_1 \\le_2 v \\le_2 y_2} \\mu_1(x_1,\\;u)\\mu_2(y_1,\\;v) \\\\<br />&\\;\\;\\;\\, + \\mu_1(x_1,\\;x_2)\\sum_{y_1 \\le_2 v \\le_2 y_2} \\mu_2(y_1,\\;v) \\\\<br />&\\;\\;\\;\\, + \\mu_2(y_1,\\;y_2)\\sum_{x_1 \\le_1 u \\le_1 x_2} \\mu_1(x_1,\\;u) \\\\<br />&\\;\\;\\;\\, + \\mu_1(x_1,\\;x_2)\\mu_2(y_1,\\;y_2) & (\\text{扩展上界})<br />\\end{align}<br />$$<br />由于：<br />$$<br />\\begin{align}<br />0<br />& = \\sum_{y_1 \\le_2 v \\le_2 y_2} \\mu_2(y_1,\\;v) \\\\<br />& = \\sum_{x_1 \\le_1 u \\le_1 x_2} \\mu_1(x_1,\\;u)  \\\\ <br />& = \\sum_{x_1 \\le_1 u \\le_1 x_2} \\sum_{y_1 \\le_2 v \\le_2 y_2} \\mu_1(x_1,\\;u)\\mu_2(y_1,\\;v) <br />\\end{align}<br />$$<br />所以定理成立。<br />在$(X_n,\\;\\le)$上的莫比乌斯函数<br />注意这里的是真正的小于等于号了......<br />这个比较智障，分析一下就好了：<br />对于$y = x$，我们有：<br />$$<br />\\mu(x,\\;y) = \\mu(x,\\;x) = 1<br />$$<br />对于$y = x + 1$，我们有：<br />$$<br />\\mu(x,\\;y) = \\mu(x,\\;x + 1) = -\\mu(x,\\;x) = -1<br />$$<br />对于$y = x + 2$，我们有：<br />$$<br />\\mu(x,\\;y) = \\mu(x,\\;x + 2) = -\\left[\\mu(x,\\;x) + \\mu(x,\\;x + 1)\\right] = 0<br />$$<br />不难发现，对于$y \\gt x + 1$的函数值就全都变为$0$了。<br />总结一下就是：<br />$$<br />\\mu(x,\\;y) = <br />\\begin{cases}<br />1 & (y = x) \\\\<br />-1 & (y = x + 1) \\\\<br />0 & (\\text{otherwise})<br />\\end{cases}<br />\\tag{5.1}<br />$$<br />在$(X_n,\\;\\subseteq)$上的莫比乌斯函数<br /><br />试证明：<br />偏序集$(X_n,\\;\\subseteq)$的莫比乌斯函数是：<br />$$\\mu(A,\\;B) = (-1)^{|B| - |A|} \\tag{6.1}$$<br /><br />运用归纳法证明：<br />首先对于$A = B$，显然成立：<br />$$<br />\\mu(A, B) = \\mu(A, A) = 1 = (-1)^0<br />$$<br />假设对于$|B| - |A| \\le k$均成立，尝试证明对于$|B| - |A| = k + 1$也成立：<br />$$<br />\\begin{align}<br />\\mu(A,\\;B) & = -\\sum_{A \\subseteq C \\subset B} \\mu(A,\\;C) \\\\<br />& = -\\sum_{A \\subseteq C \\subset B} (-1)^{|C| - |A|} \\\\<br />& = -\\sum_{i = 0}^{k} {k + 1 \\choose i}(-1)^i \\\\<br />& = -\\left[(1 - 1)^{k + 1} - (-1)^{k + 1} \\right] \\\\<br />& = (-1)^{k + 1} \\\\<br />& = (-1)^{|B| - |A|}<br />\\end{align}<br />$$<br />在$(X_n,\\;\\mid)$上的莫比乌斯函数<br />首先我不会证这玩意：<br />$$<br />a \\mid b \\Longrightarrow \\mu(a,\\;b) = \\mu(1,\\;\\frac{b}a) \\tag{7.1}<br />$$<br />不管了......<br />反正它是对的......<br />由于有上面的式子，所以我们只用关心$\\mu(1,\\;n)$。<br />首先可以递归计算：<br />$$<br />\\mu(1,\\;n) = -\\sum_{a \\mid n,\\;a\\neq n} \\mu(1,\\;a)<br />$$<br />考虑对$n$进行质因数分解：<br />$$<br />n = p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_m^{\\alpha_m}<br />$$<br />对于$n$的任意一个因子$d$都有：<br />$$<br />d = p_1^{\\beta_1}p_2^{\\beta_2}\\cdots p_m^{\\beta_m} \\;\\;\\;\\; (0 \\le \\beta_i \\le \\alpha_i)<br />$$<br />相当于可以看作$m$个大小为$\\alpha_1 + 1,\\;\\alpha_2 + 1,\\;\\dots,\\;\\alpha_m + 1$的偏序集的直积的结果。<br />于是可以得到：<br />$$<br />\\mu(1,\\;n) = \\prod_{i=1}^m\\mu(1,\\;p_i^{\\alpha_i}) \\tag{7.2}<br />$$<br />注意到，对于$\\varphi(p) = p - 1$：<br />$$<br />\\mu(1,\\;1) = 1 \\\\<br />\\mu(1,\\;p) = -\\mu(1,\\;1) = -1 \\;\\; \\\\<br />\\mu(1,\\;p^2) = -\\left[ \\mu(1,\\;1) + \\mu(1,\\;p) \\right] = 0 \\\\<br />\\dots<br />$$<br />总结一下就是：<br />$$<br />\\mu(1,\\;p^k) = <br />\\begin{cases}<br />1 & (k = 0) \\\\<br />-1 & (k = 1) \\\\ <br />0 & (\\text{otherwise})<br />\\end{cases}<br />\\tag{7.3}<br />$$<br />运用直积，可以知道：<br />$$<br />\\mu(1,\\;n) = <br />\\begin{cases}<br />1 & (n = 1) \\\\<br />(-1)^k & (n = p_1p_2\\cdots p_k, \\;\\;\\varphi(p_i) = p_i - 1) \\\\<br />0 & (\\text{otherwise})<br />\\end{cases}<br />\\tag{7.4}<br />$$<br />为了方便，通常把$\\mu(1,\\;n)$记作$\\mu(n)$，就变成常见的莫比乌斯函数了。<br />据此，我们可以证明莫比乌斯函数是积性函数，即：<br />$$<br />a \\bot b \\Longrightarrow \\mu(ab) = \\mu(a)\\mu(b) \\tag{7.5}<br />$$<br />证明：<br />1. 如果$a$、$b$中有一者为$1$，结论显然成立。<br />2. 如果$a$、$b$中有一者不为素数连乘的形式，它们的积也一定不会是素数连乘的形式，故等于$0$。<br />3. 此时假设$a$、$b$都是素数连乘的形式，又因为$a$与$b$互质，所以它们的素因子中没有相同的。设$a = p_1p_2\\cdots p_m$和$b = q_1q_2\\cdots q_n$所以可以知道$\\mu(ab) = (-1)^{n + m} = \\mu(a)\\mu(b)$。<br />反演示例：容斥原理<br />设$S$为有限集，$A_1,\\;A_2,\\;\\dots,\\;A_n$是$S$的子集，$K \\subseteq \\{1,\\;2,\\;\\dots,\\;n\\}$。<br />定义函数$F(K)$计数$s$同时满足下列条件：<br />$$<br />s \\not\\in \\bigcup_{i \\in K} A_i \\\\<br />s \\in \\bigcap_{i \\not\\in K} A_i<br />$$<br />即：<br />$$<br />F(K) = \\left| \\bigcap_{i \\not\\in K} A_i - \\bigcup_{i \\in K} A_i \\right| \\tag{8.1}<br />$$<br />如何脑补这个函数？可以想象成是用$K$把$S$中的很多东西挖走了，然后剩下的集合再求交集。<br />对于此，再定义函数$G(K)$：<br />$$<br />G(K) = \\sum_{L \\subseteq K} F(L) \\tag{8.2}<br />$$<br />这货居然计数的是：<br />$$<br />G(K) = \\left| \\bigcap_{i \\not\\in K} A_i \\right| \\tag{8.3}<br />$$<br />如何脑补其正确性？可以想象是一个智障用$K$把本来属于它们交集的东西挖去了，然后又一个一个吐出来，于是就还原了原本的交集......<br />根据莫比乌斯反演公式可以知道：<br />$$<br />G(K) = \\sum_{L \\subseteq K} F(K) \\Longrightarrow F(K) = \\sum_{L \\subseteq K} (-1)^{|K| - |L|} G(L)<br />$$<br />所以取$K = \\{1,\\;2,\\;\\dots,\\;n\\}$可以得到：<br />$$<br />F(K) = \\sum_{L \\subseteq K} (-1)^{n - |L|} G(L) \\tag{8.4}<br />$$<br />这个时候的$F(K)$计数的东西有了新的含义：<br />$$<br />F(K) = \\left|\\bigcup_{i \\in K} A_i\\right| = \\left|\\bigcap_{i \\in K} \\overline{A}_i \\right| \\tag{8.5}<br />$$<br />用$F(K)$和$G(K)$本身的含义来替换，就可以得到容斥原理 (感觉好神奇)：<br />$$<br />\\left|\\bigcap_{i = 1}^n \\overline{A}_i \\right| = \\sum_{K \\subseteq \\{1,\\;,2,\\;,\\dots,\\;n\\}} (-1)^{|K|} \\left| \\bigcap_{i \\in K} A_i \\right| \\tag{8.6}<br />$$<br />反演示例：$\\varphi(n)$通项公式<br />欧拉$\\varphi(n)$函数计数的是不大于$n$的与$n$互质的正整数个数。<br />对于欧拉$\\varphi$函数，我们有如下的定理：<br />$$<br />n = \\sum_{d \\mid n} \\varphi(d) \\tag{9.1}<br />$$<br />有两种证明方法：<br />第一种考虑不与$n$互质的数，如果存在一个数$d$与$n$不互质，那么必有$\\gcd(d, n) = a \\gt 1$，换言之$\\gcd(d / a, n / a) = 1$，所以一个数不与$n$互质，那么必定与$n$的一个因子互质。所以上式成立。<br />另一种是使用归纳法证明：<br />首先考虑$1$，是显然成立的。<br />然后考虑质数$p$，$\\varphi(1) + \\varphi(p) = p$，所以也是成立的。<br />考虑质数$p$的幂$p^k$，它的因子有$1,\\;p,\\;p^2,\\;\\dots,\\;p^k$，由于：<br />$$<br />\\varphi(p^k) = (p - 1)p^{k-1} \\;\\;\\;\\; (\\varphi(p) = p - 1)<br />$$<br />所以我们对其进行等比数列求和：<br />$$<br />\\begin{align}<br />\\sum_{d \\mid n} \\varphi(d) & = 1 + (p - 1)\\sum_{i=0}^{k-1} p^i \\\\<br />& = 1 + (p - 1) \\cdot {1 - p^k \\over 1 - p} \\\\<br />& = 1 + p^k - 1 \\\\<br />& = p^k<br />\\end{align}<br />$$<br />故对质数的幂也成立。<br />假设对于一个数$c$，所有小于$c$的数均成立，那么选取$n$的两个互质的因子$a$、$b$使得$ab = c$，那么有：<br />$$<br />\\sum_{n \\mid a} \\varphi(n) \\sum_{m \\mid b} \\varphi(m) = a \\cdot b = c<br />$$<br />下面证明$\\sum_{n \\mid a} \\varphi(n) \\sum_{m \\mid b} \\varphi(m) = \\sum_{d \\mid c} \\varphi(d)$，即可证明原式：<br />$$<br />\\begin{align}<br />\\sum_{n \\mid a} \\varphi(n) \\sum_{m \\mid b} \\varphi(m) & = \\sum_{n \\mid a}\\sum_{m \\mid b}\\varphi(n)\\varphi(m) & (\\text{改变枚举顺序}) \\\\<br />& = \\sum_{n \\mid a}\\sum_{m \\mid b} \\varphi(nm) & (\\text{由于}n \\bot m) \\\\<br />& = \\sum_{nm \\mid ab} \\varphi(nm) & (\\text{由于}a \\bot b) \\\\<br />& = \\sum_{d \\mid c} \\varphi(d) & (\\text{等价代换}) \\\\<br />& = c<br />\\end{align}<br />$$<br />注意到$(9.1)$式是一个明显的莫比乌斯反演的形式。根据莫比乌斯反演公式，我们可以得到：<br />$$<br />\\begin{align}<br />\\varphi(n) & = \\sum_{d \\mid n} d \\cdot \\mu(d,\\;n) \\\\<br />& = \\sum_{d \\mid n} d \\cdot \\mu(1,\\;n / d) \\\\<br />& = \\sum_{d \\mid n} d \\cdot \\mu(n / d) \\\\<br />& = \\sum_{d \\mid n} \\mu(d) \\cdot n/d<br />\\end{align}<br />$$<br />考虑一下$\\mu$函数的取值，对于因子$1$，和式中的结果为$n$。对于由素数相乘的因子，这些素因子必定来自$n$。而其它情况就都为$0$。<br />设$n = p_1^{k_1}p_2^{k_2}\\cdots p_m^{k_m}$。<br />因此可以得到下面的式子：<br />$$<br />\\varphi(n) = n\\left[1 - \\sum \\frac1{p_i} + \\sum \\frac1{p_ip_j} - \\cdots + (-1)^{m}\\sum \\frac1{\\prod_{i=1}^m p_i} \\right] \\tag{9.2}<br />$$<br />这恰好是下面的式子展开的形式：<br />$$<br />\\varphi(n) = n\\prod_{i=1}^m \\left( 1 - \\frac1{p_i} \\right) \\tag{9.3}<br />$$<br />因此：<br />$$<br />\\varphi(n) = n\\prod_{p \\mid n,\\;\\varphi(p) = p - 1} \\left( 1 - \\frac1p\\right) \\tag{9.4}<br />$$<br />反演示例：多重集合的循环排列<br /><br />我们有一个多重集合$\\{\\infty \\cdot 1,\\;\\infty \\cdot 2,\\;\\dots,\\;\\infty \\cdot k\\}$。易知长度为$n$的全排列数为$k^n$。<br />现在对于两个排列$A$和$B$，如果$A$通过”旋转” (即将最后一个变成第一个，并且把之前的全部后移) 能变成$B$，那么$A$和$B$是等价的。<br />换言之，最小表示法相同的排列是等价。<br />求不同的长度为$n$的循环排列数量。<br /><br />对于这个计数问题，我们记$h(n)$为长度为$n$时的答案，$f(n)$为长度为$n$并且旋转$n$次才会变为原排列 (即循环节长度为$n$) 的排列的数量。显然，一个排列的循环节长度$m$必须满足$m \\mid n$。<br />那么可以知道：<br />$$<br />h(n) = \\sum_{d \\mid n} \\frac{f(d)}d \\tag{10.1}<br />$$<br />由于循环节长度小于$n$的排列都可以由循环节不断重复而得来。因此我们设：<br />$$<br />g(n) = \\sum_{d \\mid n} f(d)<br />$$<br />$g(n)$就计数了所有长度为$n$的排列数量。<br />所以：<br />$$<br />g(n) = k^n \\tag{10.2}<br />$$<br />根据莫比乌斯反演公式可得：<br />$$<br />\\begin{align}<br />f(n) & = \\sum_{d \\mid n} g(d)\\mu(n/d) \\\\<br />& = \\sum_{d \\mid n} k^d\\mu(n/d)<br />\\end{align}<br />\\tag{10.3}<br />$$<br />带入$h(n)$的计算公式可得：<br />$$<br />h(n) = \\sum_{d \\mid n} \\frac1d \\sum_{e \\mid d} k^e\\mu(d/e) \\tag{10.4}<br />$$<br />由于$e \\mid d$并且$d \\mid n$，所以我们设$n = rd,\\;d = me$，所以$n = rem$，这样将方便我们变换公式：<br />$$<br />\\begin{align}<br />\\sum_{d \\mid n} \\frac1d \\sum_{e \\mid d} k^e\\mu(d/e) & = \\sum_{e \\mid n} k^e \\sum_{m \\mid (n/e)} \\frac1{me}\\mu(m) \\\\<br />& =\\sum_{e\\mid n} \\frac{k^e}n \\sum_{r \\mid (n/e)} r\\cdot\\mu(\\frac{n}e/r)<br />\\end{align}<br />$$<br />由于：<br />$$<br />\\varphi(n) = \\sum_{d \\mid n} d \\cdot \\mu(n/d)<br />$$<br />所以：<br />$$<br />h(n) = \\frac1n \\sum_{d \\mid n} k^d \\varphi(n/d) \\tag{10.5}<br />$$<br />莫比乌斯函数示例：最大公约数<br />除了莫比乌斯反演公式，莫比乌斯函数本身的性质也是很好的。<br />考虑下面一个问题：<br /><br />给定$n$和$m$，求$\\gcd(x,\\;y)\\;\\;(1 \\le x \\le n,\\;1 \\le y \\le m)$为素数的二元组$(x,\\;y)$个数。<br /><br />换言之，我们要求的是这个：<br />$$<br />\\sum_{x=1}^n\\sum_{y=1}^m \\left[\\varphi(\\gcd(x,\\;y)) = \\gcd(x,\\;y) - 1\\right] \\tag{11.1}<br />$$<br />首先，我们可以换个思路，就是枚举最大公约数的答案：<br />$$<br />\\sum_{\\varphi(p) = p - 1}^{\\min\\{n,\\;m\\}}\\sum_{x=1}^n\\sum_{y=1}^m \\left[ \\gcd(x,\\;y) = p \\right] \\tag{11.2}<br />$$<br />由于$\\gcd(x,\\;y) = p \\Longrightarrow \\gcd(x/p,\\;y/p) = 1$，所以就变成了枚举互质的数的对数：<br />$$<br />\\sum_{\\varphi(p) = p - 1}^{\\min\\{n,\\;m\\}}\\sum_{x=1}^{\\left\\lfloor \\frac{n}p\\right\\rfloor}\\sum_{y=1}^{\\left\\lfloor \\frac{m}p \\right\\rfloor} \\left[ \\gcd(x,\\;y) = 1 \\right] \\tag{11.3}<br />$$<br />由于莫比乌斯函数有这样的性质：<br />$$<br />\\sum_{d \\mid n} \\mu(d) = [n = 1] \\tag{11.4}<br />$$<br />所以可以使用莫比乌斯函数来测试一个数是否为$1$：<br />$$<br />\\sum_{\\varphi(p) = p - 1}^{\\min\\{n,\\;m\\}}\\sum_{x=1}^{\\left\\lfloor \\frac{n}p\\right\\rfloor}\\sum_{y=1}^{\\left\\lfloor \\frac{m}p \\right\\rfloor} \\sum_{d \\mid \\gcd(x,\\;y)} \\mu(d) \\tag{11.5}<br />$$<br />因为$d \\mid \\gcd(x,\\;y)$当且仅当$d \\mid x$并且$d \\mid y$，所以可以变成这样：<br />$$<br />\\sum_{\\varphi(p) = p - 1}^{\\min\\{n,\\;m\\}}\\sum_{x=1}^{\\left\\lfloor \\frac{n}p\\right\\rfloor}\\sum_{y=1}^{\\left\\lfloor \\frac{m}p \\right\\rfloor} \\sum_{d \\mid x \\,\\land\\, d \\mid y} \\mu(d) \\tag{11.6}<br />$$<br />现在东西越来越多了，是时候考虑简化一下了。<br />首先对于一堆和式的一个技巧就是调整枚举顺序。<br />尝试先枚举$d$，这样合法的$d$就可以直接计算了：<br />$$<br />\\sum_{\\varphi(p) = p - 1}^{\\min\\{n,\\;m\\}} \\sum_{d=1}^{\\min\\{n,\\;m\\}} \\left\\lfloor \\frac{n}{dp} \\right\\rfloor \\left\\lfloor \\frac{m}{dp} \\right\\rfloor \\mu(d) \\tag{11.7}<br />$$<br />其实这个式子已经可以用来计算答案了。因为两个向下取整的乘积最多有$O(\\sqrt{n} + \\sqrt{m})$个不同的取值，左边枚举的素数约为$O({n \\over \\ln n})$个，故根据此公式计算的时间复杂度为$O({n (\\sqrt{n} + \\sqrt{m}) \\over \\ln n})$。<br />然而我们可以做得更快一些。<br />设$T = dp$，现在改成先枚举$T$：<br />$$<br />\\sum_{T = 1}^{\\min\\{n,\\;m\\}} \\left\\lfloor \\frac{n}T \\right\\rfloor \\left\\lfloor \\frac{m}T \\right\\rfloor \\sum_{p \\mid T,\\;\\varphi(p) = p - 1} \\mu(T / p) \\tag{11.8}<br />$$<br />这样左边就可以在$O(\\sqrt{n} + \\sqrt{m})$的时间内进行枚举。<br />枚举大概是这样的一个过程：<br />1<br />2<br />3<br />4<br />5<br />6lastpos = 0<br />i = 1<br />while i <= min(n, m):<br />    lastpos = min(n / (n / i), m / (m / i))<br />    # Do something...<br />    i = lastpos + 1<br /><br /><br />我们企图能使右边快速计算。因此我们来研究一下右边这个玩意。<br />设：<br />$$<br />g(x) = \\sum_{p \\mid x,\\;\\varphi(p) = p - 1} \\mu(p) \\tag{11.9}<br />$$<br />考虑使用线性筛来计算$g(x)$。<br /><br />当$x = 1$时，$g(x) = 0$。<br />当$x$为素数时，$g(x) = -1$。<br />在线性筛的处理过程中，设当前数为$i$，枚举到的素数为$p$，我们将要计算$g(ip)$：<br />当$\\mu(i) = 0$时，说明$i$的质因数分解中至少存在一个一个素因子的次数大于$1$。<br />   在这种情况下，除非只有一个素因子的次数为$2$，其它均为$1$，否则无论如何$g$的函数值都为$0$。<br />   假设只存在一个素因子的次数为$2$，记这个素因子为$f(i)$。<br />若$p \\mid i$，那么将会导致无论是哪个素因子，$\\mu$函数的值都为$0$。因此$g$函数的值为$0$。<br />若$p \\not\\mid i$，那么就只有除以$f(i)$时会有值，此时的值为$\\mu(i / f(i) \\cdot p)$。<br /><br /><br />当$\\mu(i) \\neq 0$时，意味着$i$将是多个素数之积。同样我们来考虑两种情况：<br />若$p \\mid i$，那么就只有$p$的次数为$2$，此时$g(ip) = \\mu(i)$。<br />若$p \\not\\mid i$，那么$\\mu(ip)$依然不为$0$。假设$i$有$r$个素因子，那么$g(i) = r(-1)^{r-1}$，并且$g(ip) = (r + 1)(-1)^r = -r(-1)^{r-1} + (-1)^{r+1}$，这意味着它们符号相反且绝对值差$1$。这样就可以直接计算。<br /><br /><br /><br /><br /><br />经过一番分类讨论，我们总算成功地找到了预处理$g(x)$的方法。<br />在这中间有一个问题还亟待解决，就是我们需要计算$f(x)$，事实上它也可以用线性筛计算。<br />假设存在这样的素因子$p$，就记$f(x) = p$。如果$x$还是多个素数相乘，就记$f(x) = 1$。否则记作$0$，又称为”没救了”。这样就只有$f(x) \\gt 1$时才有我们需要的结果。<br /><br />当$x = 1$或$x$为质数时，$f(x) = 1$。<br />每次往一个数$i$加入一个素数$p$时，需要考虑下面的情况：<br />若$f(i) = 0$，那么没救了。<br />若$p \\mid i$，并且$f(i) = 1$，那么$ip$将不再是素数连乘的形式，此时可以记下$f(ip) = p$。如果$f(i) > 1$，那么它没救了。<br />若$p \\not\\mid i$，那么$f$函数值不会改变。<br /><br /><br /><br />这样就可以欢快地计算$f$函数啦~<br />回到之前的问题，我们能够计算$g(x)$函数后，预处理出它的前缀和，就可以在前面伪代码中展示的迭代过程计算答案了。时间复杂度是$O(\\sqrt{n} + \\sqrt{m})$。<br /><br /><br /><br /><br />在偏序集$(X_n,\\;\\mid\\;)$上简化后的卷积 (即狄利克雷卷积)，会满足交换律。 ↩<br /><br /><br />","tags": "数学 组合数学 莫比乌斯反演","url": "blog/2016-8-18/mobius.html"},
{"title": "诱导排序与SA-IS算法","text": "诱导排序与SA-IS算法<br />SA-IS是一种在实际运用中相当快速的线性时间构建字符串的后缀数组的算法。本文将通过对原论文1进行一些翻译和总结来介绍该算法。最后会提供一个SA-IS算法的C++实现。<br />1. 记号<br />现在先规定一些记号，以方便之后的讨论。<br />我们通常使用大写字母$S, A, B, \\dots$来表示一个字符串，小写字母$a, b, c, \\dots$表示单个的字符。字符通常被认为是一个整数。字符在一定条件下数量是有限的，我们将所有会用到的字符放入字符集$\\Sigma$中，此时$|\\Sigma|$表示字符集的大小。字符串之间可以任意连接，如$AB$表示字符串$A$与字符串$B$依次连接而成的新字符串。字符串与单个字符之间也是如此。特别的，我们将空串记为$\\epsilon$。<br />对于一个字符串我们可以访问其中的任意字符，用$S[x]$表示$S$中下标为$x$的字符。下标从$0$开始。我们用$S[a, b]$表示$S$的一个子串，即下标为$a$的字符开始一直到下标为$b$的字符依次连接而成的字符串，其中必须满足$0 \\le a \\le b \\lt |S|$。定义一个字符串$S$的前缀为$\\text{prefix}(S, i) = S[0, i]$，其后缀为$\\text{suffix}(S, i) = S[i, |S| - 1]$。<br />两个字符串$A$和$B$之间存在比较关系。当$A$与$B$的长度相同，且其中对应下标的字符也相同时，则为$A = B$。当从左至右出现第一对不相同的字符时，则以这两个字符的大小关系作为$A$和$B$间的大小关系，这称为字典序。为了简化一些操作，定义$\\#$是字典序最小的字符，并且将其默认作为每个字符串的最后一个字符2，即作为$S[|S|]$。<br />另外，定义函数$\\text{lcp}(A, B)$表示$A$和$B$的最长公共前缀的长度，即两者所有相同的前缀中，最长的一个的长度。由此我们可以得知字典序的一个性质：<br />定理 1.1 $A < B$当且仅当$A[\\text{lcp}(A, B)] < B[\\text{lcp}(A, B)]$。<br />证明 这个结论显然成立，因为$\\text{prefix}(A, \\text{lcp}(A, B) - 1) = \\text{prefix}(B, \\text{lcp}(A, B) - 1)$。<br />2. SA-IS算法<br />SA-IS算法是基于诱导排序这种思想。基本想法就是将问题的规模缩小，通过解决更小的问题，获取足够信息，就可以快速的解决原始问题。从这里也可以看出，这一过程需要递归处理子问题。<br />在介绍SA-IS算法前，我们先来看一下该算法的基本框架：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17function SA-IS(S):<br />    t = bool[]<br />    S1 = int[]<br />    P = int[]<br />    bucket = int[]<br />    扫描倒序字符串确定每一个后缀的类型 -> t<br />    扫描t数组确定所有的LMS子串 -> P<br />    对所有的LMS子串进行诱导排序<br />    对每一个LMS子串重新命名，生成新的串S1<br /><br />    if S1中的每一个字符都不一样:<br />        直接计算SA1<br />    else<br />        SA1 = SA-IS(S1)  # 递归计算SA1<br /><br />    利用SA1来进行诱导排序，计算SA<br />    return SA<br /><br /><br />现在你不会明白这里面都写了些什么东西，因为这只是一个简单的流程。接下来将会介绍其中的每一步并证明其正确性。<br />2.1 后缀类型<br />在第6行中，确定后缀的类型可能会令人无法理解，这是因为我们还没有定义什么是后缀的类型......<br />对于每一个后缀$\\text{suffix}(S, i)$，当$\\text{suffix}(S, i) < \\text{suffix}(S, i + 1)$时，是$S$型后缀。当$\\text{suffix}(S, i) > \\text{suffix}(S, i + 1)$时，是$L$型后缀。对于特殊的后缀$\\text{suffix}(S, |S|) = \\#$，它默认为$S$型。<br />例如，对于字符串mmiissiissiippii，每一后缀的类型为：<br />1<br />2<br />3      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16<br />S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #<br />t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S<br /><br /><br />既然我们需要得知每一个后缀类型，就需要一个快速的算法来计算。在此之前，我们发现它们有如下的性质：<br />引理 2.1 (后缀类型递推性质) 对于任意的$i \\in [0, |S| - 1]$:<br />如果$t[i] = \\text{S-type}$，当且仅当下面任意一项成立：<br /><br />$S[i] < S[i + 1]$<br />$S[i] = S[i + 1]$且$t[i + 1] = \\text{S-type}$<br /><br />如果$t[i] = \\text{L-type}$，当且仅当下面任意一项成立：<br /><br />$S[i] > S[i + 1]$<br />$S[i] = S[i + 1]$且$t[i + 1] = \\text{L-type}$<br /><br />证明 这里证明$S$型的，$L$型是类似的。对于第一种情况，显然是成立的。对于第二种情况，我们设$\\text{suffix}(S, i) = aA, \\text{suffix}(S, i + 1) = aB$。由于第一个字符是相同的，因此我们需要比较$A$和$B$的大小。因为它们是连续的后缀，所以$A = \\text{suffix}(S, i + 1), B = \\text{suffix}(S, i + 2)$。由于我们是从右往左推出$t$，所以$A$与$B$的关系实际上可以由$t[i + 1]$给出。故$t[i] = t[i + 1]$。<br />因此，我们可以在$\\Theta(|S|)$的时间内，推出整个$t$数组。<br />关于后缀类型，我们还可得出另外一个比较重要的性质：<br />引理 2.2 (后缀类型指导排序) 对于两个后缀$A$和$B$，如果$A[0] = B[0]$且$A$是$L$型，$B$是$S$型，则$A < B$。<br />证明 设$A = abX, B = acY$，这里假设$a \\neq b, a \\neq c$。因为$A$是$S$型，所以可知$a < b$。同理，$B$是$L$型，可知$a > c$。故$ c < a < b$，所以$A < B$。如果$a = b, a = c$，则我们可以将第一个字符去掉，得到新的后缀来进行比较。根据引理 2.1，去掉第一个字符后的后缀类型不变。因此我们可以通过这样的操作从而变为第一种情况。<br />2.2 LMS子串<br />然而光有后缀类型，还不足以进行排序。因此我们在后缀类型的$S$型中挑出特别的一类，记为$*$型。$*$型是$S$型的一种，它的特殊之处在于它要求它的左边的后缀必须是$L$型的。依然以mmiissiissiippii为例：<br />1<br />2<br />3<br />4      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16<br />S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #<br />t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S<br />            *           *           *                 *<br /><br /><br />可以将其理解为一连串的$S$型中最靠左的一个。LMS (LeftMost S-type)也正是这个意思。同时我们注意到，后缀$\\#$始终是$*$型的。<br />对于每一个$*$型所对应上的字符，我们称为LMS字符。上面的示例中，下标为$2, 6, 10, 16$都是LMS字符。<br />位置相邻的两个LMS字符中间(包括这两个字符)所构成的子串，称为LMS子串。对于mmiissiissiippii，其LMS子串依次为iissi、iissi、iippii#和#。<br />通过观察，我们发现LMS子串具有以下的性质：<br />引理 2.3 #是最短的LMS子串。<br />引理 2.4 对于任意的非#的LMS子串，其长度大于$2$。<br />证明 因为两个LMS字符中间必定有一个$L$型的后缀。<br />引理 2.5 (原串折半) 一个字符串中LMS子串的数量不超过$\\left\\lceil{|S| / 2}\\right\\rceil$。<br />证明 根据引理2.4可知。<br />引理 2.6 一个字符串的所有LMS子串的长度之和为$O(|S|)$。<br />此外，对于LMS子串间的大小比较，除了对每个字符的字典序进行比较外，还要对比每个字符所对应的后缀类型。$S$型的有更高的优先权，因为根据引理2.2可得，$S$型的后缀字典序更大。只有当每一个字符与其后缀类型都相同时，这两个LMS子串才被称为是相同的。<br />之所以这样定义，是因为在之后我们会利用LMS子串来进行对后缀的排序。如果缺少后缀类型的信息，就不能够任务。<br />根据引理2.6，我们可以利用基数排序在$O(|S|)$的时间内对所有的LMS子串排序3。对LMS子串排序完后，我们按照字典序依次重新命名4，注意，如果两个LMS子串相同，则使用同样的名称5。这样给每个LMS子串命名后，按照其子串原有的顺序排出一个新串$S_1$。继续以mmiissiissiippii为例：<br />1<br />2<br />3<br />4<br />5<br />6      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16<br />S[i]: m  m  i  i  s  s  i  i  s  s  i  i  p  p  i  i  #<br />t[i]: L  L  S  S  L  L  S  S  L  L  S  S  L  L  L  L  S<br />            *           *           *                 *<br />新名称      2           2           1                 0<br />S1:   2 2 1 0<br /><br /><br />这样有什么用呢？我们发现，这实际上是将所有$*$型的后缀进行了缩减，从而减小了问题的规模。对于这一点，我们有如下的引理：<br />引理 2.7 (问题缩减) $S_1$中两个后缀的字典序关系，就是$S$中对应的$*$型后缀的字典序关系。<br />证明 我们可以将$S_1$视为是将$*$后缀中不重合的部分进行切割并缩减。这样每一个LMS子串就可作为一个整体来进行比较。从而保持了这两者的一致性。<br />需要注意的是这里只是$*$型后缀的字典序关系，与其它后缀无关。<br />2.3 从SA1诱导至SA<br />从上面的引理2.7我们得知，只要获得了$S_1$的后缀数组$SA_1$，就可以得到所有$*$型后缀的相对顺序。如果我们可以利用$*$型后缀的相对顺序来对其它的$L$型和$S$型后缀6进行排序，就可以完成后缀数组的计算。<br />在这里我们先假定$SA_1$已经计算出来，只需考虑如何计算$SA$。在这之前，我们先观察一下后缀数组的形式。以aabaaaab为例，它的后缀数组是这样的：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9#<br />aaaab#<br />aaab#<br />aab#<br />aabaaaab#<br />ab#<br />abaaaab#<br />b#<br />baaaab#<br /><br /><br />不难发现，首字母相同的后缀是连续排布的，这一点可以用反证法来证明。因此我们可以利用桶排序的思想，为每一个出现过的字符建立一个桶，用$SA$数组来存储这些桶，每个桶之间按照字典序排列，这样就可以使后缀数组初步有序。<br />我们对每个后缀都赋予了一个后缀类型，那么在首字母一样的情况下，$S$型或$L$型会连续分布吗？答案是肯定的。因为根据引理2.2，首字母相同的后缀如果后缀类型不同，则相对顺序是确定的。因此易知不会出现$S$型和$L$型交替出现的情况。更进一步，由于$L$型后缀更小，因此总是先排布$L$型后缀，再排布$S$型后缀。因此每一个字符的桶可以分为两部分，一个用于放置$L$型后缀，另一个则用于$S$型后缀。为了方便确定每一个桶的起始位置，$S$型后缀的桶的放置是倒序的。<br />但是如果首字母和后缀类型都一致，我们不能直接快速地判断大小关系。在这里就要利用到诱导排序了。<br />诱导排序的过程分为以下几步：<br /><br />将$SA$数组初始化为每个元素都为$-1$的数组。<br />确定每个桶$S$型桶的起始位置。将$SA_1$中的每一个$*$型后缀按照$SA_1$中的顺序放入相应的桶内。<br />确定每个桶$L$型桶的起始位置。在$SA$数组中从左往右扫一遍。如果$SA[i] > 0$且$t[SA[i] - 1] = \\text{L-type}$，则将$SA[i] - 1$所代表的后缀放入对应的桶中。<br />重新确定每个桶$S$型桶的起始位置，因为所有的$*$型后缀要重新被排序。由于$S$型桶是逆序排放的，所以这次从右至左地扫描一遍$SA$。如果$SA[i] > 0$且$t[SA[i] - 1] = \\text{S-type}$，则将$SA[i] - 1$所代表的后缀放入对应的桶中。<br /><br />这样我们就可以完成从$SA_1$诱导到$SA$的排序工作。这里简单说明一下为什么这样做是正确的：首先对于所有的$*$型后缀，都是有序排放的。从左至右扫描$SA$数组实际上就是按照字典序扫描现有的已排序的后缀。对于两个相邻的$L$型后缀$A$和$B$，这里假设$|A| > |B|$，则必定有$A > B$。由于$B$会被先加入$SA$中，所以我们保证了$A$和$B$之间的有序性。又因为$L$型桶是从左往右的顺序加入的，所以所有的$L$型后缀会逐步地按顺序加入到$SA$中。最后所有的$L$型后缀将会有序。<br />对于$S$型后缀，除了要注意是相反的顺序和需要重新对$*$型后缀排序外，其余的原理与$L$型的排序类似。<br />之前的讨论都是基于我们已知$SA_1$的情况下进行的。现在我们来考虑如何计算$SA_1$。由于$S_1$也是一个字符串，计算其后缀数组时可以考虑两种情况：<br /><br />如果$S_1$中每一个字符都不一样，则可以直接利用桶排序直接计算$SA_1$。<br />否则，递归计算$SA_1$。就如之前的算法框架所展示的一样。<br /><br />2.4 对LMS子串排序<br />到这里，SA-IS算法几乎已经结束了，只是还有一个问题需要解决，就是对LMS子串的排序。<br />之前我们所提及的，我们可以利用基数排序。虽然可以在$O(|S|)$的时间内完成，但是事实上，这个基数排序不但常熟大，而且十分复杂(请想象一下对字符串进行基数排序......)。这个排序直接成为了整个算法的性能瓶颈。因此我们急切的需要一种新的算法来胜任这一任务。<br />这个算法依然是诱导排序。<br />与之前从$SA_1$诱导到$SA$的算法一样，只是我们这里将第二步改为：<br /><br />确定每个桶$S$型桶的起始位置。将每一个LMS子串的首字母按照任意顺序放入对应的桶中。<br /><br />待算法完成，我们会获得一个$SA$数组，其中LMS子串之间是排好了序的。<br />为什么这个算法是正确的，我们需要扯到一个新的概念：LMS前缀。<br />规定LMS前缀函数$\\text{pre}(S, i)$表示 (1) 如果$\\text{suffix}(S, i)$是$*$型的，则$\\text{pre}(S, i) = S[i]$，即LMS字符的LMS前缀就是自己。 (2) 否则是从$S[i]$开始，到下一个LMS字符之间(包括首尾)的子串。同样的，按照$\\text{suffix}(S, i)$的后缀类型的不同，LMS前缀也同样分为$S$型和$L$型。<br />例如，在mmiissiissiippii中，$\\text{pre}(S, 2) = S[2] =$ i，而$\\text{pre}(S, 3) = S[3, 6] =$ issi。<br />因此上面的算法实际上是在对每个LMS前缀进行排序。<br />接下来将证明2-4步都是正确的，即每一步完成时$SA$数组中，LMS前缀都是有序的。<br /><br />对于第二步，由于放入的LMS前缀都只有一个字符，因为桶的排列是按照字典序的，所以保证放置后一定有序。<br />对于第三步，当放入第一个$L$型LMS前缀时，$SA$数组必定是有序的(根据引理2.2)。假设我们已经放置了$k$个$L$型LMS前缀，且它们在$SA$数组中保持有序，现在考虑放入的第$k + 1$个LMS前缀是否会保证有序。我们设这个LMS前缀为$\\text{pre}(S, i)$，因为首字母不同的LMS前缀一定是保持有序的，因此我们只需要考虑它与其首字母相同的LMS前缀之间的关系。因为我们是从左至右扫描来使$L$型LMS前缀从小至大放置，那么对于所有之前放置的且首字母与其相同的LMS前缀$\\text{pre}(S, j)$，应该都有$\\text{pre}(S, j) < \\text{pre}(S, i)$。假设我们存在一个这样的LMS前缀，使得$\\text{pre}(S, j) > \\text{pre}(S, i)$，由于$\\text{pre}(S, j)[0] = \\text{pre}(S, i)[0]$，所以我们得知$\\text{pre}(S, j + 1) > \\text{pre}(S, i + 1)$。而$\\text{pre}(S, j + 1)$与$\\text{pre}(S, i + 1)$都是之前所加入过的，因此它们之间应当保持有序。而$\\text{pre}(S, j) > \\text{pre}(S, i)$告诉我们之前的$SA$数组不是有序的，与假设相反，故不存在这样的$\\text{pre}(S, j)$。因此，当$\\text{pre}(S, i)$放置后，$SA$数组保持有序。直到所有的$L$型LMS前缀加入完毕。<br />对于第四步的正确性的证明，与第三步的证明是类似的。读者可以自行推理一下。<br /><br />这样，我们就完成了对这个诱导排序的正确性的证明。但我们需要注意的是，这只是对LMS前缀的排序，我们期望是对LMS子串进行排序。我们注意到每一个LMS子串都可以视为是一个LMS字符与一个LMS前缀连接而成的，因此我们只需要判断两个LMS字符和其后一位对应的LMS前缀的大小关系，就可以判断LMS子串之间的大小关系。<br />然而，我们其实可以做得更简单。下面的引理说明了上面的算法结束后的$SA$数组就是排好序的LMS子串的数组。<br />引理 2.8 (LMS子串排序) $SA$数组中每一个LMS字符所对应的LMS前缀已经按照其对应的LMS子串的顺序排好。<br />证明 对于首字母不同的LMS子串，这个结论是显然的。<br />对于首字母相同的LMS子串，它必定是由一个$L$型LMS前缀从右至左的推导过来的。由于不同的LMS子串必定对应着不同的递推的顺序，并且在第二步中，所有的$L$型LMS前缀已经排好了序。所以结论成立。<br />根据这个引理，我们可以直接对$SA$数组扫描一遍，就可以得到LMS子串的字典序，同时对它们进行命名。<br />3. 时空复杂度分析<br />在之前的讨论中，我们已经成功的运用诱导排序使每一步都是$\\Theta(|S|)$。但是由于有一个递归的过程，时间复杂度似乎并不一定是线性的。<br />我们注意到，每次递归都是计算$S_1$的后缀数组。如果我们能够知道$S_1$的规模，就能够计算SA-IS的事件复杂度。<br />根据引理2.5，我们得知$|S_1| \\le \\left\\lceil|S| / 2\\right\\rceil$。因此每一层的递归的问题规模都会减半。因此我们可以用以下的递归式来表示时间复杂度：<br />$$ T(n) = T(\\left\\lceil n/2\\right\\rceil) + \\Theta(n) \\tag{3.1} $$<br />求解可得：<br />$$ T(n) = \\Theta(n) \\tag{3.2} $$<br />因此总时间复杂度是$\\Theta(n)$的。<br />对于这个递归式，我们可以理解为是递归了$O(\\log n)$层，其中每一层的问题规模从小到大排序是$2^0, 2^1, 2^2, \\dots, 2^{\\left\\lfloor\\log n\\right\\rfloor}$。因此总复杂度就是对它们进行求和：<br />$$ \\sum^{\\left\\lfloor\\log n\\right\\rfloor}_{k=0} 2^k = 2 \\times 2^{\\left\\lfloor\\log n\\right\\rfloor} = \\Theta(2^{\\left\\lfloor\\log n\\right\\rfloor}) = \\Theta(n) \\tag{3.3} $$<br />对于空间复杂度的分析，与时间复杂度是如出一辙的。<br />4. 运行示例<br />下面将用aabaaaab作为输入字符串，展示计算其后缀数组的每一步。希望能通过这个示例能够更清晰地展现SA-IS算法的运作流程。由于涉及到对桶的操作，这里用@表示正在被处理的元素，而用^表示每个桶的起始位置。<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30<br />31<br />32<br />33<br />34<br />35<br />36<br />37<br />38<br />39<br />40<br />41<br />42<br />43<br />44<br />45<br />46<br />47<br />48<br />49<br />50<br />51<br />52<br />53<br />54<br />55<br />56<br />57<br />58<br />59<br />60<br />61<br />62<br />63<br />64<br />65<br />66<br />67<br />68<br />69<br />70<br />71<br />72<br />73<br />74<br />75<br />76<br />77<br />78<br />79<br />80<br />81<br />82<br />83           0  1  2  3  4  5  6  7  8<br />S:         a  a  b  a  a  a  a  b  #<br />扫描后缀类型<br />t:         S  S  L  S  S  S  S  L  S<br />LMS characters:     *              *<br />         |# |       a         |  b  |  # 桶的名称<br />SA:       -1|-1 -1 -1 -1 -1 -1|-1 -1<br />对LMS子串进行排序<br />1. 放入LMS子串<br />SA:       08|-1 -1 -1 -1 -1 03|-1 -1<br />2. 从*型LMS前缀诱导到L型LMS前缀<br />SA:       08|-1 -1 -1 -1 -1 03|-1 -1<br />          @^  ^                 ^<br />SA:       08|-1 -1 -1 -1 -1 03|07 -1<br />           ^  ^             @      ^<br />SA:       08|-1 -1 -1 -1 -1 03|07 02  # pre(S, 6)不是L型的<br />           ^  ^                @   ^<br />SA:       08|-1 -1 -1 -1 -1 03|07 02<br />           ^  ^                   @^<br />SA:       08|-1 -1 -1 -1 -1 03|07 02<br />3. 从L型LMS前缀诱导到S型前缀<br />SA:       08|-1 -1 -1 -1 -1 03|07 02<br />           ^                 ^    @^<br />SA:       08|-1 -1 -1 -1 -1 01|07 02<br />           ^              ^    @   ^<br />SA:       08|-1 -1 -1 -1 06 01|07 02<br />           ^           ^    @      ^<br />SA:       08|-1 -1 -1 00 06 01|07 02<br />           ^        ^    @         ^<br />SA:       08|-1 -1 05 00 06 01|07 02  # 不存在pre(S, -1)<br />           ^     ^    @            ^<br />SA:       08|-1 -1 05 00 06 01|07 02<br />           ^     ^ @               ^<br />SA:       08|-1 04 05 00 06 01|07 02<br />           ^  ^ @                  ^<br />SA:       08|03 04 05 00 06 01|07 02<br />           ^ @^                    ^<br />SA:       08|03 04 05 00 06 01|07 02  # pre(S, 7)不是S型的<br />          @^  ^                    ^<br />SA:       08|03 04 05 00 06 01|07 02<br />扫描并重命名LMS子串<br />name:      1  2<br />S1:       2 1 0<br />由于每一个字符都不一样，直接计算SA1<br />SA1：     2 1 0<br />从SA1诱导到SA<br />         |$ |       a         |  b  |<br />SA:       -1|-1 -1 -1 -1 -1 -1|-1 -1<br />1. 按照SA1的原顺序放入(忽略S1最后的字符)<br />SA:       08|-1 -1 -1 -1 -1 03|-1 -1<br />           ^  ^                 ^<br />2. 从*型后缀诱导到L型后缀<br />SA:       08|-1 -1 -1 -1 -1 03|-1 -1<br />          @^  ^                 ^<br />SA:       08|-1 -1 -1 -1 -1 03|07 -1<br />           ^  ^             @      ^<br />SA:       08|-1 -1 -1 -1 -1 03|07 02<br />           ^  ^                @   ^<br />SA:       08|-1 -1 -1 -1 -1 03|07 02<br />           ^  ^                   @^<br />3. 从L型后缀诱导到S型后缀<br />SA:       08|-1 -1 -1 -1 -1 03|07 02<br />           ^                 ^    @^<br />SA:       08|-1 -1 -1 -1 -1 01|07 02<br />           ^              ^    @   ^<br />SA:       08|-1 -1 -1 -1 06 01|07 02<br />           ^           ^    @      ^<br />SA:       08|-1 -1 -1 00 06 01|07 02<br />           ^        ^    @         ^<br />SA:       08|-1 -1 05 00 06 01|07 02<br />           ^     ^    @            ^<br />SA:       08|-1 -1 05 00 06 01|07 02<br />           ^     ^ @               ^<br />SA:       08|-1 04 05 00 06 01|07 02<br />           ^  ^ @                  ^<br />SA:       08|03 04 05 00 06 01|07 02  # pre(S, 2)是L型<br />           ^ @^                    ^<br />SA:       08|03 04 05 00 06 01|07 02<br />          @^  ^                    ^<br />后缀数组构造完毕<br />SA: 8 3 4 5 0 6 1 7 2<br /><br />return SA<br /><br /><br />5. 具体实现及性能对比<br />在原论文中说道SA-IS算法可以在100行左右的代码完成。我试了一下，基本符合这个要求。<br />在进行具体实现之前，你可能需要先考虑下面几个问题，避免陷入一些陷阱......<br /><br />我真的理解了SA-IS算法了吗？<br />如何为每一层递归申请空间？<br />诱导排序的过程被调用了两次，可以用一个函数封装起来吗？<br />后缀类型可以用bool数组存储吗？<br />字符集是否是动态的？<br />如何通过一遍扫描为LMS子串命名？<br />如何快速判断S1中是否有重复的字符？<br />如果每个字符都不一样，如何快速计算后缀数组？<br />实际工程中，需要考虑内存回收。<br /><br />如果说你考虑清楚了上面的问题，基本上写出SA-IS也只是时间的问题了。下面将会给出一个C++实现。需要注意的是，为了方便，这份代码中并没有回收分配的内存。<br />  1<br />  2<br />  3<br />  4<br />  5<br />  6<br />  7<br />  8<br />  9<br /> 10<br /> 11<br /> 12<br /> 13<br /> 14<br /> 15<br /> 16<br /> 17<br /> 18<br /> 19<br /> 20<br /> 21<br /> 22<br /> 23<br /> 24<br /> 25<br /> 26<br /> 27<br /> 28<br /> 29<br /> 30<br /> 31<br /> 32<br /> 33<br /> 34<br /> 35<br /> 36<br /> 37<br /> 38<br /> 39<br /> 40<br /> 41<br /> 42<br /> 43<br /> 44<br /> 45<br /> 46<br /> 47<br /> 48<br /> 49<br /> 50<br /> 51<br /> 52<br /> 53<br /> 54<br /> 55<br /> 56<br /> 57<br /> 58<br /> 59<br /> 60<br /> 61<br /> 62<br /> 63<br /> 64<br /> 65<br /> 66<br /> 67<br /> 68<br /> 69<br /> 70<br /> 71<br /> 72<br /> 73<br /> 74<br /> 75<br /> 76<br /> 77<br /> 78<br /> 79<br /> 80<br /> 81<br /> 82<br /> 83<br /> 84<br /> 85<br /> 86<br /> 87<br /> 88<br /> 89<br /> 90<br /> 91<br /> 92<br /> 93<br /> 94<br /> 95<br /> 96<br /> 97<br /> 98<br /> 99<br />100<br />101<br />102<br />103<br />104<br />105<br />106<br />107<br />108<br />109<br />110<br />111<br />112<br />113<br />114<br />115<br />116<br />117<br />118<br />119<br />120<br />121<br />122<br />123<br />124<br />125<br />126<br />127<br />128<br />129<br />130// 后缀类型<br />#define L_TYPE 0<br />#define S_TYPE 1<br /><br />// 判断一个字符是否为LMS字符<br />inline bool is_lms_char(int *type, int x) {<br />    return x > 0 && type[x] == S_TYPE && type[x - 1] == L_TYPE;<br />}<br /><br />// 判断两个LMS子串是否相同<br />inline bool equal_substring(int *S, int x, int y, int *type) {<br />    do {<br />        if (S[x] != S[y])<br />            return false;<br />        x++, y++;<br />    } while (!is_lms_char(type, x) && !is_lms_char(type, y));<br /><br />    return S[x] == S[y];<br />}<br /><br />// 诱导排序(从*型诱导到L型、从L型诱导到S型)<br />// 调用之前应将*型按要求放入SA中<br />inline void induced_sort(int *S, int *SA, int *type, int *bucket, int *lbucket,<br />                         int *sbucket, int n, int SIGMA) {<br />    for (int i = 0; i <= n; i++)<br />        if (SA[i] > 0 && type[SA[i] - 1] == L_TYPE)<br />            SA[lbucket[S[SA[i] - 1]]++] = SA[i] - 1;<br />    for (int i = 1; i <= SIGMA; i++)  // Reset S-type bucket<br />        sbucket[i] = bucket[i] - 1;<br />    for (int i = n; i >= 0; i--)<br />        if (SA[i] > 0 && type[SA[i] - 1] == S_TYPE)<br />            SA[sbucket[S[SA[i] - 1]]--] = SA[i] - 1;<br />}<br /><br />// SA-IS主体<br />// S是输入字符串，length是字符串的长度, SIGMA是字符集的大小<br />static int *SAIS(int *S, int length, int SIGMA) {<br />    int n = length - 1;<br />    int *type = new int[n + 1];  // 后缀类型<br />    int *position = new int[n + 1];  // 记录LMS子串的起始位置<br />    int *name = new int[n + 1];  // 记录每个LMS子串的新名称<br />    int *SA = new int[n + 1];  // SA数组<br />    int *bucket = new int[SIGMA];  // 每个字符的桶<br />    int *lbucket = new int[SIGMA];  // 每个字符的L型桶的起始位置<br />    int *sbucket = new int[SIGMA];  // 每个字符的S型桶的起始位置<br /><br />    // 初始化每个桶<br />    memset(bucket, 0, sizeof(int) * (SIGMA + 1));<br />    for (int i = 0; i <= n; i++)<br />        bucket[S[i]]++;<br />    for (int i = 1; i <= SIGMA; i++) {<br />        bucket[i] += bucket[i - 1];<br />        lbucket[i] = bucket[i - 1];<br />        sbucket[i] = bucket[i] - 1;<br />    }<br /><br />    // 确定后缀类型(利用引理2.1)<br />    type[n] = S_TYPE;<br />    for (int i = n - 1; i >= 0; i--) {<br />        if (S[i] < S[i + 1])<br />            type[i] = S_TYPE;<br />        else if (S[i] > S[i + 1])<br />            type[i] = L_TYPE;<br />        else<br />            type[i] = type[i + 1];<br />    }<br /><br />    // 寻找每个LMS子串<br />    int cnt = 0;<br />    for (int i = 1; i <= n; i++)<br />        if (type[i] == S_TYPE && type[i - 1] == L_TYPE)<br />            position[cnt++] = i;<br /><br />    // 对LMS子串进行排序<br />    fill(SA, SA + n + 1, -1);<br />    for (int i = 0; i < cnt; i++)<br />        SA[sbucket[S[position[i]]]--] = position[i];<br />    induced_sort(S, SA, type, bucket, lbucket, sbucket, n, SIGMA);<br /><br />    // 为每个LMS子串命名<br />    fill(name, name + n + 1, -1);<br />    int lastx = -1, namecnt = 1;  // 上一次处理的LMS子串与名称的计数<br />    bool flag = false;  // 这里顺便记录是否有重复的字符<br />    for (int i = 1; i <= n; i++) {<br />        int x = SA[i];<br /><br />        if (is_lms_char(type, x)) {<br />            if (lastx >= 0 && !equal_substring(S, x, lastx, type))<br />                namecnt++;<br />            // 因为只有相同的LMS子串才会有同样的名称<br />            if (lastx >= 0 && namecnt == name[lastx])<br />                flag = true;<br /><br />            name[x] = namecnt;<br />            lastx = x;<br />        }<br />    }  // for<br />    name[n] = 0;<br /><br />    // 生成S1<br />    int *S1 = new int[cnt];<br />    int pos = 0;<br />    for (int i = 0; i <= n; i++)<br />        if (name[i] >= 0)<br />            S1[pos++] = name[i];<br /><br />    int *SA1;<br />    if (!flag) {<br />        // 直接计算SA1<br />        SA1 = new int[cnt + 1];<br /><br />        for (int i = 0; i < cnt; i++)<br />            SA1[S1[i]] = i;<br />    } else<br />        SA1 = SAIS(S1, cnt, namecnt);  // 递归计算SA1<br /><br />    // 从SA1诱导到SA<br />    lbucket[0] = sbucket[0] = 0;<br />    for (int i = 1; i <= SIGMA; i++) {<br />        lbucket[i] = bucket[i - 1];<br />        sbucket[i] = bucket[i] - 1;<br />    }<br />    fill(SA, SA + n + 1, -1);<br />    for (int i = cnt - 1; i >= 0; i--)  // 这里是逆序扫描SA1，因为SA中S型桶是倒序的<br />        SA[sbucket[S[position[SA1[i]]]]--] = position[SA1[i]];<br />    induced_sort(S, SA, type, bucket, lbucket, sbucket, n, SIGMA);<br /><br />    // 后缀数组计算完毕<br />    return SA;<br />}<br /><br /><br />SA-IS的实现还可以参考一篇很好的博文: A walk through the SA-IS Suffix Array Construction Algorithm，这篇文章的作者使用Python一步一步地介绍了如何实现一个基础的SA-IS算法。<br />我们看到SA-IS作为一个后缀排序的算法，代码量也并不小，然而实际上它速度非常快，其中一个重要的原因就是SA-IS算法几乎所有的操作都是顺序访问的，这样就可以很好地提高缓存命中率7。原论文中实测SA-IS算法击败了KA算法，不愧为目前为止速度最快的后缀数组的构建算法。<br />对中学OI界，构造后缀数组通常是使用倍增法和DC3算法。倍增法速度比DC3算法慢是众所周知的了，下面我将用不同规模的随机字符串来比较DC3算法与SA-IS算法。<br /><br /><br /><br />数据规模<br />DC3<br />SA-IS<br /><br /><br /><br /><br />$10^4$<br />$0.015\\text{s}$<br />$0.011\\text{s}$<br /><br /><br />$10^5$<br />$0.055\\text{s}$<br />$0.036\\text{s}$<br /><br /><br />$10^6$<br />$0.365\\text{s}$<br />$0.270\\text{s}$<br /><br /><br />$2\\times 10^6$<br />$0.997\\text{s}$<br />$0.593\\text{s}$<br /><br /><br />$5\\times 10^6$<br />$2.803\\text{s}$<br />$2.085\\text{s}$<br /><br /><br />$10^7$<br />$4.012\\text{s}$<br />$3.326\\text{s}$<br /><br /><br /><br />编译命令: g++ SAIS.cpp/DC3.cpp -o sais/dc3 -O3<br />运行环境: Ubuntu 14.04 LTS x64 / CPU: 2.0GHz 奔腾某CPU / 4GB内存 / 未启动X window<br />从上面的结果可以看出，SA-IS算法速度上明显优于DC3算法，并且数据规模越大，两者的速度差距越明显。<br />总而言之，SA-IS算法是一个相当不错的后缀数组的构建算法。似乎SA-IS算法所利用的诱导排序的思想还可以解决其它的一些字符串的问题，如计算LCP数组，我并没有对此做过多的了解了。<br /><br /><br /><br /><br />Nong, Ge; Zhang, Sen; Chan, Wai Hong (2009): Linear Suffix Array Construction by Almost Pure Induced-Sorting ↩<br /><br /><br />这里的$\\#$并不是指井号，而是一个特殊记号。字符串中不会出现这个字符。 ↩<br /><br /><br />后面我们将会有更好的算法来对LMS子串排序，时间复杂度一致，但在实际运用中速度快很多。 ↩<br /><br /><br />注意之后会创建新字符串$S_1$，其字符集$\\Sigma$是不同的。 ↩<br /><br /><br />判断两个LMS子串是否相等可以暴力判断，基于引理2.6，可以证明其总复杂度为$O(|S|)$。 ↩<br /><br /><br />注意$*$型后缀也属于$S$型后缀，因此会对它们进行重排，从而确保新加入的$S$型后缀的顺序是对的。 ↩<br /><br /><br />即降低cache-missing。 ↩<br /><br /><br />","tags": "数据结构 字符串 后缀数组 诱导排序 SA-IS","url": "blog/2016-6-19/sais.html"},
{"title": "辛普森积分法","text": "辛普森积分法<br />辛普森积分法是一种快速求函数定积分的方法。与普通的直线拟合方法相比，辛普森积分法采用的是二次函数来拟合函数，而效果十分显著。<br />用抛物线拟合<br />假设我们有三个不重合的点，那么可以唯一确定一个抛物线经过这三个点。如下图所示：<br /><br />辛普森积分法就是在积分区间$[a,\\;b]$上去三个点$a$、$b$和$m = (a + b) / 2$，计算其原函数的在此处的值，然后用抛物线来拟合原函数，即使用该二次函数的积分值代替原函数的积分值，达到近似积分的效果。<br />如何计算这个二次函数？我们自然可以解三元三次方程组，但更方便的方法是拉格朗日差值公式：<br />$$<br />g(x) = {(x - m)(x - b) \\over (a - m)(a - b)}f(a) + {(x - a)(a - b) \\over (m - a)(m - b)}f(m) + {(x - a)(x - m) \\over (b - a)(b - m)}f(b)<br />$$<br />其中$f(x)$是原函数，$g(x)$是拟合后的函数。下文中$f$和$g$也表示同样的意义，不再复述。<br />二次函数的积分<br />有了二次函数后，计算其积分是十分简单的事，但是这一切还不够完美。下面我们将推导出一个更简单的公式。<br />设：<br />$$<br />g(x) = Ax^2 + Bx + C \\\\<br />m = \\frac{(a + b)}2 \\\\<br />f(a) = g(a), \\; f(m) = g(m), \\; f(b) = g(b)<br />$$<br />那么：<br />$$<br />\\int_a^b f(x) \\;\\mathrm{d}x \\approx \\int_a^b (Ax^2 + Bx + C)\\;\\mathrm{d}x<br />$$<br />所以：<br />$$<br />\\int_a^b (Ax^2 + Bx + C)\\;\\mathrm{d}x = \\frac{A}3(b-a)^3 + \\frac{B}2(b-a)^2 + C(b-a)<br />$$<br />因为：<br />$$<br />b^3 - a^3 = (b^2 + ab + a^2)(b-a)\\\\<br />b^2 - a^2 = (b+a)(b-a)<br />$$<br />所以之前的式子可变为：<br />$$<br />{b-a \\over 6}[2A(b^2 + ab + a^2) + 3B(b+a) + 6C]<br />$$<br />调整可得：<br />$$<br />{b-a \\over 6}\\left[(Aa^2 + Ba + C) + (Ab^2 + Bb + C) + 4A\\left({b+a \\over 2}\\right)^2 + 4B\\left({b+a \\over 2}\\right) + 4C\\right]<br />$$<br />于是就是：<br />$$<br />\\int_a^b f(x) \\;\\mathrm{d}x \\approx {b - a \\over 6}(f(a) + 4f(m) + f(b))<br />$$<br />这就是辛普森法则。<br />辛普森积分<br />下面将用Python简单实现一下辛普森积分，首先我们需要一个计算积分的函数：<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8def sample(f, a, b):<br />    \"\"\"用二次函数近似计算函数f的积分<br />    f: 函数<br />    a: 积分下界<br />    b: 积分上界<br />    \"\"\"<br /><br />    return (b - a) * (f(a) + 4.0 * f((a + b) * 0.5) + f(b)) * 0.5<br /><br /><br />然后就是对f分成n段，每一段使用二次函数近似计算：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17def simpson(f, a, b, n = 1000):<br />    \"\"\"计算定积分<br />    f: 原函数<br />    a: 积分下界<br />    b: 积分上界<br />    n: 划分的区间数<br />    \"\"\"<br /><br />    delta = (b - a) / n<br />    result = 0<br /><br />    for i in range(0, n):<br />        left = a + i * delta<br />        right = left + delta<br />        result += sample(f, left, right)<br /><br />    return result<br /><br /><br />用它来试着算一下圆周率：<br />1<br />2In [1]: simpson(lambda x : 2.0 * sqrt(1 - x**2), -1, 1, 100000)<br />Out[1]: 3.1415926390691236<br /><br /><br />可以发现分为$100000$个区间就获得了$7$位的精度。事实上，如果你将sample换为直线的拟合，你将只能得到$6$的精度。<br />自适应辛普森积分<br />然而控制区间个数不是一个控制答案精度的好办法，通常我们将使用特定的$\\varepsilon$来控制精度误差。<br />如何让算法知道应当继续细分来达到特定精度呢？通常的方法就是将当前区间分为两半，用这两半的拟合值与当前计算的值做差。如果小于$\\varepsilon$，那么我们就认为精度达到了要求。否则我们就递归下去，计算两个子区间的积分。注意，此时$\\varepsilon$也应当缩小，从而避免累积的误差超过了$\\varepsilon$。<br />这样我们就将得到一个递归算法，具体实现如下：<br /> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28def _adaptive_simpson(f, a, b, eps, current):<br />    \"\"\"递归过程<br />    f: 原函数<br />    a: 积分下界<br />    b: 积分上界<br />    eps: 精度<br />    current: [a, b]的定积分近似值，用于减少计算量<br />    \"\"\"<br /><br />    mid = (a + b) * 0.5<br />    leftans = sample(f, a, mid)<br />    rightans = sample(f, mid, b)<br /><br />    if abs(leftans + rightans - current) < eps:  # 如果达到要求<br />        return current<br />    else:  # 否则将递归下去计算<br />        return (_adaptive_simpson(f, a, mid, eps * 0.5, leftans) +<br />                _adaptive_simpson(f, mid, b, eps * 0.5, rightans))<br /><br />def adaptive_simpson(f, a, b, eps):<br />    \"\"\"自适应辛普森积分<br />    f: 原函数<br />    a: 积分下界<br />    b: 积分上界<br />    eps: 精度<br />    \"\"\"<br /><br />    return _adaptive_simpson(f, a, b, eps, sample(f, a, b))<br /><br /><br />我将其与线性拟合的算法对比了一下速度。他们共用一个递归的框架，只是sample函数有二次函数拟合和直线拟合两种：<br />直线拟合：<br />1<br />2<br />3<br />4In [1]: % time adaptive_simpson(sin, 0, 1000, 0.00001)<br />CPU times: user 5.58 s, sys: 0 ns, total: 5.58 s<br />Wall time: 5.58 s<br />Out[1]: 0.4376209161316862<br /><br /><br />二次函数拟合：<br />1<br />2<br />3<br />4In [26]: % time adaptive_simpson(sin, 0, 1000, 0.00001)<br />CPU times: user 60 ms, sys: 0 ns, total: 60 ms<br />Wall time: 59.6 ms<br />Out[26]: 0.43762092534838204<br /><br /><br />可见辛普森积分法是相当迅速的。<br />异常情况<br />由于是使用二次函数拟合，所以辛普森积分法对光滑的函数效果较好。但下面集中情况需要谨慎考虑：<br /><br />上下震荡十分剧烈的函数（如$y = \\sin(1/x)$）不适用，事实上这种函数一般都不好积。<br />突变的函数（如$y = |x|$，在$x = 0$处无导数）不适用。<br /><br />对于存在没有导数的点的函数，通常的解决方法就是从这些点分开，然后就可以分段计算了。","tags": "辛普森积分法","url": "blog/2016-11-16/simpson.html"}]};